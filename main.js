var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/i18n/en.js
var require_en = __commonJS({
  "src/i18n/en.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "English",
      "settings_title": "Always Color Text Settings",
      "header_plugin_name": "Always Color Text",
      "ribbon_title": "Always Color Text",
      // Language Settings
      "language_label": "Language",
      "language_desc": "Choose the language for the plugin",
      "language_en": "English",
      "language_es": "Espa\xF1ol",
      "language_fr": "Fran\xE7ais",
      "language_eu": "Basque",
      "language_ru": "P\u0443\u0441\u0441\u043A\u0438\u0439",
      "language_auto": "System Default",
      "default": "Default",
      // Release Notes
      "latest_release_notes_label": "Latest Release Notes",
      "latest_release_notes_desc": "Check the latest release notes for the plugin",
      "open_changelog_button": "Open Changelog",
      "command_show_release_notes": "Show Latest Release Notes",
      "changelog_view_on_github": "View on GitHub",
      "changelog_loading": "Loading releases...",
      "changelog_no_info": "No release information available.",
      "changelog_release": "Release",
      "changelog_no_notes": "No notes",
      "changelog_failed_to_load": "Failed to load release notes.",
      // UI Elements & Menus
      "file_menu_enable": "Enable Always Color Text for this file",
      "file_menu_disable": "Disable Always Color Text for this file",
      "menu_color_once": "Color Once",
      "menu_highlight_once": "Highlight Once",
      "menu_color_highlight_once": "Color / Highlight Once",
      "menu_remove_inline_color": "Remove Inline Color",
      "menu_always_color_text": "Always Color Text",
      "menu_remove_always_color_text": "Remove Always Color Text",
      "menu_blacklist_word": "Blacklist Word",
      "show_toggle_statusbar": "Show Toggle in Status Bar",
      "show_toggle_ribbon": "Show Toggle Icon in Ribbon",
      "show_toggle_command": "Show Toggle in Commands",
      "menu_options_header": "Menu Options",
      "show_blacklist_menu": 'Show "Blacklist Word" in right-click menu',
      "show_blacklist_menu_desc": "Adds a right-click menu item to blacklist selected text from coloring.",
      "show_add_to_existing_menu": 'Show "Add to Existing Entry" in right-click menu',
      "show_add_to_existing_menu_desc": "Adds a right-click menu item to add selected text to an existing entry.",
      "show_always_color_text_menu": 'Show "Always Color Text" in right-click menu',
      "show_always_color_text_menu_desc": "Adds a right-click menu item to color selected text.",
      "hide_inactive_groups_in_dropdowns": "Hide Inactive Groups in Dropdowns",
      "hide_inactive_groups_in_dropdowns_desc": "Hide inactive word groups when displaying group lists in dropdowns.",
      "show_word_groups_in_commands": "Show Word Groups in Commands",
      "show_word_groups_in_commands_desc": "When enabled, word groups appear in the command palette with Activate/Deactivate commands.",
      "tooltip_enable_for_file": "Enable for this file",
      "tooltip_delete_all_words": "Delete all defined words/patterns",
      "tooltip_delete_all_blacklist": "Delete all blacklisted words/patterns",
      "tooltip_use_regex": "Use as regex pattern",
      "drag_to_reorder": "Drag to reorder",
      "reset_text_color": "Reset Text Color",
      "reset_highlight": "Reset Highlight",
      "tooltip_duplicate_group": "Duplicate Group",
      "tooltip_edit_group_settings": "Edit Group Settings",
      "tooltip_delete_all_groups": "Delete all Word Groups",
      "grouped_entries_desc": "Manage word groups. Search filters by group name.",
      "search_groups_placeholder": "Search groups\u2026",
      "no_entries_found": "No entries found.",
      // Commands
      "command_color_selected": "Color Selected Text",
      "command_toggle_current": "Enable/Disable coloring for current document",
      "command_toggle_global": "Enable/Disable Global Coloring",
      "command_enable_current": "Enable coloring for current document",
      "command_disable_current": "Disable coloring for current document",
      "command_enable_global": "Enable Global Coloring",
      "command_disable_global": "Disable Global Coloring",
      "command_manage_advanced_rules": "manage specific include/exclude rules",
      "command_open_regex_tester": "Add Regex (Open Regex Tester)",
      "command_open_blacklist_regex_tester": "Add Blacklist Regex",
      "command_manage_colored_texts": "Manage Colored Texts",
      "command_toggle_hide_text_colors": "Hide/Unhide Text Colors",
      "command_toggle_hide_highlights": "Hide/Unhide Highlights",
      "command_hide_text_colors": "Hide Text Colors",
      "command_unhide_text_colors": "Unhide Text Colors",
      "command_hide_highlights": "Hide Highlights",
      "command_unhide_highlights": "Unhide Highlights",
      "command_enable_lightweight_mode": "Enable Lightweight Mode",
      "command_disable_lightweight_mode": "Disable Lightweight Mode",
      "command_color_highlight_once": "Color / Highlight Once Selected Text",
      "notice_select_text_first_once": "Please select text first to color/highlight once.",
      "command_activate_word_group": "Activate {groupName} Word Group",
      "command_deactivate_word_group": "Deactivate {groupName} Word Group",
      // Notifications
      "notice_lightweight_mode_enabled": "Lightweight Mode enabled",
      "notice_lightweight_mode_disabled": "Lightweight Mode disabled",
      "notice_enabled": "Always Color Text Enabled",
      "notice_disabled": "Always Color Text Disabled",
      "notice_blacklisted_cannot_color": '"{word}" is blacklisted and cannot be colored.',
      "notice_removed_always_color": 'Removed Always Color Text for "{word}".',
      "notice_added_to_blacklist": 'Added "{word}" to blacklist.',
      "notice_already_blacklisted": '"{word}" is already in blacklist.',
      "notice_select_text_first": "Please select some text first.",
      "notice_no_active_file": "No active file to toggle coloring for.",
      "notice_coloring_enabled_for_path": "Coloring enabled for {path}",
      "notice_coloring_disabled_for_path": "Coloring disabled for {path}",
      "notice_global_enabled": "Always Color Text Enabled",
      "notice_global_disabled": "Always Color Text Disabled",
      "notice_unable_open_changelog": "Unable to open changelog modal.",
      "notice_pattern_blocked": "Pattern blocked for memory safety:",
      "notice_pattern_too_complex": "Pattern too complex:",
      "notice_invalid_hex_format": "Invalid hex color format. Use #RRGGBB or #RGB.",
      "notice_error_saving_changes": "Error saving changes. Please try again.",
      "notice_invalid_color_format": "Invalid color format.",
      "notice_exported": "Exported: {fname}",
      "notice_export_failed": "Export failed",
      "notice_import_completed": "Import completed",
      "notice_import_failed": "Import failed",
      "notice_invalid_regex": "Invalid Regex",
      "notice_empty_pattern": "Pattern is empty",
      "notice_added_regex": "Regex Added",
      "notice_rule_updated": "Rule updated",
      "notice_regex_updated": "Regex updated",
      "notice_entry_updated": "Entry updated",
      "notice_entry_duplicated": "Entry Duplicated",
      "notice_error_opening_regex_tester": "Error opening regex tester",
      "notice_error_opening_blacklist_regex_tester": "Error opening blacklist regex tester",
      "notice_error_opening_advanced_rules": "Error opening advanced rules modal",
      "notice_text_color_reset": "Text color reset",
      "notice_highlight_reset": "Highlight reset",
      "notice_text_colors_hidden": "Text colors hidden",
      "notice_text_colors_visible": "Text colors visible",
      "notice_highlights_hidden": "Highlights hidden",
      "notice_highlights_visible": "Highlights visible",
      "notice_regex_support_disabled": "Regex support is disabled. Enable it in settings to use regex patterns.",
      "notice_no_active_file_to_disable": "No active file to disable coloring for.",
      "notice_already_disabled_for_path": "Coloring already disabled for {path}",
      "notice_filter_disabled": "Filter Disabled",
      // Confirmation Dialogs
      "confirm_delete_all_title": "Delete All Words",
      "confirm_delete_all_desc": "Are you sure you want to delete ALL colored words/patterns? This cannot be undone!",
      "confirm_delete_all_blacklist_title": "Delete All Blacklisted Words",
      "confirm_delete_all_blacklist_desc": "Are you sure you want to delete ALL blacklist entries? This cannot be undone!",
      "restart_required_title": "Restart Required",
      "restart_required_desc": "Disabling command palette toggle requires an Obsidian restart to fully remove the command from the palette. Restart now?",
      "btn_cancel": "Cancel",
      "btn_confirm": "Confirm",
      // Basic Settings
      "enable_document_color": "Enable Global Color",
      "color_rendering_header": "Color Rendering & Performance",
      "theme_support_header": "Theme Support",
      "matching_behavior_header": "Matching Behavior",
      "smart_update_mode": "Smart Updates (Experimental)",
      "smart_update_mode_desc": "Intelligently updates only visible, changed lines while typing. Significantly improves typing performance.",
      "light_mode_fixer": "Light Mode Text Color Fixer",
      "dark_mode_fixer": "Dark Mode Text Color Fixer",
      "color_in_live_preview_mode": "Color in Live Preview Mode",
      "color_in_reading_mode": "Color in Reading Mode",
      "force_full_render_reading": "Force Full Render in Reading Mode",
      "force_full_render_reading_desc": "If on, Reading Mode will try to color the whole document at once. May cause lag on large docs, use carefully!",
      "lightweight_mode": "Lightweight Mode (Experimental)",
      "lightweight_mode_desc": "Optimized for speed. Skips expensive checks and partial matches. Auto-enabled for large files.",
      "disable_coloring_current_file": "Disable coloring for current file",
      "disable_coloring_current_file_desc": "Adds an exclude rule for the active file under File & Folder Coloring Rules.",
      "btn_disable_for_this_file": "Disable for this file",
      // Coloring Settings
      "coloring_settings_header": "Coloring Settings",
      "regex_support": "Regex Support",
      "regex_support_desc": "Allow patterns to be regex. Invalid regex will be ignored for safety.",
      "disable_regex_safety": "Disable Regex Safety Check",
      "disable_regex_safety_desc": "Allow complex or potentially dangerous expressions. May cause lag or freezes.",
      "requires_regex_safety_disabled": "Requires regex safety disabled",
      "case_sensitive": "Case Sensitive",
      "case_sensitive_desc": 'If on, "word" and "Word" are different. If off, they color the same.',
      "partial_match": "Partial Match",
      "partial_match_desc": 'If on, colors the whole word if any colored word is found inside (e.g. "as" colors "Jasper").',
      // One-Time Actions
      "one_time_actions_header": "One-Time Actions",
      "setting_color_once": "Color Once",
      "setting_color_once_desc": "Insert HTML inline style for selected text. Persists even if plugin is off.",
      "setting_highlight_once": "Highlight Once",
      "setting_highlight_once_desc": "Insert HTML inline style with background. Persists even if plugin is off.",
      "setting_color_highlight_once": "Color & Highlight Once",
      "setting_color_highlight_once_desc": "Opens the unified color picker to apply both text color and background highlight inline. Uses Unified Menu.",
      "highlight_once_preview": "Highlight Once Preview",
      "highlight_once_preview_text": "This is how highlight once looks!",
      // Highlight Once Settings
      "highlight_once_opacity": "Highlight Once Opacity",
      "highlight_once_border_radius": "Highlight Once Border Radius (px)",
      "reset_to_8": "Reset to 8",
      "highlight_horizontal_padding": "Highlight Horizontal Padding (px)",
      "highlight_vertical_padding": "Highlight Vertical Padding (px)",
      "reset_to_4": "Reset to 4",
      "enable_border_highlight_once": "Enable Border for Highlight Once",
      "enable_border_highlight_once_desc": "Add a border to the inline highlight. Added HTML/CSS will be long.",
      "highlight_once_border_style": "Highlight Once Border Side",
      "highlight_once_border_line_style": "Border Style",
      "opt_border_full": "Full Border (All Sides)",
      "opt_border_top_bottom": "Top & Bottom",
      "opt_border_left_right": "Left & Right",
      "opt_border_top_left_right": "Top, Left & Right",
      "opt_border_bottom_left_right": "Bottom, Left & Right",
      "opt_border_top_right": "Top & Right",
      "opt_border_top_left": "Top & Left",
      "opt_border_bottom_right": "Bottom & Right",
      "opt_border_bottom_left": "Bottom & Left",
      "opt_border_top": "Top Only",
      "opt_border_bottom": "Bottom Only",
      "opt_border_left": "Left Only",
      "opt_border_right": "Right Only",
      "highlight_once_border_opacity": "Highlight Once Border Opacity",
      "highlight_once_border_thickness": "Highlight Once Border Thickness (px)",
      "reset_to_1": "Reset to 1",
      "use_global_highlight_style": "Use Global Highlight Style for Highlight Once",
      "use_global_highlight_style_desc": "Use your global inline styles. Added HTML/CSS may be long.",
      "style_highlight_once": "Style Highlight Once",
      "style_highlight_once_desc": "Use your custom inline styles. Added HTML/CSS may be long.",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "Global Highlight Coloring Appearance",
      "highlight_opacity": "Highlight Opacity",
      "highlight_opacity_desc": "Set the opacity of the highlight (0-100%)",
      "highlight_border_radius": "Highlight Border Radius (px)",
      "highlight_border_radius_desc": "Set the border radius of the highlight corners in px",
      "highlight_horizontal_padding_desc": "Set left/right padding for highlighted text in px",
      "highlight_vertical_padding_desc": "Set top/bottom padding for highlighted text in px",
      "rounded_corners_wrapping": "Rounded Corners on Wrap",
      "rounded_corners_wrapping_desc": "If on, highlights have rounded corners on all sides even when text wraps to a new line.",
      "enable_highlight_border": "Enable Highlight Border",
      "enable_highlight_border_desc": "Add a border around highlights. Border matches text or highlight color.",
      "border_style": "Border Side",
      "border_style_desc": "Select which sides to apply the border to",
      "border_line_style": "Border Style",
      "border_line_style_desc": "Select the border line style",
      "border_opacity": "Border Opacity",
      "border_opacity_desc": "Set the opacity of the border (0-100%)",
      "border_thickness": "Border Thickness (px)",
      "border_thickness_desc": "Set the border thickness from 0-5 pixels (e.g. 1, 2.5, 5)",
      "highlight_preview": "Highlight Preview",
      "highlight_preview_text": "This is how your highlight looks!",
      "opt_line_solid": "Solid",
      "opt_line_dashed": "Dashed",
      "opt_line_dotted": "Dotted",
      "opt_line_double": "Double",
      "opt_line_groove": "Groove",
      "opt_line_ridge": "Ridge",
      "opt_line_inset": "Inset",
      "opt_line_outset": "Outset",
      // Color Swatches
      "color_swatches_header": "Color Management",
      "color_picker_layout": "Color Picker Layout",
      "color_picker_layout_desc": "Choose which color types to show when picking colors for text",
      "enable_custom_swatches": "Enable custom swatches",
      "enable_custom_swatches_desc": "Turn this on if you want to pick your own colors for the color picker.",
      "replace_default_swatches": "Replace default swatches",
      "replace_default_swatches_desc": "If enabled, only your custom swatches will be shown. If disabled, they will be appended to the default ones.",
      "use_swatch_names": "Use swatch names for coloring text",
      "use_swatch_names_desc": "If enabled, the text will be colored using the name of the swatch (e.g., 'Red') instead of the hex code.",
      "link_swatch_updates": "Link swatch updates to text colors",
      "link_swatch_updates_desc": "If enabled, updating a swatch color will update all text colored with that swatch.",
      "default_colors_header": "Default Swatches",
      "custom_swatches_header": "Custom Swatches",
      "btn_add_color": "+ Add Color",
      "no_custom_swatches_yet": 'No custom swatches yet. Click "+ Add Color" to create one.',
      "label_built_in": "(Built-in)",
      // Color Picker
      "pick_color_header": "Pick Color",
      "selected_text_preview": "Selected Text",
      "text_color_title": "Text Color",
      "select_swatch": "Select Swatch...",
      "highlight_color_title": "Highlight Color",
      "select_highlight_swatch": "Select Highlight Swatch...",
      "settings_tab_general": "General",
      "settings_tab_colored_texts": "Colored Texts",
      "settings_tab_blacklists": "Blacklists",
      "settings_tab_file_folder_rules": "File / Folder Rules",
      "settings_tab_data": "Data",
      // Always Colored Texts
      "colored_texts_header": "Colored Texts",
      "always_colored_texts_desc": "This is where you manage your words/patterns and their colors.",
      "grouped_entries_header": "Grouped Entries",
      "btn_create_new_group": "+ Create New Group",
      "edit_word_group_modal_title": "Edit Word Group",
      "group_name_placeholder": "Name your group",
      "btn_save_group": "Save Group",
      "btn_delete_group": "Delete Group",
      "group_active_label": "Active",
      "group_inactive_label": "Inactive",
      "confirm_delete_group_title": "Delete Group",
      "confirm_delete_group_desc": "Are you sure you want to delete this group? This cannot be undone.",
      "confirm_delete_all_groups_title": "Delete All Word Groups",
      "confirm_delete_all_groups_desc": "Are you sure you want to delete ALL word groups? This cannot be undone!",
      "search_colored_words_placeholder": "Search colored words or patterns...",
      "btn_add_new_word": "+ Add New Word",
      "sort_label_last-added": "Sort: Last Added",
      "sort_label_a-z": "Sort: A-Z",
      "sort_label_reverse-a-z": "Sort: Z-A",
      "sort_label_style-order": "Sort: Style Order",
      "sort_label_color": "Sort: Color",
      "style_type_text": "Color",
      "style_type_highlight": "Highlight",
      "style_type_both": "Both",
      "word_pattern_placeholder_long": "pattern, word, or comma separated words (e.g. hello, world, foo)",
      "word_pattern_placeholder_short": "keyword or pattern, or comma separated words",
      "use_regex": "Use Regex",
      "flags_placeholder": "Flags",
      "text_or_regex_placeholder": "Text/Regex Input",
      "duplicate_entry": "Duplicate Entry",
      "open_in_regex_tester": "Open in Regex Tester",
      "no_rules_configured": "No rules configured.",
      "no_rules_found": "No rules found.",
      "match_option_exact": "Exact",
      "match_option_contains": "Contains",
      "match_option_starts_with": "Starts With",
      "match_option_ends_with": "Ends With",
      // Presets
      "btn_presets": "Presets",
      "preset_all_headings": "All Headings (H1-H6)",
      "preset_headings_h3": "Headings (H3)",
      "preset_bullet_points": "Bullet Points",
      "preset_numbered_lists": "Numbered Lists",
      "preset_task_checked": "Task Lists (Checked)",
      "preset_task_unchecked": "Task Lists (Unchecked)",
      "preset_dates_yyyy_mm_dd": "Dates (YYYY-MM-DD)",
      "preset_times_am_pm": "Times (AM/PM)",
      "preset_times_24h": "Times (24h)",
      "preset_dates_yyyy_mmm_dd": "Dates (YYYY-MMM-DD)",
      "preset_relative_dates": "Relative Dates",
      "preset_basic_urls": "Basic URLs",
      "preset_markdown_links": "Markdown Links",
      "preset_domain_names": "Domain Names",
      "preset_email_addresses": "Email Addresses",
      "preset_at_username": "@Username",
      "preset_currency": "Currency",
      "preset_measurements": "Measurements",
      "preset_phone_numbers": "Phone Numbers",
      "preset_all_texts": "All Text",
      "preset_codeblocks": "Codeblocks",
      "preset_inline_comments": "Comments (%%...%%)",
      "preset_highlighted_text": "Highlighted Text (==...==)",
      "preset_parentheses": "Parentheses ()",
      "preset_square_brackets": "Square Brackets []",
      "preset_curly_braces": "Curly Braces {}",
      "preset_angle_brackets": "Angle Brackets <>",
      "preset_colons": "Colons :",
      "preset_double_quotes": "Double Quotes",
      "preset_single_quotes": "Single Quotes",
      "preset_single_quotes_word_bounded": "Single Quotes (Word Bounded)",
      "preset_bold": "Bold",
      "preset_italic": "Italic",
      "preset_bold_italic": "Bold Italic",
      "preset_group_markdown_formatting": "Markdown Formatting",
      "preset_group_other_patterns": "Other Patterns",
      "preset_group_brackets": "Brackets",
      // Preset Examples
      "preset_example_heading": "# Heading",
      "preset_example_heading_h3": "### Heading",
      "preset_example_bullet": "- Bullet point",
      "preset_example_numbered": "1. First item",
      "preset_example_task_checked": "- [x] Completed",
      "preset_example_task_unchecked": "- [ ] Todo",
      "preset_example_codeblock": "``` code ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[Link](https://example.com)",
      "preset_example_comment": "%% comment %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "name@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "$29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( text )",
      "preset_example_square_brackets": "[ yes ]",
      "preset_example_curly_braces": "{ no }",
      "preset_example_angle_brackets": "< text >",
      "preset_example_colons": ": text :",
      "preset_example_double_quotes": '"text"',
      "preset_example_single_quotes": "'text'",
      "preset_example_single_quotes_word": "'word'",
      "preset_example_highlight": "==highlighted text==",
      "preset_example_all_text": "This will target all texts.",
      // Blacklist Settings
      "blacklist_words_header": "Blacklists",
      "blacklist_words_desc": "Keywords or patterns here will never be colored, even for partial matches.",
      "search_blacklist_placeholder": "Search blacklisted words or patterns\u2026",
      "blacklist_sort_label_last-added": "Sort: Last Added",
      "blacklist_sort_label_a-z": "Sort: A-Z",
      "blacklist_sort_label_reverse-a-z": "Sort: Z-A",
      "btn_add_blacklist": "+ Add blacklist word or pattern",
      "btn_add_to_blacklist": "+ Add to Blacklist",
      "btn_add_blacklist_word": "+ Add blacklist word",
      "btn_add_blacklist_regex": "+ Add blacklist regex",
      // File & Folder Rules
      "file_folder_rules_header": "File & Folder Coloring Rules",
      "file_folder_rules_desc": "Control coloring with name matching, exact paths, or regex patterns. Leave an empty exclude entry to disable coloring vault-wide.",
      "search_file_folder_rules_placeholder": "Search file/folder rules\u2026",
      "path_sort_label_last-added": "Sort: Last Added",
      "path_sort_label_a-z": "Sort: A-Z",
      "path_sort_label_reverse-a-z": "Sort: Z-A",
      "path_sort_label_mode": "Sort: Mode",
      "path_sort_label_type": "Sort: Type",
      "btn_add_file_folder_rule": "+ Add file/folder rule",
      "disabled_files_header": "Files with coloring disabled:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "Include",
      "path_rule_mode_exclude": "Exclude",
      "text_rule_mode_include": "only colors in (whitelist)",
      "text_rule_mode_exclude": "does not color in (blacklist)",
      "mode_only_colors_in": "only colors in",
      "mode_does_not_color_in": "does not color in",
      "label_text_include": "Whitelist",
      "label_text_exclude": "Blacklist",
      "label_enable_in": "Enable in",
      "label_disable_in": "Disable in",
      "enter_path_or_pattern": "Enter path, pattern or tags",
      "label_regex": "Regex",
      // Advanced Rules
      "advanced_rules_header": "Specific Include/Exclude Rules",
      "advanced_rules_modal_header": "Specific Include/Exclude Rules",
      "advanced_rules_manage_button": "manage specific include/exclude rules",
      "edit_rule_header": "Edit Rule",
      "add_rule_header": "Add New Rule",
      "btn_add_rule": "+ Add Rule",
      "btn_save_rule": "Save Rule",
      "btn_add_words": "+ Add Words",
      "btn_add_regex": "+ Add Regex",
      "btn_save_regex": "Save Regex",
      // Regex Tester
      "regex_tester_header": "Regex Tester",
      "regex_tester_blacklist": "Regex tester - blacklist",
      "regex_expression_placeholder": "Put your Regex Expression here",
      "regex_subject_placeholder": "type your subject / test string here...",
      "regex_name_placeholder": "name your regex",
      "matches": "matches",
      "matches_found": "matches found",
      // Regex Flags
      "flag_g": "global flag: find all matches",
      "flag_i": "case-insensitive flag",
      "flag_m": "multiline flag: ^ and $ match line boundaries",
      "flag_s": "dotAll flag: . matches newlines",
      "flag_u": "unicode flag: treat as unicode code points",
      "flag_y": "sticky flag: match from lastIndex position",
      // Data Export/Import
      "data_export_import_header": "Data Export/Import",
      "export_plugin_data": "Export plugin data",
      "export_plugin_data_desc": "Export settings, words, and rules to a JSON file.",
      "btn_export": "Export",
      "import_plugin_data": "Import plugin data",
      "import_plugin_data_desc": "Import settings from a JSON file",
      "btn_import": "Import",
      "limit_input_placeholder": "limit",
      "limit_input_tooltip": "0=all; number=last N; r=regex; h=highlight; c=text; b=text+bg; sw=starts; ew=ends; e=exact",
      // Missing Keys Added
      "highlight_styling_header": "Edit Highlight Styling",
      "edit_entry_header": "Edit Entry",
      "opt_case_sensitive": "is case sensitive",
      "opt_not_case_sensitive": "not case sensitive",
      "opt_case_all": "Case Sensitivity (All)",
      "opt_match_all": "Match Type (All)",
      "edit_highlight_styling_btn": "Edit Highlight Styling",
      "inclusion_exclusion_header": "Inclusion / Exclusion Rules",
      "btn_save_entry": "Save Entry",
      "edit_entry_details": "Edit Entry Details",
      "prompt_search_existing": "Search existing entries\u2026",
      "command_add_to_existing_entry": "Add to Existing Entry",
      "context_remove_from_entry": 'Remove "{word}" from entry',
      "context_delete_entry": "Delete entry",
      "btn_reset": "Reset",
      "btn_reset_all": "Reset Highlight Style",
      "btn_add_word": "+ Add Word",
      "btn_add_regex_short": "+ Add Regex",
      "section_highlight_border_styling": "Highlight Border Styling",
      "section_highlight_styling": "Highlight Styling",
      "label_highlight_opacity": "Highlight Opacity",
      "label_highlight_radius": "Highlight Border Radius",
      "label_horizontal_padding": "Horizontal Padding",
      "label_vertical_padding": "Vertical Padding",
      "label_enable_border": "Enable Border",
      "label_border_sides": "Border Sides",
      "label_border_style": "Border Style",
      "label_border_opacity": "Border Opacity",
      "label_border_thickness": "Border Thickness",
      "btn_save_style": "Save Style",
      "share_export_title": "Always Color Text export",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "Style Name",
      "preview_text": "Text",
      // Quick Colors / Styles
      "quick_actions_header": "Quick Actions",
      "quick_colors_header": "Quick Colors",
      "quick_colors_desc": "Allows you to quickly highlight or color text by showing colors in the right-click menu. If Quick Colors are off, per-style colors in Quick Styles will be used.",
      "quick_colors_apply_mode_label": "The text coloring will apply as",
      "quick_colors_apply_mode_act": "Always Color Text",
      "quick_colors_apply_mode_html": "Inline HTML",
      "quick_styles_header": "Quick Styles",
      "quick_styles_desc": "Define named styles for applying text color and highlights. If Quick Colors are off, per-style colors here will be used.",
      "btn_add_style": "+ Add Style",
      "quick_styles_menu_option": "Quick Styles",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "Blacklist Group Entries",
      "show_blacklist_groups_in_commands": "Show blacklist groups in commands",
      "show_blacklist_groups_in_commands_desc": "When enabled, blacklist groups appear in the command palette with Activate/Deactivate commands.",
      "search_blacklist_groups_placeholder": "Search blacklist groups\u2026",
      "btn_create_new_blacklist_group": "+ Create New Blacklist Group",
      "edit_blacklist_group_modal_title": "Edit Blacklist Group",
      "tooltip_delete_all_blacklist_groups": "Delete all Blacklist Groups",
      "confirm_delete_all_blacklist_groups_title": "Delete All Blacklist Groups",
      "confirm_delete_all_blacklist_groups_desc": "Are you sure you want to delete ALL blacklist groups? This cannot be undone!",
      "confirm_delete_blacklist_group_title": "Delete Blacklist Group",
      "confirm_delete_blacklist_group_desc": "Are you sure you want to delete this blacklist group? This cannot be undone.",
      "notice_blacklist_group_activated": "Blacklist group activated",
      "notice_blacklist_group_deactivated": "Blacklist group deactivated",
      "command_activate_blacklist_group": "Activate {groupName} Blacklist Group",
      "command_deactivate_blacklist_group": "Deactivate {groupName} Blacklist Group",
      "btn_duplicate_entry": "Duplicate Entry",
      "btn_open_in_regex_tester": "Open in Regex Tester",
      "move_to_blacklist_group": "Move to Blacklist Group",
      "btn_delete_entry": "Delete Entry",
      "edit_group_highlight_styling": "Edit Group Highlight Styling",
      "light_mode_fixer_desc": "Automatically darkens colored text when using Light theme to improve visibility.",
      "dark_mode_fixer_desc": "Automatically lightens colored text when using Dark theme to improve visibility."
    };
  }
});

// src/i18n/es.js
var require_es = __commonJS({
  "src/i18n/es.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "Espa\xF1ol",
      "settings_title": "Configuraci\xF3n de Always Color Text",
      "header_plugin_name": "Always Color Text",
      "ribbon_title": "Always color text",
      // Language Settings
      "language_label": "Idioma",
      "language_desc": "Selecciona el idioma que se utilizar\xE1 en este plugin",
      "language_en": "Ingl\xE9s",
      "language_es": "Espa\xF1ol",
      "language_fr": "Franc\xE9s",
      "language_eu": "Euskera",
      "language_ru": "Ruso",
      "language_auto": "Predeterminado del Sistema",
      "default": "Predeterminado",
      // Release Notes
      "latest_release_notes_label": "Notas de la \xDAltima Versi\xF3n",
      "latest_release_notes_desc": "Ver las notas de la versi\xF3n m\xE1s reciente del plugin",
      "open_changelog_button": "Abrir Registro de Cambios",
      "command_show_release_notes": "Mostrar Notas de la \xDAltima Versi\xF3n",
      "changelog_view_on_github": "Ver en GitHub",
      "changelog_loading": "Cargando versiones\u2026",
      "changelog_no_info": "No hay informaci\xF3n de versi\xF3n disponible.",
      "changelog_release": "Versi\xF3n",
      "changelog_no_notes": "Sin notas",
      "changelog_failed_to_load": "Error al cargar las notas de la versi\xF3n.",
      // UI Elements & Menus
      "file_menu_enable": "Activar always color text para este archivo",
      "file_menu_disable": "Desactivar always color text para este archivo",
      "menu_color_once": "Colorear Una Vez",
      "menu_highlight_once": "Resaltar Una Vez",
      "menu_color_highlight_once": "Color / Resaltar Una Vez",
      "menu_remove_inline_color": "Eliminar Color Inline",
      "menu_always_color_text": "Always color text",
      "menu_remove_always_color_text": "Eliminar Always Color Text",
      "menu_blacklist_word": "A\xF1adir Palabra a la Lista Negra",
      "show_toggle_statusbar": "Mostrar Alternador en Barra de Estado",
      "show_toggle_ribbon": "Mostrar icono de alternancia en la cinta",
      "show_toggle_command": "Mostrar Alternador en comandos",
      "menu_options_header": "Opciones de Men\xFA",
      "show_blacklist_menu": 'Mostrar "Palabra en Lista Negra" en el men\xFA contextual',
      "show_blacklist_menu_desc": "A\xF1ade un elemento al men\xFA contextual para a\xF1adir el texto seleccionado a la lista negra del coloreado.",
      "show_add_to_existing_menu": 'Mostrar "A\xF1adir a Entrada Existente" en el men\xFA contextual',
      "show_add_to_existing_menu_desc": "A\xF1ade un elemento al men\xFA contextual para a\xF1adir el texto seleccionado a una entrada existente.",
      "show_always_color_text_menu": 'Mostrar "Always Color Text" en el men\xFA contextual',
      "show_always_color_text_menu_desc": "A\xF1ade un elemento al men\xFA contextual para colorear el texto seleccionado.",
      "hide_inactive_groups_in_dropdowns": "Ocultar grupos inactivos en los men\xFAs desplegables",
      "hide_inactive_groups_in_dropdowns_desc": "Oculta los grupos de palabras inactivos al mostrar listas de grupos en los men\xFAs desplegables.",
      "show_word_groups_in_commands": "Mostrar grupos de palabras en comandos",
      "show_word_groups_in_commands_desc": "Cuando est\xE1 activado, los grupos de palabras aparecen en la paleta de comandos con comandos Activar/Desactivar.",
      "tooltip_enable_for_file": "Activar para este archivo",
      "tooltip_delete_all_words": "Eliminar todas las palabras/patrones definidos",
      "tooltip_delete_all_blacklist": "Eliminar todas las palabras/patrones de la lista negra",
      "tooltip_use_regex": "Usar como patr\xF3n regex",
      "drag_to_reorder": "Arrastra para reordenar",
      "reset_text_color": "Restablecer color de texto",
      "reset_highlight": "Restablecer resaltado",
      // Commands
      "command_color_selected": "Colorear Texto Seleccionado",
      "command_toggle_current": "Activar/Desactivar coloreado para el documento actual",
      "command_enable_current": "Activar coloreado para el documento actual",
      "command_disable_current": "Desactivar coloreado para el documento actual",
      "command_toggle_global": "Activar/Desactivar coloraci\xF3n global",
      "command_enable_global": "Activar coloraci\xF3n global",
      "command_disable_global": "Desactivar coloraci\xF3n global",
      "enable_document_color": "Activar color global",
      "color_swatches_header": "Gesti\xF3n del color",
      "color_rendering_header": "Renderizado de color y rendimiento",
      "theme_support_header": "Soporte de temas",
      "matching_behavior_header": "Comportamiento de coincidencia",
      "smart_update_mode": "Actualizaciones inteligentes (Experimental)",
      "smart_update_mode_desc": "Solo actualiza el coloreado de la l\xEDnea activa mientras se escribe y congela otras l\xEDneas para mejorar el rendimiento.",
      "light_mode_fixer": "Corrector de color de texto en modo claro",
      "dark_mode_fixer": "Corrector de color de texto en modo oscuro",
      "command_manage_advanced_rules": "gestionar reglas espec\xEDficas de inclusi\xF3n/exclusi\xF3n",
      "command_open_regex_tester": "A\xF1adir Regex (Abrir Probador de Regex)",
      "command_open_blacklist_regex_tester": "Agregar Expresi\xF3n Regular de Lista Negra",
      "command_manage_colored_texts": "Gestionar Textos Coloreados",
      "command_toggle_hide_text_colors": "Ocultar/Mostrar colores de texto",
      "command_toggle_hide_highlights": "Ocultar/Mostrar resaltados",
      "command_hide_text_colors": "Ocultar colores de texto",
      "command_unhide_text_colors": "Mostrar colores de texto",
      "command_hide_highlights": "Ocultar resaltados",
      "command_unhide_highlights": "Mostrar resaltados",
      "command_enable_lightweight_mode": "Activar Modo Ligero",
      "command_disable_lightweight_mode": "Desactivar Modo Ligero",
      "command_color_highlight_once": "Colorear / Resaltar Texto Seleccionado (Una vez)",
      "notice_select_text_first_once": "Por favor seleccione texto primero para colorear/resaltar.",
      "command_activate_word_group": "Activar el grupo de palabras {groupName}",
      "command_deactivate_word_group": "Desactivar el grupo de palabras {groupName}",
      // Notifications
      "notice_lightweight_mode_enabled": "Modo Ligero activado",
      "notice_lightweight_mode_disabled": "Modo Ligero desactivado",
      "notice_enabled": "Always color text activado",
      "notice_disabled": "Always color text desactivado",
      "notice_blacklisted_cannot_color": '"{word}" est\xE1 en la lista negra y no puede colorearse.',
      "notice_removed_always_color": 'Se elimin\xF3 el coloreado permanente de "{word}".',
      "notice_added_to_blacklist": '"{word}" a\xF1adido a la lista negra.',
      "notice_already_blacklisted": '"{word}" ya est\xE1 en la lista negra.',
      "notice_select_text_first": "Por favor, selecciona primero alg\xFAn texto.",
      "notice_no_active_file": "No hay un archivo activo para activar o desactivar el coloreado.",
      "notice_coloring_enabled_for_path": "Coloreado activado para {path}",
      "notice_coloring_disabled_for_path": "Coloreado desactivado para {path}",
      "notice_global_enabled": "Always Color Text Activado",
      "notice_global_disabled": "Always Color Text Desactivado",
      "notice_unable_open_changelog": "No se pudo abrir el modal del registro de cambios.",
      "notice_pattern_blocked": "Patr\xF3n bloqueado por Seguridad de Memoria:",
      "notice_pattern_too_complex": "Patr\xF3n demasiado complejo:",
      "notice_invalid_hex_format": "Formato de color hexadecimal inv\xE1lido. Usa #RRGGBB o #RGB.",
      "notice_error_saving_changes": "Error guardando cambios. Por favor, int\xE9ntalo de nuevo.",
      "notice_invalid_color_format": "Formato de color inv\xE1lido.",
      "notice_exported": "Exportado: {fname}",
      "notice_export_failed": "Error en la exportaci\xF3n",
      "notice_import_completed": "Importaci\xF3n completada",
      "notice_import_failed": "Error en la importaci\xF3n",
      "notice_invalid_regex": "Expresi\xF3n regular inv\xE1lida",
      "notice_empty_pattern": "El patr\xF3n est\xE1 vac\xEDo",
      "notice_added_regex": "Expresi\xF3n regular a\xF1adida",
      "notice_rule_updated": "Regla actualizada",
      "notice_regex_updated": "Expresi\xF3n regular actualizada",
      "notice_entry_updated": "Entrada actualizada",
      "notice_entry_duplicated": "Entrada duplicada",
      "notice_error_opening_regex_tester": "Error al abrir el probador de regex",
      "notice_error_opening_blacklist_regex_tester": "Error al abrir el probador de regex de lista negra",
      "notice_error_opening_advanced_rules": "Error al abrir el modal de reglas avanzadas",
      "notice_text_color_reset": "Color de texto restablecido",
      "notice_highlight_reset": "Resaltado restablecido",
      "notice_text_colors_hidden": "Colores de texto ocultos",
      "notice_text_colors_visible": "Colores de texto visibles",
      "notice_highlights_hidden": "Resaltados ocultos",
      "notice_highlights_visible": "Resaltados visibles",
      "notice_regex_support_disabled": "El soporte de regex est\xE1 desactivado. Act\xEDvalo en la configuraci\xF3n para usar patrones regex.",
      "notice_no_active_file_to_disable": "No hay archivo activo para desactivar el coloreado.",
      "notice_already_disabled_for_path": "El coloreado ya est\xE1 desactivado para {path}",
      "notice_filter_disabled": "Filtro desactivado",
      // Confirmation Dialogs
      "confirm_delete_all_title": "Eliminar todas las palabras",
      "confirm_delete_all_desc": "\xBFEst\xE1s seguro de que quieres eliminar TODAS las palabras/patrones coloreados? \xA1Esto no se puede deshacer!",
      "confirm_delete_all_blacklist_title": "Eliminar todas las palabras de la lista negra",
      "confirm_delete_all_blacklist_desc": "\xBFEst\xE1s seguro de que quieres eliminar TODAS las entradas de la lista negra? \xA1Esto no se puede deshacer!",
      "confirm_delete_all_groups_title": "Eliminar todos los grupos de palabras",
      "confirm_delete_all_groups_desc": "\xBFEst\xE1s seguro de que quieres eliminar TODOS los grupos de palabras? \xA1Esto no se puede deshacer!",
      "restart_required_title": "Reinicio necesario",
      "restart_required_desc": "Desactivar la alternancia en la paleta de comandos requiere reiniciar Obsidian para eliminar completamente el comando de la paleta. \xBFReiniciar ahora?",
      // Basic Settings
      "color_in_live_preview_mode": "Colorear en Modo Vista Previa",
      "color_in_reading_mode": "Colorear en Modo Lectura",
      "force_full_render_reading": "Forzar renderizado completo en Modo Lectura",
      "force_full_render_reading_desc": "Si est\xE1 activado, el Modo Lectura intentar\xE1 colorear todo el documento a la vez. \xA1Puede causar retrasos en documentos grandes, \xFAsalo con cuidado!",
      "lightweight_mode": "Modo ligero (Experimental)",
      "lightweight_mode_desc": "Reduce enormemente el procesamiento al escribir. Puede omitir algunas coincidencias.",
      "disable_coloring_current_file": "Desactivar coloreado para el archivo actual",
      "disable_coloring_current_file_desc": "A\xF1ade una regla de exclusi\xF3n para el archivo activo en Reglas de Coloreado para Archivos y Carpetas.",
      "btn_disable_for_this_file": "Desactivar para este archivo",
      // Coloring Settings
      "coloring_settings_header": "Configuraci\xF3n de Coloreado",
      "regex_support": "Soporte Regex",
      "regex_support_desc": "Permite que los patrones sean expresiones regulares. Las regex inv\xE1lidas se ignorar\xE1n por seguridad.",
      "disable_regex_safety": "Desactivar comprobaci\xF3n de seguridad de Regex",
      "disable_regex_safety_desc": "Permite expresiones complejas o potencialmente peligrosas. Puede causar retrasos o bloqueos.",
      "case_sensitive": "Sensible a may\xFAsculas",
      "case_sensitive_desc": 'Si est\xE1 activado, "palabra" y "Palabra" son diferentes. Si est\xE1 desactivado, se colorean igual.',
      "partial_match": "Coincidencia parcial",
      "partial_match_desc": 'Si est\xE1 activado, colorea toda la palabra si se encuentra alguna palabra coloreada dentro (p. ej. "sol" colorea "girasol").',
      // One-Time Actions
      "one_time_actions_header": "Acciones de una sola vez",
      "setting_color_once": "Colorear Una Vez",
      "setting_color_once_desc": "Insertar estilo HTML inline para el texto seleccionado. Persiste incluso si el plugin est\xE1 desactivado.",
      "setting_highlight_once": "Resaltar Una Vez",
      "setting_highlight_once_desc": "Insertar estilo HTML inline con fondo. Persiste incluso si el plugin est\xE1 desactivado.",
      "setting_color_highlight_once": "Color y Resaltar una vez",
      "setting_color_highlight_once_desc": "Abre el selector de color unificado para aplicar tanto el color del texto como el resaltado de fondo en l\xEDnea. Utiliza el men\xFA unificado.",
      "highlight_once_preview": "Vista previa de Resaltar Una Vez",
      "highlight_once_preview_text": "\xA1As\xED se ve el resaltado una vez!",
      // Highlight Once Settings
      "highlight_once_opacity": "Opacidad de Resaltar Una Vez",
      "highlight_once_border_radius": "Radio de borde de Resaltar Una Vez (px)",
      "reset_to_8": "Restablecer a 8",
      "highlight_horizontal_padding": "Relleno horizontal de resaltado (px)",
      "highlight_vertical_padding": "Relleno vertical de resaltado (px)",
      "reset_to_4": "Restablecer a 4",
      "enable_border_highlight_once": "Habilitar borde para Resaltar Una Vez",
      "enable_border_highlight_once_desc": "A\xF1adir un borde al resaltado inline. El HTML/CSS a\xF1adido ser\xE1 largo.",
      "highlight_once_border_style": "Lado del borde de Resaltar Una Vez",
      "highlight_once_border_line_style": "Estilo de Borde",
      "opt_border_full": "Borde Completo (Todos los lados)",
      "opt_border_top_bottom": "Arriba y Abajo",
      "opt_border_left_right": "Izquierda y Derecha",
      "opt_border_top_left_right": "Arriba, Izquierda y Derecha",
      "opt_border_bottom_left_right": "Abajo, Izquierda y Derecha",
      "opt_border_top_right": "Arriba y Derecha",
      "opt_border_top_left": "Arriba e Izquierda",
      "opt_border_bottom_right": "Abajo y Derecha",
      "opt_border_bottom_left": "Abajo e Izquierda",
      "opt_border_top": "Solo Arriba",
      "opt_border_bottom": "Solo Abajo",
      "opt_border_left": "Solo Izquierda",
      "opt_border_right": "Solo Derecha",
      "highlight_once_border_opacity": "Opacidad del borde de Resaltar Una Vez",
      "highlight_once_border_thickness": "Grosor del borde de Resaltar Una Vez (px)",
      "reset_to_1": "Restablecer a 1",
      "use_global_highlight_style": "Usar estilo global para Resaltar Una Vez",
      "use_global_highlight_style_desc": "Usar tus estilos inline globales. El HTML/CSS a\xF1adido puede ser largo.",
      "style_highlight_once": "Estilo de Resaltar Una Vez",
      "style_highlight_once_desc": "Usar tus estilos inline personalizados. El HTML/CSS a\xF1adido puede ser largo.",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "Apariencia Global del Resaltado",
      "highlight_opacity": "Opacidad del Resaltado",
      "highlight_opacity_desc": "Establecer la opacidad del resaltado (0-100%)",
      "highlight_border_radius": "Radio del borde del Resaltado (px)",
      "highlight_border_radius_desc": "Establecer el radio del borde de las esquinas del resaltado en px",
      "highlight_horizontal_padding_desc": "Establecer relleno izquierdo/derecho para texto resaltado en px",
      "highlight_vertical_padding_desc": "Establecer relleno superior/inferior para texto resaltado en px",
      "rounded_corners_wrapping": "Esquinas redondeadas al ajustar",
      "rounded_corners_wrapping_desc": "Si est\xE1 activado, los resaltados tienen esquinas redondeadas en todos los lados incluso cuando el texto salta a una nueva l\xEDnea.",
      "enable_highlight_border": "Habilitar borde de resaltado",
      "enable_highlight_border_desc": "A\xF1adir un borde alrededor de los resaltados. El borde coincide con el color del texto o del resaltado.",
      "border_style": "Lado del Borde",
      "border_style_desc": "Selecciona en qu\xE9 lados aplicar el borde",
      "border_line_style": "Estilo de Borde",
      "border_line_style_desc": "Selecciona el estilo de l\xEDnea del borde",
      "border_opacity": "Opacidad del Borde",
      "border_opacity_desc": "Establecer la opacidad del borde (0-100%)",
      "border_thickness": "Grosor del Borde (px)",
      "border_thickness_desc": "Establecer el grosor del borde de 0-5 p\xEDxeles (p. ej. 1, 2.5, 5)",
      "highlight_preview": "Vista previa del Resaltado",
      "highlight_preview_text": "\xA1As\xED se ve tu resaltado!",
      "opt_line_solid": "S\xF3lido",
      "opt_line_dashed": "Discontinuo",
      "opt_line_dotted": "Punteado",
      "opt_line_double": "Doble",
      "opt_line_groove": "Ranura",
      "opt_line_ridge": "Cresta",
      "opt_line_inset": "Recuadro",
      "opt_line_outset": "Relieve",
      // Color Swatches
      "color_picker_layout": "Dise\xF1o del Selector de Color",
      "color_picker_layout_desc": "Elige qu\xE9 tipos de color mostrar al elegir un color para una palabra",
      "opt_both_text_left": "Ambos: Texto Izquierda, Resaltado Derecha",
      "opt_both_bg_left": "Ambos: Resaltado Izquierda, Texto Derecha",
      "opt_both_text_top": "Ambos (Vertical): Texto Arriba, Resaltado Abajo",
      "opt_both_bg_top": "Ambos (Vertical): Resaltado Arriba, Texto Abajo",
      "opt_text_only": "Solo Color de Texto",
      "opt_background_only": "Solo Color de Resaltado",
      "replace_default_swatches": "Reemplazar muestras predeterminadas",
      "replace_default_swatches_desc": "Si est\xE1 activado, solo se muestran tus colores personalizados en el selector, \xA1sin los predeterminados!",
      "enable_custom_swatches": "Habilitar muestras personalizadas",
      "enable_custom_swatches_desc": "Si est\xE1 activado, tus muestras personalizadas aparecer\xE1n en el selector de color.",
      "use_swatch_names": "Colorear texto usando nombres de muestras",
      "use_swatch_names_desc": "Mostrar un men\xFA desplegable de nombres de muestras junto a la entrada de palabra/patr\xF3n",
      "link_swatches_to_entries": "Vincular actualizaciones de muestras a textos coloreados",
      "link_swatches_to_entries_desc": "Actualizar todas las entradas que usan una muestra personalizada cuando cambia el color de esa muestra",
      "default_colors_header": "Muestras predeterminadas",
      "custom_swatches_header": "Muestras Personalizadas",
      "btn_add_color": "+ A\xF1adir Color",
      "no_custom_swatches_yet": 'A\xFAn no hay muestras personalizadas. Haz clic en "+ A\xF1adir Color" para crear una.',
      "label_built_in": "(Integrado)",
      // Color Picker
      "pick_color_header": "Elegir Color",
      "selected_text_preview": "Texto Seleccionado",
      "text_color_title": "Color del Texto",
      "select_swatch": "Seleccionar Muestra...",
      "highlight_color_title": "Color del Resaltado",
      "select_highlight_swatch": "Seleccionar Muestra de Resaltado...",
      "settings_tab_general": "General",
      "settings_tab_colored_texts": "Textos Coloreados",
      "settings_tab_blacklists": "Listas Negras",
      "settings_tab_file_folder_rules": "Reglas de Archivo / Carpeta",
      "settings_tab_data": "Datos",
      // Always Colored Texts
      "colored_texts_header": "Textos Coloreados",
      "always_colored_texts_desc": "Aqu\xED es donde gestionas tus palabras/patrones y sus colores.",
      "grouped_entries_header": "Entradas Agrupadas",
      "grouped_entries_desc": "Gestiona grupos de palabras. La b\xFAsqueda filtra por nombre.",
      "search_groups_placeholder": "Buscar grupos\u2026",
      "edit_word_group_modal_title": "Editar Grupo de Palabras",
      "btn_save_group": "Guardar Grupo",
      "btn_delete_group": "Eliminar Grupo",
      "group_active_label": "Activo",
      "group_inactive_label": "Inactivo",
      "tooltip_duplicate_group": "Duplicar Grupo",
      "tooltip_edit_group_settings": "Editar configuraci\xF3n del grupo",
      "tooltip_delete_all_groups": "Eliminar todos los grupos de palabras",
      "btn_create_new_group": "+ Crear nuevo grupo",
      "no_entries_found": "No se encontraron entradas.",
      "search_colored_words_placeholder": "Buscar palabras o patrones coloreados\u2026",
      "sort_label_last-added": "Ordenar: \xDAltimo A\xF1adido",
      "sort_label_a-z": "Ordenar: A-Z",
      "sort_label_reverse-a-z": "Ordenar: Z-A",
      "sort_label_style-order": "Ordenar: Estilo",
      "sort_label_color": "Ordenar: Color",
      "btn_add_new_word": "+ A\xF1adir nueva palabra / patr\xF3n coloreado",
      "style_type_text": "Color",
      "style_type_highlight": "Resaltado",
      "style_type_both": "Ambos",
      "word_pattern_placeholder_long": "patr\xF3n, palabra, o palabras separadas por comas (p. ej. hola, mundo, foo)",
      "word_pattern_placeholder_short": "palabra clave o patr\xF3n, o palabras separadas por comas",
      "use_regex": "Usar Regex",
      "flags_placeholder": "Banderas",
      "text_or_regex_placeholder": "Entrada de Texto/Regex",
      "duplicate_entry": "Entrada Duplicada",
      "open_in_regex_tester": "Abrir en Probador de Regex",
      "no_rules_configured": "No hay reglas configuradas.",
      "no_rules_found": "No se encontraron reglas.",
      "match_option_exact": "Exacto",
      "match_option_contains": "Contiene",
      "match_option_starts_with": "Empieza Con",
      "match_option_ends_with": "Termina Con",
      // Presets
      "btn_presets": "Preajustes",
      "preset_all_headings": "Todos los Encabezados (H1-H6)",
      "preset_bullet_points": "Vi\xF1etas",
      "preset_numbered_lists": "Listas Numeradas",
      "preset_task_checked": "Listas de Tareas (Marcadas)",
      "preset_task_unchecked": "Listas de Tareas (Sin Marcar)",
      "preset_dates_yyyy_mm_dd": "Fechas (AAAA-MM-DD)",
      "preset_times_am_pm": "Horas (AM/PM)",
      "preset_times_24h": "Horas (24h)",
      "preset_dates_yyyy_mmm_dd": "Fechas (AAAA-MMM-DD)",
      "preset_relative_dates": "Fechas Relativas",
      "preset_basic_urls": "URLs B\xE1sicas",
      "preset_markdown_links": "Enlaces Markdown",
      "preset_domain_names": "Nombres de Dominio",
      "preset_email_addresses": "Direcciones de Correo",
      "preset_at_username": "@Usuario",
      "preset_currency": "Moneda",
      "preset_measurements": "Medidas",
      "preset_phone_numbers": "N\xFAmeros de Tel\xE9fono",
      "preset_all_texts": "Todo el Texto",
      "preset_codeblocks": "Bloques de c\xF3digo",
      "preset_inline_comments": "Comentarios (%%...%%)",
      "preset_highlighted_text": "Texto resaltado (==...==)",
      "preset_parentheses": "Par\xE9ntesis ()",
      "preset_square_brackets": "Corchetes []",
      "preset_curly_braces": "Llaves {}",
      "preset_angle_brackets": "Par\xE9ntesis angulares <>",
      "preset_colons": "Dos puntos :",
      "preset_double_quotes": "Comillas dobles",
      "preset_single_quotes": "Comillas simples",
      "preset_single_quotes_word_bounded": "Comillas simples (L\xEDmite de palabra)",
      "preset_group_markdown_formatting": "Formato Markdown",
      "preset_group_other_patterns": "Otros Patrones",
      "preset_group_brackets": "Par\xE9ntesis y Corchetes",
      // Preset Examples
      "preset_example_heading": "# T\xEDtulo",
      "preset_example_bullet": "- Vi\xF1eta",
      "preset_example_numbered": "1. Primer elemento",
      "preset_example_task_checked": "- [x] Completado",
      "preset_example_task_unchecked": "- [ ] Por hacer",
      "preset_example_codeblock": "``` c\xF3digo ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[Enlace](https://example.com)",
      "preset_example_comment": "%% comentario %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "nombre@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "\u20AC29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( texto )",
      "preset_example_square_brackets": "[ s\xED ]",
      "preset_example_curly_braces": "{ no }",
      "preset_example_angle_brackets": "< texto >",
      "preset_example_colons": ": texto :",
      "preset_example_double_quotes": '"texto"',
      "preset_example_single_quotes": "'texto'",
      "preset_example_single_quotes_word": "'palabra'",
      "preset_example_highlight": "==texto resaltado==",
      "preset_example_all_text": "Esto seleccionar\xE1 todo el texto.",
      // Blacklist Settings
      "blacklist_words_header": "Lista negra de palabras",
      "blacklist_words_desc": "Las palabras clave o patrones aqu\xED nunca se colorear\xE1n, incluso para coincidencias parciales.",
      "search_blacklist_placeholder": "Buscar palabras o patrones en lista negra\u2026",
      "blacklist_sort_label_last-added": "Ordenar: \xDAltimo A\xF1adido",
      "blacklist_sort_label_a-z": "Ordenar: A-Z",
      "blacklist_sort_label_reverse-a-z": "Ordenar: Z-A",
      "btn_add_blacklist": "+ A\xF1adir palabra o patr\xF3n a la lista negra",
      "btn_add_to_blacklist": "+ A\xF1adir a lista negra",
      "btn_add_blacklist_word": "+ A\xF1adir palabra a lista negra",
      "btn_add_blacklist_regex": "+ A\xF1adir regex a lista negra",
      // File & Folder Rules
      "file_folder_rules_header": "Reglas de Coloreado para Archivos y Carpetas",
      "file_folder_rules_desc": "Controla el coloreado mediante coincidencia de nombres, rutas exactas o patrones regex. Deja una entrada de exclusi\xF3n vac\xEDa para desactivar el coloreado en toda la b\xF3veda.",
      "search_file_folder_rules_placeholder": "Buscar reglas de archivo/carpeta\u2026",
      "path_sort_label_last-added": "Ordenar: \xDAltimo A\xF1adido",
      "path_sort_label_a-z": "Ordenar: A-Z",
      "path_sort_label_reverse-a-z": "Ordenar: Z-A",
      "path_sort_label_mode": "Ordenar: Modo",
      "path_sort_label_type": "Ordenar: Tipo",
      "btn_add_file_folder_rule": "+ A\xF1adir regla de archivo/carpeta",
      "disabled_files_header": "Archivos con coloreado desactivado:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "incluir",
      "path_rule_mode_exclude": "excluir",
      "text_rule_mode_include": "solo colores en (lista blanca)",
      "text_rule_mode_exclude": "no colorea en (lista negra)",
      "mode_only_colors_in": "solo colores en",
      "mode_does_not_color_in": "no colores en",
      "label_text_include": "Lista Blanca",
      "label_text_exclude": "Lista Negra",
      "label_enable_in": "Habilitar en",
      "label_disable_in": "Deshabilitar en",
      "enter_path_or_pattern": "Ingrese ruta, patr\xF3n o etiquetas",
      "label_regex": "Expresi\xF3n regular",
      // Advanced Rules
      "advanced_rules_header": "Reglas espec\xEDficas de inclusi\xF3n/exclusi\xF3n",
      "advanced_rules_modal_header": "Reglas espec\xEDficas de inclusi\xF3n/exclusi\xF3n",
      "advanced_rules_manage_button": "gestionar reglas espec\xEDficas de inclusi\xF3n/exclusi\xF3n",
      "edit_rule_header": "Editar Regla",
      "add_rule_header": "A\xF1adir Nueva Regla",
      "btn_add_rule": "+ A\xF1adir Regla",
      "btn_save_rule": "Guardar Regla",
      "btn_add_words": "+ A\xF1adir Palabras",
      "btn_add_regex": "+ A\xF1adir Regex",
      "btn_save_regex": "Guardar Expresi\xF3n Regular",
      // Regex Tester
      "regex_tester_header": "Probador de Expresiones Regulares",
      "regex_tester_blacklist": "Probador de regex - lista negra",
      "regex_expression_placeholder": "Pon tu expresi\xF3n regex aqu\xED",
      "regex_subject_placeholder": "escribe el texto a probar aqu\xED...",
      "regex_name_placeholder": "nombra tu regex",
      "matches": "coincidencias",
      "matches_found": "coincidencias encontradas",
      // Regex Flags
      "flag_g": "bandera global: encontrar todas las coincidencias",
      "flag_i": "bandera sin distinci\xF3n de may\xFAsculas",
      "flag_m": "bandera multilinea: ^ y $ coinciden con l\xEDmites de l\xEDnea",
      "flag_s": "bandera dotAll: . coincide con saltos de l\xEDnea",
      "flag_u": "bandera unicode: tratar como puntos de c\xF3digo unicode",
      "flag_y": "bandera sticky: coincidir desde la posici\xF3n lastIndex",
      // Data Export/Import
      "data_export_import_header": "Exportar/Importar Datos",
      "export_plugin_data": "Exportar datos del plugin",
      "export_plugin_data_desc": "Exporta la configuraci\xF3n, palabras y reglas a un archivo JSON.",
      "btn_export": "Exportar",
      "import_plugin_data": "Importar datos del plugin",
      "import_plugin_data_desc": "Importa la configuraci\xF3n desde un archivo JSON",
      "btn_import": "Importar",
      "limit_input_placeholder": "l\xEDmite",
      "limit_input_tooltip": "0=todos; n\xFAmero=\xFAltimos N; r=solo regex; h=solo resaltado; c=solo texto; b=texto+fondo; sw=empieza con; ew=termina con; e=exacto",
      // Missing Keys Added
      "highlight_styling_header": "Editar Estilo de Resaltado",
      "edit_entry_header": "Editar Entrada",
      "opt_case_sensitive": "es sensible a may\xFAsculas",
      "opt_not_case_sensitive": "no sensible a may\xFAsculas",
      "opt_case_all": "Sensibilidad a may\xFAsculas (Todo)",
      "opt_match_all": "Tipo de coincidencia (Todo)",
      "edit_highlight_styling_btn": "Editar Estilo de Resaltado",
      "inclusion_exclusion_header": "Reglas de Inclusi\xF3n / Exclusi\xF3n",
      "btn_save_entry": "Guardar Entrada",
      "edit_entry_details": "Editar Detalles de Entrada",
      "prompt_search_existing": "Buscar entradas existentes\u2026",
      "command_add_to_existing_entry": "A\xF1adir a Entrada Existente",
      "context_remove_from_entry": 'Eliminar "{word}" de la entrada',
      "context_delete_entry": "Eliminar entrada",
      "btn_reset": "Restablecer",
      "btn_reset_all": "Restablecer estilo de resaltado",
      "btn_add_word": "+ A\xF1adir Palabra",
      "btn_add_regex_short": "+ A\xF1adir Regex",
      "section_highlight_border_styling": "Estilo de borde de resaltado",
      "section_highlight_styling": "Estilo de resaltado",
      "label_highlight_opacity": "Opacidad del resaltado",
      "label_highlight_radius": "Radio del borde del resaltado",
      "label_horizontal_padding": "Relleno horizontal",
      "label_vertical_padding": "Relleno vertical",
      "label_enable_border": "Habilitar borde",
      "label_border_sides": "Lados del borde",
      "label_border_style": "Estilo de borde",
      "label_border_opacity": "Opacidad del borde",
      "label_border_thickness": "Grosor del borde",
      "btn_save_style": "Guardar estilo",
      // Quick Colors / Styles
      "quick_actions_header": "Quick Actions",
      "quick_colors_header": "Colores R\xE1pidos",
      "quick_colors_desc": "Permite resaltar o colorear texto r\xE1pidamente mostrando colores en el men\xFA contextual. Si Colores R\xE1pidos est\xE1 desactivado, se usar\xE1n los colores por estilo en Estilos R\xE1pidos.",
      "quick_colors_apply_mode_label": "El coloreado de texto se aplicar\xE1 como",
      "quick_colors_apply_mode_act": "Siempre colorear texto",
      "quick_colors_apply_mode_html": "HTML en l\xEDnea",
      "quick_styles_header": "Estilos R\xE1pidos",
      "quick_styles_desc": "Define estilos con nombre para aplicar color de texto y resaltados. Si Colores R\xE1pidos est\xE1 desactivado, se usar\xE1n los colores por estilo aqu\xED.",
      "btn_add_style": "+ A\xF1adir Estilo",
      "quick_styles_menu_option": "Estilos R\xE1pidos",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "Entradas del grupo de lista negra",
      "show_blacklist_groups_in_commands": "Mostrar grupos de lista negra en comandos",
      "show_blacklist_groups_in_commands_desc": "Cuando est\xE1 habilitado, los grupos de lista negra aparecen en la paleta de comandos con comandos Activar/Desactivar.",
      "search_blacklist_groups_placeholder": "Buscar grupos de lista negra\u2026",
      "btn_create_new_blacklist_group": "+ Crear nuevo grupo de lista negra",
      "edit_blacklist_group_modal_title": "Editar grupo de lista negra",
      "tooltip_delete_all_blacklist_groups": "Eliminar todos los grupos de lista negra",
      "confirm_delete_all_blacklist_groups_title": "Eliminar todos los grupos de lista negra",
      "confirm_delete_all_blacklist_groups_desc": "\xBFEst\xE1s seguro de que deseas eliminar TODOS los grupos de lista negra? \xA1Esto no se puede deshacer!",
      "confirm_delete_blacklist_group_title": "Eliminar grupo de lista negra",
      "confirm_delete_blacklist_group_desc": "\xBFEst\xE1s seguro de que deseas eliminar este grupo de lista negra? Esto no se puede deshacer.",
      "notice_blacklist_group_activated": "Grupo de lista negra activado",
      "notice_blacklist_group_deactivated": "Grupo de lista negra desactivado",
      "command_activate_blacklist_group": "Activar grupo de lista negra {groupName}",
      "command_deactivate_blacklist_group": "Desactivar grupo de lista negra {groupName}",
      "btn_duplicate_entry": "Duplicar entrada",
      "btn_open_in_regex_tester": "Abrir en Regex Tester",
      "move_to_blacklist_group": "Mover a grupo de lista negra",
      "btn_delete_entry": "Eliminar entrada",
      "btn_cancel": "Cancelar",
      "btn_confirm": "Confirmar",
      "requires_regex_safety_disabled": "Requiere seguridad regex desactivada",
      "share_export_title": "Always Color Text exportaci\xF3n",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "Nombre del estilo",
      "preview_text": "Texto",
      "edit_group_highlight_styling": "Editar estilo de resaltado del grupo",
      "light_mode_fixer_desc": "Oscurece autom\xE1ticamente el texto coloreado al usar el tema claro para mejorar la visibilidad.",
      "dark_mode_fixer_desc": "Aclara autom\xE1ticamente el texto coloreado al usar el tema oscuro para mejorar la visibilidad.",
      "preset_bold": "Negrita",
      "preset_italic": "Cursiva",
      "preset_bold_italic": "Negrita Cursiva"
    };
  }
});

// src/i18n/fr.js
var require_fr = __commonJS({
  "src/i18n/fr.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "Fran\xE7ais",
      "settings_title": "Param\xE8tres de Always Color Text",
      "header_plugin_name": "Always Color Text",
      "ribbon_title": "Toujours colorer le texte",
      // Language Settings
      "language_label": "Langue",
      "language_desc": "S\xE9lectionnez la langue \xE0 utiliser dans ce plugin",
      "language_en": "Anglais",
      "language_es": "Espagnol",
      "language_fr": "Fran\xE7ais",
      "language_eu": "Basque",
      "language_ru": "Russe",
      "language_auto": "Par d\xE9faut du syst\xE8me",
      "default": "Par d\xE9faut",
      // Release Notes
      "latest_release_notes_label": "Notes de version les plus r\xE9centes",
      "latest_release_notes_desc": "Voir les notes de version les plus r\xE9centes du plugin",
      "open_changelog_button": "Ouvrir le journal des modifications",
      "command_show_release_notes": "Afficher les derni\xE8res notes de version",
      "changelog_view_on_github": "Voir sur GitHub",
      "changelog_loading": "Chargement des versions\u2026",
      "changelog_no_info": "Aucune information de version disponible.",
      "changelog_release": "Version",
      "changelog_no_notes": "Aucune note",
      "changelog_failed_to_load": "\xC9chec du chargement des notes de version.",
      // UI Elements & Menus
      "file_menu_enable": "Activer toujours colorer le texte pour ce fichier",
      "file_menu_disable": "D\xE9sactiver toujours colorer le texte pour ce fichier",
      "menu_color_once": "Colorer une fois",
      "menu_highlight_once": "Surligner une fois",
      "menu_color_highlight_once": "Couleur / Surligner une fois",
      "menu_remove_inline_color": "Supprimer la couleur en ligne",
      "menu_always_color_text": "Toujours colorer le texte",
      "menu_remove_always_color_text": "Supprimer Always Color Text",
      "menu_blacklist_word": "Mettre le mot en liste noire pour le coloriage",
      "show_toggle_statusbar": "Afficher le bouton d'activation dans la barre d'\xE9tat",
      "show_toggle_ribbon": "Afficher l'ic\xF4ne d'activation dans le ruban",
      "show_toggle_command": "Afficher l'activation dans les commandes",
      "menu_options_header": "Options du menu",
      "show_blacklist_menu": 'Afficher "Mot en liste noire" dans le menu clic-droit',
      "show_blacklist_menu_desc": "Ajoute un \xE9l\xE9ment au menu clic-droit pour mettre le texte s\xE9lectionn\xE9 en liste noire pour le coloriage.",
      "show_add_to_existing_menu": 'Afficher "Ajouter \xE0 une entr\xE9e existante" dans le menu clic-droit',
      "show_add_to_existing_menu_desc": "Ajoute un \xE9l\xE9ment au menu clic-droit pour ajouter le texte s\xE9lectionn\xE9 \xE0 une entr\xE9e existante.",
      "show_always_color_text_menu": 'Afficher "Always Color Text" dans le menu clic-droit',
      "show_always_color_text_menu_desc": "Ajoute un \xE9l\xE9ment au menu clic-droit pour colorer le texte s\xE9lectionn\xE9.",
      "hide_inactive_groups_in_dropdowns": "Masquer les groupes inactifs dans les listes d\xE9roulantes",
      "hide_inactive_groups_in_dropdowns_desc": "Masque les groupes de mots inactifs lors de l'affichage des listes de groupes dans les listes d\xE9roulantes.",
      "show_word_groups_in_commands": "Afficher les groupes de mots dans les commandes",
      "show_word_groups_in_commands_desc": "Lorsque activ\xE9, les groupes de mots apparaissent dans la palette de commandes avec des commandes Activer/D\xE9sactiver.",
      "tooltip_enable_for_file": "Activer pour ce fichier",
      "tooltip_delete_all_words": "Supprimer tous les mots/motifs d\xE9finis",
      "tooltip_delete_all_blacklist": "Supprimer tous les mots/motifs en liste noire",
      "tooltip_use_regex": "Utiliser comme mod\xE8le d'expression r\xE9guli\xE8re",
      "drag_to_reorder": "Glisser pour r\xE9organiser",
      "reset_text_color": "R\xE9initialiser la couleur du texte",
      "reset_highlight": "R\xE9initialiser la surbrillance",
      // Commands
      "command_color_selected": "Colorer le texte s\xE9lectionn\xE9",
      "command_toggle_current": "Activer/D\xE9sactiver le coloriage pour le document actuel",
      "command_enable_current": "Activer le coloriage pour le document actuel",
      "command_disable_current": "D\xE9sactiver le coloriage pour le document actuel",
      "command_toggle_global": "Activer/D\xE9sactiver la coloration globale",
      "command_enable_global": "Activer la coloration globale",
      "command_disable_global": "D\xE9sactiver la coloration globale",
      "command_enable_lightweight_mode": "Activer le mode l\xE9ger",
      "command_disable_lightweight_mode": "D\xE9sactiver le mode l\xE9ger",
      "command_color_highlight_once": "Colorer / Surligner le texte s\xE9lectionn\xE9 (une fois)",
      "notice_select_text_first_once": "Veuillez d'abord s\xE9lectionner du texte pour le colorer/surligner.",
      "enable_document_color": "Activer la couleur globale",
      "color_swatches_header": "Gestion des couleurs",
      "color_rendering_header": "Rendu des couleurs et performances",
      "theme_support_header": "Support de th\xE8me",
      "matching_behavior_header": "Comportement de correspondance",
      "smart_update_mode": "Mises \xE0 jour intelligentes (Exp\xE9rimental)",
      "smart_update_mode_desc": "Met \xE0 jour la coloration uniquement pour la ligne active lors de la frappe et fige les autres lignes pour am\xE9liorer les performances.",
      "light_mode_fixer": "Correcteur de couleur de texte en mode clair",
      "dark_mode_fixer": "Correcteur de couleur de texte en mode sombre",
      "command_manage_advanced_rules": "g\xE9rer les r\xE8gles sp\xE9cifiques d\u2019inclusion/exclusion",
      "command_open_regex_tester": "Ajouter Regex (Ouvrir le Testeur Regex)",
      "command_open_blacklist_regex_tester": "Ajouter Regex \xE0 la Liste Noire",
      "command_manage_colored_texts": "G\xE9rer les textes color\xE9s",
      "command_toggle_hide_text_colors": "Masquer/Afficher les couleurs de texte",
      "command_toggle_hide_highlights": "Masquer/Afficher les surbrillances",
      "command_hide_text_colors": "Masquer les couleurs de texte",
      "command_unhide_text_colors": "Afficher les couleurs de texte",
      "command_hide_highlights": "Masquer les surbrillances",
      "command_unhide_highlights": "Afficher les surbrillances",
      "command_activate_word_group": "Activer le groupe de mots {groupName}",
      "command_deactivate_word_group": "D\xE9sactiver le groupe de mots {groupName}",
      // Notifications
      "notice_lightweight_mode_enabled": "Mode l\xE9ger activ\xE9",
      "notice_lightweight_mode_disabled": "Mode l\xE9ger d\xE9sactiv\xE9",
      "notice_enabled": "Always color text activ\xE9",
      "notice_disabled": "Always color text d\xE9sactiv\xE9",
      "notice_blacklisted_cannot_color": '"{word}" est sur liste noire et ne peut pas \xEAtre color\xE9.',
      "notice_removed_always_color": 'Coloriage permanent supprim\xE9 pour "{word}".',
      "notice_added_to_blacklist": '"{word}" ajout\xE9 \xE0 la liste noire.',
      "notice_already_blacklisted": '"{word}" est d\xE9j\xE0 sur liste noire.',
      "notice_select_text_first": "Veuillez d'abord s\xE9lectionner du texte.",
      "notice_no_active_file": "Aucun fichier actif pour activer/d\xE9sactiver le coloriage.",
      "notice_coloring_enabled_for_path": "Coloriage activ\xE9 pour {path}",
      "notice_coloring_disabled_for_path": "Coloriage d\xE9sactiv\xE9 pour {path}",
      "notice_global_enabled": "Always Color Text Activ\xE9",
      "notice_global_disabled": "Always Color Text D\xE9sactiv\xE9",
      "notice_unable_open_changelog": "Impossible d'ouvrir la fen\xEAtre du journal des modifications.",
      "notice_pattern_blocked": "Motif bloqu\xE9 pour la s\xE9curit\xE9 m\xE9moire :",
      "notice_pattern_too_complex": "Motif trop complexe :",
      "notice_invalid_hex_format": "Format de couleur hexad\xE9cimale invalide. Utilisez #RRGGBB ou #RGB.",
      "notice_error_saving_changes": "Erreur lors de l'enregistrement des modifications. Veuillez r\xE9essayer.",
      "notice_invalid_color_format": "Format de couleur invalide.",
      "notice_exported": "Export\xE9 : {fname}",
      "notice_export_failed": "\xC9chec de l'exportation",
      "notice_import_completed": "Importation termin\xE9e",
      "notice_import_failed": "\xC9chec de l'importation",
      "notice_invalid_regex": "Expression r\xE9guli\xE8re invalide",
      "notice_empty_pattern": "Le motif est vide",
      "notice_added_regex": "Expression r\xE9guli\xE8re ajout\xE9e",
      "notice_rule_updated": "R\xE8gle mise \xE0 jour",
      "notice_regex_updated": "Expression r\xE9guli\xE8re mise \xE0 jour",
      "notice_entry_updated": "Entr\xE9e mise \xE0 jour",
      "notice_entry_duplicated": "Entr\xE9e dupliqu\xE9e",
      "notice_error_opening_regex_tester": "Erreur lors de l'ouverture du testeur regex",
      "notice_error_opening_blacklist_regex_tester": "Erreur lors de l'ouverture du testeur regex de liste noire",
      "notice_error_opening_advanced_rules": "Erreur lors de l'ouverture de la bo\xEEte de dialogue des r\xE8gles avanc\xE9es",
      "notice_text_color_reset": "Couleur du texte r\xE9initialis\xE9e",
      "notice_highlight_reset": "Surbrillance r\xE9initialis\xE9e",
      "notice_text_colors_hidden": "Couleurs de texte masqu\xE9es",
      "notice_text_colors_visible": "Couleurs de texte visibles",
      "notice_highlights_hidden": "Surbrillances masqu\xE9es",
      "notice_highlights_visible": "Surbrillances visibles",
      "notice_regex_support_disabled": "Le support des regex est d\xE9sactiv\xE9. Activez-le dans les param\xE8tres pour utiliser des mod\xE8les regex.",
      "notice_no_active_file_to_disable": "Aucun fichier actif pour d\xE9sactiver le coloriage.",
      "notice_already_disabled_for_path": "Coloriage d\xE9j\xE0 d\xE9sactiv\xE9 pour {path}",
      "notice_filter_disabled": "Filtre d\xE9sactiv\xE9",
      // Confirmation Dialogs
      "confirm_delete_all_title": "Supprimer tous les mots",
      "confirm_delete_all_desc": "\xCAtes-vous s\xFBr de vouloir supprimer TOUS les mots/motifs color\xE9s ? Cela ne peut pas \xEAtre annul\xE9 !",
      "confirm_delete_all_blacklist_title": "Supprimer tous les mots de la liste noire",
      "confirm_delete_all_blacklist_desc": "\xCAtes-vous s\xFBr de vouloir supprimer TOUTES les entr\xE9es de la liste noire ? Cette action ne peut pas \xEAtre annul\xE9e !",
      "confirm_delete_all_groups_title": "Supprimer tous les groupes de mots",
      "confirm_delete_all_groups_desc": "\xCAtes-vous s\xFBr de vouloir supprimer TOUS les groupes de mots ? Cette action ne peut pas \xEAtre annul\xE9e !",
      "restart_required_title": "Red\xE9marrage requis",
      "restart_required_desc": "D\xE9sactiver l'activation dans la palette de commandes n\xE9cessite un red\xE9marrage d'Obsidian pour supprimer compl\xE8tement la commande de la palette. Red\xE9marrer maintenant ?",
      // Basic Settings
      "color_in_live_preview_mode": "Colore en mode aper\xE7u direct",
      "color_in_reading_mode": "Colorer en mode lecture",
      "force_full_render_reading": "Forcer le rendu complet en mode lecture",
      "force_full_render_reading_desc": "Si activ\xE9, le mode lecture essaiera de colorer tout le document \xE0 la fois. Peut causer des ralentissements sur les gros documents, utilisez avec prudence !",
      "lightweight_mode": "Mode l\xE9ger (Exp\xE9rimental)",
      "lightweight_mode_desc": "R\xE9duit consid\xE9rablement le traitement lors de la frappe. Peut ignorer certaines correspondances.",
      "disable_coloring_current_file": "D\xE9sactiver le coloriage pour le fichier actuel",
      "disable_coloring_current_file_desc": "Ajoute une r\xE8gle d'exclusion pour le fichier actif sous R\xE8gles de coloriage des fichiers et dossiers.",
      "btn_disable_for_this_file": "D\xE9sactiver pour ce fichier",
      // Coloring Settings
      "coloring_settings_header": "Param\xE8tres de coloriage",
      "regex_support": "Support Regex",
      "regex_support_desc": "Autoriser les motifs \xE0 \xEAtre des regex. Les regex invalides seront ignor\xE9s par s\xE9curit\xE9.",
      "disable_regex_safety": "D\xE9sactiver la v\xE9rification de s\xE9curit\xE9 Regex",
      "disable_regex_safety_desc": "Autoriser les expressions complexes ou potentiellement dangereuses. Peut causer des ralentissements ou des blocages.",
      "case_sensitive": "Sensible \xE0 la casse",
      "case_sensitive_desc": 'Si activ\xE9, "mot" et "Mot" sont diff\xE9rents. Si d\xE9sactiv\xE9, ils sont color\xE9s de la m\xEAme mani\xE8re.',
      "partial_match": "Correspondance partielle",
      "partial_match_desc": `Si activ\xE9, colore tout le mot si un mot color\xE9 est trouv\xE9 \xE0 l'int\xE9rieur (par exemple "as" colore "Jasper").`,
      // One-Time Actions
      "one_time_actions_header": "Actions uniques",
      "setting_color_once": "Colorer une fois",
      "setting_color_once_desc": "Ins\xE9rer un style HTML en ligne pour le texte s\xE9lectionn\xE9. Persiste m\xEAme si le plugin est d\xE9sactiv\xE9.",
      "setting_highlight_once": "Surligner une fois",
      "setting_highlight_once_desc": "Ins\xE9rer un style HTML en ligne avec fond. Persiste m\xEAme si le plugin est d\xE9sactiv\xE9.",
      "setting_color_highlight_once": "Couleur et Surligner une fois",
      "setting_color_highlight_once_desc": "Ouvre le s\xE9lecteur de couleur unifi\xE9 pour appliquer \xE0 la fois la couleur du texte et le surlignage de l'arri\xE8re-plan en ligne. Utilise le menu unifi\xE9.",
      "highlight_once_preview": "Aper\xE7u de Surligner une fois",
      "highlight_once_preview_text": "Voici \xE0 quoi ressemble le surlignage une fois !",
      // Highlight Once Settings
      "highlight_once_opacity": "Opacit\xE9 de Surligner une fois",
      "highlight_once_border_radius": "Rayon de bordure de Surligner une fois (px)",
      "reset_to_8": "R\xE9initialiser \xE0 8",
      "highlight_horizontal_padding": "Marge interne horizontale de surlignage (px)",
      "highlight_vertical_padding": "Marge interne verticale de surlignage (px)",
      "reset_to_4": "R\xE9initialiser \xE0 4",
      "enable_border_highlight_once": "Activer la bordure pour Surligner une fois",
      "enable_border_highlight_once_desc": "Ajouter une bordure au surlignage en ligne. Le HTML/CSS ajout\xE9 sera long.",
      "highlight_once_border_style": "C\xF4t\xE9 de la bordure de Surligner une fois",
      "highlight_once_border_line_style": "Style de bordure",
      "opt_border_full": "Bordure compl\xE8te (Tous les c\xF4t\xE9s)",
      "opt_border_top_bottom": "Haut et Bas",
      "opt_border_left_right": "Gauche et Droite",
      "opt_border_top_left_right": "Haut, Gauche et Droite",
      "opt_border_bottom_left_right": "Bas, Gauche et Droite",
      "opt_border_top_right": "Haut et Droite",
      "opt_border_top_left": "Haut et Gauche",
      "opt_border_bottom_right": "Bas et Droite",
      "opt_border_bottom_left": "Bas et Gauche",
      "opt_border_top": "Haut seulement",
      "opt_border_bottom": "Bas seulement",
      "opt_border_left": "Gauche seulement",
      "opt_border_right": "Droite seulement",
      "highlight_once_border_opacity": "Opacit\xE9 de la bordure de Surligner une fois",
      "highlight_once_border_thickness": "\xC9paisseur de la bordure de Surligner une fois (px)",
      "reset_to_1": "R\xE9initialiser \xE0 1",
      "use_global_highlight_style": "Utiliser le style global pour Surligner une fois",
      "use_global_highlight_style_desc": "Utiliser vos styles globaux en ligne. Le HTML/CSS ajout\xE9 peut \xEAtre long.",
      "style_highlight_once": "Style de Surligner une fois",
      "style_highlight_once_desc": "Utiliser vos styles personnalis\xE9s en ligne. Le HTML/CSS ajout\xE9 peut \xEAtre long.",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "Apparence globale du coloriage en surbrillance",
      "highlight_opacity": "Opacit\xE9 de la surbrillance",
      "highlight_opacity_desc": "D\xE9finir l'opacit\xE9 de la surbrillance (0-100%)",
      "highlight_border_radius": "Rayon de bordure de la surbrillance (px)",
      "highlight_border_radius_desc": "D\xE9finir le rayon de bordure des coins de la surbrillance en px",
      "highlight_horizontal_padding_desc": "D\xE9finir la marge interne gauche/droite pour le texte surlign\xE9 en px",
      "highlight_vertical_padding_desc": "D\xE9finir la marge interne haut/bas pour le texte surlign\xE9 en px",
      "rounded_corners_wrapping": "Coins arrondis \xE0 l'emballage",
      "rounded_corners_wrapping_desc": "Si activ\xE9, les surbrillances ont des coins arrondis sur tous les c\xF4t\xE9s m\xEAme lorsque le texte passe \xE0 la ligne suivante.",
      "enable_highlight_border": "Activer la bordure de surbrillance",
      "enable_highlight_border_desc": "Ajouter une bordure autour des surbrillances. La bordure correspond \xE0 la couleur du texte ou de la surbrillance.",
      "border_style": "C\xF4t\xE9 de la bordure",
      "border_style_desc": "S\xE9lectionnez les c\xF4t\xE9s auxquels appliquer la bordure",
      "border_line_style": "Style de bordure",
      "border_line_style_desc": "S\xE9lectionnez le style de ligne de la bordure",
      "border_opacity": "Opacit\xE9 de la bordure",
      "border_opacity_desc": "D\xE9finir l'opacit\xE9 de la bordure (0-100%)",
      "border_thickness": "\xC9paisseur de la bordure (px)",
      "border_thickness_desc": "D\xE9finir l'\xE9paisseur de la bordure de 0 \xE0 5 pixels (par exemple 1, 2.5, 5)",
      "highlight_preview": "Aper\xE7u de la surbrillance",
      "highlight_preview_text": "Voici \xE0 quoi ressemble votre surbrillance !",
      "opt_line_solid": "Solide",
      "opt_line_dashed": "Tiret\xE9",
      "opt_line_dotted": "Pointill\xE9",
      "opt_line_double": "Double",
      "opt_line_groove": "Rainure",
      "opt_line_ridge": "Cr\xEAte",
      "opt_line_inset": "Incrust\xE9",
      "opt_line_outset": "Relief",
      // Color Swatches
      "color_picker_layout": "Disposition du s\xE9lecteur de couleurs",
      "color_picker_layout_desc": "Choisissez les types de couleurs \xE0 afficher lors du choix d'une couleur pour un mot",
      "opt_both_text_left": "Les deux : Texte Gauche, Surbrillance Droite",
      "opt_both_bg_left": "Les deux : Surbrillance Gauche, Texte Droite",
      "opt_both_text_top": "Les deux (Vertical) : Texte Haut, Surbrillance Bas",
      "opt_both_bg_top": "Les deux (Vertical) : Surbrillance Haut, Texte Bas",
      "opt_text_only": "Couleur du texte uniquement",
      "opt_background_only": "Couleur de surbrillance uniquement",
      "replace_default_swatches": "Remplacer les nuanciers par d\xE9faut",
      "replace_default_swatches_desc": "Si activ\xE9, seules vos couleurs personnalis\xE9es s'affichent dans le s\xE9lecteur, pas celles par d\xE9faut !",
      "enable_custom_swatches": "Activer les nuanciers personnalis\xE9s",
      "enable_custom_swatches_desc": "Si activ\xE9, vos nuanciers personnalis\xE9s appara\xEEtront dans le s\xE9lecteur de couleurs.",
      "use_swatch_names": "Colorer le texte en utilisant les noms de nuanciers",
      "use_swatch_names_desc": "Afficher une liste d\xE9roulante des noms de nuanciers \xE0 c\xF4t\xE9 de l'entr\xE9e mot/motif",
      "link_swatches_to_entries": "Lier les mises \xE0 jour des nuanciers aux textes color\xE9s",
      "link_swatches_to_entries_desc": "Mettre \xE0 jour toutes les entr\xE9es utilisant un nuancier personnalis\xE9 lorsque la couleur de ce nuancier change",
      "default_colors_header": "Nuanciers par d\xE9faut",
      "custom_swatches_header": "Nuanciers personnalis\xE9s",
      "btn_add_color": "+ Ajouter une couleur",
      "no_custom_swatches_yet": 'Pas encore de nuanciers personnalis\xE9s. Cliquez sur "+ Ajouter une couleur" pour en cr\xE9er un.',
      "label_built_in": "(Int\xE9gr\xE9)",
      // Color Picker
      "pick_color_header": "Choisir une couleur",
      "selected_text_preview": "Texte s\xE9lectionn\xE9",
      "text_color_title": "Couleur du texte",
      "select_swatch": "S\xE9lectionner un nuancier...",
      "highlight_color_title": "Couleur de surbrillance",
      "select_highlight_swatch": "S\xE9lectionner un nuancier de surbrillance...",
      "settings_tab_general": "G\xE9n\xE9ral",
      "settings_tab_colored_texts": "Textes color\xE9s",
      "settings_tab_blacklists": "Listes noires",
      "settings_tab_file_folder_rules": "R\xE8gles Fichier / Dossier",
      "settings_tab_data": "Donn\xE9es",
      // Always Colored Texts
      "colored_texts_header": "Textes color\xE9s",
      "always_colored_texts_desc": "C'est ici que vous g\xE9rez vos mots/motifs et leurs couleurs.",
      "grouped_entries_header": "Entr\xE9es group\xE9es",
      "grouped_entries_desc": "G\xE9rez des groupes de mots. La recherche filtre par nom.",
      "search_groups_placeholder": "Rechercher des groupes\u2026",
      "edit_word_group_modal_title": "Modifier le groupe de mots",
      "btn_save_group": "Enregistrer le groupe",
      "btn_delete_group": "Supprimer le groupe",
      "group_active_label": "Actif",
      "group_inactive_label": "Inactif",
      "tooltip_duplicate_group": "Dupliquer le groupe",
      "tooltip_edit_group_settings": "Modifier les param\xE8tres du groupe",
      "tooltip_delete_all_groups": "Supprimer tous les groupes de mots",
      "btn_create_new_group": "+ Cr\xE9er un nouveau groupe",
      "no_entries_found": "Aucune entr\xE9e trouv\xE9e.",
      "search_colored_words_placeholder": "Rechercher des mots ou motifs color\xE9s\u2026",
      "sort_label_last-added": "Trier : Dernier ajout",
      "sort_label_a-z": "Trier : A-Z",
      "sort_label_reverse-a-z": "Trier : Z-A",
      "sort_label_style-order": "Trier : Ordre de style",
      "sort_label_color": "Trier : Couleur",
      "btn_add_new_word": "+ Ajouter un nouveau mot / motif color\xE9",
      "style_type_text": "Couleur",
      "style_type_highlight": "Surbrillance",
      "style_type_both": "Les deux",
      "word_pattern_placeholder_long": "motif, mot ou mots s\xE9par\xE9s par des virgules (ex. bonjour, monde, foo)",
      "word_pattern_placeholder_short": "mot-cl\xE9 ou motif, ou mots s\xE9par\xE9s par des virgules",
      "use_regex": "Utiliser Regex",
      "flags_placeholder": "Drapeaux",
      "text_or_regex_placeholder": "Entr\xE9e Texte/Regex",
      "duplicate_entry": "Entr\xE9e dupliqu\xE9e",
      "open_in_regex_tester": "Ouvrir dans le testeur Regex",
      "no_rules_configured": "Aucune r\xE8gle configur\xE9e.",
      "no_rules_found": "Aucune r\xE8gle trouv\xE9e.",
      "match_option_exact": "Exact",
      "match_option_contains": "Contient",
      "match_option_starts_with": "Commence par",
      "match_option_ends_with": "Se termine par",
      // Presets
      "btn_presets": "Pr\xE9r\xE9glages",
      "preset_all_headings": "Tous les titres (H1-H6)",
      "preset_bullet_points": "Puces",
      "preset_numbered_lists": "Listes num\xE9rot\xE9es",
      "preset_task_checked": "Listes de t\xE2ches (Coch\xE9es)",
      "preset_task_unchecked": "Listes de t\xE2ches (Non coch\xE9es)",
      "preset_dates_yyyy_mm_dd": "Dates (AAAA-MM-JJ)",
      "preset_times_am_pm": "Heures (AM/PM)",
      "preset_times_24h": "Heures (24h)",
      "preset_dates_yyyy_mmm_dd": "Dates (AAAA-MMM-JJ)",
      "preset_relative_dates": "Dates relatives",
      "preset_basic_urls": "URLs de base",
      "preset_markdown_links": "Liens Markdown",
      "preset_domain_names": "Noms de domaine",
      "preset_email_addresses": "Adresses e-mail",
      "preset_at_username": "@Nom d'utilisateur",
      "preset_currency": "Devise",
      "preset_measurements": "Mesures",
      "preset_phone_numbers": "Num\xE9ros de t\xE9l\xE9phone",
      "preset_all_texts": "Tout le texte",
      "preset_codeblocks": "Blocs de code",
      "preset_inline_comments": "Commentaires (%%...%%)",
      "preset_highlighted_text": "Texte surlign\xE9 (==...==)",
      "preset_parentheses": "Parenth\xE8ses ()",
      "preset_square_brackets": "Crochets []",
      "preset_curly_braces": "Accolades {}",
      "preset_angle_brackets": "Chevrons <>",
      "preset_colons": "Deux-points :",
      "preset_double_quotes": "Guillemets doubles",
      "preset_single_quotes": "Guillemets simples",
      "preset_single_quotes_word_bounded": "Guillemets simples (D\xE9limit\xE9 par mot)",
      "preset_group_markdown_formatting": "Formatage Markdown",
      "preset_group_other_patterns": "Autres motifs",
      "preset_group_brackets": "Crochets et Parenth\xE8ses",
      // Preset Examples
      "preset_example_heading": "# Titre",
      "preset_example_bullet": "- Puce",
      "preset_example_numbered": "1. Premier \xE9l\xE9ment",
      "preset_example_task_checked": "- [x] Termin\xE9",
      "preset_example_task_unchecked": "- [ ] \xC0 faire",
      "preset_example_codeblock": "``` code ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[Lien](https://example.com)",
      "preset_example_comment": "%% commentaire %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "nom@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "\u20AC29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( texte )",
      "preset_example_square_brackets": "[ oui ]",
      "preset_example_curly_braces": "{ non }",
      "preset_example_angle_brackets": "< texte >",
      "preset_example_colons": ": texte :",
      "preset_example_double_quotes": '"texte"',
      "preset_example_single_quotes": "'texte'",
      "preset_example_single_quotes_word": "'mot'",
      "preset_example_highlight": "==texte surlign\xE9==",
      "preset_example_all_text": "Ceci ciblera tout le texte.",
      // Blacklist Settings
      "blacklist_words_header": "Mots en liste noire",
      "blacklist_words_desc": "Les mots-cl\xE9s ou motifs ici ne seront jamais color\xE9s, m\xEAme pour les correspondances partielles.",
      "search_blacklist_placeholder": "Rechercher des mots ou motifs en liste noire\u2026",
      "blacklist_sort_label_last-added": "Trier : Dernier ajout",
      "blacklist_sort_label_a-z": "Trier : A-Z",
      "blacklist_sort_label_reverse-a-z": "Trier : Z-A",
      "btn_add_blacklist": "+ Ajouter un mot ou motif en liste noire",
      "btn_add_to_blacklist": "+ Ajouter \xE0 la liste noire",
      "btn_add_blacklist_word": "+ Ajouter un mot \xE0 la liste noire",
      "btn_add_blacklist_regex": "+ Ajouter un regex \xE0 la liste noire",
      // File & Folder Rules
      "file_folder_rules_header": "R\xE8gles de coloriage des fichiers et dossiers",
      "file_folder_rules_desc": "Contr\xF4lez le coloriage par correspondance de nom, chemins exacts ou motifs regex. Laissez une entr\xE9e d'exclusion vide pour d\xE9sactiver le coloriage dans l'ensemble du coffre.",
      "search_file_folder_rules_placeholder": "Rechercher des r\xE8gles de fichier/dossier\u2026",
      "path_sort_label_last-added": "Trier : Dernier ajout",
      "path_sort_label_a-z": "Trier : A-Z",
      "path_sort_label_reverse-a-z": "Trier : Z-A",
      "path_sort_label_mode": "Trier : Mode",
      "path_sort_label_type": "Trier : Type",
      "btn_add_file_folder_rule": "+ Ajouter une r\xE8gle de fichier/dossier",
      "disabled_files_header": "Fichiers avec coloriage d\xE9sactiv\xE9 :",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "inclure",
      "path_rule_mode_exclude": "exclure",
      "text_rule_mode_include": "colore uniquement en (liste blanche)",
      "text_rule_mode_exclude": "ne colore pas en (liste noire)",
      "mode_only_colors_in": "ne colore que dans",
      "mode_does_not_color_in": "ne colore pas dans",
      "label_text_include": "Liste Blanche",
      "label_text_exclude": "Liste Noire",
      "label_enable_in": "Activer dans",
      "label_disable_in": "D\xE9sactiver dans",
      "enter_path_or_pattern": "Entrer un chemin, un motif ou des balises",
      "label_regex": "Expression r\xE9guli\xE8re",
      // Advanced Rules
      "advanced_rules_header": "R\xE8gles sp\xE9cifiques d\u2019inclusion/exclusion",
      "advanced_rules_modal_header": "R\xE8gles sp\xE9cifiques d\u2019inclusion/exclusion",
      "advanced_rules_manage_button": "g\xE9rer les r\xE8gles sp\xE9cifiques d\u2019inclusion/exclusion",
      "edit_rule_header": "Modifier la r\xE8gle",
      "add_rule_header": "Ajouter une nouvelle r\xE8gle",
      "btn_add_rule": "+ Ajouter une r\xE8gle",
      "btn_save_rule": "Enregistrer la r\xE8gle",
      "btn_add_words": "+ Ajouter des mots",
      "btn_add_regex": "+ Ajouter Regex",
      "btn_save_regex": "Enregistrer l'expression r\xE9guli\xE8re",
      // Regex Tester
      "regex_tester_header": "Testeur d'expressions r\xE9guli\xE8res",
      "regex_tester_blacklist": "Testeur regex - liste noire",
      "regex_expression_placeholder": "Mettez votre expression regex ici",
      "regex_subject_placeholder": "tapez votre texte \xE0 tester ici...",
      "regex_name_placeholder": "nommez votre regex",
      "matches": "correspondances",
      "matches_found": "correspondances trouv\xE9es",
      // Regex Flags
      "flag_g": "indicateur global : trouver tous les correspondances",
      "flag_i": "indicateur de casse insensible",
      "flag_m": "indicateur multiligne : ^ et $ correspondent aux limites de ligne",
      "flag_s": "indicateur dotAll : . correspond aux sauts de ligne",
      "flag_u": "indicateur unicode : traiter comme des points de code unicode",
      "flag_y": "indicateur sticky : correspondance \xE0 partir de la position lastIndex",
      // Data Export/Import
      "data_export_import_header": "Export/Import des donn\xE9es",
      "export_plugin_data": "Exporter les donn\xE9es du plugin",
      "export_plugin_data_desc": "Exporter les param\xE8tres, mots et r\xE8gles vers un fichier JSON.",
      "btn_export": "Exporter",
      "import_plugin_data": "Importer les donn\xE9es du plugin",
      "import_plugin_data_desc": "Importer les param\xE8tres depuis un fichier JSON",
      "btn_import": "Importer",
      "limit_input_placeholder": "limite",
      "limit_input_tooltip": "0=tous; nombre=derniers N; r=regex; h=surlignage; c=texte; b=texte+fond; sw=commence par; ew=se termine par; e=exact",
      // Missing Keys Added
      "highlight_styling_header": "Modifier le style de surbrillance",
      "edit_entry_header": "Modifier l'entr\xE9e",
      "opt_case_sensitive": "est sensible \xE0 la casse",
      "opt_not_case_sensitive": "non sensible \xE0 la casse",
      "opt_case_all": "Sensibilit\xE9 \xE0 la casse (Tous)",
      "opt_match_all": "Type de correspondance (Tous)",
      "edit_highlight_styling_btn": "Modifier le style de surbrillance",
      "inclusion_exclusion_header": "R\xE8gles d'inclusion / exclusion",
      "btn_save_entry": "Enregistrer l'entr\xE9e",
      "edit_entry_details": "Modifier les d\xE9tails de l'entr\xE9e",
      "prompt_search_existing": "Rechercher des entr\xE9es existantes\u2026",
      "command_add_to_existing_entry": "Ajouter \xE0 une entr\xE9e existante",
      "context_remove_from_entry": `Supprimer "{word}" de l'entr\xE9e`,
      "context_delete_entry": "Supprimer l'entr\xE9e",
      "btn_reset": "R\xE9initialiser",
      "btn_reset_all": "R\xE9initialiser le style de surbrillance",
      "btn_add_word": "+ Ajouter un mot",
      "btn_add_regex_short": "+ Ajouter Regex",
      "section_highlight_border_styling": "Style de bordure de surlignage",
      "section_highlight_styling": "Style de surlignage",
      "label_highlight_opacity": "Opacit\xE9 du surlignage",
      "label_highlight_radius": "Rayon de bordure du surlignage",
      "label_horizontal_padding": "Marge int\xE9rieure horizontale",
      "label_vertical_padding": "Marge int\xE9rieure verticale",
      "label_enable_border": "Activer la bordure",
      "label_border_sides": "C\xF4t\xE9s de la bordure",
      "label_border_style": "Style de bordure",
      "label_border_opacity": "Opacit\xE9 de la bordure",
      "label_border_thickness": "\xC9paisseur de la bordure",
      "btn_save_style": "Enregistrer le style",
      // Quick Colors / Styles
      "quick_actions_header": "Quick Actions",
      "quick_colors_header": "Couleurs Rapides",
      "quick_colors_desc": "Permet de surligner ou colorer rapidement du texte en affichant des couleurs dans le menu contextuel. Si Couleurs Rapides est d\xE9sactiv\xE9, les couleurs par style dans Styles Rapides seront utilis\xE9es.",
      "quick_colors_apply_mode_label": "La coloration du texte s'appliquera comme",
      "quick_colors_apply_mode_act": "Toujours colorer le texte",
      "quick_colors_apply_mode_html": "HTML en ligne",
      "quick_styles_header": "Styles Rapides",
      "quick_styles_desc": "D\xE9finir des styles nomm\xE9s pour appliquer la couleur du texte et les surlignages. Si Couleurs Rapides est d\xE9sactiv\xE9, les couleurs par style ici seront utilis\xE9es.",
      "btn_add_style": "+ Ajouter un style",
      "quick_styles_menu_option": "Styles Rapides",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "Entr\xE9es du groupe de liste noire",
      "show_blacklist_groups_in_commands": "Afficher les groupes de liste noire dans les commandes",
      "show_blacklist_groups_in_commands_desc": "Lorsqu'elle est activ\xE9e, les groupes de liste noire apparaissent dans la palette de commandes avec les commandes Activer/D\xE9sactiver.",
      "search_blacklist_groups_placeholder": "Rechercher des groupes de liste noire\u2026",
      "btn_create_new_blacklist_group": "+ Cr\xE9er un nouveau groupe de liste noire",
      "edit_blacklist_group_modal_title": "Modifier le groupe de liste noire",
      "tooltip_delete_all_blacklist_groups": "Supprimer tous les groupes de liste noire",
      "confirm_delete_all_blacklist_groups_title": "Supprimer tous les groupes de liste noire",
      "confirm_delete_all_blacklist_groups_desc": "\xCAtes-vous s\xFBr de vouloir supprimer TOUS les groupes de liste noire ? Cela ne peut pas \xEAtre annul\xE9 !",
      "confirm_delete_blacklist_group_title": "Supprimer le groupe de liste noire",
      "confirm_delete_blacklist_group_desc": "\xCAtes-vous s\xFBr de vouloir supprimer ce groupe de liste noire ? Cela ne peut pas \xEAtre annul\xE9.",
      "notice_blacklist_group_activated": "Groupe de liste noire activ\xE9",
      "notice_blacklist_group_deactivated": "Groupe de liste noire d\xE9sactiv\xE9",
      "command_activate_blacklist_group": "Activer le groupe de liste noire {groupName}",
      "command_deactivate_blacklist_group": "D\xE9sactiver le groupe de liste noire {groupName}",
      "btn_duplicate_entry": "Dupliquer l'entr\xE9e",
      "btn_open_in_regex_tester": "Ouvrir dans le testeur d'expression r\xE9guli\xE8re",
      "move_to_blacklist_group": "D\xE9placer vers un groupe de liste noire",
      "btn_delete_entry": "Supprimer l'entr\xE9e",
      "btn_cancel": "Annuler",
      "btn_confirm": "Confirmer",
      "requires_regex_safety_disabled": "N\xE9cessite la s\xE9curit\xE9 regex d\xE9sactiv\xE9e",
      "share_export_title": "Always Color Text export",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "Nom du style",
      "edit_group_highlight_styling": "Modifier le style de surlignage du groupe",
      "light_mode_fixer_desc": "Assombrit automatiquement le texte color\xE9 lors de l'utilisation du th\xE8me clair pour am\xE9liorer la visibilit\xE9.",
      "dark_mode_fixer_desc": "\xC9claircit automatiquement le texte color\xE9 lors de l'utilisation du th\xE8me sombre pour am\xE9liorer la visibilit\xE9.",
      "preset_bold": "Gras",
      "preset_italic": "Italique",
      "preset_bold_italic": "Gras Italique",
      "preview_text": "Texte"
    };
  }
});

// src/i18n/hi.js
var require_hi = __commonJS({
  "src/i18n/hi.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "\u0939\u093F\u0928\u094D\u0926\u0940",
      "settings_title": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0938\u0947\u091F\u093F\u0902\u0917\u094D\u0938",
      "header_plugin_name": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      "ribbon_title": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      // Language Settings
      "language_label": "\u092D\u093E\u0937\u093E",
      "language_desc": "\u0907\u0938 \u092A\u094D\u0932\u0917\u0907\u0928 \u092E\u0947\u0902 \u0909\u092A\u092F\u094B\u0917 \u0915\u0940 \u091C\u093E\u0928\u0947 \u0935\u093E\u0932\u0940 \u092D\u093E\u0937\u093E \u091A\u0941\u0928\u0947\u0902",
      "language_en": "\u0905\u0902\u0917\u094D\u0930\u0947\u091C\u093C\u0940",
      "language_es": "\u0938\u094D\u092A\u0947\u0928\u093F\u0936",
      "language_fr": "\u092B\u094D\u0930\u0947\u0902\u091A",
      "language_eu": "\u092C\u093E\u0938\u094D\u0915",
      "language_ru": "\u0930\u0942\u0938\u0940",
      "language_auto": "\u0938\u093F\u0938\u094D\u091F\u092E \u0921\u093F\u092B\u0949\u0932\u094D\u091F",
      "default": "\u0921\u093F\u092B\u093C\u0949\u0932\u094D\u091F",
      // Release Notes
      "latest_release_notes_label": "\u0928\u0935\u0940\u0928\u0924\u092E \u0930\u093F\u0932\u0940\u091C\u093C \u0928\u094B\u091F\u094D\u0938",
      "latest_release_notes_desc": "\u092A\u094D\u0932\u0917\u0907\u0928 \u0915\u0947 \u0928\u0935\u0940\u0928\u0924\u092E \u0930\u093F\u0932\u0940\u091C\u093C \u0928\u094B\u091F\u094D\u0938 \u0926\u0947\u0916\u0947\u0902",
      "open_changelog_button": "\u091A\u0947\u0902\u091C\u0932\u0949\u0917 \u0916\u094B\u0932\u0947\u0902",
      "command_show_release_notes": "\u0928\u0935\u0940\u0928\u0924\u092E \u0930\u093F\u0932\u0940\u091C\u093C \u0928\u094B\u091F\u094D\u0938 \u0926\u093F\u0916\u093E\u090F\u0901",
      "changelog_view_on_github": "GitHub \u092A\u0930 \u0926\u0947\u0916\u0947\u0902",
      "changelog_loading": "\u0930\u093F\u0932\u0940\u091C\u093C \u0932\u094B\u0921 \u0939\u094B \u0930\u0939\u0940 \u0939\u0948\u0902\u2026",
      "changelog_no_info": "\u0915\u094B\u0908 \u0930\u093F\u0932\u0940\u091C\u093C \u091C\u093E\u0928\u0915\u093E\u0930\u0940 \u0909\u092A\u0932\u092C\u094D\u0927 \u0928\u0939\u0940\u0902 \u0939\u0948\u0964",
      "changelog_release": "\u0930\u093F\u0932\u0940\u091C\u093C",
      "changelog_no_notes": "\u0915\u094B\u0908 \u0928\u094B\u091F\u094D\u0938 \u0928\u0939\u0940\u0902",
      "changelog_failed_to_load": "\u0930\u093F\u0932\u0940\u091C\u093C \u0928\u094B\u091F\u094D\u0938 \u0932\u094B\u0921 \u0915\u0930\u0928\u0947 \u092E\u0947\u0902 \u0935\u093F\u092B\u0932\u0964",
      // UI Elements & Menus
      "file_menu_enable": "\u0907\u0938 \u092B\u093C\u093E\u0907\u0932 \u0915\u0947 \u0932\u093F\u090F \u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u091A\u093E\u0932\u0942 \u0915\u0930\u0947\u0902",
      "file_menu_disable": "\u0907\u0938 \u092B\u093C\u093E\u0907\u0932 \u0915\u0947 \u0932\u093F\u090F \u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      "menu_color_once": "\u090F\u0915 \u092C\u093E\u0930 \u0930\u0902\u0917 \u0932\u0917\u093E\u090F\u0901",
      "menu_highlight_once": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0930\u0947\u0902",
      "menu_color_highlight_once": "\u0930\u0902\u0917 / \u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0930\u0947\u0902",
      "menu_remove_inline_color": "\u0907\u0928\u0932\u093E\u0907\u0928 \u0930\u0902\u0917 \u0939\u091F\u093E\u090F\u0901",
      "menu_always_color_text": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      "menu_remove_always_color_text": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0939\u091F\u093E\u090F\u0901",
      "menu_blacklist_word": "\u0930\u0902\u0917\u093E\u0908 \u0938\u0947 \u0936\u092C\u094D\u0926 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0915\u0930\u0947\u0902",
      "show_toggle_statusbar": "\u0938\u094D\u091F\u0947\u091F\u0938 \u092C\u093E\u0930 \u092E\u0947\u0902 \u091F\u0949\u0917\u0932 \u0926\u093F\u0916\u093E\u090F\u0901",
      "show_toggle_ribbon": "\u0930\u093F\u092C\u0928 \u092E\u0947\u0902 \u091F\u0949\u0917\u0932 \u0906\u0907\u0915\u0928 \u0926\u093F\u0916\u093E\u090F\u0901",
      "show_toggle_command": "\u0915\u092E\u093E\u0902\u0921 \u092E\u0947\u0902 \u091F\u0949\u0917\u0932 \u0926\u093F\u0916\u093E\u090F\u0901",
      "menu_options_header": "\u092E\u0947\u0928\u0942 \u0935\u093F\u0915\u0932\u094D\u092A",
      "show_blacklist_menu": '\u0930\u093E\u0907\u091F-\u0915\u094D\u0932\u093F\u0915 \u092E\u0947\u0928\u0942 \u092E\u0947\u0902 "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0936\u092C\u094D\u0926" \u0926\u093F\u0916\u093E\u090F\u0901',
      "show_blacklist_menu_desc": "\u0930\u0902\u0917\u093E\u0908 \u0938\u0947 \u091A\u092F\u0928\u093F\u0924 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u094B \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0930\u093E\u0907\u091F-\u0915\u094D\u0932\u093F\u0915 \u092E\u0947\u0928\u0942 \u0906\u0907\u091F\u092E \u091C\u094B\u0921\u093C\u0924\u093E \u0939\u0948\u0964",
      "show_add_to_existing_menu": '\u0930\u093E\u0907\u091F-\u0915\u094D\u0932\u093F\u0915 \u092E\u0947\u0928\u0942 \u092E\u0947\u0902 "\u092E\u094C\u091C\u0942\u0926\u093E \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u092E\u0947\u0902 \u091C\u094B\u0921\u093C\u0947\u0902" \u0926\u093F\u0916\u093E\u090F\u0901',
      "show_add_to_existing_menu_desc": "\u091A\u092F\u0928\u093F\u0924 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u094B \u0915\u093F\u0938\u0940 \u092E\u094C\u091C\u0942\u0926\u093E \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u092E\u0947\u0902 \u091C\u094B\u0921\u093C\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0930\u093E\u0907\u091F-\u0915\u094D\u0932\u093F\u0915 \u092E\u0947\u0928\u0942 \u0906\u0907\u091F\u092E \u091C\u094B\u0921\u093C\u0924\u093E \u0939\u0948\u0964",
      "show_always_color_text_menu": '\u0930\u093E\u0907\u091F-\u0915\u094D\u0932\u093F\u0915 \u092E\u0947\u0928\u0942 \u092E\u0947\u0902 "Always Color Text" \u0926\u093F\u0916\u093E\u090F\u0901',
      "show_always_color_text_menu_desc": "\u091A\u092F\u0928\u093F\u0924 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u094B \u0930\u0902\u0917\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0930\u093E\u0907\u091F-\u0915\u094D\u0932\u093F\u0915 \u092E\u0947\u0928\u0942 \u0906\u0907\u091F\u092E \u091C\u094B\u0921\u093C\u0924\u093E \u0939\u0948\u0964",
      "hide_inactive_groups_in_dropdowns": "\u0921\u094D\u0930\u0949\u092A\u0921\u093E\u0909\u0928 \u092E\u0947\u0902 \u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u0938\u092E\u0942\u0939 \u091B\u0941\u092A\u093E\u090F\u0901",
      "hide_inactive_groups_in_dropdowns_desc": "\u0921\u094D\u0930\u0949\u092A\u0921\u093E\u0909\u0928 \u092E\u0947\u0902 \u0938\u092E\u0942\u0939 \u0938\u0942\u091A\u0940 \u092A\u094D\u0930\u0926\u0930\u094D\u0936\u093F\u0924 \u0915\u0930\u0924\u0947 \u0938\u092E\u092F \u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939\u094B\u0902 \u0915\u094B \u091B\u0941\u092A\u093E\u0924\u093E \u0939\u0948\u0964",
      "show_word_groups_in_commands": "\u0915\u092E\u093E\u0902\u0921 \u092E\u0947\u0902 \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0926\u093F\u0916\u093E\u090F\u0901",
      "show_word_groups_in_commands_desc": "\u091A\u093E\u0932\u0942 \u0939\u094B\u0928\u0947 \u092A\u0930, \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0915\u092E\u093E\u0902\u0921 \u092A\u0948\u0932\u0947\u091F \u092E\u0947\u0902 \u0938\u0915\u094D\u0930\u093F\u092F/\u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u0915\u092E\u093E\u0902\u0921 \u0915\u0947 \u0938\u093E\u0925 \u0926\u093F\u0916\u0924\u0947 \u0939\u0948\u0902\u0964",
      "tooltip_enable_for_file": "\u0907\u0938 \u092B\u093C\u093E\u0907\u0932 \u0915\u0947 \u0932\u093F\u090F \u091A\u093E\u0932\u0942 \u0915\u0930\u0947\u0902",
      "tooltip_delete_all_words": "\u092A\u0930\u093F\u092D\u093E\u0937\u093F\u0924 \u0938\u092D\u0940 \u0936\u092C\u094D\u0926/\u092A\u0948\u091F\u0930\u094D\u0928 \u0939\u091F\u093E\u090F\u0901",
      "tooltip_delete_all_blacklist": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F\u0947\u0921 \u0938\u092D\u0940 \u0936\u092C\u094D\u0926/\u092A\u0948\u091F\u0930\u094D\u0928 \u0939\u091F\u093E\u090F\u0901",
      "tooltip_use_regex": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u092A\u0948\u091F\u0930\u094D\u0928 \u0915\u0947 \u0930\u0942\u092A \u092E\u0947\u0902 \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902",
      "drag_to_reorder": "\u092A\u0941\u0928\u0903 \u0935\u094D\u092F\u0935\u0938\u094D\u0925\u093F\u0924 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0916\u0940\u0902\u091A\u0947\u0902",
      "reset_text_color": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      "reset_highlight": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      // Commands
      "command_color_selected": "\u091A\u092F\u0928\u093F\u0924 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917\u0947\u0902",
      "command_toggle_current": "\u0935\u0930\u094D\u0924\u092E\u093E\u0928 \u0926\u0938\u094D\u0924\u093E\u0935\u0947\u091C\u093C \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917\u093E\u0908 \u091A\u093E\u0932\u0942/\u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      "command_enable_current": "\u0935\u0930\u094D\u0924\u092E\u093E\u0928 \u0926\u0938\u094D\u0924\u093E\u0935\u0947\u091C\u093C \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917\u093E\u0908 \u091A\u093E\u0932\u0942 \u0915\u0930\u0947\u0902",
      "command_disable_current": "\u0935\u0930\u094D\u0924\u092E\u093E\u0928 \u0926\u0938\u094D\u0924\u093E\u0935\u0947\u091C\u093C \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917\u093E\u0908 \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      "command_toggle_global": "\u0935\u0948\u0936\u094D\u0935\u093F\u0915 \u0930\u0902\u0917\u093E\u0908 \u0938\u0915\u094D\u0937\u092E/\u0905\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "command_enable_global": "\u0935\u0948\u0936\u094D\u0935\u093F\u0915 \u0930\u0902\u0917\u093E\u0908 \u0938\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "command_disable_global": "\u0935\u0948\u0936\u094D\u0935\u093F\u0915 \u0930\u0902\u0917\u093E\u0908 \u0905\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "command_enable_lightweight_mode": "\u0932\u093E\u0907\u091F\u0935\u0947\u091F \u092E\u094B\u0921 \u0938\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "command_disable_lightweight_mode": "\u0932\u093E\u0907\u091F\u0935\u0947\u091F \u092E\u094B\u0921 \u0905\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "command_color_highlight_once": "\u091A\u092F\u0928\u093F\u0924 \u092A\u093E\u0920 \u0915\u094B \u0930\u0902\u0917\u0947\u0902 / \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0930\u0947\u0902 (\u090F\u0915 \u092C\u093E\u0930)",
      "notice_select_text_first_once": "\u0915\u0943\u092A\u092F\u093E \u092A\u0939\u0932\u0947 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u091A\u0941\u0928\u0947\u0902\u0964",
      "enable_document_color": "\u0935\u0948\u0936\u094D\u0935\u093F\u0915 \u0930\u0902\u0917 \u0938\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "color_swatches_header": "\u0930\u0902\u0917 \u092A\u094D\u0930\u092C\u0902\u0927\u0928",
      "color_rendering_header": "\u0930\u0902\u0917 \u092A\u094D\u0930\u0924\u093F\u092A\u093E\u0926\u0928 \u0914\u0930 \u092A\u094D\u0930\u0926\u0930\u094D\u0936\u0928",
      "theme_support_header": "\u0925\u0940\u092E \u0938\u092E\u0930\u094D\u0925\u0928",
      "matching_behavior_header": "\u092E\u093F\u0932\u093E\u0928 \u0935\u094D\u092F\u0935\u0939\u093E\u0930",
      "smart_updates": "\u0938\u094D\u092E\u093E\u0930\u094D\u091F \u0905\u092A\u0921\u0947\u091F (\u092A\u094D\u0930\u092F\u094B\u0917\u093E\u0924\u094D\u092E\u0915)",
      "light_mode_fixer": "\u0932\u093E\u0907\u091F \u092E\u094B\u0921 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u0932\u0930 \u092B\u093F\u0915\u094D\u0938\u0930",
      "dark_mode_fixer": "\u0921\u093E\u0930\u094D\u0915 \u092E\u094B\u0921 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u0932\u0930 \u092B\u093F\u0915\u094D\u0938\u0930",
      "command_manage_advanced_rules": "\u0935\u093F\u0936\u093F\u0937\u094D\u091F \u0938\u092E\u093E\u0935\u0947\u0936\u0928/\u092C\u0939\u093F\u0937\u094D\u0915\u0930\u0923 \u0928\u093F\u092F\u092E \u092A\u094D\u0930\u092C\u0902\u0927\u093F\u0924 \u0915\u0930\u0947\u0902",
      "command_open_regex_tester": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091C\u094B\u0921\u093C\u0947\u0902 (\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091F\u0947\u0938\u094D\u091F\u0930 \u0916\u094B\u0932\u0947\u0902)",
      "command_open_blacklist_regex_tester": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u092E\u0947\u0902 \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091C\u094B\u0921\u093C\u0947\u0902",
      "command_manage_colored_texts": "\u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u092A\u094D\u0930\u092C\u0902\u0927\u093F\u0924 \u0915\u0930\u0947\u0902",
      "command_toggle_hide_text_colors": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u091B\u093F\u092A\u093E\u090F\u0901/\u0926\u093F\u0916\u093E\u090F\u0901",
      "command_toggle_hide_highlights": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F\u094D\u0938 \u091B\u093F\u092A\u093E\u090F\u0901/\u0926\u093F\u0916\u093E\u090F\u0901",
      "command_hide_text_colors": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u091B\u093F\u092A\u093E\u090F\u0901",
      "command_unhide_text_colors": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u0926\u093F\u0916\u093E\u090F\u0901",
      "command_hide_highlights": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F\u094D\u0938 \u091B\u093F\u092A\u093E\u090F\u0901",
      "command_unhide_highlights": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F\u094D\u0938 \u0926\u093F\u0916\u093E\u090F\u0901",
      "command_activate_word_group": "{groupName} \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0938\u0915\u094D\u0930\u093F\u092F \u0915\u0930\u0947\u0902",
      "command_deactivate_word_group": "{groupName} \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u0915\u0930\u0947\u0902",
      // Notifications
      "notice_lightweight_mode_enabled": "\u0932\u093E\u0907\u091F\u0935\u0947\u091F \u092E\u094B\u0921 \u0938\u0915\u094D\u0937\u092E",
      "notice_lightweight_mode_disabled": "\u0932\u093E\u0907\u091F\u0935\u0947\u091F \u092E\u094B\u0921 \u0905\u0915\u094D\u0937\u092E",
      "notice_enabled": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u091A\u093E\u0932\u0942",
      "notice_disabled": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u092C\u0902\u0926",
      "notice_blacklisted_cannot_color": '"{word}" \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F\u0947\u0921 \u0939\u0948 \u0914\u0930 \u0930\u0902\u0917 \u0928\u0939\u0940\u0902 \u0932\u0917\u093E\u092F\u093E \u091C\u093E \u0938\u0915\u0924\u093E\u0964',
      "notice_removed_always_color": '"{word}" \u0915\u0947 \u0932\u093F\u090F \u0939\u092E\u0947\u0936\u093E \u0915\u0940 \u0930\u0902\u0917\u093E\u0908 \u0939\u091F\u093E\u0908 \u0917\u0908\u0964',
      "notice_added_to_blacklist": '"{word}" \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u092E\u0947\u0902 \u091C\u094B\u0921\u093C\u093E \u0917\u092F\u093E\u0964',
      "notice_already_blacklisted": '"{word}" \u092A\u0939\u0932\u0947 \u0938\u0947 \u0939\u0940 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F\u0947\u0921 \u0939\u0948\u0964',
      "notice_select_text_first": "\u0915\u0943\u092A\u092F\u093E \u092A\u0939\u0932\u0947 \u0915\u0941\u091B \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u091A\u0941\u0928\u0947\u0902\u0964",
      "notice_no_active_file": "\u0930\u0902\u0917\u093E\u0908 \u091F\u0949\u0917\u0932 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0915\u094B\u0908 \u0938\u0915\u094D\u0930\u093F\u092F \u092B\u093C\u093E\u0907\u0932 \u0928\u0939\u0940\u0902 \u0939\u0948\u0964",
      "notice_coloring_enabled_for_path": "{path} \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917\u093E\u0908 \u091A\u093E\u0932\u0942",
      "notice_coloring_disabled_for_path": "{path} \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917\u093E\u0908 \u092C\u0902\u0926",
      "notice_global_enabled": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u091A\u093E\u0932\u0942",
      "notice_global_disabled": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u092C\u0902\u0926",
      "notice_unable_open_changelog": "\u091A\u0947\u0902\u091C\u0932\u0949\u0917 \u0916\u094B\u0932\u0928\u0947 \u092E\u0947\u0902 \u0905\u0938\u092E\u0930\u094D\u0925\u0964",
      "notice_pattern_blocked": "\u092E\u0947\u092E\u094B\u0930\u0940 \u0938\u0941\u0930\u0915\u094D\u0937\u093E \u0915\u0947 \u0932\u093F\u090F \u092A\u0948\u091F\u0930\u094D\u0928 \u092C\u094D\u0932\u0949\u0915 \u0915\u093F\u092F\u093E \u0917\u092F\u093E:",
      "notice_pattern_too_complex": "\u092A\u0948\u091F\u0930\u094D\u0928 \u092C\u0939\u0941\u0924 \u091C\u091F\u093F\u0932:",
      "notice_invalid_hex_format": "\u0905\u092E\u093E\u0928\u094D\u092F \u0939\u0947\u0915\u094D\u0938 \u0930\u0902\u0917 \u092B\u0949\u0930\u094D\u092E\u0947\u091F\u0964 #RRGGBB \u092F\u093E #RGB \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902\u0964",
      "notice_error_saving_changes": "\u092A\u0930\u093F\u0935\u0930\u094D\u0924\u0928 \u0938\u0939\u0947\u091C\u0928\u0947 \u092E\u0947\u0902 \u0924\u094D\u0930\u0941\u091F\u093F\u0964 \u0915\u0943\u092A\u092F\u093E \u092A\u0941\u0928\u0903 \u092A\u094D\u0930\u092F\u093E\u0938 \u0915\u0930\u0947\u0902\u0964",
      "notice_invalid_color_format": "\u0905\u092E\u093E\u0928\u094D\u092F \u0930\u0902\u0917 \u092B\u0949\u0930\u094D\u092E\u0947\u091F\u0964",
      "notice_exported": "\u0928\u093F\u0930\u094D\u092F\u093E\u0924 \u0915\u093F\u092F\u093E \u0917\u092F\u093E: {fname}",
      "notice_export_failed": "\u0928\u093F\u0930\u094D\u092F\u093E\u0924 \u0935\u093F\u092B\u0932",
      "notice_import_completed": "\u0906\u092F\u093E\u0924 \u092A\u0942\u0930\u094D\u0923",
      "notice_import_failed": "\u0906\u092F\u093E\u0924 \u0935\u093F\u092B\u0932",
      "notice_invalid_regex": "\u0905\u092E\u093E\u0928\u094D\u092F \u0928\u093F\u092F\u092E\u093F\u0924 \u0905\u092D\u093F\u0935\u094D\u092F\u0915\u094D\u0924\u093F",
      "notice_empty_pattern": "\u092A\u0948\u091F\u0930\u094D\u0928 \u0916\u093E\u0932\u0940 \u0939\u0948",
      "notice_added_regex": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091C\u094B\u0921\u093C\u093E \u0917\u092F\u093E",
      "notice_rule_updated": "\u0928\u093F\u092F\u092E \u0905\u092A\u0921\u0947\u091F \u0915\u093F\u092F\u093E \u0917\u092F\u093E",
      "notice_regex_updated": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u0905\u092A\u0921\u0947\u091F \u0915\u093F\u092F\u093E \u0917\u092F\u093E",
      "notice_entry_updated": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0905\u092A\u0921\u0947\u091F \u0915\u0940 \u0917\u0908",
      "notice_entry_duplicated": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0921\u0941\u092A\u094D\u0932\u093F\u0915\u0947\u091F \u0915\u0940 \u0917\u0908",
      "notice_error_opening_regex_tester": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091F\u0947\u0938\u094D\u091F\u0930 \u0916\u094B\u0932\u0928\u0947 \u092E\u0947\u0902 \u0924\u094D\u0930\u0941\u091F\u093F",
      "notice_error_opening_blacklist_regex_tester": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091F\u0947\u0938\u094D\u091F\u0930 \u0916\u094B\u0932\u0928\u0947 \u092E\u0947\u0902 \u0924\u094D\u0930\u0941\u091F\u093F",
      "notice_error_opening_advanced_rules": "\u0909\u0928\u094D\u0928\u0924 \u0928\u093F\u092F\u092E \u092E\u0949\u0921\u0932 \u0916\u094B\u0932\u0928\u0947 \u092E\u0947\u0902 \u0924\u094D\u0930\u0941\u091F\u093F",
      "notice_text_color_reset": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u0930\u0940\u0938\u0947\u091F \u0915\u093F\u092F\u093E \u0917\u092F\u093E",
      "notice_highlight_reset": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0930\u0940\u0938\u0947\u091F \u0915\u093F\u092F\u093E \u0917\u092F\u093E",
      "notice_text_colors_hidden": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u091B\u093F\u092A\u093E\u090F \u0917\u090F",
      "notice_text_colors_visible": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u0926\u093F\u0916\u093E\u0908 \u0926\u0947 \u0930\u0939\u0947 \u0939\u0948\u0902",
      "notice_highlights_hidden": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F\u094D\u0938 \u091B\u093F\u092A\u093E\u090F \u0917\u090F",
      "notice_highlights_visible": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F\u094D\u0938 \u0926\u093F\u0916\u093E\u0908 \u0926\u0947 \u0930\u0939\u0947 \u0939\u0948\u0902",
      "notice_regex_support_disabled": "Regex \u0938\u0939\u093E\u092F\u0924\u093E \u092C\u0902\u0926 \u0939\u0948\u0964 Regex \u092A\u0948\u091F\u0930\u094D\u0928 \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0938\u0947\u091F\u093F\u0902\u0917 \u092E\u0947\u0902 \u0938\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902\u0964",
      "notice_no_active_file_to_disable": "\u0930\u0902\u0917\u093E\u0908 \u092C\u0902\u0926 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0915\u094B\u0908 \u0938\u0915\u094D\u0930\u093F\u092F \u092B\u093C\u093E\u0907\u0932 \u0928\u0939\u0940\u0902 \u0939\u0948\u0964",
      "notice_already_disabled_for_path": "{path} \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917\u093E\u0908 \u092A\u0939\u0932\u0947 \u0938\u0947 \u0939\u0940 \u092C\u0902\u0926 \u0939\u0948",
      "notice_filter_disabled": "\u092B\u093F\u0932\u094D\u091F\u0930 \u092C\u0902\u0926 \u0915\u0940",
      // Confirmation Dialogs
      "confirm_delete_all_title": "\u0938\u092D\u0940 \u0936\u092C\u094D\u0926 \u0939\u091F\u093E\u090F\u0901",
      "confirm_delete_all_desc": "\u0915\u094D\u092F\u093E \u0906\u092A \u0935\u093E\u0915\u0908 \u0905\u092A\u0928\u0947 \u0938\u092D\u0940 \u0930\u0902\u0917\u0947 \u0936\u092C\u094D\u0926/\u092A\u0948\u091F\u0930\u094D\u0928 \u0939\u091F\u093E\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902? \u0906\u092A \u0907\u0938\u0947 \u092A\u0942\u0930\u094D\u0935\u0935\u0924 \u0928\u0939\u0940\u0902 \u0915\u0930 \u0938\u0915\u0924\u0947!",
      "confirm_delete_all_blacklist_title": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F\u0947\u0921 \u0938\u092D\u0940 \u0936\u092C\u094D\u0926 \u0939\u091F\u093E\u090F\u0901",
      "confirm_delete_all_blacklist_desc": "\u0915\u094D\u092F\u093E \u0906\u092A \u0935\u093E\u0915\u0908 \u0938\u092D\u0940 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u090F\u0902\u091F\u094D\u0930\u0940\u091C\u093C \u0939\u091F\u093E\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902? \u0906\u092A \u0907\u0938\u0947 \u092A\u0942\u0930\u094D\u0935\u0935\u0924 \u0928\u0939\u0940\u0902 \u0915\u0930 \u0938\u0915\u0924\u0947!",
      "confirm_delete_all_groups_title": "\u0938\u092D\u0940 \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0939\u091F\u093E\u090F\u0902",
      "confirm_delete_all_groups_desc": "\u0915\u094D\u092F\u093E \u0906\u092A \u0935\u093E\u0915\u0908 \u0938\u092D\u0940 \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0939\u091F\u093E\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902? \u0906\u092A \u0907\u0938\u0947 \u092A\u0942\u0930\u094D\u0935\u0935\u0924 \u0928\u0939\u0940\u0902 \u0915\u0930 \u0938\u0915\u0924\u0947!",
      "restart_required_title": "\u0930\u0940\u0938\u094D\u091F\u093E\u0930\u094D\u091F \u0906\u0935\u0936\u094D\u092F\u0915",
      "restart_required_desc": "\u0915\u092E\u093E\u0902\u0921 \u092A\u0948\u0932\u0947\u091F \u091F\u0949\u0917\u0932 \u092C\u0902\u0926 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u092A\u0948\u0932\u0947\u091F \u0938\u0947 \u0915\u092E\u093E\u0902\u0921\u094D\u0938 \u0915\u094B \u092A\u0942\u0930\u0940 \u0924\u0930\u0939 \u0939\u091F\u093E\u0928\u0947 \u0939\u0947\u0924\u0941 \u0911\u092C\u094D\u0938\u0940\u0921\u093F\u092F\u0928 \u0915\u094B \u0930\u0940\u0938\u094D\u091F\u093E\u0930\u094D\u091F \u0915\u0930\u0928\u093E \u0906\u0935\u0936\u094D\u092F\u0915 \u0939\u0948\u0964 \u0905\u092D\u0940 \u0930\u0940\u0938\u094D\u091F\u093E\u0930\u094D\u091F \u0915\u0930\u0947\u0902?",
      "btn_cancel": "\u0930\u0926\u094D\u0926 \u0915\u0930\u0947\u0902",
      "btn_confirm": "\u092A\u0941\u0937\u094D\u091F\u093F \u0915\u0930\u0947\u0902",
      // Basic Settings
      "color_in_live_preview_mode": "\u0932\u093E\u0907\u0935 \u092A\u0942\u0930\u094D\u0935\u093E\u0935\u0932\u094B\u0915\u0928 \u092E\u094B\u0921 \u092E\u0947\u0902 \u0930\u0902\u0917",
      "color_in_reading_mode": "\u0930\u0940\u0921\u093F\u0902\u0917 \u092E\u094B\u0921 \u092E\u0947\u0902 \u0930\u0902\u0917 \u0932\u0917\u093E\u090F\u0901",
      "force_full_render_reading": "\u0930\u0940\u0921\u093F\u0902\u0917 \u092E\u094B\u0921 \u092E\u0947\u0902 \u092A\u0942\u0930\u094D\u0923 \u0930\u0947\u0902\u0921\u0930 \u092B\u094B\u0930\u094D\u0938 \u0915\u0930\u0947\u0902",
      "force_full_render_reading_desc": "\u091C\u092C \u091A\u093E\u0932\u0942 \u0939\u094B, \u0924\u094B \u0930\u0940\u0921\u093F\u0902\u0917-\u092E\u094B\u0921 \u092A\u0942\u0930\u0947 \u0926\u0938\u094D\u0924\u093E\u0935\u0947\u091C\u093C \u0915\u094B \u090F\u0915 \u092A\u093E\u0938 \u092E\u0947\u0902 \u0930\u0902\u0917\u0928\u0947 \u0915\u093E \u092A\u094D\u0930\u092F\u093E\u0938 \u0915\u0930\u0947\u0917\u093E\u0964 \u092C\u0921\u093C\u0947 \u0926\u0938\u094D\u0924\u093E\u0935\u0947\u091C\u093C\u094B\u0902 \u092A\u0930 \u092A\u094D\u0930\u0926\u0930\u094D\u0936\u0928 \u0938\u092E\u0938\u094D\u092F\u093E\u090F\u0901 \u0939\u094B \u0938\u0915\u0924\u0940 \u0939\u0948\u0902\u0964 \u0938\u093E\u0935\u0927\u093E\u0928\u0940 \u0938\u0947 \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902!",
      "lightweight_mode": "\u0932\u093E\u0907\u091F\u0935\u0947\u091F \u092E\u094B\u0921 (\u092A\u094D\u0930\u092F\u094B\u0917\u093E\u0924\u094D\u092E\u0915)",
      "lightweight_mode_desc": "\u091F\u093E\u0907\u092A \u0915\u0930\u0924\u0947 \u0938\u092E\u092F \u092A\u094D\u0930\u094B\u0938\u0947\u0938\u093F\u0902\u0917 \u0915\u094B \u0915\u093E\u092B\u0940 \u0915\u092E \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u0915\u0941\u091B \u092E\u093F\u0932\u093E\u0928 \u091B\u0942\u091F \u0938\u0915\u0924\u0947 \u0939\u0948\u0902\u0964",
      "disable_coloring_current_file": "\u0935\u0930\u094D\u0924\u092E\u093E\u0928 \u092B\u093C\u093E\u0907\u0932 \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917\u093E\u0908 \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      "disable_coloring_current_file_desc": "\u092B\u093C\u093E\u0907\u0932 \u0914\u0930 \u092B\u093C\u094B\u0932\u094D\u0921\u0930 \u0930\u0902\u0917\u093E\u0908 \u0928\u093F\u092F\u092E\u094B\u0902 \u0915\u0947 \u0924\u0939\u0924 \u0938\u0915\u094D\u0930\u093F\u092F \u092B\u093C\u093E\u0907\u0932 \u0915\u0947 \u0932\u093F\u090F \u090F\u0915 \u092C\u0939\u093F\u0937\u094D\u0915\u0930\u0923 \u0928\u093F\u092F\u092E \u091C\u094B\u0921\u093C\u0924\u093E \u0939\u0948\u0964",
      "btn_disable_for_this_file": "\u0907\u0938 \u092B\u093C\u093E\u0907\u0932 \u0915\u0947 \u0932\u093F\u090F \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      // Coloring Settings
      "coloring_settings_header": "\u0930\u0902\u0917\u093E\u0908 \u0938\u0947\u091F\u093F\u0902\u0917\u094D\u0938",
      "regex_support": "\u0930\u0947\u0917\u0947\u0915\u094D\u0938 \u0938\u092A\u094B\u0930\u094D\u091F",
      "regex_support_desc": "\u092A\u0948\u091F\u0930\u094D\u0928 \u0915\u094B \u0930\u0947\u0917\u0941\u0932\u0930 \u090F\u0915\u094D\u0938\u092A\u094D\u0930\u0947\u0936\u0928 \u0939\u094B\u0928\u0947 \u0915\u0940 \u0905\u0928\u0941\u092E\u0924\u093F \u0926\u0947\u0902\u0964 \u0938\u0941\u0930\u0915\u094D\u0937\u093E \u0915\u0947 \u0932\u093F\u090F \u0905\u092E\u093E\u0928\u094D\u092F \u0930\u0947\u0917\u0947\u0915\u094D\u0938 \u0915\u094B \u0928\u091C\u093C\u0930\u0905\u0902\u0926\u093E\u091C\u093C \u0915\u093F\u092F\u093E \u091C\u093E\u0924\u093E \u0939\u0948\u0964",
      "disable_regex_safety": "\u0930\u0947\u0917\u0947\u0915\u094D\u0938 \u0938\u0941\u0930\u0915\u094D\u0937\u093E \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      "disable_regex_safety_desc": "\u091C\u091F\u093F\u0932 \u092F\u093E \u0938\u0902\u092D\u093E\u0935\u093F\u0924 \u0916\u0924\u0930\u0928\u093E\u0915 \u090F\u0915\u094D\u0938\u092A\u094D\u0930\u0947\u0936\u0928\u094D\u0938 \u0915\u0940 \u0905\u0928\u0941\u092E\u0924\u093F \u0926\u0947\u0902\u0964 \u092A\u094D\u0930\u0926\u0930\u094D\u0936\u0928 \u0938\u092E\u0938\u094D\u092F\u093E\u090F\u0901 \u092F\u093E \u092B\u094D\u0930\u0940\u091C\u093C \u0939\u094B \u0938\u0915\u0924\u0940 \u0939\u0948\u0902\u0964",
      "requires_regex_safety_disabled": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u0938\u0941\u0930\u0915\u094D\u0937\u093E \u0905\u0915\u094D\u0937\u092E \u0915\u0930\u0928\u093E \u0906\u0935\u0936\u094D\u092F\u0915 \u0939\u0948",
      "case_sensitive": "\u0915\u0947\u0938 \u0938\u0947\u0902\u0938\u093F\u091F\u093F\u0935",
      "case_sensitive_desc": '\u092F\u0926\u093F \u092F\u0939 \u091A\u093E\u0932\u0942 \u0939\u0948, \u0924\u094B "word" \u0914\u0930 "Word" \u0915\u094B \u0905\u0932\u0917 \u092E\u093E\u0928\u093E \u091C\u093E\u0924\u093E \u0939\u0948\u0964 \u092F\u0926\u093F \u092C\u0902\u0926 \u0939\u0948, \u0924\u094B \u0935\u0947 \u0938\u092E\u093E\u0928 \u0930\u0942\u092A \u0938\u0947 \u0930\u0902\u0917\u0947 \u091C\u093E\u0924\u0947 \u0939\u0948\u0902\u0964',
      "partial_match": "\u0906\u0902\u0936\u093F\u0915 \u092E\u093F\u0932\u093E\u0928",
      "partial_match_desc": '\u092F\u0926\u093F \u0938\u0915\u094D\u0937\u092E \u0939\u0948, \u0924\u094B \u092A\u0942\u0930\u093E \u0936\u092C\u094D\u0926 \u0930\u0902\u0917\u093E \u091C\u093E\u090F\u0917\u093E \u092F\u0926\u093F \u0909\u0938\u0915\u0947 \u0905\u0902\u0926\u0930 \u0915\u094B\u0908 \u0930\u0902\u0917\u093E \u0939\u0941\u0906 \u0936\u092C\u094D\u0926 \u092E\u093F\u0932\u0924\u093E \u0939\u0948 (\u091C\u0948\u0938\u0947, "as" "Jasper" \u0915\u094B \u0930\u0902\u0917\u0947\u0917\u093E)\u0964',
      // One-Time Actions
      "one_time_actions_header": "\u090F\u0915-\u092C\u093E\u0930 \u0915\u0940 \u0915\u094D\u0930\u093F\u092F\u093E\u090F\u0901",
      "setting_color_once": "\u090F\u0915 \u092C\u093E\u0930 \u0930\u0902\u0917 \u0932\u0917\u093E\u090F\u0901",
      "setting_color_once_desc": "\u091A\u092F\u0928\u093F\u0924 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u0947 \u0932\u093F\u090F HTML \u0907\u0928\u0932\u093E\u0907\u0928 \u0938\u092E\u094D\u092E\u093F\u0932\u093F\u0924 \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u092A\u094D\u0932\u0917\u0907\u0928 \u092C\u0902\u0926 \u0939\u094B\u0928\u0947 \u092A\u0930 \u092D\u0940 \u092F\u0939 \u092C\u0928\u093E \u0930\u0939\u0924\u093E \u0939\u0948\u0964",
      "setting_highlight_once": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0930\u0947\u0902",
      "setting_highlight_once_desc": "\u092C\u0948\u0915\u0917\u094D\u0930\u093E\u0909\u0902\u0921 \u0938\u094D\u091F\u093E\u0907\u0932\u093F\u0902\u0917 \u0915\u0947 \u0938\u093E\u0925 HTML \u0907\u0928\u0932\u093E\u0907\u0928 \u0938\u092E\u094D\u092E\u093F\u0932\u093F\u0924 \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u092A\u094D\u0932\u0917\u0907\u0928 \u092C\u0902\u0926 \u0939\u094B\u0928\u0947 \u092A\u0930 \u092D\u0940 \u092F\u0939 \u092C\u0928\u093E \u0930\u0939\u0924\u093E \u0939\u0948\u0964",
      "setting_color_highlight_once": "\u0930\u0902\u0917 \u0914\u0930 \u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0930\u0947\u0902",
      "setting_color_highlight_once_desc": "\u0926\u094B\u0928\u094B\u0902 \u092A\u093E\u0920 \u0930\u0902\u0917 \u0914\u0930 \u092A\u0943\u0937\u094D\u0920\u092D\u0942\u092E\u093F \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0907\u0928\u0932\u093E\u0907\u0928 \u0932\u093E\u0917\u0942 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u090F\u0915\u0940\u0915\u0943\u0924 \u0930\u0902\u0917 \u092A\u093F\u0915\u0930 \u0916\u094B\u0932\u0924\u093E \u0939\u0948\u0964 \u090F\u0915\u0940\u0915\u0943\u0924 \u092E\u0947\u0928\u0942 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u093E \u0939\u0948\u0964",
      "highlight_once_preview": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092A\u094D\u0930\u0940\u0935\u094D\u092F\u0942",
      "highlight_once_preview_text": "\u0926\u0947\u0916\u0947\u0902 \u0915\u093F \u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0948\u0938\u093E \u0926\u093F\u0916\u0947\u0917\u093E!",
      // Highlight Once Settings
      "highlight_once_opacity": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0913\u092A\u0947\u0938\u093F\u091F\u0940",
      "highlight_once_border_radius": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u0930\u0947\u0921\u093F\u092F\u0938 (px)",
      "reset_to_8": "\u096E \u092A\u0930 \u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      "highlight_horizontal_padding": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u094D\u0937\u0948\u0924\u093F\u091C \u092A\u0948\u0921\u093F\u0902\u0917 (px)",
      "highlight_vertical_padding": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0935\u0930\u094D\u091F\u093F\u0915\u0932 \u092A\u0948\u0921\u093F\u0902\u0917 (px)",
      "reset_to_4": "\u096A \u092A\u0930 \u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      "enable_border_highlight_once": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0947 \u0932\u093F\u090F \u092C\u0949\u0930\u094D\u0921\u0930 \u091A\u093E\u0932\u0942 \u0915\u0930\u0947\u0902",
      "enable_border_highlight_once_desc": "\u0905\u092A\u0928\u0940 \u0907\u0928\u0932\u093E\u0907\u0928 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092E\u0947\u0902 \u092C\u0949\u0930\u094D\u0921\u0930 \u091C\u094B\u0921\u093C\u0947\u0902\u0964 \u091C\u094B\u0921\u093C\u093E \u0917\u092F\u093E HTML/CSS \u0932\u0902\u092C\u093E \u0939\u094B\u0917\u093E\u0964",
      "highlight_once_border_style": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u0938\u093E\u0907\u0921\u094D\u0938",
      "highlight_once_border_line_style": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0938\u094D\u091F\u093E\u0907\u0932",
      "opt_border_full": "\u092A\u0942\u0930\u094D\u0923 \u092C\u0949\u0930\u094D\u0921\u0930 (\u0938\u092D\u0940 \u0913\u0930)",
      "opt_border_top_bottom": "\u090A\u092A\u0930 \u0914\u0930 \u0928\u0940\u091A\u0947 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_left_right": "\u092C\u093E\u090F\u0901 \u0914\u0930 \u0926\u093E\u090F\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_top_left_right": "\u090A\u092A\u0930, \u092C\u093E\u090F\u0901 \u0914\u0930 \u0926\u093E\u090F\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_bottom_left_right": "\u0928\u0940\u091A\u0947, \u092C\u093E\u090F\u0901 \u0914\u0930 \u0926\u093E\u090F\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_top_right": "\u090A\u092A\u0930 \u0914\u0930 \u0926\u093E\u090F\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_top_left": "\u090A\u092A\u0930 \u0914\u0930 \u092C\u093E\u090F\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_bottom_right": "\u0928\u0940\u091A\u0947 \u0914\u0930 \u0926\u093E\u090F\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_bottom_left": "\u0928\u0940\u091A\u0947 \u0914\u0930 \u092C\u093E\u090F\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_top": "\u0915\u0947\u0935\u0932 \u090A\u092A\u0930\u0940 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_bottom": "\u0915\u0947\u0935\u0932 \u0928\u093F\u091A\u0932\u093E \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_left": "\u0915\u0947\u0935\u0932 \u092C\u093E\u092F\u093E\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "opt_border_right": "\u0915\u0947\u0935\u0932 \u0926\u093E\u092F\u093E\u0901 \u092C\u0949\u0930\u094D\u0921\u0930",
      "highlight_once_border_opacity": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u0913\u092A\u0947\u0938\u093F\u091F\u0940",
      "highlight_once_border_thickness": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u092E\u094B\u091F\u093E\u0908 (px)",
      "reset_to_1": "1 \u092A\u0930 \u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      "use_global_highlight_style": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0947 \u0932\u093F\u090F \u0917\u094D\u0932\u094B\u092C\u0932 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u091F\u093E\u0907\u0932 \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902",
      "use_global_highlight_style_desc": "\u0906\u092A\u0915\u0940 \u0917\u094D\u0932\u094B\u092C\u0932 \u0907\u0928\u0932\u093E\u0907\u0928 \u0938\u094D\u091F\u093E\u0907\u0932 \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u091C\u094B\u0921\u093C\u093E \u0917\u092F\u093E HTML/CSS \u0932\u0902\u092C\u093E \u0939\u094B \u0938\u0915\u0924\u093E \u0939\u0948\u0964",
      "style_highlight_once": "\u090F\u0915 \u092C\u093E\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u091F\u093E\u0907\u0932 \u0915\u0930\u0947\u0902",
      "style_highlight_once_desc": "\u0906\u092A\u0915\u0940 \u0915\u0938\u094D\u091F\u092E \u0907\u0928\u0932\u093E\u0907\u0928 \u0938\u094D\u091F\u093E\u0907\u0932 \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u093E \u0939\u0948\u0964 \u091C\u094B\u0921\u093C\u093E \u0917\u092F\u093E HTML/CSS \u0932\u0902\u092C\u093E \u0939\u094B \u0938\u0915\u0924\u093E \u0939\u0948\u0964",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "\u0917\u094D\u0932\u094B\u092C\u0932 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0930\u0902\u0917\u093E\u0908 \u0938\u094D\u0935\u0930\u0942\u092A",
      "highlight_opacity": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0913\u092A\u0947\u0938\u093F\u091F\u0940",
      "highlight_opacity_desc": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0940 \u0913\u092A\u0947\u0938\u093F\u091F\u0940 \u0938\u0947\u091F \u0915\u0930\u0947\u0902 (0-100%)",
      "highlight_border_radius": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u0930\u0947\u0921\u093F\u092F\u0938 (px)",
      "highlight_border_radius_desc": "\u0917\u094B\u0932 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u094B\u0928\u094B\u0902 \u0915\u0947 \u0932\u093F\u090F \u092C\u0949\u0930\u094D\u0921\u0930 \u0930\u0947\u0921\u093F\u092F\u0938 \u0938\u0947\u091F \u0915\u0930\u0947\u0902 (px \u092E\u0947\u0902)",
      "highlight_horizontal_padding_desc": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u093F\u090F \u0917\u090F \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u0947 \u0932\u093F\u090F \u092C\u093E\u090F\u0901 \u0914\u0930 \u0926\u093E\u090F\u0901 \u092A\u0948\u0921\u093F\u0902\u0917 \u0938\u0947\u091F \u0915\u0930\u0947\u0902 (px \u092E\u0947\u0902)",
      "highlight_vertical_padding_desc": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u093F\u090F \u0917\u090F \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u0947 \u0932\u093F\u090F \u090A\u092A\u0930 \u0914\u0930 \u0928\u0940\u091A\u0947 \u0915\u0940 \u092A\u0948\u0921\u093F\u0902\u0917 (px \u092E\u0947\u0902) \u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      "rounded_corners_wrapping": "\u0932\u093E\u0907\u0928 \u0930\u0948\u092A\u093F\u0902\u0917 \u092A\u0930 \u0917\u094B\u0932 \u0915\u094B\u0928\u0947",
      "rounded_corners_wrapping_desc": "\u091C\u092C \u091A\u093E\u0932\u0942 \u0939\u094B, \u0939\u093E\u0907\u0932\u093E\u0907\u091F\u094D\u0938 \u0915\u0947 \u0938\u092D\u0940 \u0913\u0930 \u0917\u094B\u0932 \u0915\u094B\u0928\u0947 \u0939\u094B\u0902\u0917\u0947, \u092F\u0939\u093E\u0901 \u0924\u0915 \u0915\u093F \u091C\u092C \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0928\u0908 \u0932\u093E\u0907\u0928 \u092A\u0930 \u0930\u0948\u092A \u0939\u094B\u0924\u093E \u0939\u0948\u0964",
      "enable_highlight_border": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u091A\u093E\u0932\u0942 \u0915\u0930\u0947\u0902",
      "enable_highlight_border_desc": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F\u094D\u0938 \u0915\u0947 \u091A\u093E\u0930\u094B\u0902 \u0913\u0930 \u092C\u0949\u0930\u094D\u0921\u0930 \u091C\u094B\u0921\u093C\u0947\u0902\u0964 \u092C\u0949\u0930\u094D\u0921\u0930 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u092F\u093E \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0930\u0902\u0917 \u0938\u0947 \u092E\u0947\u0932 \u0916\u093E\u090F\u0917\u093E\u0964",
      "border_style": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0938\u093E\u0907\u0921\u094D\u0938",
      "border_style_desc": "\u091A\u0941\u0928\u0947\u0902 \u0915\u093F \u092C\u0949\u0930\u094D\u0921\u0930 \u0915\u093F\u0928 \u0913\u0930 \u0932\u093E\u0917\u0942 \u0915\u0930\u0928\u093E \u0939\u0948",
      "border_line_style": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0938\u094D\u091F\u093E\u0907\u0932",
      "border_line_style_desc": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0932\u093E\u0907\u0928 \u0915\u093E \u0938\u094D\u091F\u093E\u0907\u0932 \u091A\u0941\u0928\u0947\u0902",
      "border_opacity": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0913\u092A\u0947\u0938\u093F\u091F\u0940",
      "border_opacity_desc": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0915\u0940 \u0913\u092A\u0947\u0938\u093F\u091F\u0940 \u0938\u0947\u091F \u0915\u0930\u0947\u0902 (0-100%)",
      "border_thickness": "\u092C\u0949\u0930\u094D\u0921\u0930 \u092E\u094B\u091F\u093E\u0908 (px)",
      "border_thickness_desc": "\u092C\u0949\u0930\u094D\u0921\u0930 \u092E\u094B\u091F\u093E\u0908 0-5 \u092A\u093F\u0915\u094D\u0938\u0947\u0932 \u0938\u0947 \u0938\u0947\u091F \u0915\u0930\u0947\u0902 (\u091C\u0948\u0938\u0947 1, 2.5, 5)",
      "highlight_preview": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092A\u094D\u0930\u0940\u0935\u094D\u092F\u0942",
      "highlight_preview_text": "\u0926\u0947\u0916\u0947\u0902 \u0915\u093F \u0906\u092A\u0915\u093E \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u0948\u0938\u093E \u0926\u093F\u0916\u0947\u0917\u093E!",
      "opt_line_solid": "\u0920\u094B\u0938",
      "opt_line_dashed": "\u0921\u0948\u0936\u094D\u0921",
      "opt_line_dotted": "\u0921\u0949\u091F\u0947\u0921",
      "opt_line_double": "\u0921\u092C\u0932",
      "opt_line_groove": "\u0917\u094D\u0930\u0942\u0935",
      "opt_line_ridge": "\u0930\u093F\u091C",
      "opt_line_inset": "\u0907\u0928\u0938\u0947\u091F",
      "opt_line_outset": "\u0906\u0909\u091F\u0938\u0947\u091F",
      // Color Swatches
      "color_picker_layout": "\u0930\u0902\u0917 \u092A\u093F\u0915\u0930 \u0932\u0947\u0906\u0909\u091F",
      "color_picker_layout_desc": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u0947 \u0932\u093F\u090F \u0930\u0902\u0917 \u091A\u0941\u0928\u0924\u0947 \u0938\u092E\u092F \u0915\u094C\u0928 \u0938\u0947 \u0930\u0902\u0917 \u092A\u094D\u0930\u0915\u093E\u0930 \u0926\u093F\u0916\u093E\u0928\u0947 \u0939\u0948\u0902 \u091A\u0941\u0928\u0947\u0902",
      "opt_both_text_left": "\u0926\u094B\u0928\u094B\u0902: \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u092C\u093E\u090F\u0901, \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0926\u093E\u090F\u0901",
      "opt_both_bg_left": "\u0926\u094B\u0928\u094B\u0902: \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u093E\u090F\u0901, \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0926\u093E\u090F\u0901",
      "opt_both_text_top": "\u0926\u094B\u0928\u094B\u0902 (\u0935\u0930\u094D\u091F\u093F\u0915\u0932): \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u090A\u092A\u0930, \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0928\u0940\u091A\u0947",
      "opt_both_bg_top": "\u0926\u094B\u0928\u094B\u0902 (\u0935\u0930\u094D\u091F\u093F\u0915\u0932): \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u090A\u092A\u0930, \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0928\u0940\u091A\u0947",
      "opt_text_only": "\u0915\u0947\u0935\u0932 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917",
      "opt_background_only": "\u0915\u0947\u0935\u0932 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0930\u0902\u0917",
      "replace_default_swatches": "\u0921\u093F\u092B\u0949\u0932\u094D\u091F \u0938\u094D\u0935\u0948\u091A\u0947\u0938 \u092C\u0926\u0932\u0947\u0902",
      "replace_default_swatches_desc": "\u092F\u0926\u093F \u092F\u0939 \u091A\u093E\u0932\u0942 \u0939\u0948, \u0924\u094B \u0915\u0947\u0935\u0932 \u0906\u092A\u0915\u0947 \u0915\u0938\u094D\u091F\u092E \u0930\u0902\u0917 \u0939\u0940 \u0915\u0932\u0930 \u092A\u093F\u0915\u0930 \u092E\u0947\u0902 \u0926\u093F\u0916\u0947\u0902\u0917\u0947\u0964 \u0915\u094B\u0908 \u0921\u093F\u092B\u0949\u0932\u094D\u091F \u0928\u0939\u0940\u0902!",
      "enable_custom_swatches": "\u0915\u0938\u094D\u091F\u092E \u0938\u094D\u0935\u0948\u091A\u0947\u0938 \u091A\u093E\u0932\u0942 \u0915\u0930\u0947\u0902",
      "enable_custom_swatches_desc": "\u092F\u0926\u093F \u092F\u0939 \u091A\u093E\u0932\u0942 \u0939\u0948, \u0924\u094B \u0906\u092A\u0915\u0947 \u0915\u0938\u094D\u091F\u092E \u0938\u094D\u0935\u0948\u091A\u0947\u0938 \u0915\u0932\u0930 \u092A\u093F\u0915\u0930 \u092E\u0947\u0902 \u0926\u093F\u0916\u0947\u0902\u0917\u0947\u0964",
      "use_swatch_names": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917\u093E\u0908 \u0915\u0947 \u0932\u093F\u090F \u0938\u094D\u0935\u0948\u091A \u0928\u093E\u092E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902",
      "use_swatch_names_desc": "\u0936\u092C\u094D\u0926/\u092A\u0948\u091F\u0930\u094D\u0928 \u0907\u0928\u092A\u0941\u091F\u094D\u0938 \u0915\u0947 \u092C\u0917\u0932 \u092E\u0947\u0902 \u0938\u094D\u0935\u0948\u091A \u0928\u093E\u092E\u094B\u0902 \u0915\u093E \u0921\u094D\u0930\u0949\u092A\u0921\u093E\u0909\u0928 \u0926\u093F\u0916\u093E\u090F\u0901",
      "link_swatches_to_entries": "\u0938\u094D\u0935\u0948\u091A \u0905\u092A\u0921\u0947\u091F\u094D\u0938 \u0915\u094B \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917\u094B\u0902 \u0938\u0947 \u0932\u093F\u0902\u0915 \u0915\u0930\u0947\u0902",
      "link_swatches_to_entries_desc": "\u091C\u092C \u0915\u0938\u094D\u091F\u092E \u0938\u094D\u0935\u0948\u091A \u0915\u093E \u0930\u0902\u0917 \u092C\u0926\u0932\u0924\u093E \u0939\u0948, \u0909\u0938 \u0930\u0902\u0917 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0928\u0947 \u0935\u093E\u0932\u0947 \u0938\u092D\u0940 \u090F\u0902\u091F\u094D\u0930\u0940\u091C\u093C \u0905\u092A\u0921\u0947\u091F \u0915\u0930\u0947\u0902",
      "default_colors_header": "\u0921\u093F\u092B\u093C\u0949\u0932\u094D\u091F \u0928\u092E\u0942\u0928\u0947",
      "custom_swatches_header": "\u0915\u0938\u094D\u091F\u092E \u0938\u094D\u0935\u0948\u091A\u0947\u0938",
      "btn_add_color": "+ \u0930\u0902\u0917 \u091C\u094B\u0921\u093C\u0947\u0902",
      "no_custom_swatches_yet": '\u0905\u092D\u0940 \u0924\u0915 \u0915\u094B\u0908 \u0915\u0938\u094D\u091F\u092E \u0938\u094D\u0935\u0948\u091A\u0947\u0938 \u0928\u0939\u0940\u0902\u0964 \u092C\u0928\u093E\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F "+ \u0930\u0902\u0917 \u091C\u094B\u0921\u093C\u0947\u0902" \u0915\u094D\u0932\u093F\u0915 \u0915\u0930\u0947\u0902\u0964',
      "label_built_in": "(\u092C\u093F\u0932\u094D\u091F-\u0907\u0928)",
      // Color Picker
      "pick_color_header": "\u0930\u0902\u0917 \u091A\u0941\u0928\u0947\u0902",
      "selected_text_preview": "\u091A\u092F\u0928\u093F\u0924 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      "text_color_title": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917",
      "select_swatch": "\u0938\u094D\u0935\u0948\u091A \u091A\u0941\u0928\u0947\u0902\u2026",
      "highlight_color_title": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0930\u0902\u0917",
      "select_highlight_swatch": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u0935\u0948\u091A \u091A\u0941\u0928\u0947\u0902\u2026",
      "settings_tab_general": "\u0938\u093E\u092E\u093E\u0928\u094D\u092F",
      "settings_tab_colored_texts": "\u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      "settings_tab_blacklists": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F",
      "settings_tab_file_folder_rules": "\u092B\u093C\u093E\u0907\u0932 / \u092B\u093C\u094B\u0932\u094D\u0921\u0930 \u0928\u093F\u092F\u092E",
      "settings_tab_data": "\u0921\u0947\u091F\u093E",
      // Always Colored Texts
      "always_colored_texts_header": "\u0939\u092E\u0947\u0936\u093E \u0930\u0902\u0917\u0947 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      "always_colored_texts_desc": "\u092F\u0939\u093E\u0901 \u0906\u092A \u0905\u092A\u0928\u0947 \u0936\u092C\u094D\u0926/\u092A\u0948\u091F\u0930\u094D\u0928 \u0914\u0930 \u0909\u0928\u0915\u0947 \u0930\u0902\u0917 \u092A\u094D\u0930\u092C\u0902\u0927\u093F\u0924 \u0915\u0930\u0924\u0947 \u0939\u0948\u0902\u0964",
      "colored_texts_header": "\u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      "grouped_entries_header": "\u0938\u092E\u0942\u0939\u093F\u0924 \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F\u092F\u093E\u0901",
      "grouped_entries_desc": "\u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939\u094B\u0902 \u0915\u094B \u092A\u094D\u0930\u092C\u0902\u0927\u093F\u0924 \u0915\u0930\u0947\u0902\u0964 \u0916\u094B\u091C \u0928\u093E\u092E \u0915\u0947 \u0905\u0928\u0941\u0938\u093E\u0930 \u092B\u093C\u093F\u0932\u094D\u091F\u0930 \u0915\u0930\u0924\u0940 \u0939\u0948\u0964",
      "search_groups_placeholder": "\u0938\u092E\u0942\u0939 \u0916\u094B\u091C\u0947\u0902\u2026",
      "edit_word_group_modal_title": "\u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "btn_save_group": "\u0938\u092E\u0942\u0939 \u0938\u0939\u0947\u091C\u0947\u0902",
      "btn_delete_group": "\u0938\u092E\u0942\u0939 \u0939\u091F\u093E\u090F\u0901",
      "group_active_label": "\u0938\u0915\u094D\u0930\u093F\u092F",
      "group_inactive_label": "\u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F",
      "tooltip_duplicate_group": "\u0938\u092E\u0942\u0939 \u0921\u0941\u092A\u094D\u0932\u093F\u0915\u0947\u091F \u0915\u0930\u0947\u0902",
      "tooltip_edit_group_settings": "\u0938\u092E\u0942\u0939 \u0938\u0947\u091F\u093F\u0902\u0917\u094D\u0938 \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "tooltip_delete_all_groups": "\u0938\u092D\u0940 \u0936\u092C\u094D\u0926 \u0938\u092E\u0942\u0939 \u0939\u091F\u093E\u090F\u0902",
      "btn_create_new_group": "+ \u0928\u092F\u093E \u0938\u092E\u0942\u0939 \u092C\u0928\u093E\u090F\u0901",
      "no_entries_found": "\u0915\u094B\u0908 \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F\u092F\u093E\u0901 \u0928\u0939\u0940\u0902 \u092E\u093F\u0932\u0940\u0902\u0964",
      "search_colored_words_placeholder": "\u0930\u0902\u0917\u0947 \u0936\u092C\u094D\u0926/\u092A\u0948\u091F\u0930\u094D\u0928 \u0916\u094B\u091C\u0947\u0902\u2026",
      "sort_label_last-added": "\u0915\u094D\u0930\u092E: \u0905\u0902\u0924\u093F\u092E \u091C\u094B\u0921\u093C\u093E \u0939\u0941\u0906",
      "sort_label_a-z": "\u0915\u094D\u0930\u092E: A-Z",
      "sort_label_reverse-a-z": "\u0915\u094D\u0930\u092E: Z-A",
      "sort_label_style-order": "\u0915\u094D\u0930\u092E: \u0938\u094D\u091F\u093E\u0907\u0932 \u0911\u0930\u094D\u0921\u0930",
      "sort_label_color": "\u0915\u094D\u0930\u092E: \u0930\u0902\u0917",
      "btn_add_new_word": "+ \u0928\u092F\u093E \u0930\u0902\u0917\u0940\u0928 \u0936\u092C\u094D\u0926 / \u092A\u0948\u091F\u0930\u094D\u0928 \u091C\u094B\u0921\u093C\u0947\u0902",
      "style_type_text": "\u0930\u0902\u0917",
      "style_type_highlight": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F",
      "style_type_both": "\u0926\u094B\u0928\u094B\u0902",
      "word_pattern_placeholder_long": "\u092A\u0948\u091F\u0930\u094D\u0928, \u0936\u092C\u094D\u0926 \u092F\u093E \u0905\u0932\u094D\u092A\u0935\u093F\u0930\u093E\u092E \u0938\u0947 \u0905\u0932\u0917 \u0915\u093F\u090F \u0917\u090F \u0936\u092C\u094D\u0926 (\u091C\u0948\u0938\u0947 hello, world, foo)",
      "word_pattern_placeholder_short": "\u0915\u0940\u0935\u0930\u094D\u0921 \u092F\u093E \u092A\u0948\u091F\u0930\u094D\u0928, \u092F\u093E \u0905\u0932\u094D\u092A\u0935\u093F\u0930\u093E\u092E \u0938\u0947 \u0905\u0932\u0917 \u0915\u093F\u090F \u0917\u090F \u0936\u092C\u094D\u0926",
      "use_regex": "\u0930\u0947\u0917\u0947\u0915\u094D\u0938 \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0947\u0902",
      "flags_placeholder": "\u092B\u094D\u0932\u0948\u0917\u094D\u0938",
      "text_or_regex_placeholder": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F / \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u0907\u0928\u092A\u0941\u091F",
      "duplicate_entry": "\u0921\u0941\u092A\u094D\u0932\u093F\u0915\u0947\u091F \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F",
      "open_in_regex_tester": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091F\u0947\u0938\u094D\u091F\u0930 \u092E\u0947\u0902 \u0916\u094B\u0932\u0947\u0902",
      "no_rules_configured": "\u0915\u094B\u0908 \u0928\u093F\u092F\u092E \u0915\u0949\u0928\u094D\u092B\u093C\u093F\u0917\u0930 \u0928\u0939\u0940\u0902 \u0915\u093F\u090F \u0917\u090F\u0964",
      "no_rules_found": "\u0915\u094B\u0908 \u0928\u093F\u092F\u092E \u0928\u0939\u0940\u0902 \u092E\u093F\u0932\u093E\u0964",
      "match_option_exact": "\u0938\u091F\u0940\u0915",
      "match_option_contains": "\u0938\u092E\u093E\u0939\u093F\u0924",
      "match_option_starts_with": "\u0938\u0947 \u0936\u0941\u0930\u0942 \u0939\u094B\u0924\u093E \u0939\u0948",
      "match_option_ends_with": "\u092A\u0930 \u0938\u092E\u093E\u092A\u094D\u0924 \u0939\u094B\u0924\u093E \u0939\u0948",
      // Presets
      "btn_presets": "\u092A\u094D\u0930\u0940\u0938\u0947\u091F\u094D\u0938",
      "preset_all_headings": "\u0938\u092D\u0940 \u0939\u0947\u0921\u093F\u0902\u0917\u094D\u0938 (H1-H6)",
      "preset_bullet_points": "\u092C\u0941\u0932\u0947\u091F \u092A\u0949\u0907\u0902\u091F\u094D\u0938",
      "preset_numbered_lists": "\u0938\u0902\u0916\u094D\u092F\u093E\u092F\u093F\u0924 \u0938\u0942\u091A\u093F\u092F\u093E\u0901",
      "preset_task_checked": "\u091F\u093E\u0938\u094D\u0915 \u0932\u093F\u0938\u094D\u091F (\u091A\u0947\u0915 \u0915\u093F\u092F\u093E \u0939\u0941\u0906)",
      "preset_task_unchecked": "\u091F\u093E\u0938\u094D\u0915 \u0932\u093F\u0938\u094D\u091F (\u0905\u0928\u091A\u0947\u0915 \u0915\u093F\u092F\u093E \u0939\u0941\u0906)",
      "preset_dates_yyyy_mm_dd": "\u0924\u093F\u0925\u093F\u092F\u093E\u0901 (YYYY-MM-DD)",
      "preset_times_am_pm": "\u0938\u092E\u092F (AM/PM)",
      "preset_times_24h": "\u0938\u092E\u092F (24h)",
      "preset_dates_yyyy_mmm_dd": "\u0924\u093F\u0925\u093F\u092F\u093E\u0901 (YYYY-MMM-DD)",
      "preset_relative_dates": "\u0938\u093E\u092A\u0947\u0915\u094D\u0937 \u0924\u093F\u0925\u093F\u092F\u093E\u0901",
      "preset_basic_urls": "\u092C\u0947\u0938\u093F\u0915 URL",
      "preset_markdown_links": "\u092E\u093E\u0930\u094D\u0915\u0921\u093E\u0909\u0928 \u0932\u093F\u0902\u0915",
      "preset_domain_names": "\u0921\u094B\u092E\u0947\u0928 \u0928\u093E\u092E",
      "preset_email_addresses": "\u0908\u092E\u0947\u0932 \u092A\u0924\u0947",
      "preset_at_username": "@\u0909\u092A\u092F\u094B\u0917\u0915\u0930\u094D\u0924\u093E \u0928\u093E\u092E",
      "preset_currency": "\u092E\u0941\u0926\u094D\u0930\u093E",
      "preset_measurements": "\u092E\u093E\u092A",
      "preset_phone_numbers": "\u092B\u094B\u0928 \u0928\u0902\u092C\u0930",
      "preset_all_texts": "\u0938\u092D\u0940 \u091F\u0947\u0915\u094D\u0938\u094D\u091F",
      "preset_codeblocks": "\u0915\u094B\u0921 \u092C\u094D\u0932\u0949\u0915",
      "preset_inline_comments": "\u091F\u093F\u092A\u094D\u092A\u0923\u093F\u092F\u093E\u0901 (%%\u2026%%)",
      "preset_highlighted_text": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u093F\u092F\u093E \u0939\u0941\u0906 \u091F\u0947\u0915\u094D\u0938\u094D\u091F (==...==)",
      "preset_parentheses": "\u0915\u094B\u0937\u094D\u0920\u0915 ()",
      "preset_square_brackets": "\u0935\u0930\u094D\u0917 \u0915\u094B\u0937\u094D\u0920\u0915 []",
      "preset_curly_braces": "\u0918\u0941\u0902\u0918\u0930\u093E\u0932\u0947 \u092C\u094D\u0930\u0947\u0938\u0947\u0938 {}",
      "preset_angle_brackets": "\u0915\u094B\u0923 \u0915\u094B\u0937\u094D\u0920\u0915 <>",
      "preset_colons": "\u0915\u094B\u0932\u0928 :",
      "preset_double_quotes": "\u0921\u092C\u0932 \u0915\u094B\u091F\u094D\u0938",
      "preset_single_quotes": "\u0938\u093F\u0902\u0917\u0932 \u0915\u094B\u091F\u094D\u0938",
      "preset_single_quotes_word_bounded": "\u0938\u093F\u0902\u0917\u0932 \u0915\u094B\u091F\u094D\u0938 (\u0936\u092C\u094D\u0926-\u0938\u0940\u092E\u093F\u0924)",
      "preset_group_markdown_formatting": "\u092E\u093E\u0930\u094D\u0915\u0921\u093E\u0909\u0928 \u092B\u0949\u0930\u094D\u092E\u0947\u091F\u093F\u0902\u0917",
      "preset_group_other_patterns": "\u0905\u0928\u094D\u092F \u092A\u0948\u091F\u0930\u094D\u0928",
      "preset_group_brackets": "\u0915\u094B\u0937\u094D\u0920\u0915",
      // Preset Examples
      "preset_example_heading": "# \u0936\u0940\u0930\u094D\u0937\u0915",
      "preset_example_bullet": "- \u092C\u093F\u0902\u0926\u0941",
      "preset_example_numbered": "1. \u092A\u0939\u0932\u0940 \u0935\u0938\u094D\u0924\u0941",
      "preset_example_task_checked": "- [x] \u092A\u0942\u0930\u093E \u0939\u0941\u0906",
      "preset_example_task_unchecked": "- [ ] \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F",
      "preset_example_codeblock": "``` \u0915\u094B\u0921 ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[\u0932\u093F\u0902\u0915](https://example.com)",
      "preset_example_comment": "%% \u091F\u093F\u092A\u094D\u092A\u0923\u0940 %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "name@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "$29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( \u092A\u093E\u0920 )",
      "preset_example_square_brackets": "[ \u0939\u093E\u0901 ]",
      "preset_example_curly_braces": "{ \u0928\u0939\u0940\u0902 }",
      "preset_example_angle_brackets": "< \u092A\u093E\u0920 >",
      "preset_example_colons": ": \u092A\u093E\u0920 :",
      "preset_example_double_quotes": '"\u092A\u093E\u0920"',
      "preset_example_single_quotes": "'\u092A\u093E\u0920'",
      "preset_example_single_quotes_word": "'\u0936\u092C\u094D\u0926'",
      "preset_example_highlight": "==\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0915\u093F\u092F\u093E \u0939\u0941\u0906 \u091F\u0947\u0915\u094D\u0938\u094D\u091F==",
      "preset_example_all_text": "\u092F\u0939 \u0938\u092D\u0940 \u092A\u093E\u0920 \u0915\u094B \u0932\u0915\u094D\u0937\u093F\u0924 \u0915\u0930\u0947\u0917\u093E\u0964",
      // Blacklist Settings
      "blacklist_words_header": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0936\u092C\u094D\u0926",
      "blacklist_words_desc": "\u092F\u0939\u093E\u0901 \u0915\u0940\u0935\u0930\u094D\u0921 \u092F\u093E \u092A\u0948\u091F\u0930\u094D\u0928 \u0915\u092D\u0940 \u0930\u0902\u0917\u0947 \u0928\u0939\u0940\u0902 \u091C\u093E\u090F\u0901\u0917\u0947, \u092F\u0939\u093E\u0901 \u0924\u0915 \u0915\u093F \u0906\u0902\u0936\u093F\u0915 \u092E\u093F\u0932\u093E\u0928 \u0915\u0947 \u0932\u093F\u090F \u092D\u0940\u0964",
      "search_blacklist_placeholder": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F\u0947\u0921 \u0936\u092C\u094D\u0926 \u092F\u093E \u092A\u0948\u091F\u0930\u094D\u0928 \u0916\u094B\u091C\u0947\u0902\u2026",
      "blacklist_sort_label_last-added": "\u0915\u094D\u0930\u092E: \u0905\u0902\u0924\u093F\u092E \u091C\u094B\u0921\u093C\u093E \u0939\u0941\u0906",
      "blacklist_sort_label_a-z": "\u0915\u094D\u0930\u092E: A-Z",
      "blacklist_sort_label_reverse-a-z": "\u0915\u094D\u0930\u092E: Z-A",
      "btn_add_blacklist": "+ \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0936\u092C\u094D\u0926 \u092F\u093E \u092A\u0948\u091F\u0930\u094D\u0928 \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_add_to_blacklist": "+ \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u092E\u0947\u0902 \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_add_blacklist_word": "+ \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0936\u092C\u094D\u0926 \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_add_blacklist_regex": "+ \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091C\u094B\u0921\u093C\u0947\u0902",
      // File & Folder Rules
      "file_folder_rules_header": "\u092B\u093C\u093E\u0907\u0932 \u0914\u0930 \u092B\u093C\u094B\u0932\u094D\u0921\u0930 \u0930\u0902\u0917\u093E\u0908 \u0928\u093F\u092F\u092E",
      "file_folder_rules_desc": "\u0928\u093E\u092E \u092E\u093F\u0932\u093E\u0928, \u0938\u091F\u0940\u0915 \u092A\u0925 \u092F\u093E \u0930\u0947\u0917\u0947\u0915\u094D\u0938 \u092A\u0948\u091F\u0930\u094D\u0928 \u0915\u0947 \u0938\u093E\u0925 \u0930\u0902\u0917\u093E\u0908 \u0928\u093F\u092F\u0902\u0924\u094D\u0930\u093F\u0924 \u0915\u0930\u0947\u0902\u0964 \u0935\u0949\u0932\u094D\u091F-\u0935\u093E\u0907\u0921 \u0930\u0902\u0917\u093E\u0908 \u092C\u0902\u0926 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u090F\u0915 \u0916\u093E\u0932\u0940 \u092C\u0939\u093F\u0937\u094D\u0915\u0930\u0923 \u090F\u0902\u091F\u094D\u0930\u0940 \u091B\u094B\u0921\u093C\u0947\u0902\u0964",
      "search_file_folder_rules_placeholder": "\u092B\u093C\u093E\u0907\u0932/\u092B\u093C\u094B\u0932\u094D\u0921\u0930 \u0928\u093F\u092F\u092E \u0916\u094B\u091C\u0947\u0902\u2026",
      "path_sort_label_last-added": "\u0915\u094D\u0930\u092E: \u0905\u0902\u0924\u093F\u092E \u091C\u094B\u0921\u093C\u093E \u0939\u0941\u0906",
      "path_sort_label_a-z": "\u0915\u094D\u0930\u092E: A-Z",
      "path_sort_label_reverse-a-z": "\u0915\u094D\u0930\u092E: Z-A",
      "path_sort_label_mode": "\u0915\u094D\u0930\u092E: \u092E\u094B\u0921",
      "path_sort_label_type": "\u0915\u094D\u0930\u092E: \u092A\u094D\u0930\u0915\u093E\u0930",
      "btn_add_file_folder_rule": "+ \u092B\u093C\u093E\u0907\u0932/\u092B\u093C\u094B\u0932\u094D\u0921\u0930 \u0928\u093F\u092F\u092E \u091C\u094B\u0921\u093C\u0947\u0902",
      "disabled_files_header": "\u0930\u0902\u0917\u093E\u0908 \u092C\u0902\u0926 \u0915\u0940 \u0917\u0908 \u092B\u093C\u093E\u0907\u0932\u0947\u0902:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "\u0936\u093E\u092E\u093F\u0932 \u0915\u0930\u0947\u0902",
      "path_rule_mode_exclude": "\u092C\u093E\u0939\u0930 \u0915\u0930\u0947\u0902",
      "text_rule_mode_include": "\u0915\u0947\u0935\u0932 (\u0935\u094D\u0939\u093E\u0907\u091F\u0932\u093F\u0938\u094D\u091F) \u092E\u0947\u0902 \u0930\u0902\u0917 \u0915\u0930\u0947\u0902",
      "text_rule_mode_exclude": "(\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F) \u092E\u0947\u0902 \u0930\u0902\u0917 \u0928 \u0915\u0930\u0947\u0902",
      "mode_only_colors_in": "\u0915\u0947 \u092D\u0940\u0924\u0930 \u0939\u0940 \u0930\u0902\u0917 \u0915\u0930\u0924\u093E \u0939\u0948",
      "mode_does_not_color_in": "\u0915\u0947 \u092D\u0940\u0924\u0930 \u0930\u0902\u0917 \u0928\u0939\u0940\u0902 \u0915\u0930\u0924\u093E",
      "label_text_include": "\u0935\u094D\u0939\u093E\u0907\u091F\u0932\u093F\u0938\u094D\u091F",
      "label_text_exclude": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F",
      "label_enable_in": "\u092F\u0939\u093E\u0901 \u0938\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "label_disable_in": "\u092F\u0939\u093E\u0901 \u0905\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "enter_path_or_pattern": "\u092A\u0925, \u092A\u0948\u091F\u0930\u094D\u0928 \u092F\u093E \u091F\u0948\u0917 \u0926\u0930\u094D\u091C \u0915\u0930\u0947\u0902",
      "label_regex": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938",
      // Advanced Rules
      "advanced_rules_header": "\u0935\u093F\u0936\u093F\u0937\u094D\u091F \u0938\u092E\u093E\u0935\u0947\u0936\u0928/\u092C\u0939\u093F\u0937\u094D\u0915\u0930\u0923 \u0928\u093F\u092F\u092E",
      "advanced_rules_modal_header": "\u0935\u093F\u0936\u093F\u0937\u094D\u091F \u0938\u092E\u093E\u0935\u0947\u0936\u0928/\u092C\u0939\u093F\u0937\u094D\u0915\u0930\u0923 \u0928\u093F\u092F\u092E",
      "advanced_rules_manage_button": "\u0935\u093F\u0936\u093F\u0937\u094D\u091F \u0938\u092E\u093E\u0935\u0947\u0936\u0928/\u092C\u0939\u093F\u0937\u094D\u0915\u0930\u0923 \u0928\u093F\u092F\u092E \u092A\u094D\u0930\u092C\u0902\u0927\u093F\u0924 \u0915\u0930\u0947\u0902",
      "edit_rule_header": "\u0928\u093F\u092F\u092E \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "add_rule_header": "\u0928\u092F\u093E \u0928\u093F\u092F\u092E \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_add_rule": "+ \u0928\u093F\u092F\u092E \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_save_rule": "\u0928\u093F\u092F\u092E \u0938\u0939\u0947\u091C\u0947\u0902",
      "btn_add_words": "+ \u0936\u092C\u094D\u0926 \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_add_regex": "+ \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_save_regex": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u0938\u0939\u0947\u091C\u0947\u0902",
      // Regex Tester
      "regex_tester_header": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091F\u0947\u0938\u094D\u091F\u0930",
      "regex_tester_blacklist": "\u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091F\u0947\u0938\u094D\u091F\u0930 - \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F",
      "regex_expression_placeholder": "\u0905\u092A\u0928\u093E \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u0935\u094D\u092F\u0902\u091C\u0928 \u092F\u0939\u093E\u0901 \u0921\u093E\u0932\u0947\u0902",
      "regex_subject_placeholder": "\u092F\u0939\u093E\u0901 \u092A\u0930\u0940\u0915\u094D\u0937\u0923 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u091F\u093E\u0907\u092A \u0915\u0930\u0947\u0902...",
      "regex_name_placeholder": "\u0905\u092A\u0928\u0947 \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u0915\u093E \u0928\u093E\u092E \u0926\u0947\u0902",
      "matches": "\u092E\u0947\u0932",
      "matches_found": "\u092E\u0947\u0932 \u092E\u093F\u0932 \u0917\u090F",
      // Regex Flags
      "flag_g": "\u0935\u0948\u0936\u094D\u0935\u093F\u0915 \u092B\u094D\u0932\u0948\u0917: \u0938\u092D\u0940 \u092E\u0947\u0932 \u0916\u094B\u091C\u0947\u0902",
      "flag_i": "\u0915\u0947\u0938-\u0905\u0938\u0902\u0935\u0947\u0926\u0928\u0936\u0940\u0932 \u092B\u094D\u0932\u0948\u0917",
      "flag_m": "\u092E\u0932\u094D\u091F\u0940\u0932\u093E\u0907\u0928 \u092B\u094D\u0932\u0948\u0917: ^ \u0914\u0930 $ \u0932\u093E\u0907\u0928 \u0938\u0940\u092E\u093E\u0913\u0902 \u0938\u0947 \u092E\u0947\u0932 \u0916\u093E\u0924\u0947 \u0939\u0948\u0902",
      "flag_s": "dotAll \u092B\u094D\u0932\u0948\u0917: . \u0928\u0908 \u092A\u0902\u0915\u094D\u0924\u093F\u092F\u094B\u0902 \u0938\u0947 \u092E\u0947\u0932 \u0916\u093E\u0924\u093E \u0939\u0948",
      "flag_u": "\u092F\u0942\u0928\u093F\u0915\u094B\u0921 \u092B\u094D\u0932\u0948\u0917: \u092F\u0942\u0928\u093F\u0915\u094B\u0921 \u0915\u094B\u0921 \u092A\u0949\u0907\u0902\u091F\u094D\u0938 \u0915\u0947 \u0930\u0942\u092A \u092E\u0947\u0902 \u0935\u094D\u092F\u0935\u0939\u093E\u0930 \u0915\u0930\u0947\u0902",
      "flag_y": "\u0938\u094D\u091F\u093F\u0915\u0940 \u092B\u094D\u0932\u0948\u0917: lastIndex \u0938\u094D\u0925\u093F\u0924\u093F \u0938\u0947 \u092E\u0947\u0932 \u0916\u093E\u090F\u0902",
      // Data Export/Import
      "data_export_import_header": "\u0921\u0947\u091F\u093E \u0928\u093F\u0930\u094D\u092F\u093E\u0924/\u0906\u092F\u093E\u0924",
      "export_plugin_data": "\u092A\u094D\u0932\u0917\u0907\u0928 \u0921\u0947\u091F\u093E \u0928\u093F\u0930\u094D\u092F\u093E\u0924 \u0915\u0930\u0947\u0902",
      "export_plugin_data_desc": "\u0938\u0947\u091F\u093F\u0902\u0917\u094D\u0938, \u0936\u092C\u094D\u0926 \u0914\u0930 \u0928\u093F\u092F\u092E JSON \u092B\u093C\u093E\u0907\u0932 \u092E\u0947\u0902 \u0928\u093F\u0930\u094D\u092F\u093E\u0924 \u0915\u0930\u0947\u0902\u0964",
      "btn_export": "\u0928\u093F\u0930\u094D\u092F\u093E\u0924",
      "import_plugin_data": "\u092A\u094D\u0932\u0917\u0907\u0928 \u0921\u0947\u091F\u093E \u0906\u092F\u093E\u0924 \u0915\u0930\u0947\u0902",
      "import_plugin_data_desc": "JSON \u092B\u093C\u093E\u0907\u0932 \u0938\u0947 \u0938\u0947\u091F\u093F\u0902\u0917\u094D\u0938 \u0906\u092F\u093E\u0924 \u0915\u0930\u0947\u0902",
      "btn_import": "\u0906\u092F\u093E\u0924",
      "limit_input_placeholder": "\u0938\u0940\u092E\u093E",
      "limit_input_tooltip": "0=\u0938\u092C; \u0938\u0902\u0916\u094D\u092F\u093E=\u0905\u0902\u0924\u093F\u092E N; r=\u0915\u0947\u0935\u0932 \u0930\u0947\u091C\u0947\u0915\u094D\u0938; h=\u0915\u0947\u0935\u0932 \u0939\u093E\u0907\u0932\u093E\u0907\u091F; c=\u0915\u0947\u0935\u0932 \u091F\u0947\u0915\u094D\u0938\u094D\u091F; b=\u091F\u0947\u0915\u094D\u0938\u094D\u091F+\u092C\u0948\u0915\u0917\u094D\u0930\u093E\u0909\u0902\u0921; sw=\u0938\u0947 \u0936\u0941\u0930\u0942; ew=\u092A\u0930 \u0938\u092E\u093E\u092A\u094D\u0924; e=\u0938\u091F\u0940\u0915",
      // Missing Keys Added
      "highlight_styling_header": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u091F\u093E\u0907\u0932\u093F\u0902\u0917 \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "edit_entry_header": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "opt_case_sensitive": "\u0915\u0947\u0938 \u0938\u0947\u0902\u0938\u093F\u091F\u093F\u0935 \u0939\u0948",
      "opt_not_case_sensitive": "\u0915\u0947\u0938 \u0938\u0947\u0902\u0938\u093F\u091F\u093F\u0935 \u0928\u0939\u0940\u0902 \u0939\u0948",
      "opt_case_all": "\u0915\u0947\u0938 \u0938\u0947\u0902\u0938\u093F\u091F\u093F\u0935\u093F\u091F\u0940 (\u0938\u092D\u0940)",
      "opt_match_all": "\u092E\u093F\u0932\u093E\u0928 \u092A\u094D\u0930\u0915\u093E\u0930 (\u0938\u092D\u0940)",
      "edit_highlight_styling_btn": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u091F\u093E\u0907\u0932\u093F\u0902\u0917 \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "inclusion_exclusion_header": "\u0938\u092E\u093E\u0935\u0947\u0936\u0928 / \u092C\u0939\u093F\u0937\u094D\u0915\u0930\u0923 \u0928\u093F\u092F\u092E",
      "btn_save_entry": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0938\u0939\u0947\u091C\u0947\u0902",
      "edit_entry_details": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0935\u093F\u0935\u0930\u0923 \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "prompt_search_existing": "\u092E\u094C\u091C\u0942\u0926\u093E \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F\u092F\u093E\u0901 \u0916\u094B\u091C\u0947\u0902\u2026",
      "command_add_to_existing_entry": "\u092E\u094C\u091C\u0942\u0926\u093E \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u092E\u0947\u0902 \u091C\u094B\u0921\u093C\u0947\u0902",
      "context_remove_from_entry": '\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0938\u0947 "{word}" \u0939\u091F\u093E\u090F\u0901',
      "context_delete_entry": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0939\u091F\u093E\u090F\u0901",
      "btn_reset": "\u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      "btn_reset_all": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u091F\u093E\u0907\u0932 \u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      "btn_add_word": "+ \u0936\u092C\u094D\u0926 \u091C\u094B\u0921\u093C\u0947\u0902",
      "btn_add_regex_short": "+ \u0930\u0947\u091C\u0947\u0915\u094D\u0938 \u091C\u094B\u0921\u093C\u0947\u0902",
      "section_highlight_border_styling": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u0938\u094D\u091F\u093E\u0907\u0932\u093F\u0902\u0917",
      "section_highlight_styling": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u091F\u093E\u0907\u0932\u093F\u0902\u0917",
      "label_highlight_opacity": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0905\u092A\u093E\u0930\u0926\u0930\u094D\u0936\u093F\u0924\u093E",
      "label_highlight_radius": "\u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092C\u0949\u0930\u094D\u0921\u0930 \u0930\u0947\u0921\u093F\u092F\u0938",
      "label_horizontal_padding": "\u0915\u094D\u0937\u0948\u0924\u093F\u091C \u092A\u0948\u0921\u093F\u0902\u0917",
      "label_vertical_padding": "\u090A\u0930\u094D\u0927\u094D\u0935\u093E\u0927\u0930 \u092A\u0948\u0921\u093F\u0902\u0917",
      "label_enable_border": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0938\u0915\u094D\u0937\u092E \u0915\u0930\u0947\u0902",
      "label_border_sides": "\u092C\u0949\u0930\u094D\u0921\u0930 \u092A\u0915\u094D\u0937",
      "label_border_style": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0936\u0948\u0932\u0940",
      "label_border_opacity": "\u092C\u0949\u0930\u094D\u0921\u0930 \u0905\u092A\u093E\u0930\u0926\u0930\u094D\u0936\u093F\u0924\u093E",
      "label_border_thickness": "\u092C\u0949\u0930\u094D\u0921\u0930 \u092E\u094B\u091F\u093E\u0908",
      "btn_save_style": "\u0938\u094D\u091F\u093E\u0907\u0932 \u0938\u0939\u0947\u091C\u0947\u0902",
      "share_export_title": "Always Color Text export",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "Style Name",
      "preview_text": "Text",
      // Quick Colors / Styles
      "quick_actions_header": "Quick Actions",
      "quick_colors_header": "\u0924\u094D\u0935\u0930\u093F\u0924 \u0930\u0902\u0917",
      "quick_colors_desc": "\u0930\u093E\u0907\u091F-\u0915\u094D\u0932\u093F\u0915 \u092E\u0947\u0928\u0942 \u092E\u0947\u0902 \u0930\u0902\u0917 \u0926\u093F\u0916\u093E\u0915\u0930 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u094B \u091C\u0932\u094D\u0926\u0940 \u0938\u0947 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u092F\u093E \u0930\u0902\u0917\u0928\u0947 \u0915\u0940 \u0905\u0928\u0941\u092E\u0924\u093F \u0926\u0947\u0924\u093E \u0939\u0948\u0964 \u092F\u0926\u093F \u0924\u094D\u0935\u0930\u093F\u0924 \u0930\u0902\u0917 \u092C\u0902\u0926 \u0939\u0948\u0902, \u0924\u094B \u0924\u094D\u0935\u0930\u093F\u0924 \u0936\u0948\u0932\u093F\u092F\u094B\u0902 \u092E\u0947\u0902 \u092A\u094D\u0930\u0924\u093F-\u0936\u0948\u0932\u0940 \u0930\u0902\u0917\u094B\u0902 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u093F\u092F\u093E \u091C\u093E\u090F\u0917\u093E\u0964",
      "quick_colors_apply_mode_label": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917\u093E\u0908 \u0907\u0938 \u0930\u0942\u092A \u092E\u0947\u0902 \u0932\u093E\u0917\u0942 \u0939\u094B\u0917\u0940",
      "quick_colors_apply_mode_act": "\u0939\u092E\u0947\u0936\u093E \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u094B \u0930\u0902\u0917\u0947\u0902",
      "quick_colors_apply_mode_html": "\u0907\u0928\u0932\u093E\u0907\u0928 HTML",
      "quick_styles_header": "\u0924\u094D\u0935\u0930\u093F\u0924 \u0936\u0948\u0932\u093F\u092F\u093E\u0901",
      "quick_styles_desc": "\u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0930\u0902\u0917 \u0914\u0930 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0932\u093E\u0917\u0942 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0928\u093E\u092E\u093F\u0924 \u0936\u0948\u0932\u093F\u092F\u093E\u0901 \u092A\u0930\u093F\u092D\u093E\u0937\u093F\u0924 \u0915\u0930\u0947\u0902\u0964 \u092F\u0926\u093F \u0924\u094D\u0935\u0930\u093F\u0924 \u0930\u0902\u0917 \u092C\u0902\u0926 \u0939\u0948\u0902, \u0924\u094B \u092F\u0939\u093E\u0902 \u092A\u094D\u0930\u0924\u093F-\u0936\u0948\u0932\u0940 \u0930\u0902\u0917\u094B\u0902 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u093F\u092F\u093E \u091C\u093E\u090F\u0917\u093E\u0964",
      "btn_add_style": "+ \u0936\u0948\u0932\u0940 \u091C\u094B\u0921\u093C\u0947\u0902",
      "quick_styles_menu_option": "\u0924\u094D\u0935\u0930\u093F\u0924 \u0936\u0948\u0932\u093F\u092F\u093E\u0901",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F\u092F\u093E\u0901",
      "show_blacklist_groups_in_commands": "\u0915\u092E\u093E\u0902\u0921 \u092E\u0947\u0902 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0926\u093F\u0916\u093E\u090F\u0902",
      "show_blacklist_groups_in_commands_desc": "\u0938\u0915\u094D\u0937\u092E \u0939\u094B\u0928\u0947 \u092A\u0930, \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0915\u092E\u093E\u0902\u0921 \u092A\u0948\u0932\u0947\u091F \u092E\u0947\u0902 \u0938\u0915\u094D\u0930\u093F\u092F/\u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u0915\u0930\u0947\u0902 \u0915\u092E\u093E\u0902\u0921 \u0915\u0947 \u0938\u093E\u0925 \u0926\u093F\u0916\u093E\u0908 \u0926\u0947\u0924\u0947 \u0939\u0948\u0902\u0964",
      "search_blacklist_groups_placeholder": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939\u094B\u0902 \u0915\u094B \u0916\u094B\u091C\u0947\u0902\u2026",
      "btn_create_new_blacklist_group": "+ \u0928\u092F\u093E \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u092C\u0928\u093E\u090F\u0902",
      "edit_blacklist_group_modal_title": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "tooltip_delete_all_blacklist_groups": "\u0938\u092D\u0940 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939\u094B\u0902 \u0915\u094B \u0939\u091F\u093E\u090F\u0902",
      "confirm_delete_all_blacklist_groups_title": "\u0938\u092D\u0940 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939\u094B\u0902 \u0915\u094B \u0939\u091F\u093E\u090F\u0902",
      "confirm_delete_all_blacklist_groups_desc": "\u0915\u094D\u092F\u093E \u0906\u092A \u0938\u092D\u0940 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939\u094B\u0902 \u0915\u094B \u0939\u091F\u093E\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902? \u092F\u0939 \u092A\u0942\u0930\u094D\u0935\u0935\u0924 \u0928\u0939\u0940\u0902 \u0915\u093F\u092F\u093E \u091C\u093E \u0938\u0915\u0924\u093E!",
      "confirm_delete_blacklist_group_title": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0939\u091F\u093E\u090F\u0902",
      "confirm_delete_blacklist_group_desc": "\u0915\u094D\u092F\u093E \u0906\u092A \u0907\u0938 \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0915\u094B \u0939\u091F\u093E\u0928\u093E \u091A\u093E\u0939\u0924\u0947 \u0939\u0948\u0902? \u092F\u0939 \u092A\u0942\u0930\u094D\u0935\u0935\u0924 \u0928\u0939\u0940\u0902 \u0915\u093F\u092F\u093E \u091C\u093E \u0938\u0915\u0924\u093E\u0964",
      "notice_blacklist_group_activated": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0938\u0915\u094D\u0930\u093F\u092F \u0915\u093F\u092F\u093E \u0917\u092F\u093E",
      "notice_blacklist_group_deactivated": "\u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u0915\u093F\u092F\u093E \u0917\u092F\u093E",
      "command_activate_blacklist_group": "{groupName} \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0938\u0915\u094D\u0930\u093F\u092F \u0915\u0930\u0947\u0902",
      "command_deactivate_blacklist_group": "{groupName} \u092C\u094D\u0932\u0948\u0915\u0932\u093F\u0938\u094D\u091F \u0938\u092E\u0942\u0939 \u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u0915\u0930\u0947\u0902",
      "btn_duplicate_entry": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0915\u094B \u0921\u0941\u092A\u094D\u0932\u093F\u0915\u0947\u091F \u0915\u0930\u0947\u0902",
      "btn_open_in_regex_tester": "Regex Tester \u092E\u0947\u0902 \u0916\u094B\u0932\u0947\u0902",
      "move_to_blacklist_group": "\u0915\u093E\u0932\u0940 \u0938\u0942\u091A\u0940 \u0938\u092E\u0942\u0939 \u0915\u094B \u0938\u094D\u0925\u093E\u0928\u093E\u0902\u0924\u0930\u093F\u0924 \u0915\u0930\u0947\u0902",
      "btn_delete_entry": "\u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F \u0939\u091F\u093E\u090F\u0902",
      "edit_group_highlight_styling": "\u0938\u092E\u0942\u0939 \u0939\u093E\u0907\u0932\u093E\u0907\u091F \u0938\u094D\u091F\u093E\u0907\u0932 \u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      "light_mode_fixer_desc": "\u0926\u0943\u0936\u094D\u092F\u0924\u093E \u092E\u0947\u0902 \u0938\u0941\u0927\u093E\u0930 \u0915\u0947 \u0932\u093F\u090F \u0932\u093E\u0907\u091F \u0925\u0940\u092E \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u0947 \u0938\u092E\u092F \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u094B \u0938\u094D\u0935\u091A\u093E\u0932\u093F\u0924 \u0930\u0942\u092A \u0938\u0947 \u0917\u0939\u0930\u093E \u0915\u0930\u0924\u093E \u0939\u0948\u0964",
      "dark_mode_fixer_desc": "\u0926\u0943\u0936\u094D\u092F\u0924\u093E \u092E\u0947\u0902 \u0938\u0941\u0927\u093E\u0930 \u0915\u0947 \u0932\u093F\u090F \u0921\u093E\u0930\u094D\u0915 \u0925\u0940\u092E \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u0947 \u0938\u092E\u092F \u0930\u0902\u0917\u0940\u0928 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0915\u094B \u0938\u094D\u0935\u091A\u093E\u0932\u093F\u0924 \u0930\u0942\u092A \u0938\u0947 \u0939\u0932\u094D\u0915\u093E \u0915\u0930\u0924\u093E \u0939\u0948\u0964",
      "preset_bold": "\u092C\u094B\u0932\u094D\u0921",
      "preset_italic": "\u0907\u091F\u093E\u0932\u093F\u0915",
      "preset_bold_italic": "\u092C\u094B\u0932\u094D\u0921 \u0907\u091F\u093E\u0932\u093F\u0915"
    };
  }
});

// src/i18n/it.js
var require_it = __commonJS({
  "src/i18n/it.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "Italiano",
      "settings_title": "Impostazioni Always Color Text",
      "header_plugin_name": "Always Color Text",
      "ribbon_title": "Always Color Text",
      // Language Settings
      "language_label": "Lingua",
      "language_desc": "Seleziona la lingua da utilizzare in questo plugin",
      "language_en": "Inglese",
      "language_es": "Spagnolo",
      "language_fr": "Francese",
      "language_eu": "Basco",
      "language_ru": "Russo",
      "language_auto": "Predefinito di sistema",
      "default": "Predefinito",
      // Release Notes
      "latest_release_notes_label": "Note di rilascio pi\xF9 recenti",
      "latest_release_notes_desc": "Visualizza le note di rilascio pi\xF9 recenti del plugin",
      "open_changelog_button": "Apri changelog",
      "command_show_release_notes": "Mostra note di rilascio pi\xF9 recenti",
      "changelog_view_on_github": "Visualizza su GitHub",
      "changelog_loading": "Caricamento rilasci\u2026",
      "changelog_no_info": "Nessuna informazione di rilascio disponibile.",
      "changelog_release": "Rilascio",
      "changelog_no_notes": "Nessuna nota",
      "changelog_failed_to_load": "Caricamento note di rilascio fallito.",
      // UI Elements & Menus
      "file_menu_enable": "Abilita Always Color Text per questo file",
      "file_menu_disable": "Disabilita Always Color Text per questo file",
      "menu_color_once": "Colora una volta",
      "menu_highlight_once": "Evidenzia una volta",
      "menu_color_highlight_once": "Colore / Evidenzia una volta",
      "menu_remove_inline_color": "Rimuovi Colore Inline",
      "menu_always_color_text": "Always Color Text",
      "menu_remove_always_color_text": "Rimuovi Always Color Text",
      "menu_blacklist_word": "Aggiungi parola alla blacklist",
      "show_toggle_statusbar": "Mostra toggle nella barra di stato",
      "show_toggle_ribbon": "Mostra icona toggle nel ribbon",
      "show_toggle_command": "Mostra toggle nei comandi",
      "menu_options_header": "Opzioni menu",
      "show_blacklist_menu": 'Mostra "Parola in blacklist" nel menu tasto destro',
      "show_blacklist_menu_desc": "Aggiunge una voce nel menu tasto destro per mettere in blacklist il testo selezionato dalla colorazione.",
      "show_add_to_existing_menu": 'Mostra "Aggiungi a voce esistente" nel menu tasto destro',
      "show_add_to_existing_menu_desc": "Aggiunge una voce nel menu tasto destro per aggiungere il testo selezionato a una voce esistente.",
      "show_always_color_text_menu": 'Mostra "Always Color Text" nel menu tasto destro',
      "show_always_color_text_menu_desc": "Aggiunge una voce nel menu tasto destro per colorare il testo selezionato.",
      "hide_inactive_groups_in_dropdowns": "Nascondi gruppi inattivi nei menu a discesa",
      "hide_inactive_groups_in_dropdowns_desc": "Nasconde i gruppi di parole inattivi quando si visualizzano gli elenchi di gruppi nei menu a discesa.",
      "show_word_groups_in_commands": "Mostra gruppi di parole nei comandi",
      "show_word_groups_in_commands_desc": "Quando abilitato, i gruppi di parole appaiono nella palette dei comandi con comandi Attiva/Disattiva.",
      "tooltip_enable_for_file": "Abilita per questo file",
      "tooltip_delete_all_words": "Elimina tutte le parole/pattern definiti",
      "tooltip_delete_all_blacklist": "Elimina tutte le parole/pattern in blacklist",
      "tooltip_use_regex": "Usa come pattern regex",
      "drag_to_reorder": "Trascina per riordinare",
      "reset_text_color": "Ripristina colore del testo",
      "reset_highlight": "Ripristina evidenziazione",
      // Commands
      "command_color_selected": "Colora testo selezionato",
      "command_toggle_current": "Abilita/Disabilita colorazione per il documento corrente",
      "command_enable_current": "Abilita colorazione per il documento corrente",
      "command_disable_current": "Disabilita colorazione per il documento corrente",
      "command_toggle_global": "Abilita/Disabilita colorazione globale",
      "command_enable_global": "Abilita colorazione globale",
      "command_disable_global": "Disabilita colorazione globale",
      "enable_document_color": "Abilita colore globale",
      "color_swatches_header": "Gestione colori",
      "color_rendering_header": "Resa cromatica e prestazioni",
      "theme_support_header": "Supporto temi",
      "matching_behavior_header": "Comportamento di corrispondenza",
      "smart_update_mode": "Aggiornamenti intelligenti (Sperimentale)",
      "smart_update_mode_desc": "Aggiorna la colorazione solo per la riga attiva durante la digitazione e blocca le altre righe per migliorare le prestazioni.",
      "light_mode_fixer": "Correttore colore testo modalit\xE0 chiara",
      "dark_mode_fixer": "Correttore colore testo modalit\xE0 scura",
      "command_manage_advanced_rules": "gestisci regole specifiche di inclusione/esclusione",
      "command_open_regex_tester": "Aggiungi Regex (Apri Tester Regex)",
      "command_open_blacklist_regex_tester": "Aggiungi Regex alla Lista Nera",
      "command_manage_colored_texts": "Gestisci testi colorati",
      "command_toggle_hide_text_colors": "Nascondi/Mostra colori del testo",
      "command_toggle_hide_highlights": "Nascondi/Mostra evidenziazioni",
      "command_hide_text_colors": "Nascondi colori del testo",
      "command_unhide_text_colors": "Mostra colori del testo",
      "command_hide_highlights": "Nascondi evidenziazioni",
      "command_unhide_highlights": "Mostra evidenziazioni",
      "command_enable_lightweight_mode": "Abilita modalit\xE0 leggera",
      "command_disable_lightweight_mode": "Disabilita modalit\xE0 leggera",
      "command_color_highlight_once": "Colora / Evidenzia testo selezionato (una volta)",
      "notice_select_text_first_once": "Seleziona prima del testo da colorare.",
      "command_activate_word_group": "Attiva il gruppo di parole {groupName}",
      "command_deactivate_word_group": "Disattiva il gruppo di parole {groupName}",
      // Notifications
      "notice_lightweight_mode_enabled": "Modalit\xE0 leggera attivata",
      "notice_lightweight_mode_disabled": "Modalit\xE0 leggera disattivata",
      "notice_enabled": "Always Color Text abilitato",
      "notice_disabled": "Always Color Text disabilitato",
      "notice_blacklisted_cannot_color": '"{word}" \xE8 in blacklist e non pu\xF2 essere colorata.',
      "notice_removed_always_color": 'Rimossa colorazione permanente per "{word}".',
      "notice_added_to_blacklist": '"{word}" aggiunta alla blacklist.',
      "notice_already_blacklisted": '"{word}" \xE8 gi\xE0 in blacklist.',
      "notice_select_text_first": "Seleziona prima del testo da colorare.",
      "notice_no_active_file": "Nessun file attivo per attivare/disattivare la colorazione.",
      "notice_coloring_enabled_for_path": "Colorazione abilitata per {path}",
      "notice_coloring_disabled_for_path": "Colorazione disabilitata per {path}",
      "notice_global_enabled": "Always Color Text abilitato",
      "notice_global_disabled": "Always Color Text disabilitato",
      "notice_unable_open_changelog": "Impossibile aprire la finestra del changelog.",
      "notice_pattern_blocked": "Pattern bloccato per sicurezza memoria:",
      "notice_pattern_too_complex": "Pattern troppo complesso:",
      "notice_invalid_hex_format": "Formato colore esadecimale non valido. Usa #RRGGBB o #RGB.",
      "notice_error_saving_changes": "Errore nel salvare le modifiche. Riprova.",
      "notice_invalid_color_format": "Formato colore non valido.",
      "notice_exported": "Esportato: {fname}",
      "notice_export_failed": "Esportazione fallita",
      "notice_import_completed": "Importazione completata",
      "notice_import_failed": "Importazione fallita",
      "notice_invalid_regex": "Espressione regolare non valida",
      "notice_empty_pattern": "Il modello \xE8 vuoto",
      "notice_added_regex": "Espressione regolare aggiunta",
      "notice_rule_updated": "Regola aggiornata",
      "notice_regex_updated": "Espressione regolare aggiornata",
      "notice_entry_updated": "Voce aggiornata",
      "notice_entry_duplicated": "Voce duplicata",
      "notice_error_opening_regex_tester": "Errore nell'apertura del tester regex",
      "notice_error_opening_blacklist_regex_tester": "Errore nell'apertura del tester regex della lista nera",
      "notice_error_opening_advanced_rules": "Errore nell'apertura della finestra delle regole avanzate",
      "notice_text_color_reset": "Colore del testo ripristinato",
      "notice_highlight_reset": "Evidenziazione ripristinata",
      "notice_text_colors_hidden": "Colori del testo nascosti",
      "notice_text_colors_visible": "Colori del testo visibili",
      "notice_highlights_hidden": "Evidenziazioni nascoste",
      "notice_highlights_visible": "Evidenziazioni visibili",
      "notice_regex_support_disabled": "Il supporto regex \xE8 disabilitato. Abilitalo nelle impostazioni per utilizzare i pattern regex.",
      "notice_no_active_file_to_disable": "Nessun file attivo per disabilitare la colorazione.",
      "notice_already_disabled_for_path": "La colorazione \xE8 gi\xE0 disabilitata per {path}",
      "notice_filter_disabled": "Filtro disabilitato",
      // Confirmation Dialogs
      "confirm_delete_all_title": "Elimina tutte le parole",
      "confirm_delete_all_desc": "Sei sicuro di voler eliminare tutte le tue parole/pattern colorati? Non potrai annullare questa azione!",
      "confirm_delete_all_blacklist_title": "Elimina tutte le parole in blacklist",
      "confirm_delete_all_blacklist_desc": "Sei sicuro di voler eliminare TUTTE le voci della blacklist? Non potrai annullare questa azione!",
      "confirm_delete_all_groups_title": "Elimina tutti i gruppi di parole",
      "confirm_delete_all_groups_desc": "Sei sicuro di voler eliminare TUTTI i gruppi di parole? Non potrai annullare questa azione!",
      "restart_required_title": "Riavvio richiesto",
      "restart_required_desc": "Disabilitare il toggle della palette comandi richiede il riavvio di Obsidian per rimuovere completamente i comandi dalla palette. Riavviare ora?",
      // Basic Settings
      "color_in_live_preview_mode": "Colore in modalit\xE0 anteprima live",
      "color_in_reading_mode": "Colora in modalit\xE0 lettura",
      "force_full_render_reading": "Forza rendering completo in modalit\xE0 lettura",
      "force_full_render_reading_desc": "Se attivo, la modalit\xE0 lettura tenter\xE0 di colorare l'intero documento in una sola passata. Pu\xF2 causare problemi di prestazioni su documenti grandi. Usare con cautela!",
      "lightweight_mode": "Modalit\xE0 leggera (Sperimentale)",
      "lightweight_mode_desc": "Riduce notevolmente l'elaborazione durante la digitazione. Potrebbe saltare alcune corrispondenze.",
      "disable_coloring_current_file": "Disabilita colorazione per file corrente",
      "disable_coloring_current_file_desc": "Aggiunge una regola di esclusione per il file attivo sotto regole colorazione file e cartelle.",
      "btn_disable_for_this_file": "Disabilita per questo file",
      // Coloring Settings
      "coloring_settings_header": "Impostazioni colorazione",
      "regex_support": "Supporto regex",
      "regex_support_desc": "Permetti ai pattern di essere espressioni regolari. Le regex non valide vengono ignorate per sicurezza.",
      "disable_regex_safety": "Disabilita sicurezza regex",
      "disable_regex_safety_desc": "Permetti espressioni complesse o potenzialmente pericolose. Pu\xF2 causare problemi di prestazioni o blocchi.",
      "case_sensitive": "Distingui maiuscole/minuscole",
      "case_sensitive_desc": 'Se attivo, "word" e "Word" sono trattati come diversi. Se disattivo, sono colorati allo stesso modo.',
      "partial_match": "Corrispondenza parziale",
      "partial_match_desc": `Se abilitato, l'intera parola sar\xE0 colorata se viene trovata al suo interno una parola colorata (es. "as" colora "Jasper").`,
      // One-Time Actions
      "one_time_actions_header": "Azioni una tantum",
      "setting_color_once": "Colora una volta",
      "setting_color_once_desc": "Inserisce HTML inline per il testo selezionato. Persiste anche se il plugin \xE8 disattivato.",
      "setting_highlight_once": "Evidenzia una volta",
      "setting_highlight_once_desc": "Inserisce HTML inline con stile di sfondo. Persiste anche se il plugin \xE8 disattivato.",
      "setting_color_highlight_once": "Colore e Evidenzia una volta",
      "setting_color_highlight_once_desc": "Apre il selettore di colori unificato per applicare sia il colore del testo che l'evidenziazione dello sfondo in linea. Utilizza il menu unificato.",
      "highlight_once_preview": "Anteprima evidenziazione una volta",
      "highlight_once_preview_text": "Ecco come apparir\xE0 l'evidenziazione!",
      // Highlight Once Settings
      "highlight_once_opacity": "Opacit\xE0 evidenziazione una volta",
      "highlight_once_border_radius": "Raggio bordo evidenziazione una volta (px)",
      "reset_to_8": "Reimposta a 8",
      "highlight_horizontal_padding": "Spaziatura orizzontale evidenziazione (px)",
      "highlight_vertical_padding": "Spaziatura verticale evidenziazione (px)",
      "reset_to_4": "Reimposta a 4",
      "enable_border_highlight_once": "Abilita bordo per evidenziazione una volta",
      "enable_border_highlight_once_desc": "Aggiungi un bordo all'evidenziazione inline. L'HTML/CSS generato pu\xF2 essere lungo.",
      "highlight_once_border_style": "Lati del bordo per evidenziazione una volta",
      "highlight_once_border_line_style": "Stile bordo",
      "opt_border_full": "Bordo completo (tutti i lati)",
      "opt_border_top_bottom": "Bordi superiore e inferiore",
      "opt_border_left_right": "Bordi sinistro e destro",
      "opt_border_top_left_right": "Bordi superiore, sinistro e destro",
      "opt_border_bottom_left_right": "Bordi inferiore, sinistro e destro",
      "opt_border_top_right": "Bordi superiore e destro",
      "opt_border_top_left": "Bordi superiore e sinistro",
      "opt_border_bottom_right": "Bordi inferiore e destro",
      "opt_border_bottom_left": "Bordi inferiore e sinistro",
      "opt_border_top": "Solo bordo superiore",
      "opt_border_bottom": "Solo bordo inferiore",
      "opt_border_left": "Solo bordo sinistro",
      "opt_border_right": "Solo bordo destro",
      "highlight_once_border_opacity": "Opacit\xE0 bordo evidenziazione una volta",
      "highlight_once_border_thickness": "Spessore bordo evidenziazione una volta (px)",
      "reset_to_1": "Reimposta a 1",
      "use_global_highlight_style": "Usa stile evidenziazione globale per evidenzia una volta",
      "use_global_highlight_style_desc": "Utilizza il tuo stile inline globale. L'HTML/CSS generato potrebbe essere lungo.",
      "style_highlight_once": "Stile evidenzia una volta",
      "style_highlight_once_desc": "Utilizza il tuo stile inline personalizzato. L'HTML/CSS generato potrebbe essere lungo.",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "Aspetto globale evidenziazione colorata",
      "highlight_opacity": "Opacit\xE0 evidenziazione",
      "highlight_opacity_desc": "Imposta l'opacit\xE0 dell'evidenziazione (0-100%)",
      "highlight_border_radius": "Raggio bordo evidenziazione (px)",
      "highlight_border_radius_desc": "Imposta il raggio del bordo (in px) per angoli arrotondati dell'evidenziazione",
      "highlight_horizontal_padding_desc": "Imposta la spaziatura sinistra e destra (in px) per il testo evidenziato",
      "highlight_vertical_padding_desc": "Imposta la spaziatura superiore e inferiore (in px) per il testo evidenziato",
      "rounded_corners_wrapping": "Angoli arrotondati sull'a capo",
      "rounded_corners_wrapping_desc": "Se abilitato, le evidenziazioni avranno angoli arrotondati su tutti i lati, anche quando il testo va a capo.",
      "enable_highlight_border": "Abilita bordo evidenziazione",
      "enable_highlight_border_desc": "Aggiungi un bordo attorno alle evidenziazioni. Il bordo corrisponder\xE0 al colore del testo o dell'evidenziazione.",
      "border_style": "Lati del bordo",
      "border_style_desc": "Scegli quali lati applicare il bordo",
      "border_line_style": "Stile bordo",
      "border_line_style_desc": "Scegli lo stile della linea del bordo",
      "border_opacity": "Opacit\xE0 bordo",
      "border_opacity_desc": "Imposta l'opacit\xE0 del bordo (0-100%)",
      "border_thickness": "Spessore bordo (px)",
      "border_thickness_desc": "Imposta lo spessore del bordo da 0-5 pixel (es. 1, 2.5, 5)",
      "highlight_preview": "Anteprima evidenziazione",
      "highlight_preview_text": "Ecco come apparir\xE0 la tua evidenziazione!",
      "opt_line_solid": "pieno",
      "opt_line_dashed": "tratteggiato",
      "opt_line_dotted": "puntinato",
      "opt_line_double": "doppio",
      "opt_line_groove": "scanalato",
      "opt_line_ridge": "rilievo",
      "opt_line_inset": "incassato",
      "opt_line_outset": "sporgente",
      // Color Swatches
      "color_picker_layout": "Layout selettore colore",
      "color_picker_layout_desc": "Scegli quali tipi di colore mostrare quando si selezionano colori per il testo",
      "opt_both_text_left": "Entrambi: Testo sinistra, Evidenziazione destra",
      "opt_both_bg_left": "Entrambi: Evidenziazione sinistra, Testo destra",
      "opt_both_text_top": "Entrambi (verticale): Testo sopra, Evidenziazione sotto",
      "opt_both_bg_top": "Entrambi (verticale): Evidenziazione sopra, Testo sotto",
      "opt_text_only": "Solo colore testo",
      "opt_background_only": "Solo colore evidenziazione",
      "replace_default_swatches": "Sostituisci campioni predefiniti",
      "replace_default_swatches_desc": "Se attivo, nel selettore colori appariranno solo i tuoi colori personalizzati. Nessuno predefinito!",
      "enable_custom_swatches": "Abilita campioni personalizzati",
      "enable_custom_swatches_desc": "Se attivo, i tuoi campioni personalizzati appariranno nel selettore colori.",
      "use_swatch_names": "Usa nomi campioni per colorare il testo",
      "use_swatch_names_desc": "Mostra un menu a tendina con i nomi dei campioni accanto ai campi di inserimento parole/pattern",
      "link_swatches_to_entries": "Collega aggiornamenti dei campioni ai colori del testo",
      "link_swatches_to_entries_desc": "Quando cambia il colore di un campione personalizzato, aggiorna tutte le voci che usano quel colore",
      "default_colors_header": "Campioni predefiniti",
      "custom_swatches_header": "Campioni personalizzati",
      "btn_add_color": "+ Aggiungi colore",
      "no_custom_swatches_yet": 'Ancora nessun campione personalizzato. Clicca "+ Aggiungi colore" per crearne uno.',
      "label_built_in": "(integrato)",
      // Color Picker
      "pick_color_header": "Seleziona colore",
      "selected_text_preview": "Testo selezionato",
      "text_color_title": "Colore testo",
      "select_swatch": "Seleziona campione\u2026",
      "highlight_color_title": "Colore evidenziazione",
      "select_highlight_swatch": "Seleziona campione evidenziazione\u2026",
      "settings_tab_general": "Generale",
      "settings_tab_colored_texts": "Testi colorati",
      "settings_tab_blacklists": "Liste nere",
      "settings_tab_file_folder_rules": "Regole File / Cartella",
      "settings_tab_data": "Dati",
      // Always Colored Texts
      "always_colored_texts_header": "Testi sempre colorati",
      "always_colored_texts_desc": "Qui gestisci le tue parole/pattern e i loro colori.",
      "colored_texts_header": "Testi colorati",
      "grouped_entries_header": "Voci raggruppate",
      "grouped_entries_desc": "Gestisci gruppi di parole. La ricerca filtra per nome.",
      "search_groups_placeholder": "Cerca gruppi\u2026",
      "edit_word_group_modal_title": "Modifica gruppo di parole",
      "btn_save_group": "Salva gruppo",
      "btn_delete_group": "Elimina gruppo",
      "group_active_label": "Attivo",
      "group_inactive_label": "Inattivo",
      "tooltip_duplicate_group": "Duplica gruppo",
      "tooltip_edit_group_settings": "Modifica impostazioni del gruppo",
      "tooltip_delete_all_groups": "Elimina tutti i gruppi di parole",
      "btn_create_new_group": "+ Crea nuovo gruppo",
      "no_entries_found": "Nessuna voce trovata.",
      "search_colored_words_placeholder": "Cerca parole/pattern colorati\u2026",
      "sort_label_last-added": "Ordina: ultimi aggiunti",
      "sort_label_a-z": "Ordina: A-Z",
      "sort_label_reverse-a-z": "Ordina: Z-A",
      "sort_label_style-order": "Ordina: ordine stile",
      "sort_label_color": "Ordina: colore",
      "btn_add_new_word": "+ Aggiungi nuova parola/pattern colorato",
      "style_type_text": "colore",
      "style_type_highlight": "evidenziazione",
      "style_type_both": "entrambi",
      "word_pattern_placeholder_long": "pattern, parola o parole separate da virgola (es. hello, world, foo)",
      "word_pattern_placeholder_short": "Parola chiave o pattern, o parole separate da virgola",
      "use_regex": "Usa regex",
      "flags_placeholder": "flag",
      "text_or_regex_placeholder": "input di testo/regex",
      "duplicate_entry": "voce duplicata",
      "open_in_regex_tester": "Apri in Tester Regex",
      "no_rules_configured": "Nessuna regola configurata.",
      "no_rules_found": "Nessuna regola trovata.",
      "match_option_exact": "esatto",
      "match_option_contains": "contiene",
      "match_option_starts_with": "inizia con",
      "match_option_ends_with": "finisce con",
      // Presets
      "btn_presets": "Preset",
      "preset_all_headings": "Tutti i titoli (H1-H6)",
      "preset_bullet_points": "Punti elenco",
      "preset_numbered_lists": "Elenchi numerati",
      "preset_task_checked": "Elenco attivit\xE0 (selezionato)",
      "preset_task_unchecked": "Elenco attivit\xE0 (non selezionato)",
      "preset_dates_yyyy_mm_dd": "Date (AAAA-MM-GG)",
      "preset_times_am_pm": "Orari (AM/PM)",
      "preset_times_24h": "Orari (24h)",
      "preset_dates_yyyy_mmm_dd": "Date (AAAA-MMM-GG)",
      "preset_relative_dates": "Date relative",
      "preset_basic_urls": "URL di base",
      "preset_markdown_links": "Link Markdown",
      "preset_domain_names": "Nomi di dominio",
      "preset_email_addresses": "Indirizzi email",
      "preset_at_username": "@nome utente",
      "preset_currency": "Valuta",
      "preset_measurements": "Misurazioni",
      "preset_phone_numbers": "Numeri di telefono",
      "preset_all_texts": "Tutti i testi",
      "preset_codeblocks": "Blocchi di codice",
      "preset_inline_comments": "Commenti (%%\u2026%%)",
      "preset_highlighted_text": "Testo evidenziato (==...==)",
      "preset_parentheses": "Parentesi ()",
      "preset_square_brackets": "Parentesi quadre []",
      "preset_curly_braces": "Parentesi graffe {}",
      "preset_angle_brackets": "Parentesi angolari <>",
      "preset_colons": "Due punti :",
      "preset_double_quotes": "Virgolette",
      "preset_single_quotes": "Virgolette singole",
      "preset_single_quotes_word_bounded": "Virgolette singole (delimitate da parola)",
      "preset_group_markdown_formatting": "Formattazione Markdown",
      "preset_group_other_patterns": "Altri Pattern",
      "preset_group_brackets": "Parentesi",
      // Preset Examples
      "preset_example_heading": "# Titolo",
      "preset_example_bullet": "- Punto elenco",
      "preset_example_numbered": "1. Primo elemento",
      "preset_example_task_checked": "- [x] Completato",
      "preset_example_task_unchecked": "- [ ] Da fare",
      "preset_example_codeblock": "``` codice ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[Link](https://example.com)",
      "preset_example_comment": "%% commento %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "nome@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "\u20AC29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( testo )",
      "preset_example_square_brackets": "[ s\xEC ]",
      "preset_example_curly_braces": "{ no }",
      "preset_example_angle_brackets": "< testo >",
      "preset_example_colons": ": testo :",
      "preset_example_double_quotes": '"testo"',
      "preset_example_single_quotes": "'testo'",
      "preset_example_single_quotes_word": "'parola'",
      "preset_example_highlight": "==testo evidenziato==",
      "preset_example_all_text": "Questo selezioner\xE0 tutto il testo.",
      // Blacklist Settings
      "blacklist_words_header": "Parole in blacklist",
      "blacklist_words_desc": "Parole chiave o pattern qui non saranno mai colorati, nemmeno per corrispondenze parziali.",
      "search_blacklist_placeholder": "Cerca parole o pattern in blacklist\u2026",
      "blacklist_sort_label_last-added": "Ordina: ultimi aggiunti",
      "blacklist_sort_label_a-z": "Ordina: A-Z",
      "blacklist_sort_label_reverse-a-z": "Ordina: Z-A",
      "btn_add_blacklist": "+ Aggiungi parola o pattern in blacklist",
      "btn_add_to_blacklist": "+ Aggiungi a lista nera",
      "btn_add_blacklist_word": "+ Aggiungi parola lista nera",
      "btn_add_blacklist_regex": "+ Aggiungi regex lista nera",
      // File & Folder Rules
      "file_folder_rules_header": "Regole colorazione file e cartelle",
      "file_folder_rules_desc": "Gestisci la colorazione usando nomi, percorsi esatti o pattern regex. Lascia una voce di esclusione vuota per disabilitare la colorazione in tutta la vault.",
      "search_file_folder_rules_placeholder": "Cerca regole file/cartella\u2026",
      "path_sort_label_last-added": "Ordina: ultimi aggiunti",
      "path_sort_label_a-z": "Ordina: A-Z",
      "path_sort_label_reverse-a-z": "Ordina: Z-A",
      "path_sort_label_mode": "Ordina: modalit\xE0",
      "path_sort_label_type": "Ordina: tipo",
      "btn_add_file_folder_rule": "+ Aggiungi regola file/cartella",
      "disabled_files_header": "File con colorazione disabilitata:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "includi",
      "path_rule_mode_exclude": "escludi",
      "text_rule_mode_include": "colora solo in (whitelist)",
      "text_rule_mode_exclude": "non colorare in (blacklist)",
      "mode_only_colors_in": "colora solo in",
      "mode_does_not_color_in": "non colora in",
      "label_text_include": "Whitelist",
      "label_text_exclude": "Blacklist",
      "label_enable_in": "Abilita in",
      "label_disable_in": "Disabilita in",
      "enter_path_or_pattern": "Inserisci percorso, modello o tag",
      "label_regex": "Espressione regolare",
      // Advanced Rules
      "advanced_rules_header": "Regole specifiche di inclusione/esclusione",
      "advanced_rules_modal_header": "Regole specifiche di inclusione/esclusione",
      "advanced_rules_manage_button": "gestisci regole specifiche di inclusione/esclusione",
      "edit_rule_header": "Modifica Regola",
      "add_rule_header": "Aggiungi Nuova Regola",
      "btn_add_rule": "+ Aggiungi regola",
      "btn_save_rule": "Salva regola",
      "btn_add_words": "+ Aggiungi parole",
      "btn_add_regex": "+ Aggiungi Regex",
      "btn_save_regex": "Salva Espressione Regolare",
      // Regex Tester
      "regex_tester_header": "Tester di espressioni regolari",
      "regex_tester_blacklist": "Tester Regex - lista nera",
      "regex_expression_placeholder": "Inserisci la tua espressione regex qui",
      "regex_subject_placeholder": "digita il testo da testare qui...",
      "regex_name_placeholder": "dai un nome alla tua regex",
      "matches": "corrispondenze",
      "matches_found": "corrispondenze trovate",
      // Regex Flags
      "flag_g": "flag globale: trova tutte le corrispondenze",
      "flag_i": "flag case-insensitive",
      "flag_m": "flag multilinea: ^ e $ corrispondono ai limiti di riga",
      "flag_s": "flag dotAll: . corrisponde ai ritorni a capo",
      "flag_u": "flag unicode: tratta come punti di codice unicode",
      "flag_y": "flag sticky: corrisponde dalla posizione lastIndex",
      // Data Export/Import
      "data_export_import_header": "Esportazione/Importazione Dati",
      "export_plugin_data": "Esporta dati plugin",
      "export_plugin_data_desc": "Esporta impostazioni, parole e regole in un file JSON.",
      "btn_export": "Esporta",
      "import_plugin_data": "Importa dati plugin",
      "import_plugin_data_desc": "Importa impostazioni da un file JSON",
      "btn_import": "Importa",
      "limit_input_placeholder": "limite",
      "limit_input_tooltip": "0=tutti; numero=ultimi N; r=regex; h=evidenzia; c=testo; b=testo+sfondo; sw=inizia; ew=finisce; e=esatto",
      // Missing Keys Added
      "highlight_styling_header": "Modifica stile evidenziazione",
      "edit_entry_header": "Modifica voce",
      "opt_case_sensitive": "distingue maiuscole/minuscole",
      "opt_not_case_sensitive": "non distingue maiuscole/minuscole",
      "opt_case_all": "Distingui maiuscole/minuscole (Tutti)",
      "opt_match_all": "Tipo di corrispondenza (Tutti)",
      "edit_highlight_styling_btn": "Modifica stile evidenziazione",
      "inclusion_exclusion_header": "Regole di inclusione / esclusione",
      "btn_save_entry": "Salva voce",
      "edit_entry_details": "Modifica dettagli voce",
      "prompt_search_existing": "Cerca voci esistenti\u2026",
      "command_add_to_existing_entry": "Aggiungi a voce esistente",
      "context_remove_from_entry": 'Rimuovi "{word}" dalla voce',
      "context_delete_entry": "Elimina voce",
      "btn_reset": "Reimposta",
      "btn_reset_all": "Reimposta stile evidenziazione",
      "btn_add_word": "+ Aggiungi parola",
      "btn_add_regex_short": "+ Aggiungi Regex",
      "section_highlight_border_styling": "Stile bordo evidenziazione",
      "section_highlight_styling": "Stile evidenziazione",
      "label_highlight_opacity": "Opacit\xE0 evidenziazione",
      "label_highlight_radius": "Raggio bordo evidenziazione",
      "label_horizontal_padding": "Padding orizzontale",
      "label_vertical_padding": "Padding verticale",
      "label_enable_border": "Abilita bordo",
      "label_border_sides": "Lati del bordo",
      "label_border_style": "Stile bordo",
      "label_border_opacity": "Opacit\xE0 bordo",
      "label_border_thickness": "Spessore bordo",
      "btn_save_style": "Salva stile",
      // Quick Colors / Styles
      "quick_actions_header": "Quick Actions",
      "quick_colors_header": "Colori Rapidi",
      "quick_colors_desc": "Consente di evidenziare o colorare rapidamente il testo mostrando i colori nel menu contestuale. Se i Colori Rapidi sono disattivati, verranno utilizzati i colori per stile in Stili Rapidi.",
      "quick_colors_apply_mode_label": "La colorazione del testo verr\xE0 applicata come",
      "quick_colors_apply_mode_act": "Colora sempre il testo",
      "quick_colors_apply_mode_html": "HTML in linea",
      "quick_styles_header": "Stili Rapidi",
      "quick_styles_desc": "Definisci stili con nome per applicare colore del testo ed evidenziazioni. Se i Colori Rapidi sono disattivati, verranno utilizzati i colori per stile qui.",
      "btn_add_style": "+ Aggiungi Stile",
      "quick_styles_menu_option": "Stili Rapidi",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "Voci del gruppo blacklist",
      "show_blacklist_groups_in_commands": "Mostra gruppi blacklist nei comandi",
      "show_blacklist_groups_in_commands_desc": "Se abilitato, i gruppi blacklist vengono visualizzati nella tavolozza dei comandi con i comandi Attiva/Disattiva.",
      "search_blacklist_groups_placeholder": "Cerca gruppi blacklist\u2026",
      "btn_create_new_blacklist_group": "+ Crea nuovo gruppo blacklist",
      "edit_blacklist_group_modal_title": "Modifica gruppo blacklist",
      "tooltip_delete_all_blacklist_groups": "Elimina tutti i gruppi blacklist",
      "confirm_delete_all_blacklist_groups_title": "Elimina tutti i gruppi blacklist",
      "confirm_delete_all_blacklist_groups_desc": "Sei sicuro di voler eliminare TUTTI i gruppi blacklist? Non pu\xF2 essere annullato!",
      "confirm_delete_blacklist_group_title": "Elimina gruppo blacklist",
      "confirm_delete_blacklist_group_desc": "Sei sicuro di voler eliminare questo gruppo blacklist? Non pu\xF2 essere annullato.",
      "notice_blacklist_group_activated": "Gruppo blacklist attivato",
      "notice_blacklist_group_deactivated": "Gruppo blacklist disattivato",
      "command_activate_blacklist_group": "Attiva gruppo blacklist {groupName}",
      "command_deactivate_blacklist_group": "Disattiva gruppo blacklist {groupName}",
      "btn_duplicate_entry": "Duplica voce",
      "btn_open_in_regex_tester": "Apri in Regex Tester",
      "move_to_blacklist_group": "Sposta al gruppo blacklist",
      "btn_delete_entry": "Elimina voce",
      "btn_cancel": "Annulla",
      "btn_confirm": "Conferma",
      "requires_regex_safety_disabled": "Richiede sicurezza regex disabilitata",
      "share_export_title": "Always Color Text export",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "Nome stile",
      "preview_text": "Testo",
      "edit_group_highlight_styling": "Modifica stile evidenziazione gruppo",
      "light_mode_fixer_desc": "Scurisce automaticamente il testo colorato quando si utilizza il tema chiaro per migliorare la visibilit\xE0.",
      "dark_mode_fixer_desc": "Schiarisce automaticamente il testo colorato quando si utilizza il tema scuro per migliorare la visibilit\xE0.",
      "preset_bold": "Grassetto",
      "preset_italic": "Corsivo",
      "preset_bold_italic": "Grassetto Corsivo"
    };
  }
});

// src/i18n/bn.js
var require_bn = __commonJS({
  "src/i18n/bn.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "\u09AC\u09BE\u0982\u09B2\u09BE",
      "settings_title": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u09C7\u099F\u09BF\u0982\u09B8",
      "header_plugin_name": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F",
      "ribbon_title": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F",
      // Language Settings
      "language_label": "\u09AD\u09BE\u09B7\u09BE",
      "language_desc": "\u098F\u0987 \u09AA\u09CD\u09B2\u09BE\u0997\u0987\u09A8\u09C7 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09AD\u09BE\u09B7\u09BE \u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09A8 \u0995\u09B0\u09C1\u09A8",
      "language_en": "\u0987\u0982\u09B0\u09C7\u099C\u09BF",
      "language_es": "\u09B8\u09CD\u09AA\u09CD\u09AF\u09BE\u09A8\u09BF\u09B6",
      "language_fr": "\u09AB\u09CD\u09B0\u09C7\u099E\u09CD\u099A",
      "language_eu": "\u09AC\u09BE\u09B8\u09CD\u0995",
      "language_ru": "\u09B0\u09BE\u09B6\u09BF\u09AF\u09BC\u09BE\u09A8",
      "language_auto": "\u09B8\u09BF\u09B8\u09CD\u099F\u09C7\u09AE \u09A1\u09BF\u09AB\u09B2\u09CD\u099F",
      "default": "\u09A1\u09BF\u09AB\u09B2\u09CD\u099F",
      // Release Notes
      "latest_release_notes_label": "\u09B8\u09B0\u09CD\u09AC\u09B6\u09C7\u09B7 \u09B0\u09BF\u09B2\u09BF\u099C \u09A8\u09CB\u099F\u09B8",
      "latest_release_notes_desc": "\u09AA\u09CD\u09B2\u09BE\u0997\u0987\u09A8\u09C7\u09B0 \u09B8\u09B0\u09CD\u09AC\u09B6\u09C7\u09B7 \u09B0\u09BF\u09B2\u09BF\u099C \u09A8\u09CB\u099F\u09B8 \u09A6\u09C7\u0996\u09C1\u09A8",
      "open_changelog_button": "\u099A\u09C7\u099E\u09CD\u099C\u09B2\u0997 \u0996\u09C1\u09B2\u09C1\u09A8",
      "command_show_release_notes": "\u09B8\u09B0\u09CD\u09AC\u09B6\u09C7\u09B7 \u09B0\u09BF\u09B2\u09BF\u099C \u09A8\u09CB\u099F\u09B8 \u09A6\u09C7\u0996\u09BE\u09A8",
      "changelog_view_on_github": "GitHub \u098F \u09A6\u09C7\u0996\u09C1\u09A8",
      "changelog_loading": "\u09B0\u09BF\u09B2\u09BF\u099C \u09B2\u09CB\u09A1 \u09B9\u099A\u09CD\u099B\u09C7\u2026",
      "changelog_no_info": "\u0995\u09CB\u09A8\u09CB \u09B0\u09BF\u09B2\u09BF\u099C \u09A4\u09A5\u09CD\u09AF \u09AA\u09BE\u0993\u09AF\u09BC\u09BE \u09AF\u09BE\u09AF\u09BC\u09A8\u09BF\u0964",
      "changelog_release": "\u09B0\u09BF\u09B2\u09BF\u099C",
      "changelog_no_notes": "\u0995\u09CB\u09A8\u09CB \u09A8\u09CB\u099F \u09A8\u09C7\u0987",
      "changelog_failed_to_load": "\u09B0\u09BF\u09B2\u09BF\u099C \u09A8\u09CB\u099F\u09B8 \u09B2\u09CB\u09A1 \u0995\u09B0\u09A4\u09C7 \u09AC\u09CD\u09AF\u09B0\u09CD\u09A5\u0964",
      // UI Elements & Menus
      "file_menu_enable": "\u098F\u0987 \u09AB\u09BE\u0987\u09B2\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "file_menu_disable": "\u098F\u0987 \u09AB\u09BE\u0987\u09B2\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "menu_color_once": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B0\u0999 \u0995\u09B0\u09C1\u09A8",
      "menu_highlight_once": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09C1\u09A8",
      "menu_color_highlight_once": "\u09B0\u0999 / \u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09C1\u09A8",
      "menu_remove_inline_color": "\u0987\u09A8\u09B2\u09BE\u0987\u09A8 \u09B0\u0999 \u09B8\u09B0\u09BE\u09A8",
      "menu_always_color_text": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F",
      "menu_remove_always_color_text": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u09B0\u09BE\u09A8",
      "menu_blacklist_word": "\u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09A5\u09C7\u0995\u09C7 \u09B6\u09AC\u09CD\u09A6 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0995\u09B0\u09C1\u09A8",
      "show_toggle_statusbar": "\u09B8\u09CD\u099F\u09CD\u09AF\u09BE\u099F\u09BE\u09B8 \u09AC\u09BE\u09B0\u09C7 \u099F\u0997\u09B2 \u09A6\u09C7\u0996\u09BE\u09A8",
      "show_toggle_ribbon": "\u09B0\u09BF\u09AC\u09A8\u09C7 \u099F\u0997\u09B2 \u0986\u0987\u0995\u09A8 \u09A6\u09C7\u0996\u09BE\u09A8",
      "show_toggle_command": "\u0995\u09AE\u09BE\u09A8\u09CD\u09A1\u09C7 \u099F\u0997\u09B2 \u09A6\u09C7\u0996\u09BE\u09A8",
      "menu_options_header": "\u09AE\u09C7\u09A8\u09C1 \u0985\u09AA\u09B6\u09A8",
      "show_blacklist_menu": '\u09B0\u09BE\u0987\u099F-\u0995\u09CD\u09B2\u09BF\u0995 \u09AE\u09C7\u09A8\u09C1\u09A4\u09C7 "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u09B6\u09AC\u09CD\u09A6" \u09A6\u09C7\u0996\u09BE\u09A8',
      "show_blacklist_menu_desc": "\u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09A5\u09C7\u0995\u09C7 \u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0995\u09B0\u09BE\u09B0 \u099C\u09A8\u09CD\u09AF \u098F\u0995\u099F\u09BF \u09B0\u09BE\u0987\u099F-\u0995\u09CD\u09B2\u09BF\u0995 \u09AE\u09C7\u09A8\u09C1 \u0986\u0987\u099F\u09C7\u09AE \u09AF\u09CB\u0997 \u0995\u09B0\u09C7\u0964",
      "show_add_to_existing_menu": '\u09B0\u09BE\u0987\u099F-\u0995\u09CD\u09B2\u09BF\u0995 \u09AE\u09C7\u09A8\u09C1\u09A4\u09C7 "\u09AC\u09BF\u09A6\u09CD\u09AF\u09AE\u09BE\u09A8 \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF\u09A4\u09C7 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8" \u09A6\u09C7\u0996\u09BE\u09A8',
      "show_add_to_existing_menu_desc": "\u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u098F\u0995\u099F\u09BF \u09AC\u09BF\u09A6\u09CD\u09AF\u09AE\u09BE\u09A8 \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF\u09A4\u09C7 \u09AF\u09CB\u0997 \u0995\u09B0\u09BE\u09B0 \u099C\u09A8\u09CD\u09AF \u098F\u0995\u099F\u09BF \u09B0\u09BE\u0987\u099F-\u0995\u09CD\u09B2\u09BF\u0995 \u09AE\u09C7\u09A8\u09C1 \u0986\u0987\u099F\u09C7\u09AE \u09AF\u09CB\u0997 \u0995\u09B0\u09C7\u0964",
      "show_always_color_text_menu": '\u09B0\u09BE\u0987\u099F-\u0995\u09CD\u09B2\u09BF\u0995 \u09AE\u09C7\u09A8\u09C1\u09A4\u09C7 "Always Color Text" \u09A6\u09C7\u0996\u09BE\u09A8',
      "show_always_color_text_menu_desc": "\u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u0995\u09B0\u09BE\u09B0 \u099C\u09A8\u09CD\u09AF \u098F\u0995\u099F\u09BF \u09B0\u09BE\u0987\u099F-\u0995\u09CD\u09B2\u09BF\u0995 \u09AE\u09C7\u09A8\u09C1 \u0986\u0987\u099F\u09C7\u09AE \u09AF\u09CB\u0997 \u0995\u09B0\u09C7\u0964",
      "hide_inactive_groups_in_dropdowns": "\u09A1\u09AA\u09A1\u09BE\u0989\u09A8\u09C7 \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0997\u09CD\u09B0\u09C1\u09AA\u0997\u09C1\u09B2\u09BF \u09B2\u09C1\u0995\u09BE\u09A8",
      "hide_inactive_groups_in_dropdowns_desc": "\u09A1\u09AA\u09A1\u09BE\u0989\u09A8\u09C7 \u0997\u09CD\u09B0\u09C1\u09AA \u09A4\u09BE\u09B2\u09BF\u0995\u09BE \u09AA\u09CD\u09B0\u09A6\u09B0\u09CD\u09B6\u09A8\u09C7\u09B0 \u09B8\u09AE\u09AF\u09BC \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA\u0997\u09C1\u09B2\u09BF \u09B2\u09C1\u0995\u09BE\u09AF\u09BC\u0964",
      "show_word_groups_in_commands": "\u0995\u09AE\u09BE\u09A8\u09CD\u09A1\u09C7 \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA \u09A6\u09C7\u0996\u09BE\u09A8",
      "show_word_groups_in_commands_desc": "\u09B8\u0995\u09CD\u09B7\u09AE \u09A5\u09BE\u0995\u09B2\u09C7, \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA\u0997\u09C1\u09B2\u09CB \u0995\u09AE\u09BE\u09A8\u09CD\u09A1 \u09AA\u09CD\u09AF\u09BE\u09B2\u09C7\u099F\u09C7 \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC/\u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09AE\u09BE\u09A8\u09CD\u09A1\u09B8\u09B9 \u09A6\u09C7\u0996\u09BE\u09AF\u09BC\u0964",
      "tooltip_enable_for_file": "\u098F\u0987 \u09AB\u09BE\u0987\u09B2\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "tooltip_delete_all_words": "\u09B8\u0982\u099C\u09CD\u099E\u09BE\u09AF\u09BC\u09BF\u09A4 \u09B8\u09AE\u09B8\u09CD\u09A4 \u09B6\u09AC\u09CD\u09A6/\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09AE\u09C1\u099B\u09C1\u09A8",
      "tooltip_delete_all_blacklist": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0995\u09B0\u09BE \u09B8\u09AE\u09B8\u09CD\u09A4 \u09B6\u09AC\u09CD\u09A6/\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09AE\u09C1\u099B\u09C1\u09A8",
      "tooltip_use_regex": "\u09B0\u09C7\u099C\u09C7\u0995\u09CD\u09B8 \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09B9\u09BF\u09B8\u09BE\u09AC\u09C7 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C1\u09A8",
      "drag_to_reorder": "\u09AA\u09C1\u09A8\u09B0\u09CD\u09AC\u09BF\u09A8\u09CD\u09AF\u09BE\u09B8\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u099F\u09C7\u09A8\u09C7 \u0986\u09A8\u09C1\u09A8",
      "reset_text_color": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u09B0\u09BF\u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "reset_highlight": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B0\u09BF\u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      // Commands
      "command_color_selected": "\u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u0995\u09B0\u09C1\u09A8",
      "command_toggle_current": "\u09AC\u09B0\u09CD\u09A4\u09AE\u09BE\u09A8 \u09A1\u0995\u09C1\u09AE\u09C7\u09A8\u09CD\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09B8\u0995\u09CD\u09B7\u09AE/\u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "command_toggle_global": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u0995\u09CD\u09B7\u09AE/\u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "command_enable_current": "\u09AC\u09B0\u09CD\u09A4\u09AE\u09BE\u09A8 \u09A1\u0995\u09C1\u09AE\u09C7\u09A8\u09CD\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "command_disable_current": "\u09AC\u09B0\u09CD\u09A4\u09AE\u09BE\u09A8 \u09A1\u0995\u09C1\u09AE\u09C7\u09A8\u09CD\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "command_enable_global": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "command_disable_global": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "command_enable_lightweight_mode": "\u09B2\u09BE\u0987\u099F\u0993\u09AF\u09BC\u09C7\u099F \u09AE\u09CB\u09A1 \u099A\u09BE\u09B2\u09C1 \u0995\u09B0\u09C1\u09A8",
      "command_disable_lightweight_mode": "\u09B2\u09BE\u0987\u099F\u0993\u09AF\u09BC\u09C7\u099F \u09AE\u09CB\u09A1 \u09AC\u09A8\u09CD\u09A7 \u0995\u09B0\u09C1\u09A8",
      "command_color_highlight_once": "\u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0982 / \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09C1\u09A8 (\u098F\u0995\u09AC\u09BE\u09B0)",
      "notice_select_text_first_once": "\u09A6\u09AF\u09BC\u09BE \u0995\u09B0\u09C7 \u09AA\u09CD\u09B0\u09A5\u09AE\u09C7 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09A8 \u0995\u09B0\u09C1\u09A8\u0964",
      "command_manage_advanced_rules": "\u09A8\u09BF\u09B0\u09CD\u09A6\u09BF\u09B7\u09CD\u099F \u0985\u09A8\u09CD\u09A4\u09B0\u09CD\u09AD\u09C1\u0995\u09CD\u09A4\u09BF/\u09AC\u09B0\u09CD\u099C\u09A8 \u09A8\u09BF\u09AF\u09BC\u09AE \u09AA\u09B0\u09BF\u099A\u09BE\u09B2\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "command_open_regex_tester": "Regex \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8 (Regex \u09AA\u09B0\u09C0\u0995\u09CD\u09B7\u0995 \u0996\u09C1\u09B2\u09C1\u09A8)",
      "command_open_blacklist_regex_tester": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7 Regex \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "command_manage_colored_texts": "\u09B0\u0999\u09BE\u09AF\u09BC\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F\u0997\u09C1\u09B2\u09BF \u09AA\u09B0\u09BF\u099A\u09BE\u09B2\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "command_toggle_hide_text_colors": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u09B2\u09C1\u0995\u09BE\u09A8/\u09A6\u09C7\u0996\u09BE\u09A8",
      "command_toggle_hide_highlights": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B2\u09C1\u0995\u09BE\u09A8/\u09A6\u09C7\u0996\u09BE\u09A8",
      "command_hide_text_colors": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u09B2\u09C1\u0995\u09BE\u09A8",
      "command_unhide_text_colors": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u09A6\u09C7\u0996\u09BE\u09A8",
      "command_hide_highlights": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B2\u09C1\u0995\u09BE\u09A8",
      "command_unhide_highlights": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09A6\u09C7\u0996\u09BE\u09A8",
      "command_activate_word_group": "{groupName} \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09C1\u09A8",
      "command_deactivate_word_group": "{groupName} \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09C1\u09A8",
      // Notifications
      "notice_lightweight_mode_enabled": "\u09B2\u09BE\u0987\u099F\u0993\u09AF\u09BC\u09C7\u099F \u09AE\u09CB\u09A1 \u099A\u09BE\u09B2\u09C1",
      "notice_lightweight_mode_disabled": "\u09B2\u09BE\u0987\u099F\u0993\u09AF\u09BC\u09C7\u099F \u09AE\u09CB\u09A1 \u09AC\u09A8\u09CD\u09A7",
      "notice_enabled": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC",
      "notice_disabled": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC",
      "notice_blacklisted_cannot_color": '"{word}" \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7 \u09B0\u09AF\u09BC\u09C7\u099B\u09C7 \u098F\u09AC\u0982 \u09B0\u0999 \u0995\u09B0\u09BE \u09AF\u09BE\u09AC\u09C7 \u09A8\u09BE\u0964',
      "notice_removed_always_color": '"{word}" \u098F\u09B0 \u099C\u09A8\u09CD\u09AF \u09B8\u09B0\u09CD\u09AC\u09A6\u09BE \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09B8\u09B0\u09BE\u09A8\u09CB \u09B9\u09AF\u09BC\u09C7\u099B\u09C7\u0964',
      "notice_added_to_blacklist": '"{word}" \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7 \u09AF\u09CB\u0997 \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7\u0964',
      "notice_already_blacklisted": '"{word}" \u0987\u09A4\u09BF\u09AE\u09A7\u09CD\u09AF\u09C7\u0987 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7 \u09B0\u09AF\u09BC\u09C7\u099B\u09C7\u0964',
      "notice_select_text_first": "\u09A6\u09AF\u09BC\u09BE \u0995\u09B0\u09C7 \u09AA\u09CD\u09B0\u09A5\u09AE\u09C7 \u0995\u09BF\u099B\u09C1 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09A8 \u0995\u09B0\u09C1\u09A8\u0964",
      "notice_no_active_file": "\u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u099F\u0997\u09B2 \u0995\u09B0\u09BE\u09B0 \u099C\u09A8\u09CD\u09AF \u0995\u09CB\u09A8\u09CB \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u09AB\u09BE\u0987\u09B2 \u09A8\u09C7\u0987\u0964",
      "notice_coloring_enabled_for_path": "{path} \u098F\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_coloring_disabled_for_path": "{path} \u098F\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_global_enabled": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u0995\u09CD\u09B7\u09AE",
      "notice_global_disabled": "\u0985\u09B2\u0993\u09AF\u09BC\u09C7\u099C \u0995\u09BE\u09B2\u09BE\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u0985\u0995\u09CD\u09B7\u09AE",
      "notice_unable_open_changelog": "\u099A\u09C7\u099E\u09CD\u099C\u09B2\u0997 \u0996\u09C1\u09B2\u09A4\u09C7 \u09AC\u09CD\u09AF\u09B0\u09CD\u09A5 \u09B9\u09AF\u09BC\u09C7\u099B\u09C7\u0964",
      "notice_pattern_blocked": "\u09AE\u09C7\u09AE\u09CB\u09B0\u09BF \u09B8\u09C7\u09AB\u099F\u09BF\u09B0 \u099C\u09A8\u09CD\u09AF \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09AC\u09CD\u09B2\u0995 \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7:",
      "notice_pattern_too_complex": "\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u0996\u09C1\u09AC \u099C\u099F\u09BF\u09B2:",
      "notice_invalid_hex_format": "\u0985\u09AC\u09C8\u09A7 \u09B9\u09C7\u0995\u09CD\u09B8 \u09B0\u0999 \u09AB\u09B0\u09AE\u09CD\u09AF\u09BE\u099F\u0964 #RRGGBB \u09AC\u09BE #RGB \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C1\u09A8\u0964",
      "notice_error_saving_changes": "\u09AA\u09B0\u09BF\u09AC\u09B0\u09CD\u09A4\u09A8\u0997\u09C1\u09B2\u09BF \u09B8\u0982\u09B0\u0995\u09CD\u09B7\u09A3 \u0995\u09B0\u09A4\u09C7 \u09A4\u09CD\u09B0\u09C1\u099F\u09BF\u0964 \u09A6\u09AF\u09BC\u09BE \u0995\u09B0\u09C7 \u0986\u09AC\u09BE\u09B0 \u099A\u09C7\u09B7\u09CD\u099F\u09BE \u0995\u09B0\u09C1\u09A8\u0964",
      "notice_invalid_color_format": "\u0985\u09AC\u09C8\u09A7 \u09B0\u0999 \u09AB\u09B0\u09AE\u09CD\u09AF\u09BE\u099F\u0964",
      "notice_exported": "\u098F\u0995\u09CD\u09B8\u09AA\u09CB\u09B0\u09CD\u099F \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7: {fname}",
      "notice_export_failed": "\u098F\u0995\u09CD\u09B8\u09AA\u09CB\u09B0\u09CD\u099F \u09AC\u09CD\u09AF\u09B0\u09CD\u09A5",
      "notice_import_completed": "\u0987\u09AE\u09CD\u09AA\u09CB\u09B0\u09CD\u099F \u09B8\u09AE\u09CD\u09AA\u09A8\u09CD\u09A8",
      "notice_import_failed": "\u0987\u09AE\u09CD\u09AA\u09CB\u09B0\u09CD\u099F \u09AC\u09CD\u09AF\u09B0\u09CD\u09A5",
      "share_export_title": "Always Color Text export",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "Style Name",
      "preview_text": "Text",
      "notice_invalid_regex": "\u0985\u09AC\u09C8\u09A7 \u09A8\u09BF\u09AF\u09BC\u09AE\u09BF\u09A4 \u0985\u09AD\u09BF\u09AC\u09CD\u09AF\u0995\u09CD\u09A4\u09BF",
      "notice_empty_pattern": "\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u0996\u09BE\u09B2\u09BF",
      "notice_added_regex": "\u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09AF\u09CB\u0997 \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_rule_updated": "\u09A8\u09BF\u09AF\u09BC\u09AE \u0986\u09AA\u09A1\u09C7\u099F \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_regex_updated": "\u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u0986\u09AA\u09A1\u09C7\u099F \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_entry_updated": "\u09AA\u09CD\u09B0\u09AC\u09BF\u09B7\u09CD\u099F\u09BF \u0986\u09AA\u09A1\u09C7\u099F \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_entry_duplicated": "\u09AA\u09CD\u09B0\u09AC\u09BF\u09B7\u09CD\u099F\u09BF \u09A1\u09C1\u09AA\u09CD\u09B2\u09BF\u0995\u09C7\u099F \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_error_opening_regex_tester": "\u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09AA\u09B0\u09C0\u0995\u09CD\u09B7\u0995 \u0996\u09C1\u09B2\u09A4\u09C7 \u09A4\u09CD\u09B0\u09C1\u099F\u09BF",
      "notice_error_opening_blacklist_regex_tester": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09AA\u09B0\u09C0\u0995\u09CD\u09B7\u0995 \u0996\u09C1\u09B2\u09A4\u09C7 \u09A4\u09CD\u09B0\u09C1\u099F\u09BF",
      "notice_error_opening_advanced_rules": "\u0989\u09A8\u09CD\u09A8\u09A4 \u09A8\u09BF\u09AF\u09BC\u09AE \u09AE\u09CB\u09A1\u09BE\u09B2 \u0996\u09C1\u09B2\u09A4\u09C7 \u09A4\u09CD\u09B0\u09C1\u099F\u09BF",
      "notice_text_color_reset": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u09B0\u09BF\u09B8\u09C7\u099F \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_highlight_reset": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B0\u09BF\u09B8\u09C7\u099F \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_text_colors_hidden": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u09B2\u09C1\u0995\u09BE\u09A8\u09CB \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_text_colors_visible": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u09A6\u09C3\u09B6\u09CD\u09AF\u09AE\u09BE\u09A8",
      "notice_highlights_hidden": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B2\u09C1\u0995\u09BE\u09A8\u09CB \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_highlights_visible": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09A6\u09C3\u09B6\u09CD\u09AF\u09AE\u09BE\u09A8",
      "notice_regex_support_disabled": "\u09B0\u09C7\u099C\u09C7\u0995\u09CD\u09B8 \u09B8\u0982\u0998\u09BE\u09A4 \u09B8\u09A8\u09CD\u09AC\u09AC\u09B0\u09A8 \u099C\u09A8\u0995 \u0985\u0995\u09CD\u09B7\u09AE\u0964 \u09B0\u09C7\u099C\u09C7\u0995\u09CD\u09B8 \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09A8 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09AC\u09BE\u09B0 \u0985\u09A8\u09C1\u09AE\u09A4\u09BF \u09A6\u09BF\u09AF\u09BC\u09C7 \u098F\u099F\u09BF \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8\u0964",
      "notice_no_active_file_to_disable": "\u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09BE\u09B0 \u099C\u09A8\u09CD\u09AF \u0995\u09CB\u09A8\u09CB \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u09AB\u09BE\u0987\u09B2 \u09A8\u09C7\u0987\u0964",
      "notice_already_disabled_for_path": "{path} \u098F\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u0987\u09A4\u09BF\u09AE\u09A7\u09CD\u09AF\u09C7\u0987 \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC",
      "notice_filter_disabled": "\u09AB\u09BF\u09B2\u09CD\u099F\u09BE\u09B0 \u0985\u0995\u09CD\u09B7\u09AE",
      // Confirmation Dialogs
      "confirm_delete_all_title": "\u09B8\u09AE\u09B8\u09CD\u09A4 \u09B6\u09AC\u09CD\u09A6 \u09AE\u09C1\u099B\u09C1\u09A8",
      "confirm_delete_all_desc": "\u0986\u09AA\u09A8\u09BF \u0995\u09BF \u09A8\u09BF\u09B6\u09CD\u099A\u09BF\u09A4 \u09AF\u09C7 \u0986\u09AA\u09A8\u09BF \u0986\u09AA\u09A8\u09BE\u09B0 \u09B8\u09AE\u09B8\u09CD\u09A4 \u09B0\u0999 \u0995\u09B0\u09BE \u09B6\u09AC\u09CD\u09A6/\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09AE\u09C1\u099B\u09A4\u09C7 \u099A\u09BE\u09A8? \u0986\u09AA\u09A8\u09BF \u098F\u099F\u09BF \u09AA\u09C2\u09B0\u09CD\u09AC\u09BE\u09AC\u09B8\u09CD\u09A5\u09BE\u09AF\u09BC \u09AB\u09BF\u09B0\u09BF\u09AF\u09BC\u09C7 \u0986\u09A8\u09A4\u09C7 \u09AA\u09BE\u09B0\u09AC\u09C7\u09A8 \u09A8\u09BE!",
      "confirm_delete_all_blacklist_title": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0995\u09B0\u09BE \u09B8\u09AE\u09B8\u09CD\u09A4 \u09B6\u09AC\u09CD\u09A6 \u09AE\u09C1\u099B\u09C1\u09A8",
      "confirm_delete_all_blacklist_desc": "\u0986\u09AA\u09A8\u09BF \u0995\u09BF \u09A8\u09BF\u09B6\u09CD\u099A\u09BF\u09A4 \u09AF\u09C7 \u0986\u09AA\u09A8\u09BF \u09B8\u09AE\u09B8\u09CD\u09A4 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09AE\u09C1\u099B\u09A4\u09C7 \u099A\u09BE\u09A8? \u0986\u09AA\u09A8\u09BF \u098F\u099F\u09BF \u09AA\u09C2\u09B0\u09CD\u09AC\u09BE\u09AC\u09B8\u09CD\u09A5\u09BE\u09AF\u09BC \u09AB\u09BF\u09B0\u09BF\u09AF\u09BC\u09C7 \u0986\u09A8\u09A4\u09C7 \u09AA\u09BE\u09B0\u09AC\u09C7\u09A8 \u09A8\u09BE!",
      "confirm_delete_all_groups_title": "\u09B8\u09AC \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09C7 \u09AB\u09C7\u09B2\u09C1\u09A8",
      "confirm_delete_all_groups_desc": "\u0986\u09AA\u09A8\u09BF \u0995\u09BF \u09A8\u09BF\u09B6\u09CD\u099A\u09BF\u09A4 \u09AF\u09C7 \u0986\u09AA\u09A8\u09BF \u09B8\u09AC \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09A4\u09C7 \u099A\u09BE\u09A8? \u0986\u09AA\u09A8\u09BF \u098F\u099F\u09BF \u09AA\u09C2\u09B0\u09CD\u09AC\u09BE\u09AC\u09B8\u09CD\u09A5\u09BE\u09AF\u09BC \u09AB\u09BF\u09B0\u09BF\u09AF\u09BC\u09C7 \u0986\u09A8\u09A4\u09C7 \u09AA\u09BE\u09B0\u09AC\u09C7\u09A8 \u09A8\u09BE!",
      "restart_required_title": "\u09B0\u09BF\u09B8\u09CD\u099F\u09BE\u09B0\u09CD\u099F \u09AA\u09CD\u09B0\u09AF\u09BC\u09CB\u099C\u09A8",
      "restart_required_desc": "\u0995\u09AE\u09BE\u09A8\u09CD\u09A1 \u09AA\u09CD\u09AF\u09BE\u09B2\u09C7\u099F \u099F\u0997\u09B2 \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09A4\u09C7 \u09AA\u09CD\u09AF\u09BE\u09B2\u09C7\u099F \u09A5\u09C7\u0995\u09C7 \u0995\u09AE\u09BE\u09A8\u09CD\u09A1\u0997\u09C1\u09B2\u09BF \u09B8\u09AE\u09CD\u09AA\u09C2\u09B0\u09CD\u09A3\u09AD\u09BE\u09AC\u09C7 \u09B8\u09B0\u09BE\u09A8\u09CB\u09B0 \u099C\u09A8\u09CD\u09AF \u0985\u09AC\u09B8\u09BF\u09A1\u09BF\u09AF\u09BC\u09BE\u09A8 \u09B0\u09BF\u09B8\u09CD\u099F\u09BE\u09B0\u09CD\u099F \u0995\u09B0\u09A4\u09C7 \u09B9\u09AC\u09C7\u0964 \u098F\u0996\u09A8\u0987 \u09B0\u09BF\u09B8\u09CD\u099F\u09BE\u09B0\u09CD\u099F \u0995\u09B0\u09AC\u09C7\u09A8?",
      // Basic Settings
      "enable_document_color": "\u09A1\u0995\u09C1\u09AE\u09C7\u09A8\u09CD\u099F \u09B0\u0999 \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "color_in_live_preview_mode": "\u09B2\u09BE\u0987\u09AD \u09AA\u09CD\u09B0\u09BF\u09AD\u09BF\u0989 \u09AE\u09CB\u09A1\u09C7 \u09B0\u0999 \u0995\u09B0\u09C1\u09A8",
      "color_in_reading_mode": "\u09B0\u09BF\u09A1\u09BF\u0982 \u09AE\u09CB\u09A1\u09C7 \u09B0\u0999 \u0995\u09B0\u09C1\u09A8",
      "force_full_render_reading": "\u09B0\u09BF\u09A1\u09BF\u0982 \u09AE\u09CB\u09A1\u09C7 \u09B8\u09AE\u09CD\u09AA\u09C2\u09B0\u09CD\u09A3 \u09B0\u09C7\u09A8\u09CD\u09A1\u09BE\u09B0 \u099C\u09CB\u09B0 \u0995\u09B0\u09C1\u09A8",
      "force_full_render_reading_desc": "\u099A\u09BE\u09B2\u09C1 \u09A5\u09BE\u0995\u09B2\u09C7, \u09B0\u09BF\u09A1\u09BF\u0982-\u09AE\u09CB\u09A1 \u09B8\u09AE\u09CD\u09AA\u09C2\u09B0\u09CD\u09A3 \u09A1\u0995\u09C1\u09AE\u09C7\u09A8\u09CD\u099F \u098F\u0995 \u09AA\u09BE\u09B8\u09C7 \u09B0\u0999 \u0995\u09B0\u09BE\u09B0 \u099A\u09C7\u09B7\u09CD\u099F\u09BE \u0995\u09B0\u09AC\u09C7\u0964 \u09AC\u09A1\u09BC \u09A1\u0995\u09C1\u09AE\u09C7\u09A8\u09CD\u099F\u09C7 \u09AA\u09BE\u09B0\u09AB\u09B0\u09AE\u09CD\u09AF\u09BE\u09A8\u09CD\u09B8 \u0987\u09B8\u09CD\u09AF\u09C1 \u09B9\u09A4\u09C7 \u09AA\u09BE\u09B0\u09C7\u0964 \u09B8\u09A4\u09B0\u09CD\u0995\u09A4\u09BE\u09B0 \u09B8\u09BE\u09A5\u09C7 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C1\u09A8!",
      "smart_update_mode": "\u09B8\u09CD\u09AE\u09BE\u09B0\u09CD\u099F \u0986\u09AA\u09A1\u09C7\u099F (\u09AA\u09B0\u09C0\u0995\u09CD\u09B7\u09BE\u09AE\u09C2\u09B2\u0995)",
      "smart_update_mode_desc": "\u099F\u09BE\u0987\u09AA \u0995\u09B0\u09BE\u09B0 \u09B8\u09AE\u09AF\u09BC \u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u09B2\u09BE\u0987\u09A8\u09C7\u09B0 \u09B0\u0999 \u0986\u09AA\u09A1\u09C7\u099F \u0995\u09B0\u09C7 \u098F\u09AC\u0982 \u09AA\u09BE\u09B0\u09AB\u09B0\u09AE\u09CD\u09AF\u09BE\u09A8\u09CD\u09B8 \u0989\u09A8\u09CD\u09A8\u09A4 \u0995\u09B0\u09A4\u09C7 \u0985\u09A8\u09CD\u09AF\u09BE\u09A8\u09CD\u09AF \u09B2\u09BE\u0987\u09A8\u0997\u09C1\u09B2\u09BF \u09AB\u09CD\u09B0\u09BF\u099C \u0995\u09B0\u09C7\u0964",
      "lightweight_mode": "\u09B2\u09BE\u0987\u099F\u0993\u09AF\u09BC\u09C7\u099F \u09AE\u09CB\u09A1 (\u09AA\u09B0\u09C0\u0995\u09CD\u09B7\u09BE\u09AE\u09C2\u09B2\u0995)",
      "lightweight_mode_desc": "\u099F\u09BE\u0987\u09AA \u0995\u09B0\u09BE\u09B0 \u09B8\u09AE\u09AF\u09BC \u09AA\u09CD\u09B0\u09B8\u09C7\u09B8\u09BF\u0982 \u0985\u09A8\u09C7\u0995 \u0995\u09AE\u09BF\u09AF\u09BC\u09C7 \u09A6\u09C7\u09AF\u09BC\u0964 \u0995\u09BF\u099B\u09C1 \u09AE\u09CD\u09AF\u09BE\u099A \u09AC\u09BE\u09A6 \u09AA\u09A1\u09BC\u09A4\u09C7 \u09AA\u09BE\u09B0\u09C7\u0964",
      "disable_coloring_current_file": "\u09AC\u09B0\u09CD\u09A4\u09AE\u09BE\u09A8 \u09AB\u09BE\u0987\u09B2\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "disable_coloring_current_file_desc": "\u09AB\u09BE\u0987\u09B2 \u0993 \u09AB\u09CB\u09B2\u09CD\u09A1\u09BE\u09B0 \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09B0\u09C1\u09B2\u09B8 \u098F\u09B0 \u0985\u09A7\u09C0\u09A8\u09C7 \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u09AB\u09BE\u0987\u09B2\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u098F\u0995\u099F\u09BF \u098F\u0995\u09CD\u09B8\u0995\u09CD\u09B2\u09C1\u09A1 \u09B0\u09C1\u09B2 \u09AF\u09CB\u0997 \u0995\u09B0\u09C7\u0964",
      "btn_disable_for_this_file": "\u098F\u0987 \u09AB\u09BE\u0987\u09B2\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      // Coloring Settings
      "coloring_settings_header": "\u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09B8\u09C7\u099F\u09BF\u0982\u09B8",
      "regex_support": "\u09B0\u09C7\u0997\u09C7\u0995\u09CD\u09B8 \u09B8\u09BE\u09AA\u09CB\u09B0\u09CD\u099F",
      "regex_support_desc": "\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8\u0997\u09C1\u09B2\u09BF\u0995\u09C7 \u09B0\u09C7\u0997\u09C1\u09B2\u09BE\u09B0 \u098F\u0995\u09CD\u09B8\u09AA\u09CD\u09B0\u09C7\u09B6\u09A8 \u09B9\u09A4\u09C7 \u0985\u09A8\u09C1\u09AE\u09A4\u09BF \u09A6\u09BF\u09A8\u0964 \u09A8\u09BF\u09B0\u09BE\u09AA\u09A4\u09CD\u09A4\u09BE\u09B0 \u099C\u09A8\u09CD\u09AF \u0985\u09AC\u09C8\u09A7 \u09B0\u09C7\u0997\u09C7\u0995\u09CD\u09B8 \u0989\u09AA\u09C7\u0995\u09CD\u09B7\u09BE \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u0964",
      "disable_regex_safety": "\u09B0\u09C7\u0997\u09C7\u0995\u09CD\u09B8 \u09A8\u09BF\u09B0\u09BE\u09AA\u09A4\u09CD\u09A4\u09BE \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "disable_regex_safety_desc": "\u099C\u099F\u09BF\u09B2 \u09AC\u09BE \u09B8\u09AE\u09CD\u09AD\u09BE\u09AC\u09CD\u09AF \u09AC\u09BF\u09AA\u099C\u09CD\u099C\u09A8\u0995 \u098F\u0995\u09CD\u09B8\u09AA\u09CD\u09B0\u09C7\u09B6\u09A8 \u0985\u09A8\u09C1\u09AE\u09A4\u09BF \u09A6\u09BF\u09A8\u0964 \u09AA\u09BE\u09B0\u09AB\u09B0\u09AE\u09CD\u09AF\u09BE\u09A8\u09CD\u09B8 \u0987\u09B8\u09CD\u09AF\u09C1 \u09AC\u09BE \u09AB\u09CD\u09B0\u09BF\u099C \u09B9\u09A4\u09C7 \u09AA\u09BE\u09B0\u09C7\u0964",
      "case_sensitive": "\u0995\u09C7\u09B8 \u09B8\u09C7\u09A8\u09CD\u09B8\u09BF\u099F\u09BF\u09AD",
      "case_sensitive_desc": '\u098F\u099F\u09BF \u099A\u09BE\u09B2\u09C1 \u09A5\u09BE\u0995\u09B2\u09C7, "word" \u098F\u09AC\u0982 "Word" \u0986\u09B2\u09BE\u09A6\u09BE \u09B9\u09BF\u09B8\u09C7\u09AC\u09C7 \u09AC\u09BF\u09AC\u09C7\u099A\u09BF\u09A4 \u09B9\u09AC\u09C7\u0964 \u09AC\u09A8\u09CD\u09A7 \u09A5\u09BE\u0995\u09B2\u09C7, \u09A4\u09BE\u09B0\u09BE \u098F\u0995\u0987\u09AD\u09BE\u09AC\u09C7 \u09B0\u0999 \u0995\u09B0\u09BE \u09B9\u09AC\u09C7\u0964',
      "partial_match": "\u0986\u0982\u09B6\u09BF\u0995 \u09AE\u09CD\u09AF\u09BE\u099A",
      "partial_match_desc": '\u09B8\u0995\u09CD\u09B7\u09AE \u09A5\u09BE\u0995\u09B2\u09C7, \u09AA\u09C1\u09B0\u09CB \u09B6\u09AC\u09CD\u09A6\u099F\u09BF \u09B0\u0999 \u0995\u09B0\u09BE \u09B9\u09AC\u09C7 \u09AF\u09A6\u09BF \u098F\u09B0 \u09AD\u09BF\u09A4\u09B0\u09C7 \u0995\u09CB\u09A8\u09CB \u09B0\u0999 \u0995\u09B0\u09BE \u09B6\u09AC\u09CD\u09A6 \u09AA\u09BE\u0993\u09AF\u09BC\u09BE \u09AF\u09BE\u09AF\u09BC (\u09AF\u09C7\u09AE\u09A8, "as" "Jasper" \u0995\u09C7 \u09B0\u0999 \u0995\u09B0\u09AC\u09C7)\u0964',
      // One-Time Actions
      "one_time_actions_header": "\u098F\u0995-\u09AC\u09BE\u09B0\u09C7\u09B0 \u0995\u09BE\u099C\u0997\u09C1\u09B2\u09BF",
      "setting_color_once": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B0\u0999 \u0995\u09B0\u09C1\u09A8",
      "setting_color_once_desc": "\u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF HTML \u0987\u09A8\u09B2\u09BE\u0987\u09A8 \u09B8\u09A8\u09CD\u09A8\u09BF\u09AC\u09C7\u09B6 \u0995\u09B0\u09C7\u0964 \u09AA\u09CD\u09B2\u09BE\u0997\u0987\u09A8 \u09AC\u09A8\u09CD\u09A7 \u09A5\u09BE\u0995\u09B2\u09C7\u0993 \u098F\u099F\u09BF \u09B8\u09CD\u09A5\u09BE\u09AF\u09BC\u09C0 \u09A5\u09BE\u0995\u09C7\u0964",
      "setting_highlight_once": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09C1\u09A8",
      "setting_highlight_once_desc": "\u09AC\u09CD\u09AF\u09BE\u0995\u0997\u09CD\u09B0\u09BE\u0989\u09A8\u09CD\u09A1 \u09B8\u09CD\u099F\u09BE\u0987\u09B2\u09BF\u0982 \u09B8\u09B9 HTML \u0987\u09A8\u09B2\u09BE\u0987\u09A8 \u09B8\u09A8\u09CD\u09A8\u09BF\u09AC\u09C7\u09B6 \u0995\u09B0\u09C7\u0964 \u09AA\u09CD\u09B2\u09BE\u0997\u0987\u09A8 \u09AC\u09A8\u09CD\u09A7 \u09A5\u09BE\u0995\u09B2\u09C7\u0993 \u098F\u099F\u09BF \u09B8\u09CD\u09A5\u09BE\u09AF\u09BC\u09C0 \u09A5\u09BE\u0995\u09C7\u0964",
      "setting_color_highlight_once": "\u09B0\u0999 \u098F\u09AC\u0982 \u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09C1\u09A8",
      "setting_color_highlight_once_desc": "\u0989\u09AD\u09AF\u09BC \u09AA\u09BE\u09A0\u09CD\u09AF \u09B0\u0999 \u098F\u09AC\u0982 \u09AA\u099F\u09AD\u09C2\u09AE\u09BF \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0987\u09A8\u09B2\u09BE\u0987\u09A8 \u09AA\u09CD\u09B0\u09AF\u09BC\u09CB\u0997 \u0995\u09B0\u09A4\u09C7 \u0987\u0989\u09A8\u09BF\u09AB\u09BE\u0987\u09A1 \u09B0\u0999 \u09AA\u09BF\u0995\u09BE\u09B0 \u0996\u09CB\u09B2\u09C7\u0964 \u0987\u0989\u09A8\u09BF\u09AB\u09BE\u0987\u09A1 \u09AE\u09C7\u09A8\u09C1 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C7\u0964",
      "highlight_once_preview": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AA\u09CD\u09B0\u09BF\u09AD\u09BF\u0989",
      "highlight_once_preview_text": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09C7\u09AE\u09A8 \u09A6\u09C7\u0996\u09BE\u09AC\u09C7 \u09A4\u09BE \u09A6\u09C7\u0996\u09C1\u09A8!",
      // Highlight Once Settings
      "highlight_once_opacity": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0985\u09B8\u09CD\u09AA\u09B7\u09CD\u099F\u09A4\u09BE",
      "highlight_once_border_radius": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B0\u09C7\u09A1\u09BF\u09AF\u09BC\u09BE\u09B8 (px)",
      "reset_to_8": "\u09EE \u098F \u09B0\u09BF\u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "highlight_horizontal_padding": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B9\u09B0\u09BE\u0987\u099C\u09A8\u099F\u09BE\u09B2 \u09AA\u09CD\u09AF\u09BE\u09A1\u09BF\u0982 (px)",
      "highlight_vertical_padding": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AD\u09BE\u09B0\u09CD\u099F\u09BF\u0995\u09BE\u09B2 \u09AA\u09CD\u09AF\u09BE\u09A1\u09BF\u0982 (px)",
      "reset_to_4": "\u09EA \u098F \u09B0\u09BF\u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "enable_border_highlight_once": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "enable_border_highlight_once_desc": "\u0986\u09AA\u09A8\u09BE\u09B0 \u0987\u09A8\u09B2\u09BE\u0987\u09A8 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F\u09C7 \u098F\u0995\u099F\u09BF \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8\u0964 \u09AF\u09CB\u0997 \u0995\u09B0\u09BE HTML/CSS \u09A6\u09C0\u09B0\u09CD\u0998 \u09B9\u09AC\u09C7\u0964",
      "highlight_once_border_style": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B8\u09BE\u0987\u09A1\u09B8",
      "highlight_once_border_line_style": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B8\u09CD\u099F\u09BE\u0987\u09B2",
      "opt_border_full": "\u09AA\u09C2\u09B0\u09CD\u09A3 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 (\u09B8\u09AC \u09A6\u09BF\u0995)",
      "opt_border_top_bottom": "\u0989\u09AA\u09B0 \u098F\u09AC\u0982 \u09A8\u09BF\u099A\u09C7\u09B0 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_left_right": "\u09AC\u09BE\u09AE \u098F\u09AC\u0982 \u09A1\u09BE\u09A8 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_top_left_right": "\u0989\u09AA\u09B0, \u09AC\u09BE\u09AE \u098F\u09AC\u0982 \u09A1\u09BE\u09A8 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_bottom_left_right": "\u09A8\u09BF\u099A, \u09AC\u09BE\u09AE \u098F\u09AC\u0982 \u09A1\u09BE\u09A8 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_top_right": "\u0989\u09AA\u09B0 \u098F\u09AC\u0982 \u09A1\u09BE\u09A8 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_top_left": "\u0989\u09AA\u09B0 \u098F\u09AC\u0982 \u09AC\u09BE\u09AE \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_bottom_right": "\u09A8\u09BF\u099A \u098F\u09AC\u0982 \u09A1\u09BE\u09A8 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_bottom_left": "\u09A8\u09BF\u099A \u098F\u09AC\u0982 \u09AC\u09BE\u09AE \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_top": "\u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 \u0989\u09AA\u09B0\u09C7\u09B0 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_bottom": "\u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 \u09A8\u09BF\u099A\u09C7\u09B0 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_left": "\u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 \u09AC\u09BE\u09AE \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "opt_border_right": "\u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 \u09A1\u09BE\u09A8 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0",
      "highlight_once_border_opacity": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u0985\u09B8\u09CD\u09AA\u09B7\u09CD\u099F\u09A4\u09BE",
      "highlight_once_border_thickness": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09A5\u09BF\u0995\u09A8\u09C7\u09B8 (px)",
      "reset_to_1": "\u09E7 \u098F \u09B0\u09BF\u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "use_global_highlight_style": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u0997\u09CD\u09B2\u09CB\u09AC\u09BE\u09B2 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C1\u09A8",
      "use_global_highlight_style_desc": "\u0986\u09AA\u09A8\u09BE\u09B0 \u0997\u09CD\u09B2\u09CB\u09AC\u09BE\u09B2 \u0987\u09A8\u09B2\u09BE\u0987\u09A8 \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C7\u0964 \u09AF\u09CB\u0997 \u0995\u09B0\u09BE HTML/CSS \u09A6\u09C0\u09B0\u09CD\u0998 \u09B9\u09A4\u09C7 \u09AA\u09BE\u09B0\u09C7\u0964",
      "style_highlight_once": "\u098F\u0995\u09AC\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u0995\u09B0\u09C1\u09A8",
      "style_highlight_once_desc": "\u0986\u09AA\u09A8\u09BE\u09B0 \u0995\u09BE\u09B8\u09CD\u099F\u09AE \u0987\u09A8\u09B2\u09BE\u0987\u09A8 \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C7\u0964 \u09AF\u09CB\u0997 \u0995\u09B0\u09BE HTML/CSS \u09A6\u09C0\u09B0\u09CD\u0998 \u09B9\u09A4\u09C7 \u09AA\u09BE\u09B0\u09C7\u0964",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "\u0997\u09CD\u09B2\u09CB\u09AC\u09BE\u09B2 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u0985\u09CD\u09AF\u09BE\u09AA\u09BF\u09AF\u09BC\u09BE\u09B0\u09C7\u09A8\u09CD\u09B8",
      "highlight_opacity": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0985\u09B8\u09CD\u09AA\u09B7\u09CD\u099F\u09A4\u09BE",
      "highlight_opacity_desc": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F\u09C7\u09B0 \u0985\u09B8\u09CD\u09AA\u09B7\u09CD\u099F\u09A4\u09BE \u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8 (0-100%)",
      "highlight_border_radius": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B0\u09C7\u09A1\u09BF\u09AF\u09BC\u09BE\u09B8 (px)",
      "highlight_border_radius_desc": "\u0997\u09CB\u09B2 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09CB\u09A3\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B0\u09C7\u09A1\u09BF\u09AF\u09BC\u09BE\u09B8 \u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8 (px \u098F)",
      "highlight_horizontal_padding_desc": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09BE \u099F\u09C7\u0995\u09CD\u09B8\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09AC\u09BE\u09AE \u098F\u09AC\u0982 \u09A1\u09BE\u09A8 \u09AA\u09CD\u09AF\u09BE\u09A1\u09BF\u0982 \u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8 (px \u098F)",
      "highlight_vertical_padding_desc": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09BE \u099F\u09C7\u0995\u09CD\u09B8\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u0989\u09AA\u09B0\u09C7 \u098F\u09AC\u0982 \u09A8\u09BF\u099A\u09C7 \u09AA\u09CD\u09AF\u09BE\u09A1\u09BF\u0982 \u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8 (px \u098F)",
      "rounded_corners_wrapping": "\u09B2\u09BE\u0987\u09A8 \u09B0\u200D\u09CD\u09AF\u09BE\u09AA\u09BF\u0982\u09AF\u09BC\u09C7 \u0997\u09CB\u09B2\u09BE\u0995\u09BE\u09B0 \u0995\u09CB\u09A3",
      "rounded_corners_wrapping_desc": "\u09B8\u0995\u09CD\u09B7\u09AE \u09B9\u09B2\u09C7, \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F\u0997\u09C1\u09B2\u09BF\u09B0 \u09B8\u09AC \u09A6\u09BF\u0995\u09C7 \u0997\u09CB\u09B2\u09BE\u0995\u09BE\u09B0 \u0995\u09CB\u09A3 \u09A5\u09BE\u0995\u09AC\u09C7, \u098F\u09AE\u09A8\u0995\u09BF \u09AF\u0996\u09A8 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09A8\u09A4\u09C1\u09A8 \u09B2\u09BE\u0987\u09A8\u09C7 \u09B0\u200D\u09CD\u09AF\u09BE\u09AA \u09B9\u09AF\u09BC\u0964",
      "enable_highlight_border": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B8\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09C1\u09A8",
      "enable_highlight_border_desc": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F\u09C7\u09B0 \u099A\u09BE\u09B0\u09AA\u09BE\u09B6\u09C7 \u098F\u0995\u099F\u09BF \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8\u0964 \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0\u099F\u09BF \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09AC\u09BE \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B0\u0999\u09C7\u09B0 \u09B8\u09BE\u09A5\u09C7 \u09AE\u09BF\u09B2\u09AC\u09C7\u0964",
      "border_style": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B8\u09BE\u0987\u09A1\u09B8",
      "border_style_desc": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09AA\u09CD\u09B0\u09AF\u09BC\u09CB\u0997 \u0995\u09B0\u09A4\u09C7 \u0995\u09CB\u09A8 \u09A6\u09BF\u0995\u0997\u09C1\u09B2\u09BF \u09AC\u09C7\u099B\u09C7 \u09A8\u09BF\u09A8",
      "border_line_style": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B8\u09CD\u099F\u09BE\u0987\u09B2",
      "border_line_style_desc": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0\u09C7\u09B0 \u09B2\u09BE\u0987\u09A8 \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09AC\u09C7\u099B\u09C7 \u09A8\u09BF\u09A8",
      "border_opacity": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u0985\u09B8\u09CD\u09AA\u09B7\u09CD\u099F\u09A4\u09BE",
      "border_opacity_desc": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0\u09C7\u09B0 \u0985\u09B8\u09CD\u09AA\u09B7\u09CD\u099F\u09A4\u09BE \u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8 (0-100%)",
      "border_thickness": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09A5\u09BF\u0995\u09A8\u09C7\u09B8 (px)",
      "border_thickness_desc": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09A5\u09BF\u0995\u09A8\u09C7\u09B8 0-5 \u09AA\u09BF\u0995\u09CD\u09B8\u09C7\u09B2 \u09A5\u09C7\u0995\u09C7 \u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8 (\u09AF\u09C7\u09AE\u09A8 1, 2.5, 5)",
      "highlight_preview": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AA\u09CD\u09B0\u09BF\u09AD\u09BF\u0989",
      "highlight_preview_text": "\u0986\u09AA\u09A8\u09BE\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09C7\u09AE\u09A8 \u09A6\u09C7\u0996\u09BE\u09AC\u09C7 \u09A4\u09BE \u09A6\u09C7\u0996\u09C1\u09A8!",
      "opt_line_solid": "\u09B8\u09B2\u09BF\u09A1",
      "opt_line_dashed": "\u09A1\u09CD\u09AF\u09BE\u09B6\u09A1",
      "opt_line_dotted": "\u09A1\u099F\u09C7\u09A1",
      "opt_line_double": "\u09A1\u09BE\u09AC\u09B2",
      "opt_line_groove": "\u0997\u09CD\u09B0\u09C1\u09AD",
      "opt_line_ridge": "\u09B0\u09BF\u099C",
      "opt_line_inset": "\u0987\u09A8\u09B8\u09C7\u099F",
      "opt_line_outset": "\u0986\u0989\u099F\u09B8\u09C7\u099F",
      // Color Swatches
      "color_swatches_header": "\u09B0\u0999 \u09B8\u09CB\u09AF\u09BC\u09BE\u099A\u0997\u09C1\u09B2\u09BF",
      "color_picker_layout": "\u09B0\u0999 \u09AA\u09BF\u0995\u09BE\u09B0 \u09B2\u09C7\u0986\u0989\u099F",
      "color_picker_layout_desc": "\u099F\u09C7\u0995\u09CD\u09B8\u099F\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B0\u0999 \u09AA\u09BF\u0995 \u0995\u09B0\u09BE\u09B0 \u09B8\u09AE\u09AF\u09BC \u0995\u09CB\u09A8 \u09B0\u0999 \u099F\u09BE\u0987\u09AA \u09A6\u09C7\u0996\u09BE\u09A4\u09C7 \u09B9\u09AC\u09C7 \u09A4\u09BE \u09AC\u09C7\u099B\u09C7 \u09A8\u09BF\u09A8",
      "opt_both_text_left": "\u0989\u09AD\u09AF\u09BC: \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09AC\u09BE\u09AE, \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09A1\u09BE\u09A8",
      "opt_both_bg_left": "\u0989\u09AD\u09AF\u09BC: \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09BE\u09AE, \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09A1\u09BE\u09A8",
      "opt_both_text_top": "\u0989\u09AD\u09AF\u09BC (\u09AD\u09BE\u09B0\u09CD\u099F\u09BF\u0995\u09BE\u09B2): \u099F\u09C7\u0995\u09CD\u09B8\u099F \u0989\u09AA\u09B0\u09C7, \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09A8\u09BF\u099A\u09C7",
      "opt_both_bg_top": "\u0989\u09AD\u09AF\u09BC (\u09AD\u09BE\u09B0\u09CD\u099F\u09BF\u0995\u09BE\u09B2): \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0989\u09AA\u09B0\u09C7, \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09A8\u09BF\u099A\u09C7",
      "opt_text_only": "\u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999",
      "opt_background_only": "\u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B0\u0999",
      "replace_default_swatches": "\u09A1\u09BF\u09AB\u09B2\u09CD\u099F \u09B8\u09CB\u09AF\u09BC\u09BE\u099A\u0997\u09C1\u09B2\u09BF \u09AA\u09CD\u09B0\u09A4\u09BF\u09B8\u09CD\u09A5\u09BE\u09AA\u09A8 \u0995\u09B0\u09C1\u09A8",
      "replace_default_swatches_desc": "\u098F\u099F\u09BF \u099A\u09BE\u09B2\u09C1 \u09A5\u09BE\u0995\u09B2\u09C7, \u0995\u09C7\u09AC\u09B2 \u0986\u09AA\u09A8\u09BE\u09B0 \u0995\u09BE\u09B8\u09CD\u099F\u09AE \u09B0\u0999\u0997\u09C1\u09B2\u09BF \u0995\u09BE\u09B2\u09BE\u09B0 \u09AA\u09BF\u0995\u09BE\u09B0\u09C7 \u09A6\u09C7\u0996\u09BE\u09AC\u09C7\u0964 \u0995\u09CB\u09A8\u09CB \u09A1\u09BF\u09AB\u09B2\u09CD\u099F \u09B0\u0999 \u09A8\u09AF\u09BC!",
      "enable_custom_swatches": "\u0995\u09BE\u09B8\u09CD\u099F\u09AE \u09B8\u09CB\u09AF\u09BC\u09BE\u099A\u0997\u09C1\u09B2\u09BF \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09C1\u09A8",
      "enable_custom_swatches_desc": "\u098F\u099F\u09BF \u099A\u09BE\u09B2\u09C1 \u09A5\u09BE\u0995\u09B2\u09C7, \u0986\u09AA\u09A8\u09BE\u09B0 \u0995\u09BE\u09B8\u09CD\u099F\u09AE \u09B8\u09CB\u09AF\u09BC\u09BE\u099A\u0997\u09C1\u09B2\u09BF \u0995\u09BE\u09B2\u09BE\u09B0 \u09AA\u09BF\u0995\u09BE\u09B0\u09C7 \u09A6\u09C7\u0996\u09BE\u09AC\u09C7\u0964",
      "use_swatch_names": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999\u09BE\u09AF\u09BC\u09A8\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B8\u09CB\u09AF\u09BC\u09BE\u099A \u09A8\u09BE\u09AE \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C1\u09A8",
      "use_swatch_names_desc": "\u09B6\u09AC\u09CD\u09A6/\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u0987\u09A8\u09AA\u09C1\u099F\u09C7\u09B0 \u09AA\u09BE\u09B6\u09C7 \u09B8\u09CB\u09AF\u09BC\u09BE\u099A \u09A8\u09BE\u09AE\u09C7\u09B0 \u09A1\u09CD\u09B0\u09AA\u09A1\u09BE\u0989\u09A8 \u09A6\u09C7\u0996\u09BE\u09A8",
      "link_swatches_to_entries": "\u09B8\u09CB\u09AF\u09BC\u09BE\u099A \u0986\u09AA\u09A1\u09C7\u099F\u0995\u09C7 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999\u09C7\u09B0 \u09B8\u09BE\u09A5\u09C7 \u09B2\u09BF\u0982\u0995 \u0995\u09B0\u09C1\u09A8",
      "link_swatches_to_entries_desc": "\u0995\u09BE\u09B8\u09CD\u099F\u09AE \u09B8\u09CB\u09AF\u09BC\u09BE\u099A\u09C7\u09B0 \u09B0\u0999 \u09AA\u09B0\u09BF\u09AC\u09B0\u09CD\u09A4\u09A8 \u09B9\u09B2\u09C7, \u09B8\u09C7\u0987 \u09B0\u0999 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09BE \u09B8\u09AC \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u0986\u09AA\u09A1\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "default_colors_header": "\u09A1\u09BF\u09AB\u09B2\u09CD\u099F \u09B8\u09CB\u09AF\u09BC\u09BE\u099A",
      "custom_swatches_header": "\u0995\u09BE\u09B8\u09CD\u099F\u09AE \u09B8\u09CB\u09AF\u09BC\u09BE\u099A\u0997\u09C1\u09B2\u09BF",
      "btn_add_color": "+ \u09B0\u0999 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "no_custom_swatches_yet": '\u098F\u0996\u09A8\u09CB \u0995\u09CB\u09A8\u09CB \u0995\u09BE\u09B8\u09CD\u099F\u09AE \u09B8\u09CB\u09AF\u09BC\u09BE\u099A \u09A8\u09C7\u0987\u0964 \u09A4\u09C8\u09B0\u09BF \u0995\u09B0\u09A4\u09C7 "+ \u09B0\u0999 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8" \u0995\u09CD\u09B2\u09BF\u0995 \u0995\u09B0\u09C1\u09A8\u0964',
      "label_built_in": "(\u09AC\u09BF\u09B2\u09CD\u099F-\u0987\u09A8)",
      // Color Picker
      "pick_color_header": "\u09B0\u0999 \u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09A8 \u0995\u09B0\u09C1\u09A8",
      "selected_text_preview": "\u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F",
      "text_color_title": "\u099F\u09C7\u0995\u09CD\u09B8\u099F\u09C7\u09B0 \u09B0\u0999",
      "select_swatch": "\u09B8\u09CB\u09AF\u09BC\u09BE\u099A \u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "highlight_color_title": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F\u09C7\u09B0 \u09B0\u0999",
      "select_highlight_swatch": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CB\u09AF\u09BC\u09BE\u099A \u09A8\u09BF\u09B0\u09CD\u09AC\u09BE\u099A\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "settings_tab_general": "\u09B8\u09BE\u09A7\u09BE\u09B0\u09A3",
      "settings_tab_colored_texts": "\u09B0\u0999\u09BE\u09AF\u09BC\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F",
      "settings_tab_blacklists": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F",
      "settings_tab_file_folder_rules": "\u09AB\u09BE\u0987\u09B2 / \u09AB\u09CB\u09B2\u09CD\u09A1\u09BE\u09B0 \u09A8\u09BF\u09AF\u09BC\u09AE",
      "settings_tab_data": "\u09A1\u09C7\u099F\u09BE",
      // Always Colored Texts
      "always_colored_texts_header": "\u09B8\u09B0\u09CD\u09AC\u09A6\u09BE \u09B0\u0999 \u0995\u09B0\u09BE \u099F\u09C7\u0995\u09CD\u09B8\u099F\u0997\u09C1\u09B2\u09BF",
      "always_colored_texts_desc": "\u098F\u0996\u09BE\u09A8\u09C7\u0987 \u0986\u09AA\u09A8\u09BF \u0986\u09AA\u09A8\u09BE\u09B0 \u09B6\u09AC\u09CD\u09A6/\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u098F\u09AC\u0982 \u09A4\u09BE\u09A6\u09C7\u09B0 \u09B0\u0999\u0997\u09C1\u09B2\u09BF \u09AE\u09CD\u09AF\u09BE\u09A8\u09C7\u099C \u0995\u09B0\u09C7\u09A8\u0964",
      "colored_texts_header": "\u09B0\u0999\u09BE\u09AF\u09BC\u09BF\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F",
      "grouped_entries_header": "\u0997\u09CD\u09B0\u09C1\u09AA \u0995\u09B0\u09BE \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF",
      "grouped_entries_desc": "\u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA\u0997\u09C1\u09B2\u09BF\u0995\u09C7 \u09AA\u09B0\u09BF\u099A\u09BE\u09B2\u09A8\u09BE \u0995\u09B0\u09C1\u09A8\u0964 \u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u09A8\u09BE\u09AE \u09A6\u09CD\u09AC\u09BE\u09B0\u09BE \u09AB\u09BF\u09B2\u09CD\u099F\u09BE\u09B0 \u0995\u09B0\u09C7\u0964",
      "search_groups_placeholder": "\u0997\u09CD\u09B0\u09C1\u09AA \u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "edit_word_group_modal_title": "\u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE",
      "btn_save_group": "\u0997\u09CD\u09B0\u09C1\u09AA \u09B8\u0982\u09B0\u0995\u09CD\u09B7\u09A3 \u0995\u09B0\u09C1\u09A8",
      "btn_delete_group": "\u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09C1\u09A8",
      "group_active_label": "\u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC",
      "group_inactive_label": "\u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC",
      "tooltip_duplicate_group": "\u0997\u09CD\u09B0\u09C1\u09AA \u09A1\u09C1\u09AA\u09CD\u09B2\u09BF\u0995\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "tooltip_edit_group_settings": "\u0997\u09CD\u09B0\u09C1\u09AA \u09B8\u09C7\u099F\u09BF\u0982\u09B8 \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "tooltip_delete_all_groups": "\u09B8\u09AC \u09B6\u09AC\u09CD\u09A6 \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09C7 \u09AB\u09C7\u09B2\u09C1\u09A8",
      "btn_create_new_group": "+ \u09A8\u09A4\u09C1\u09A8 \u0997\u09CD\u09B0\u09C1\u09AA \u09A4\u09C8\u09B0\u09BF \u0995\u09B0\u09C1\u09A8",
      "no_entries_found": "\u0995\u09CB\u09A8\u09CB \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09AA\u09BE\u0993\u09AF\u09BC\u09BE \u09AF\u09BE\u09AF\u09BC\u09A8\u09BF\u0964",
      "search_colored_words_placeholder": "\u09B0\u0999 \u0995\u09B0\u09BE \u09B6\u09AC\u09CD\u09A6/\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "sort_label_last-added": "\u09B8\u09B0\u09CD\u099F: \u09B8\u09B0\u09CD\u09AC\u09B6\u09C7\u09B7 \u09AF\u09CB\u0997",
      "sort_label_a-z": "\u09B8\u09B0\u09CD\u099F: A-Z",
      "sort_label_reverse-a-z": "\u09B8\u09B0\u09CD\u099F: Z-A",
      "sort_label_style-order": "\u09B8\u09B0\u09CD\u099F: \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u0985\u09B0\u09CD\u09A1\u09BE\u09B0",
      "sort_label_color": "\u09B8\u09B0\u09CD\u099F: \u09B0\u0999",
      "btn_add_new_word": "+ \u09A8\u09A4\u09C1\u09A8 \u09B0\u0999\u09BE\u09AF\u09BC\u09BF\u09A4 \u09B6\u09AC\u09CD\u09A6 / \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "style_type_text": "\u09B0\u0999",
      "style_type_highlight": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F",
      "style_type_both": "\u0989\u09AD\u09AF\u09BC",
      "word_pattern_placeholder_long": "\u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8, \u09B6\u09AC\u09CD\u09A6 \u09AC\u09BE \u0995\u09AE\u09BE \u09A6\u09CD\u09AC\u09BE\u09B0\u09BE \u09AA\u09C3\u09A5\u0995 \u0995\u09B0\u09BE \u09B6\u09AC\u09CD\u09A6 (\u09AF\u09C7\u09AE\u09A8 hello, world, foo)",
      "word_pattern_placeholder_short": "\u0995\u09C0\u0993\u09AF\u09BC\u09BE\u09B0\u09CD\u09A1 \u09AC\u09BE \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8, \u09AC\u09BE \u0995\u09AE\u09BE \u09A6\u09CD\u09AC\u09BE\u09B0\u09BE \u09AA\u09C3\u09A5\u0995 \u0995\u09B0\u09BE \u09B6\u09AC\u09CD\u09A6",
      "use_regex": "\u09B0\u09C7\u0997\u09C7\u0995\u09CD\u09B8 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09C1\u09A8",
      "flags_placeholder": "\u09AB\u09CD\u09B2\u09CD\u09AF\u09BE\u0997\u09CD\u09B8",
      "text_or_regex_placeholder": "\u099F\u09C7\u0995\u09CD\u09B8\u099F / \u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u0987\u09A8\u09AA\u09C1\u099F",
      "duplicate_entry": "\u09A1\u09C1\u09AA\u09CD\u09B2\u09BF\u0995\u09C7\u099F \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF",
      "open_in_regex_tester": "\u09B0\u09C7\u099C\u09C7\u0995\u09CD\u09B8 \u099F\u09C7\u09B8\u09CD\u099F\u09BE\u09B0\u09C7 \u0996\u09C1\u09B2\u09C1\u09A8",
      "no_rules_configured": "\u0995\u09CB\u09A8\u09CB \u09A8\u09BF\u09AF\u09BC\u09AE \u0995\u09A8\u09AB\u09BF\u0997\u09BE\u09B0 \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09A8\u09BF\u0964",
      "no_rules_found": "\u0995\u09CB\u09A8\u09CB \u09A8\u09BF\u09AF\u09BC\u09AE \u09AA\u09BE\u0993\u09AF\u09BC\u09BE \u09AF\u09BE\u09AF\u09BC\u09A8\u09BF\u0964",
      "match_option_exact": "\u09B8\u09A0\u09BF\u0995",
      "match_option_contains": "\u09A7\u09BE\u09B0\u09A3 \u0995\u09B0\u09C7",
      "match_option_starts_with": "\u09B6\u09C1\u09B0\u09C1 \u09B9\u09AF\u09BC",
      "match_option_ends_with": "\u09B6\u09C7\u09B7 \u09B9\u09AF\u09BC",
      // Presets
      "btn_presets": "\u09AA\u09CD\u09B0\u09BF\u09B8\u09C7\u099F\u0997\u09C1\u09B2\u09BF",
      "preset_all_headings": "\u09B8\u09AC \u09B6\u09BF\u09B0\u09CB\u09A8\u09BE\u09AE (H1-H6)",
      "preset_bullet_points": "\u09AC\u09C1\u09B2\u09C7\u099F \u09AA\u09AF\u09BC\u09C7\u09A8\u09CD\u099F\u0997\u09C1\u09B2\u09BF",
      "preset_numbered_lists": "\u09B8\u0982\u0996\u09CD\u09AF\u09BE\u09AF\u09BC\u09BF\u09A4 \u09A4\u09BE\u09B2\u09BF\u0995\u09BE\u0997\u09C1\u09B2\u09BF",
      "preset_task_checked": "\u099F\u09BE\u09B8\u09CD\u0995 \u09B2\u09BF\u09B8\u09CD\u099F (\u099A\u09C7\u0995 \u0995\u09B0\u09BE)",
      "preset_task_unchecked": "\u099F\u09BE\u09B8\u09CD\u0995 \u09B2\u09BF\u09B8\u09CD\u099F (\u0985\u099A\u09C7\u0995 \u0995\u09B0\u09BE)",
      "preset_dates_yyyy_mm_dd": "\u09A4\u09BE\u09B0\u09BF\u0996 (YYYY-MM-DD)",
      "preset_times_am_pm": "\u09B8\u09AE\u09AF\u09BC (AM/PM)",
      "preset_times_24h": "\u09B8\u09AE\u09AF\u09BC (24h)",
      "preset_dates_yyyy_mmm_dd": "\u09A4\u09BE\u09B0\u09BF\u0996 (YYYY-MMM-DD)",
      "preset_relative_dates": "\u0986\u09AA\u09C7\u0995\u09CD\u09B7\u09BF\u0995 \u09A4\u09BE\u09B0\u09BF\u0996",
      "preset_basic_urls": "\u09AC\u09C7\u09B8\u09BF\u0995 URL",
      "preset_markdown_links": "\u09AE\u09BE\u09B0\u09CD\u0995\u09A1\u09BE\u0989\u09A8 \u09B2\u09BF\u0982\u0995",
      "preset_domain_names": "\u09A1\u09CB\u09AE\u09C7\u0987\u09A8 \u09A8\u09BE\u09AE",
      "preset_email_addresses": "\u0987\u09AE\u09C7\u0987\u09B2 \u09A0\u09BF\u0995\u09BE\u09A8\u09BE",
      "preset_at_username": "@\u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0\u0995\u09BE\u09B0\u09C0\u09B0 \u09A8\u09BE\u09AE",
      "preset_currency": "\u09AE\u09C1\u09A6\u09CD\u09B0\u09BE",
      "preset_measurements": "\u09AA\u09B0\u09BF\u09AE\u09BE\u09AA",
      "preset_phone_numbers": "\u09AB\u09CB\u09A8 \u09A8\u09AE\u09CD\u09AC\u09B0",
      "preset_all_texts": "\u09B8\u09AC \u099F\u09C7\u0995\u09CD\u09B8\u099F",
      "preset_codeblocks": "\u0995\u09CB\u09A1\u09AC\u09CD\u09B2\u0995",
      "preset_inline_comments": "\u09AE\u09A8\u09CD\u09A4\u09AC\u09CD\u09AF (%%\u2026%%)",
      "preset_highlighted_text": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u099F\u09C7\u0995\u09CD\u09B8\u099F (==...==)",
      "preset_parentheses": "\u09AC\u09A8\u09CD\u09A7\u09A8\u09C0 ()",
      "preset_square_brackets": "\u09AC\u09B0\u09CD\u0997 \u09AC\u09A8\u09CD\u09A7\u09A8\u09C0 []",
      "preset_curly_braces": "\u0995\u09BE\u09B0\u09CD\u09B2\u09BF \u09AC\u09CD\u09B0\u09C7\u09B8\u09C7\u09B8 {}",
      "preset_angle_brackets": "\u0995\u09CB\u09A3 \u09AC\u09A8\u09CD\u09A7\u09A8\u09C0 <>",
      "preset_colons": "\u0995\u09CB\u09B2\u09A8 :",
      "preset_double_quotes": "\u09A1\u09BE\u09AC\u09B2 \u0995\u09CB\u099F",
      "preset_single_quotes": "\u09B8\u09BF\u0999\u09CD\u0997\u09C7\u09B2 \u0995\u09CB\u099F\u09B8",
      "preset_single_quotes_word_bounded": "\u09B8\u09BF\u0999\u09CD\u0997\u09C7\u09B2 \u0995\u09CB\u099F\u09B8 (\u09B6\u09AC\u09CD\u09A6-\u09B8\u09C0\u09AE\u09BF\u09A4)",
      "preset_group_markdown_formatting": "\u09AE\u09BE\u09B0\u09CD\u0995\u09A1\u09BE\u0989\u09A8 \u09B8\u09CD\u0995\u09C3\u09AA\u09CD\u09A4",
      "preset_group_other_patterns": "\u0985\u09A8\u09CD\u09AF \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8",
      "preset_group_brackets": "\u09AC\u09A8\u09CD\u09A7\u09A8\u09C0",
      // Preset Examples
      "preset_example_heading": "# \u09B6\u09BF\u09B0\u09CB\u09A8\u09BE\u09AE",
      "preset_example_bullet": "- \u09AA\u09AF\u09BC\u09C7\u09A8\u09CD\u099F",
      "preset_example_numbered": "1. \u09AA\u09CD\u09B0\u09A5\u09AE \u0986\u0987\u099F\u09C7\u09AE",
      "preset_example_task_checked": "- [x] \u09B8\u09AE\u09CD\u09AA\u09A8\u09CD\u09A8",
      "preset_example_task_unchecked": "- [ ] \u0995\u09B0\u09A3\u09C0\u09AF\u09BC",
      "preset_example_codeblock": "``` \u0995\u09CB\u09A1 ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[\u09B2\u09BF\u0999\u09CD\u0995](https://example.com)",
      "preset_example_comment": "%% \u09AE\u09A8\u09CD\u09A4\u09AC\u09CD\u09AF %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "name@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "$29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( \u09AA\u09BE\u09A0\u09CD\u09AF )",
      "preset_example_square_brackets": "[ \u09B9\u09CD\u09AF\u09BE\u0981 ]",
      "preset_example_curly_braces": "{ \u09A8\u09BE }",
      "preset_example_angle_brackets": "< \u09AA\u09BE\u09A0\u09CD\u09AF >",
      "preset_example_colons": ": \u09AA\u09BE\u09A0\u09CD\u09AF :",
      "preset_example_double_quotes": '"\u09AA\u09BE\u09A0\u09CD\u09AF"',
      "preset_example_single_quotes": "'\u09AA\u09BE\u09A0\u09CD\u09AF'",
      "preset_example_single_quotes_word": "'\u09B6\u09AC\u09CD\u09A6'",
      "preset_example_highlight": "==\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0995\u09B0\u09BE \u099F\u09C7\u0995\u09CD\u09B8\u099F==",
      "preset_example_all_text": "\u098F\u099F\u09BF \u09B8\u09AE\u09B8\u09CD\u09A4 \u09AA\u09BE\u09A0\u09CD\u09AF\u0995\u09C7 \u09B2\u0995\u09CD\u09B7\u09CD\u09AF \u0995\u09B0\u09AC\u09C7\u0964",
      // Blacklist Settings
      "blacklist_words_header": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u09B6\u09AC\u09CD\u09A6\u0997\u09C1\u09B2\u09BF",
      "blacklist_words_desc": "\u098F\u0996\u09BE\u09A8\u09C7\u09B0 \u0995\u09C0\u0993\u09AF\u09BC\u09BE\u09B0\u09CD\u09A1 \u09AC\u09BE \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8\u0997\u09C1\u09B2\u09BF \u0995\u0996\u09A8\u0993 \u09B0\u0999 \u0995\u09B0\u09BE \u09B9\u09AC\u09C7 \u09A8\u09BE, \u098F\u09AE\u09A8\u0995\u09BF \u0986\u0982\u09B6\u09BF\u0995 \u09AE\u09CD\u09AF\u09BE\u099A\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF\u0993\u0964",
      "search_blacklist_placeholder": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0995\u09B0\u09BE \u09B6\u09AC\u09CD\u09A6 \u09AC\u09BE \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "blacklist_sort_label_last-added": "\u09B8\u09B0\u09CD\u099F: \u09B8\u09B0\u09CD\u09AC\u09B6\u09C7\u09B7 \u09AF\u09CB\u0997",
      "blacklist_sort_label_a-z": "\u09B8\u09B0\u09CD\u099F: A-Z",
      "blacklist_sort_label_reverse-a-z": "\u09B8\u09B0\u09CD\u099F: Z-A",
      "btn_add_blacklist": "+ \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u09B6\u09AC\u09CD\u09A6 \u09AC\u09BE \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_add_to_blacklist": "+ \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_add_blacklist_word": "+ \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7 \u09B6\u09AC\u09CD\u09A6 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_add_blacklist_regex": "+ \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7 \u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      // File & Folder Rules
      "file_folder_rules_header": "\u09AB\u09BE\u0987\u09B2 \u0993 \u09AB\u09CB\u09B2\u09CD\u09A1\u09BE\u09B0 \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09B0\u09C1\u09B2\u09B8",
      "file_folder_rules_desc": "\u09A8\u09BE\u09AE \u09AE\u09CD\u09AF\u09BE\u099A\u09BF\u0982, \u09B8\u09A0\u09BF\u0995 \u09AA\u09BE\u09A5, \u09AC\u09BE \u09B0\u09C7\u0997\u09C7\u0995\u09CD\u09B8 \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09A6\u09BF\u09AF\u09BC\u09C7 \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u0995\u09A8\u09CD\u099F\u09CD\u09B0\u09CB\u09B2 \u0995\u09B0\u09C1\u09A8\u0964 \u09AD\u09B2\u09CD\u099F-\u0993\u09AF\u09BC\u09BE\u0987\u09A1 \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u0985\u0995\u09CD\u09B7\u09AE \u0995\u09B0\u09A4\u09C7 \u098F\u0995\u099F\u09BF \u09AB\u09BE\u0981\u0995\u09BE \u098F\u0995\u09CD\u09B8\u0995\u09CD\u09B2\u09C1\u09A1 \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09B0\u09BE\u0996\u09C1\u09A8\u0964",
      "search_file_folder_rules_placeholder": "\u09AB\u09BE\u0987\u09B2/\u09AB\u09CB\u09B2\u09CD\u09A1\u09BE\u09B0 \u09B0\u09C1\u09B2\u09B8 \u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "path_sort_label_last-added": "\u09B8\u09B0\u09CD\u099F: \u09B8\u09B0\u09CD\u09AC\u09B6\u09C7\u09B7 \u09AF\u09CB\u0997",
      "path_sort_label_a-z": "\u09B8\u09B0\u09CD\u099F: A-Z",
      "path_sort_label_reverse-a-z": "\u09B8\u09B0\u09CD\u099F: Z-A",
      "path_sort_label_mode": "\u09B8\u09B0\u09CD\u099F: \u09AE\u09CB\u09A1",
      "path_sort_label_type": "\u09B8\u09B0\u09CD\u099F: \u099F\u09BE\u0987\u09AA",
      "btn_add_file_folder_rule": "+ \u09AB\u09BE\u0987\u09B2/\u09AB\u09CB\u09B2\u09CD\u09A1\u09BE\u09B0 \u09B0\u09C1\u09B2 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "disabled_files_header": "\u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09BE \u09AB\u09BE\u0987\u09B2\u0997\u09C1\u09B2\u09BF:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "\u0985\u09A8\u09CD\u09A4\u09B0\u09CD\u09AD\u09C1\u0995\u09CD\u09A4",
      "path_rule_mode_exclude": "\u09AC\u09BE\u09A6 \u09A6\u09BF\u09A8",
      "text_rule_mode_include": "\u09B6\u09C1\u09A7\u09C1\u09AE\u09BE\u09A4\u09CD\u09B0 (\u09B9\u09CB\u09AF\u09BC\u09BE\u0987\u099F\u09B2\u09BF\u09B8\u09CD\u099F\u09C7) \u09B0\u0999 \u0995\u09B0\u09C1\u09A8",
      "text_rule_mode_exclude": "(\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F\u09C7) \u09B0\u0999 \u0995\u09B0\u09AC\u09C7\u09A8 \u09A8\u09BE",
      "mode_only_colors_in": "\u09B6\u09C1\u09A7\u09C1 \u098F\u09B0 \u09AE\u09A7\u09CD\u09AF\u09C7 \u09B0\u0999 \u0995\u09B0\u09C7",
      "mode_does_not_color_in": "\u098F\u09B0 \u09AE\u09A7\u09CD\u09AF\u09C7 \u09B0\u0999 \u0995\u09B0\u09C7 \u09A8\u09BE",
      "label_text_include": "\u09B9\u09CB\u09AF\u09BC\u09BE\u0987\u099F\u09B2\u09BF\u09B8\u09CD\u099F",
      "label_text_exclude": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F",
      "label_enable_in": "\u098F\u09A4\u09C7 \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09C1\u09A8",
      "label_disable_in": "\u098F\u09A4\u09C7 \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09C1\u09A8",
      "enter_path_or_pattern": "\u09AA\u09BE\u09A5, \u09AA\u09CD\u09AF\u09BE\u099F\u09BE\u09B0\u09CD\u09A8 \u09AC\u09BE \u099F\u09CD\u09AF\u09BE\u0997 \u09B2\u09BF\u0996\u09C1\u09A8",
      "label_regex": "\u09B0\u09C7\u099C\u09C7\u0995\u09CD\u09B8",
      // Advanced Rules
      "advanced_rules_header": "\u09A8\u09BF\u09B0\u09CD\u09A6\u09BF\u09B7\u09CD\u099F \u0985\u09A8\u09CD\u09A4\u09B0\u09CD\u09AD\u09C1\u0995\u09CD\u09A4\u09BF/\u09AC\u09B0\u09CD\u099C\u09A8 \u09A8\u09BF\u09AF\u09BC\u09AE",
      "advanced_rules_modal_header": "\u09A8\u09BF\u09B0\u09CD\u09A6\u09BF\u09B7\u09CD\u099F \u0985\u09A8\u09CD\u09A4\u09B0\u09CD\u09AD\u09C1\u0995\u09CD\u09A4\u09BF/\u09AC\u09B0\u09CD\u099C\u09A8 \u09A8\u09BF\u09AF\u09BC\u09AE",
      "advanced_rules_manage_button": "\u09A8\u09BF\u09B0\u09CD\u09A6\u09BF\u09B7\u09CD\u099F \u0985\u09A8\u09CD\u09A4\u09B0\u09CD\u09AD\u09C1\u0995\u09CD\u09A4\u09BF/\u09AC\u09B0\u09CD\u099C\u09A8 \u09A8\u09BF\u09AF\u09BC\u09AE \u09AA\u09B0\u09BF\u099A\u09BE\u09B2\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "edit_rule_header": "\u09A8\u09BF\u09AF\u09BC\u09AE \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "add_rule_header": "\u09A8\u09A4\u09C1\u09A8 \u09A8\u09BF\u09AF\u09BC\u09AE \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_add_rule": "+ \u09A8\u09BF\u09AF\u09BC\u09AE \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_save_rule": "\u09A8\u09BF\u09AF\u09BC\u09AE \u09B8\u0982\u09B0\u0995\u09CD\u09B7\u09A3 \u0995\u09B0\u09C1\u09A8",
      "btn_add_words": "+ \u09B6\u09AC\u09CD\u09A6 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_add_regex": "+ \u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_save_regex": "\u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09B8\u0982\u09B0\u0995\u09CD\u09B7\u09A3 \u0995\u09B0\u09C1\u09A8",
      // Regex Tester
      "regex_tester_header": "\u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09AA\u09B0\u09C0\u0995\u09CD\u09B7\u0995",
      "regex_tester_blacklist": "\u09B0\u09C7\u099C\u09C7\u0995\u09CD\u09B8 \u099F\u09C7\u09B8\u09CD\u099F\u09BE\u09B0 - \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F",
      "regex_expression_placeholder": "\u0986\u09AA\u09A8\u09BE\u09B0 \u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u0985\u09AD\u09BF\u09AC\u09CD\u09AF\u0995\u09CD\u09A4\u09BF \u098F\u0996\u09BE\u09A8\u09C7 \u09B0\u09BE\u0996\u09C1\u09A8",
      "regex_subject_placeholder": "\u098F\u0996\u09BE\u09A8\u09C7 \u09AA\u09B0\u09C0\u0995\u09CD\u09B7\u09BE \u0995\u09B0\u09BE\u09B0 \u09AC\u09BF\u09B7\u09AF\u09BC \u099F\u09BE\u0987\u09AA \u0995\u09B0\u09C1\u09A8...",
      "regex_name_placeholder": "\u0986\u09AA\u09A8\u09BE\u09B0 \u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8\u09C7\u09B0 \u09A8\u09BE\u09AE \u09A6\u09BF\u09A8",
      "matches": "\u09AE\u09C7\u09B2",
      "matches_found": "\u09AE\u09C7\u09B2 \u09AA\u09BE\u0993\u09AF\u09BC\u09BE \u0997\u09C7\u099B\u09C7",
      // Regex Flags
      "flag_g": "\u0997\u09CD\u09B2\u09CB\u09AC\u09BE\u09B2 \u09AB\u09CD\u09B2\u09CD\u09AF\u09BE\u0997: \u09B8\u09AE\u09B8\u09CD\u09A4 \u09AE\u09C7\u09B2 \u0996\u09C1\u0981\u099C\u09C1\u09A8",
      "flag_i": "\u0995\u09C7\u09B8-\u0985\u09B8\u0982\u09AC\u09C7\u09A6\u09A8\u09B6\u09C0\u09B2 \u09AB\u09CD\u09B2\u09CD\u09AF\u09BE\u0997",
      "flag_m": "\u09AE\u09BE\u09B2\u09CD\u099F\u09BF\u09B2\u09BE\u0987\u09A8 \u09AB\u09CD\u09B2\u09CD\u09AF\u09BE\u0997: ^ \u098F\u09AC\u0982 $ \u09B2\u09BE\u0987\u09A8 \u09B8\u09C0\u09AE\u09BE\u09A8\u09BE\u09B0 \u09B8\u09BE\u09A5\u09C7 \u09AE\u09C7\u09B2 \u0996\u09BE\u09AF\u09BC",
      "flag_s": "dotAll \u09AB\u09CD\u09B2\u09CD\u09AF\u09BE\u0997: . \u09A8\u09A4\u09C1\u09A8 \u09B2\u09BE\u0987\u09A8\u0997\u09C1\u09B2\u09BF\u09B0 \u09B8\u09BE\u09A5\u09C7 \u09AE\u09C7\u09B2 \u0996\u09BE\u09AF\u09BC",
      "flag_u": "\u0987\u0989\u09A8\u09BF\u0995\u09CB\u09A1 \u09AB\u09CD\u09B2\u09CD\u09AF\u09BE\u0997: \u0987\u0989\u09A8\u09BF\u0995\u09CB\u09A1 \u0995\u09CB\u09A1 \u09AA\u09AF\u09BC\u09C7\u09A8\u09CD\u099F \u09B9\u09BF\u09B8\u09BE\u09AC\u09C7 \u09AC\u09BF\u09AC\u09C7\u099A\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "flag_y": "\u09B8\u09CD\u099F\u09BF\u0995\u09BF \u09AB\u09CD\u09B2\u09CD\u09AF\u09BE\u0997: lastIndex \u0985\u09AC\u09B8\u09CD\u09A5\u09BE\u09A8 \u09A5\u09C7\u0995\u09C7 \u09AE\u09C7\u09B2 \u0996\u09BE\u09A8",
      // Data Export/Import
      "data_export_import_header": "\u09A1\u09C7\u099F\u09BE \u098F\u0995\u09CD\u09B8\u09AA\u09CB\u09B0\u09CD\u099F/\u0987\u09AE\u09CD\u09AA\u09CB\u09B0\u09CD\u099F",
      "export_plugin_data": "\u09AA\u09CD\u09B2\u09BE\u0997\u0987\u09A8 \u09A1\u09C7\u099F\u09BE \u098F\u0995\u09CD\u09B8\u09AA\u09CB\u09B0\u09CD\u099F \u0995\u09B0\u09C1\u09A8",
      "export_plugin_data_desc": "\u09B8\u09C7\u099F\u09BF\u0982\u09B8, \u09B6\u09AC\u09CD\u09A6 \u098F\u09AC\u0982 \u09B0\u09C1\u09B2\u0997\u09C1\u09B2\u09BF \u098F\u0995\u099F\u09BF JSON \u09AB\u09BE\u0987\u09B2\u09C7 \u098F\u0995\u09CD\u09B8\u09AA\u09CB\u09B0\u09CD\u099F \u0995\u09B0\u09C1\u09A8\u0964",
      "btn_export": "\u098F\u0995\u09CD\u09B8\u09AA\u09CB\u09B0\u09CD\u099F",
      "import_plugin_data": "\u09AA\u09CD\u09B2\u09BE\u0997\u0987\u09A8 \u09A1\u09C7\u099F\u09BE \u0987\u09AE\u09CD\u09AA\u09CB\u09B0\u09CD\u099F \u0995\u09B0\u09C1\u09A8",
      "import_plugin_data_desc": "\u098F\u0995\u099F\u09BF JSON \u09AB\u09BE\u0987\u09B2 \u09A5\u09C7\u0995\u09C7 \u09B8\u09C7\u099F\u09BF\u0982\u09B8 \u0987\u09AE\u09CD\u09AA\u09CB\u09B0\u09CD\u099F \u0995\u09B0\u09C1\u09A8",
      "btn_import": "\u0987\u09AE\u09CD\u09AA\u09CB\u09B0\u09CD\u099F",
      "limit_input_placeholder": "\u09B8\u09C0\u09AE\u09BE",
      "limit_input_tooltip": "0=\u09B8\u09AC; \u09B8\u0982\u0996\u09CD\u09AF\u09BE=\u09B6\u09C7\u09B7 N; r=\u09B6\u09C1\u09A7\u09C1 \u09B0\u09C7\u099C\u09C7\u0995\u09CD\u09B8; h=\u09B6\u09C1\u09A7\u09C1 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F; c=\u09B6\u09C1\u09A7\u09C1 \u099F\u09C7\u0995\u09CD\u09B8\u099F; b=\u099F\u09C7\u0995\u09CD\u09B8\u099F+\u09AC\u09CD\u09AF\u09BE\u0995\u0997\u09CD\u09B0\u09BE\u0989\u09A8\u09CD\u09A1; sw=\u09A6\u09BF\u09AF\u09BC\u09C7 \u09B6\u09C1\u09B0\u09C1; ew=\u09A6\u09BF\u09AF\u09BC\u09C7 \u09B6\u09C7\u09B7; e=\u09B8\u09A0\u09BF\u0995",
      // Missing Keys Added
      "highlight_styling_header": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CD\u099F\u09BE\u0987\u09B2\u09BF\u0982 \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "edit_entry_header": "\u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "opt_case_sensitive": "\u0995\u09C7\u09B8 \u09B8\u09C7\u09A8\u09CD\u09B8\u09BF\u099F\u09BF\u09AD",
      "opt_not_case_sensitive": "\u0995\u09C7\u09B8 \u09B8\u09C7\u09A8\u09CD\u09B8\u09BF\u099F\u09BF\u09AD \u09A8\u09AF\u09BC",
      "opt_case_all": "\u0995\u09C7\u09B8 \u09B8\u09C7\u09A8\u09CD\u09B8\u09BF\u099F\u09BF\u09AD\u09BF\u099F\u09BF (\u09B8\u09AC)",
      "opt_match_all": "\u09AE\u09CD\u09AF\u09BE\u099A \u099F\u09BE\u0987\u09AA (\u09B8\u09AC)",
      "edit_highlight_styling_btn": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CD\u099F\u09BE\u0987\u09B2\u09BF\u0982 \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "inclusion_exclusion_header": "\u0985\u09A8\u09CD\u09A4\u09B0\u09CD\u09AD\u09C1\u0995\u09CD\u09A4\u09BF / \u09AC\u09B0\u09CD\u099C\u09A8 \u09A8\u09BF\u09AF\u09BC\u09AE",
      "btn_save_entry": "\u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09B8\u0982\u09B0\u0995\u09CD\u09B7\u09A3 \u0995\u09B0\u09C1\u09A8",
      "edit_entry_details": "\u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09AC\u09BF\u09B6\u09A6 \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "prompt_search_existing": "\u09AC\u09BF\u09A6\u09CD\u09AF\u09AE\u09BE\u09A8 \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "command_add_to_existing_entry": "\u09AC\u09BF\u09A6\u09CD\u09AF\u09AE\u09BE\u09A8 \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF\u09A4\u09C7 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "context_remove_from_entry": '\u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09A5\u09C7\u0995\u09C7 "{word}" \u09B8\u09B0\u09BE\u09A8',
      "context_delete_entry": "\u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09AE\u09C1\u099B\u09C1\u09A8",
      "btn_reset": "\u09B0\u09BF\u09B8\u09C7\u099F",
      "btn_reset_all": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09B0\u09BF\u09B8\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "btn_add_word": "+ \u09B6\u09AC\u09CD\u09A6 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "btn_add_regex_short": "+ \u09B0\u09BF\u099C\u09C7\u0995\u09CD\u09B8 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "section_highlight_border_styling": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B8\u09CD\u099F\u09BE\u0987\u09B2\u09BF\u0982",
      "section_highlight_styling": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CD\u099F\u09BE\u0987\u09B2\u09BF\u0982",
      "label_highlight_opacity": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u0985\u09AA\u09BE\u09B8\u09BF\u099F\u09BF",
      "label_highlight_radius": "\u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u09B0\u09C7\u09A1\u09BF\u09AF\u09BC\u09BE\u09B8",
      "label_horizontal_padding": "\u0985\u09A8\u09C1\u09AD\u09C2\u09AE\u09BF\u0995 \u09AA\u09CD\u09AF\u09BE\u09A1\u09BF\u0982",
      "label_vertical_padding": "\u0989\u09B2\u09CD\u09B2\u09AE\u09CD\u09AC \u09AA\u09CD\u09AF\u09BE\u09A1\u09BF\u0982",
      "label_enable_border": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0 \u099A\u09BE\u09B2\u09C1 \u0995\u09B0\u09C1\u09A8",
      "label_border_sides": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0\u09C7\u09B0 \u09A6\u09BF\u0995",
      "label_border_style": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0\u09C7\u09B0 \u09B8\u09CD\u099F\u09BE\u0987\u09B2",
      "label_border_opacity": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0\u09C7\u09B0 \u0985\u09AA\u09BE\u09B8\u09BF\u099F\u09BF",
      "label_border_thickness": "\u09AC\u09B0\u09CD\u09A1\u09BE\u09B0\u09C7\u09B0 \u09AA\u09C1\u09B0\u09C1\u09A4\u09CD\u09AC",
      "btn_save_style": "\u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09B8\u0982\u09B0\u0995\u09CD\u09B7\u09A3 \u0995\u09B0\u09C1\u09A8",
      // Quick Colors / Styles
      "quick_actions_header": "Quick Actions",
      "quick_colors_header": "\u09A6\u09CD\u09B0\u09C1\u09A4 \u09B0\u0982",
      "quick_colors_desc": "\u09A1\u09BE\u09A8-\u0995\u09CD\u09B2\u09BF\u0995 \u09AE\u09C7\u09A8\u09C1\u09A4\u09C7 \u09B0\u0982 \u09AA\u09CD\u09B0\u09A6\u09B0\u09CD\u09B6\u09A8 \u0995\u09B0\u09C7 \u09A6\u09CD\u09B0\u09C1\u09A4 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AC\u09BE \u09B0\u0999 \u0995\u09B0\u09BE\u09B0 \u0985\u09A8\u09C1\u09AE\u09A4\u09BF \u09A6\u09C7\u09AF\u09BC\u0964 \u09AF\u09A6\u09BF \u09A6\u09CD\u09B0\u09C1\u09A4 \u09B0\u0982 \u09AC\u09A8\u09CD\u09A7 \u09A5\u09BE\u0995\u09C7, \u09A4\u09AC\u09C7 \u09A6\u09CD\u09B0\u09C1\u09A4 \u09B8\u09CD\u099F\u09BE\u0987\u09B2\u0997\u09C1\u09B2\u09BF\u09A4\u09C7 \u09AA\u09CD\u09B0\u09A4\u09BF-\u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09B0\u0982 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09BE \u09B9\u09AC\u09C7\u0964",
      "quick_colors_apply_mode_label": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999\u09BE\u09AF\u09BC\u09A8 \u098F\u0987\u09AD\u09BE\u09AC\u09C7 \u09AA\u09CD\u09B0\u09AF\u09BC\u09CB\u0997 \u09B9\u09AC\u09C7",
      "quick_colors_apply_mode_act": "\u09B8\u09AC\u09B8\u09AE\u09DF \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u0995\u09B0\u09C1\u09A8",
      "quick_colors_apply_mode_html": "\u0987\u09A8\u09B2\u09BE\u0987\u09A8 HTML",
      "quick_styles_header": "\u09A6\u09CD\u09B0\u09C1\u09A4 \u09B8\u09CD\u099F\u09BE\u0987\u09B2",
      "quick_styles_desc": "\u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B0\u0999 \u098F\u09AC\u0982 \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09AA\u09CD\u09B0\u09AF\u09BC\u09CB\u0997 \u0995\u09B0\u09BE\u09B0 \u099C\u09A8\u09CD\u09AF \u09A8\u09BE\u09AE\u09AF\u09C1\u0995\u09CD\u09A4 \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09B8\u0982\u099C\u09CD\u099E\u09BE\u09AF\u09BC\u09BF\u09A4 \u0995\u09B0\u09C1\u09A8\u0964 \u09AF\u09A6\u09BF \u09A6\u09CD\u09B0\u09C1\u09A4 \u09B0\u0982 \u09AC\u09A8\u09CD\u09A7 \u09A5\u09BE\u0995\u09C7, \u09A4\u09AC\u09C7 \u098F\u0996\u09BE\u09A8\u09C7 \u09AA\u09CD\u09B0\u09A4\u09BF-\u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09B0\u0982 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09BE \u09B9\u09AC\u09C7\u0964",
      "btn_add_style": "+ \u09B8\u09CD\u099F\u09BE\u0987\u09B2 \u09AF\u09CB\u0997 \u0995\u09B0\u09C1\u09A8",
      "quick_styles_menu_option": "\u09A6\u09CD\u09B0\u09C1\u09A4 \u09B8\u09CD\u099F\u09BE\u0987\u09B2",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF",
      "show_blacklist_groups_in_commands": "\u0995\u09AE\u09BE\u09A8\u09CD\u09A1\u09C7 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09A6\u09C7\u0996\u09BE\u09A8",
      "show_blacklist_groups_in_commands_desc": "\u09B8\u0995\u09CD\u09B7\u09AE \u09B9\u09B2\u09C7, \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA\u0997\u09C1\u09B2\u09BF \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC/\u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09BE\u09B0 \u0995\u09AE\u09BE\u09A8\u09CD\u09A1 \u09B8\u09B9 \u0995\u09AE\u09BE\u09A8\u09CD\u09A1 \u09AA\u09CD\u09AF\u09BE\u09B2\u09C7\u099F\u09C7 \u09AA\u09CD\u09B0\u09A6\u09B0\u09CD\u09B6\u09BF\u09A4 \u09B9\u09AF\u09BC\u0964",
      "search_blacklist_groups_placeholder": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u0985\u09A8\u09C1\u09B8\u09A8\u09CD\u09A7\u09BE\u09A8 \u0995\u09B0\u09C1\u09A8\u2026",
      "btn_create_new_blacklist_group": "+ \u09A8\u09A4\u09C1\u09A8 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09A4\u09C8\u09B0\u09BF \u0995\u09B0\u09C1\u09A8",
      "edit_blacklist_group_modal_title": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "tooltip_delete_all_blacklist_groups": "\u09B8\u09AE\u09B8\u09CD\u09A4 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09C1\u09A8",
      "confirm_delete_all_blacklist_groups_title": "\u09B8\u09AE\u09B8\u09CD\u09A4 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09C1\u09A8",
      "confirm_delete_all_blacklist_groups_desc": "\u0986\u09AA\u09A8\u09BF \u0995\u09BF \u09B8\u09AE\u09B8\u09CD\u09A4 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09A4\u09C7 \u099A\u09BE\u09A8? \u098F\u099F\u09BF \u0986\u09A8\u09A1\u09C1 \u0995\u09B0\u09BE \u09AF\u09BE\u09AC\u09C7 \u09A8\u09BE!",
      "confirm_delete_blacklist_group_title": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09C1\u09A8",
      "confirm_delete_blacklist_group_desc": "\u0986\u09AA\u09A8\u09BF \u0995\u09BF \u098F\u0987 \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09AE\u09C1\u099B\u09A4\u09C7 \u099A\u09BE\u09A8? \u098F\u099F\u09BF \u0986\u09A8\u09A1\u09C1 \u0995\u09B0\u09BE \u09AF\u09BE\u09AC\u09C7 \u09A8\u09BE\u0964",
      "notice_blacklist_group_activated": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "notice_blacklist_group_deactivated": "\u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09BE \u09B9\u09AF\u09BC\u09C7\u099B\u09C7",
      "command_activate_blacklist_group": "{groupName} \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09B8\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09C1\u09A8",
      "command_deactivate_blacklist_group": "{groupName} \u09AC\u09CD\u09B2\u09CD\u09AF\u09BE\u0995\u09B2\u09BF\u09B8\u09CD\u099F \u0997\u09CD\u09B0\u09C1\u09AA \u09A8\u09BF\u09B7\u09CD\u0995\u09CD\u09B0\u09BF\u09AF\u09BC \u0995\u09B0\u09C1\u09A8",
      "btn_duplicate_entry": "\u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09A1\u09C1\u09AA\u09CD\u09B2\u09BF\u0995\u09C7\u099F \u0995\u09B0\u09C1\u09A8",
      "btn_open_in_regex_tester": "Regex Tester \u098F \u0996\u09C1\u09B2\u09C1\u09A8",
      "move_to_blacklist_group": "\u0995\u09BE\u09B2\u09CB \u09B8\u09C2\u099A\u09C0 \u0997\u09CD\u09B0\u09C1\u09AA\u09C7 \u09B8\u0981\u099A\u09BE\u09B2\u09A8 \u0995\u09B0\u09C1\u09A8",
      "btn_delete_entry": "\u098F\u09A8\u09CD\u099F\u09CD\u09B0\u09BF \u09AE\u09C1\u099B\u09C1\u09A8",
      "edit_group_highlight_styling": "\u0997\u09CD\u09B0\u09C1\u09AA \u09B9\u09BE\u0987\u09B2\u09BE\u0987\u099F \u09B8\u09CD\u099F\u09BE\u0987\u09B2\u09BF\u0982 \u09B8\u09AE\u09CD\u09AA\u09BE\u09A6\u09A8\u09BE \u0995\u09B0\u09C1\u09A8",
      "light_mode_fixer": "\u09B2\u09BE\u0987\u099F \u09AE\u09CB\u09A1 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u0995\u09BE\u09B2\u09BE\u09B0 \u09AB\u09BF\u0995\u09CD\u09B8\u09BE\u09B0",
      "dark_mode_fixer": "\u09A1\u09BE\u09B0\u09CD\u0995 \u09AE\u09CB\u09A1 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u0995\u09BE\u09B2\u09BE\u09B0 \u09AB\u09BF\u0995\u09CD\u09B8\u09BE\u09B0",
      "light_mode_fixer_desc": "\u09A6\u09C3\u09B6\u09CD\u09AF\u09AE\u09BE\u09A8\u09A4\u09BE \u0989\u09A8\u09CD\u09A8\u09A4 \u0995\u09B0\u09A4\u09C7 \u09B2\u09BE\u0987\u099F \u09A5\u09BF\u09AE \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09BE\u09B0 \u09B8\u09AE\u09AF\u09BC \u09B0\u0999\u09BF\u09A8 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u09CD\u09AC\u09AF\u09BC\u0982\u0995\u09CD\u09B0\u09BF\u09AF\u09BC\u09AD\u09BE\u09AC\u09C7 \u0997\u09BE\u09A2\u09BC \u0995\u09B0\u09C7\u0964",
      "dark_mode_fixer_desc": "\u09A6\u09C3\u09B6\u09CD\u09AF\u09AE\u09BE\u09A8\u09A4\u09BE \u0989\u09A8\u09CD\u09A8\u09A4 \u0995\u09B0\u09A4\u09C7 \u09A1\u09BE\u09B0\u09CD\u0995 \u09A5\u09BF\u09AE \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0 \u0995\u09B0\u09BE\u09B0 \u09B8\u09AE\u09AF\u09BC \u09B0\u0999\u09BF\u09A8 \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09B8\u09CD\u09AC\u09AF\u09BC\u0982\u0995\u09CD\u09B0\u09BF\u09AF\u09BC\u09AD\u09BE\u09AC\u09C7 \u09B9\u09BE\u09B2\u0995\u09BE \u0995\u09B0\u09C7\u0964",
      "preset_bold": "\u09AC\u09CB\u09B2\u09CD\u09A1",
      "preset_italic": "\u0987\u099F\u09BE\u09B2\u09BF\u0995",
      "preset_bold_italic": "\u09AC\u09CB\u09B2\u09CD\u09A1 \u0987\u099F\u09BE\u09B2\u09BF\u0995",
      "theme_support_header": "\u09A5\u09BF\u09AE \u09B8\u09AE\u09B0\u09CD\u09A5\u09A8",
      "matching_behavior_header": "\u09AE\u09CD\u09AF\u09BE\u099A\u09BF\u0982 \u0986\u099A\u09B0\u09A3",
      "color_rendering_header": "\u09B0\u0999 \u09B0\u09C7\u09A8\u09CD\u09A1\u09BE\u09B0\u09BF\u0982 \u098F\u09AC\u0982 \u0995\u09B0\u09CD\u09AE\u0995\u09CD\u09B7\u09AE\u09A4\u09BE"
    };
  }
});

// src/i18n/ru.js
var require_ru = __commonJS({
  "src/i18n/ru.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
      "settings_title": "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Always Color Text",
      "header_plugin_name": "Always Color Text",
      "ribbon_title": "Always Color Text",
      // Language Settings
      "language_label": "\u042F\u0437\u044B\u043A",
      "language_desc": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
      "language_en": "\u0410\u043D\u0433\u043B\u0438\u0439\u0441\u043A\u0438\u0439",
      "language_es": "\u0418\u0441\u043F\u0430\u043D\u0441\u043A\u0438\u0439",
      "language_fr": "\u0424\u0440\u0430\u043D\u0446\u0443\u0437\u0441\u043A\u0438\u0439",
      "language_eu": "\u0411\u0430\u0441\u043A\u0441\u043A\u0438\u0439",
      "language_ru": "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
      "language_auto": "\u0421\u0438\u0441\u0442\u0435\u043C\u043D\u044B\u0439",
      "default": "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
      // Release Notes
      "latest_release_notes_label": "\u041F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043A \u0432\u044B\u043F\u0443\u0441\u043A\u0443",
      "latest_release_notes_desc": "\u041F\u0440\u043E\u0441\u043C\u0430\u0442\u0440\u0438\u0432\u0430\u0439\u0442\u0435 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043A \u0432\u044B\u043F\u0443\u0441\u043A\u0443 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
      "open_changelog_button": "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u043F\u0438\u0441\u043E\u043A \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439",
      "command_show_release_notes": "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043A \u0432\u044B\u043F\u0443\u0441\u043A\u0443",
      "changelog_view_on_github": "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C \u043D\u0430 GitHub",
      "changelog_loading": "\u0412\u044B\u043F\u0443\u0441\u043A\u0438 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044E\u0442\u0441\u044F\u2026",
      "changelog_no_info": "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0432\u044B\u043F\u0443\u0441\u043A\u0430\u0445 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430.",
      "changelog_release": "\u0412\u044B\u043F\u0443\u0441\u043A\u0438",
      "changelog_no_notes": "\u041D\u0435\u0442 \u0437\u0430\u043C\u0435\u0442\u043E\u043A",
      "changelog_failed_to_load": "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043A \u0432\u044B\u043F\u0443\u0441\u043A\u0430\u043C.",
      // UI Elements & Menus
      "file_menu_enable": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u044D\u0442\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430",
      "file_menu_disable": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u044D\u0442\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430",
      "menu_color_once": "\u041E\u043A\u0440\u0430\u0441\u0438\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E",
      "menu_highlight_once": "\u041F\u043E\u0434\u0441\u0432\u0435\u0442\u0438\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E",
      "menu_color_highlight_once": "\u0426\u0432\u0435\u0442 / \u041F\u043E\u0434\u0441\u0432\u0435\u0442\u0438\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E",
      // added
      "menu_remove_inline_color": "\u0423\u0431\u0440\u0430\u0442\u044C \u0418\u043D\u043B\u0430\u0439\u043D \u0426\u0432\u0435\u0442",
      // added
      "menu_always_color_text": "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u0432\u043D\u0435\u0448\u043D\u0438\u0439 \u0432\u0438\u0434 \u0442\u0435\u043A\u0441\u0442\u0430",
      "menu_remove_always_color_text": "\u0423\u0431\u0440\u0430\u0442\u044C Always Color Text",
      "menu_blacklist_word": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "show_toggle_statusbar": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0432 \u0441\u0442\u0440\u043E\u043A\u0435 \u0441\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u044F",
      "show_toggle_ribbon": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043D\u0430 \u0432\u0435\u0440\u0442\u0438\u043A\u0430\u043B\u044C\u043D\u043E\u0439 \u043F\u0430\u043D\u0435\u043B\u0438",
      "show_toggle_command": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0432 \u043F\u0430\u043B\u0438\u0442\u0440\u0435 \u043A\u043E\u043C\u0430\u043D\u0434",
      "menu_options_header": "\u041E\u043F\u0446\u0438\u0438 \u043C\u0435\u043D\u044E",
      "show_blacklist_menu": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \xAB\u0421\u043B\u043E\u0432\u043E \u0432 \u0447\u0451\u0440\u043D\u043E\u043C \u0441\u043F\u0438\u0441\u043A\u0435\xBB \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E",
      "show_blacklist_menu_desc": "\u0412 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E \u043F\u043E\u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u044C \u0434\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A, \u0447\u0442\u043E\u0431\u044B \u043E\u043D\u043E \u043D\u0438\u043A\u043E\u0433\u0434\u0430 \u043D\u0435 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043B\u043E\u0441\u044C.",
      "show_add_to_existing_menu": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \xAB\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0443\u044E \u0437\u0430\u043F\u0438\u0441\u044C\xBB \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E",
      "show_add_to_existing_menu_desc": "\u0412 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u044C \u0434\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442 \u0432 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0443\u044E \u0437\u0430\u043F\u0438\u0441\u044C.",
      "show_always_color_text_menu": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \xAB\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u0432\u043D\u0435\u0448\u043D\u0438\u0439 \u0432\u0438\u0434 \u0442\u0435\u043A\u0441\u0442\u0430\xBB \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E",
      "show_always_color_text_menu_desc": "\u0412 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E \u043F\u043E\u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C \u0432\u043D\u0435\u0448\u043D\u0438\u0439 \u0432\u0438\u0434 \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430.",
      "hide_inactive_groups_in_dropdowns": "\u0421\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u043D\u0435\u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0435 \u0433\u0440\u0443\u043F\u043F\u044B \u0432 \u0432\u044B\u043F\u0430\u0434\u0430\u044E\u0449\u0438\u0445 \u0441\u043F\u0438\u0441\u043A\u0430\u0445",
      "hide_inactive_groups_in_dropdowns_desc": "\u0421\u043A\u0440\u044B\u0432\u0430\u0435\u0442 \u043D\u0435\u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0435 \u0433\u0440\u0443\u043F\u043F\u044B \u0441\u043B\u043E\u0432 \u043F\u0440\u0438 \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0438 \u0433\u0440\u0443\u043F\u043F \u0432 \u0432\u044B\u043F\u0430\u0434\u0430\u044E\u0449\u0438\u0445 \u0441\u043F\u0438\u0441\u043A\u0430\u0445.",
      "show_word_groups_in_commands": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u044B \u0441\u043B\u043E\u0432 \u0432 \u043F\u0430\u043B\u0438\u0442\u0440\u0435 \u043A\u043E\u043C\u0430\u043D\u0434",
      "show_word_groups_in_commands_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0433\u0440\u0443\u043F\u043F\u044B \u0441\u043B\u043E\u0432 \u043F\u043E\u044F\u0432\u043B\u044F\u044E\u0442\u0441\u044F \u0432 \u043F\u0430\u043B\u0438\u0442\u0440\u0435 \u043A\u043E\u043C\u0430\u043D\u0434 \u0441 \u043A\u043E\u043C\u0430\u043D\u0434\u0430\u043C\u0438 \u0410\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C/\u0434\u0435\u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C.",
      "tooltip_enable_for_file": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0434\u043B\u044F \u044D\u0442\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430",
      "tooltip_delete_all_words": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0441\u043B\u043E\u0432\u0430/\u0448\u0430\u0431\u043B\u043E\u043D\u044B",
      "tooltip_delete_all_blacklist": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0438\u0437 \u0447\u0451\u0440\u043D\u043E\u0433\u043E \u0441\u043F\u0438\u0441\u043A\u0430 \u0432\u0441\u0435 \u0441\u043B\u043E\u0432\u0430/\u0448\u0430\u0431\u043B\u043E\u043D\u044B",
      "tooltip_use_regex": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u043A\u0430\u043A \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u043E\u0435 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
      "drag_to_reorder": "\u041F\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0434\u043B\u044F \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u043F\u043E\u0440\u044F\u0434\u043A\u0430",
      "reset_text_color": "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0446\u0432\u0435\u0442 \u0442\u0435\u043A\u0441\u0442\u0430",
      "reset_highlight": "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0443",
      // Commands
      "command_color_selected": "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u0432\u043D\u0435\u0448\u043D\u0438\u0439 \u0432\u0438\u0434 \u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430",
      "command_toggle_current": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C/\u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0442\u0435\u043A\u0443\u0449\u0435\u0433\u043E \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430",
      "command_enable_current": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0442\u0435\u043A\u0443\u0449\u0435\u0433\u043E \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430",
      "command_disable_current": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0442\u0435\u043A\u0443\u0449\u0435\u0433\u043E \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430",
      "command_toggle_global": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C/\u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C Always Color Text",
      "command_enable_global": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C Always Color Text",
      "command_disable_global": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C Always Color Text",
      "command_enable_lightweight_mode": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043B\u0435\u0433\u043A\u0438\u0439 \u0440\u0435\u0436\u0438\u043C",
      // added
      "command_disable_lightweight_mode": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043B\u0435\u0433\u043A\u0438\u0439 \u0440\u0435\u0436\u0438\u043C",
      // added
      "command_color_highlight_once": "\u041E\u043A\u0440\u0430\u0441\u0438\u0442\u044C / \u0412\u044B\u0434\u0435\u043B\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442 (\u043E\u0434\u0438\u043D \u0440\u0430\u0437)",
      // added
      "notice_select_text_first_once": "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043A\u0441\u0442.",
      // added
      "enable_document_color": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430",
      "color_rendering_header": "\u0420\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433 \u0446\u0432\u0435\u0442\u0430 \u0438 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
      // added
      "theme_support_header": "\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u043A\u0430 \u0442\u0435\u043C",
      // added
      "matching_behavior_header": "\u041F\u043E\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u0441\u043E\u043F\u043E\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u0438\u044F",
      // added
      "smart_update_mode": "\u0423\u043C\u043D\u044B\u0435 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F (\u042D\u043A\u0441\u043F\u0435\u0440\u0438\u043C\u0435\u043D\u0442\u0430\u043B\u044C\u043D\u044B\u0439)",
      // added
      "smart_update_mode_desc": "\u041E\u0431\u043D\u043E\u0432\u043B\u044F\u0435\u0442 \u0440\u0430\u0441\u043A\u0440\u0430\u0441\u043A\u0443 \u0442\u043E\u043B\u044C\u043A\u043E \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438 \u043F\u0440\u0438 \u043D\u0430\u0431\u043E\u0440\u0435 \u0442\u0435\u043A\u0441\u0442\u0430 \u0438 \u0437\u0430\u043C\u043E\u0440\u0430\u0436\u0438\u0432\u0430\u0435\u0442 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u0442\u0440\u043E\u043A\u0438 \u0434\u043B\u044F \u043F\u043E\u0432\u044B\u0448\u0435\u043D\u0438\u044F \u043F\u0440\u043E\u0438\u0437\u0432\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438.",
      "light_mode_fixer": "\u0418\u0441\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430 \u0432 \u0441\u0432\u0435\u0442\u043B\u043E\u043C \u0440\u0435\u0436\u0438\u043C\u0435",
      // added
      "dark_mode_fixer": "\u0418\u0441\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430 \u0432 \u0442\u0435\u043C\u043D\u043E\u043C \u0440\u0435\u0436\u0438\u043C\u0435",
      // added
      "command_manage_advanced_rules": "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u043F\u0435\u0446\u0438\u0444\u0438\u0447\u0435\u0441\u043A\u0438\u043C\u0438 \u043F\u0440\u0430\u0432\u0438\u043B\u0430\u043C\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F/\u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
      "command_open_regex_tester": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C Regex (\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440 Regex)",
      "command_open_blacklist_regex_tester": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C Regex \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "command_manage_colored_texts": "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u043E\u043A\u0440\u0430\u0448\u0435\u043D\u043D\u044B\u043C\u0438 \u0442\u0435\u043A\u0441\u0442\u0430\u043C\u0438",
      "command_toggle_hide_text_colors": "\u0421\u043A\u0440\u044B\u0442\u044C/\u043F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0446\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430",
      "command_toggle_hide_highlights": "\u0421\u043A\u0440\u044B\u0442\u044C/\u043F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "command_hide_text_colors": "\u0421\u043A\u0440\u044B\u0442\u044C \u0446\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430",
      "command_unhide_text_colors": "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0446\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430",
      "command_hide_highlights": "\u0421\u043A\u0440\u044B\u0442\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "command_unhide_highlights": "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "command_activate_word_group": "\u0410\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0443 \u0441\u043B\u043E\u0432 {groupName}",
      "command_deactivate_word_group": "\u0414\u0435\u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0443 \u0441\u043B\u043E\u0432 {groupName}",
      // Notifications
      "notice_lightweight_mode_enabled": "\u041B\u0435\u0433\u043A\u0438\u0439 \u0440\u0435\u0436\u0438\u043C \u0432\u043A\u043B\u044E\u0447\u0435\u043D",
      // added
      "notice_lightweight_mode_disabled": "\u041B\u0435\u0433\u043A\u0438\u0439 \u0440\u0435\u0436\u0438\u043C \u0432\u044B\u043A\u043B\u044E\u0447\u0435\u043D",
      // added
      "notice_enabled": "Always Color Text \u0432\u043A\u043B\u044E\u0447\u0451\u043D",
      "notice_disabled": "Always Color Text \u043E\u0442\u043A\u043B\u044E\u0447\u0451\u043D",
      "notice_blacklisted_cannot_color": "\xAB{word}\xBB \u043D\u0430\u0445\u043E\u0434\u0438\u0442\u0441\u044F \u0432 \u0447\u0451\u0440\u043D\u043E\u043C \u0441\u043F\u0438\u0441\u043A\u0435 \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0435\u043D\u043E.",
      "notice_removed_always_color": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F \xAB{word}\xBB.",
      "notice_added_to_blacklist": "\xAB{word}\xBB \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A.",
      "notice_already_blacklisted": "\xAB{word}\xBB \u0443\u0436\u0435 \u043D\u0430\u0445\u043E\u0434\u0438\u0442\u0441\u044F \u0432 \u0447\u0451\u0440\u043D\u043E\u043C \u0441\u043F\u0438\u0441\u043A\u0435.",
      "notice_select_text_first": "\u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u044B\u0434\u0435\u043B\u0438\u0442\u0435 \u0442\u0435\u043A\u0441\u0442.",
      "notice_no_active_file": "\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F.",
      "notice_coloring_enabled_for_path": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F {path}",
      "notice_coloring_disabled_for_path": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F {path}",
      "notice_global_enabled": "Always Color Text \u0432\u043A\u043B\u044E\u0447\u0451\u043D",
      "notice_global_disabled": "Always Color Text \u043E\u0442\u043A\u043B\u044E\u0447\u0451\u043D",
      "notice_unable_open_changelog": "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u0441\u043F\u0438\u0441\u043E\u043A \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439.",
      "notice_pattern_blocked": "\u0428\u0430\u0431\u043B\u043E\u043D \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0446\u0435\u043B\u044F\u0445 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438 \u043F\u0430\u043C\u044F\u0442\u0438:",
      "notice_pattern_too_complex": "\u0428\u0430\u0431\u043B\u043E\u043D \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0441\u043B\u043E\u0436\u043D\u044B\u0439:",
      "notice_invalid_hex_format": "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 hex \u0444\u043E\u0440\u043C\u0430\u0442 \u0446\u0432\u0435\u0442\u0430. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 #RRGGBB \u0438\u043B\u0438 #RGB.",
      "notice_error_saving_changes": "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0438 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0439. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
      "notice_invalid_color_format": "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0446\u0432\u0435\u0442\u0430.",
      "notice_exported": "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u0437\u0430\u0432\u0435\u0440\u0448\u0451\u043D: {fname}",
      "notice_export_failed": "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0432\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u044D\u043A\u0441\u043F\u043E\u0440\u0442",
      "notice_import_completed": "\u0418\u043C\u043F\u043E\u0440\u0442 \u0437\u0430\u0432\u0435\u0440\u0448\u0451\u043D",
      "notice_import_failed": "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0432\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0438\u043C\u043F\u043E\u0440\u0442",
      "share_export_title": "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 Always Color Text",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0441\u0442\u0438\u043B\u044F",
      "preview_text": "\u0422\u0435\u043A\u0441\u0442",
      "notice_invalid_regex": "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0435 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u043E\u0435 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
      "notice_empty_pattern": "\u0428\u0430\u0431\u043B\u043E\u043D \u043F\u0443\u0441\u0442",
      "notice_added_regex": "Regex \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D",
      "notice_rule_updated": "\u041F\u0440\u0430\u0432\u0438\u043B\u043E \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E",
      "notice_regex_updated": "Regex \u043E\u0431\u043D\u043E\u0432\u043B\u0451\u043D",
      "notice_entry_updated": "\u0417\u0430\u043F\u0438\u0441\u044C \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0430",
      "notice_entry_duplicated": "\u0417\u0430\u043F\u0438\u0441\u044C \u043F\u0440\u043E\u0434\u0443\u0431\u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0430",
      "notice_error_opening_regex_tester": "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440\u0430 Regex",
      "notice_error_opening_blacklist_regex_tester": "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440\u0430 \u0447\u0451\u0440\u043D\u043E\u0433\u043E \u0441\u043F\u0438\u0441\u043A\u0430 Regex",
      "notice_error_opening_advanced_rules": "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440\u0430 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u043D\u044B\u0445 \u043F\u0440\u0430\u0432\u0438\u043B",
      "notice_text_color_reset": "\u0426\u0432\u0435\u0442 \u0442\u0435\u043A\u0441\u0442\u0430 \u0441\u0431\u0440\u043E\u0448\u0435\u043D",
      "notice_highlight_reset": "\u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430 \u0441\u0431\u0440\u043E\u0448\u0435\u043D\u0430",
      "notice_text_colors_hidden": "\u0426\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430 \u0441\u043A\u0440\u044B\u0442\u044B",
      "notice_text_colors_visible": "\u0426\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430 \u0432\u0438\u0434\u043D\u044B",
      "notice_highlights_hidden": "\u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 \u0441\u043A\u0440\u044B\u0442\u044B",
      "notice_highlights_visible": "\u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 \u0432\u0438\u0434\u043D\u044B",
      "notice_regex_support_disabled": "\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u043A\u0430 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u0445 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u0430. \u0412\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u0435\u0451 \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445, \u0447\u0442\u043E\u0431\u044B \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u0445 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0439.",
      "notice_no_active_file_to_disable": "\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F.",
      "notice_already_disabled_for_path": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0443\u0436\u0435 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F {path}",
      "notice_filter_disabled": "\u0424\u0438\u043B\u044C\u0442\u0440 \u043E\u0442\u043A\u043B\u044E\u0447\u0451\u043D",
      // Confirmation Dialogs
      "confirm_delete_all_title": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0441\u043B\u043E\u0432\u0430",
      "confirm_delete_all_desc": "\u0412\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0412\u0421\u0415 \u0441\u043B\u043E\u0432\u0430/\u0448\u0430\u0431\u043B\u043E\u043D\u044B? \u042D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043D\u0435\u043E\u0431\u0440\u0430\u0442\u0438\u043C\u043E!",
      "confirm_delete_all_blacklist_title": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0441\u043B\u043E\u0432\u0430 \u0438\u0437 \u0447\u0451\u0440\u043D\u043E\u0433\u043E \u0441\u043F\u0438\u0441\u043A\u0430",
      "confirm_delete_all_blacklist_desc": "\u0412\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0412\u0421\u0415 \u0441\u043B\u043E\u0432\u0430/\u0448\u0430\u0431\u043B\u043E\u043D\u044B \u0438\u0437 \u0447\u0451\u0440\u043D\u043E\u0433\u043E \u0441\u043F\u0438\u0441\u043A\u0430? \u042D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043D\u0435\u043E\u0431\u0440\u0430\u0442\u0438\u043C\u043E!",
      "confirm_delete_all_groups_title": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0433\u0440\u0443\u043F\u043F\u044B \u0441\u043B\u043E\u0432",
      "confirm_delete_all_groups_desc": "\u0412\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0412\u0421\u0415 \u0433\u0440\u0443\u043F\u043F\u044B \u0441\u043B\u043E\u0432? \u042D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043D\u0435\u043E\u0431\u0440\u0430\u0442\u0438\u043C\u043E!",
      "confirm_delete_all_blacklist_groups_title": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0447\u0451\u0440\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438",
      "confirm_delete_all_blacklist_groups_desc": "\u0412\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0412\u0421\u0415 \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0447\u0451\u0440\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438? \u042D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u043E\u0442\u043C\u0435\u043D\u0438\u0442\u044C!",
      "confirm_delete_blacklist_group_title": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "confirm_delete_blacklist_group_desc": "\u0412\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u044D\u0442\u043E\u0442 \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A? \u042D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u043E\u0442\u043C\u0435\u043D\u0438\u0442\u044C.",
      "restart_required_title": "\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0430",
      "restart_required_desc": "\u0414\u043B\u044F \u043F\u043E\u043B\u043D\u043E\u0433\u043E \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u0438\u0437 \u043F\u0430\u043B\u0438\u0442\u0440\u044B \u043A\u043E\u043C\u0430\u043D\u0434 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0430 Obsidian. \u041F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0441\u0435\u0439\u0447\u0430\u0441?",
      // Basic Settings
      "color_in_live_preview_mode": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 Live Preview",
      "color_in_reading_mode": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u0447\u0442\u0435\u043D\u0438\u044F",
      "force_full_render_reading": "\u041F\u0440\u0438\u043D\u0443\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0442\u044C \u043F\u043E\u043B\u043D\u044B\u0439 \u0440\u0435\u043D\u0434\u0435\u0440\u0438\u043D\u0433 \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 \u0447\u0442\u0435\u043D\u0438\u044F",
      "force_full_render_reading_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0440\u0435\u0436\u0438\u043C \u0447\u0442\u0435\u043D\u0438\u044F \u043F\u043E\u043F\u044B\u0442\u0430\u0435\u0442\u0441\u044F \u043E\u043A\u0440\u0430\u0441\u0438\u0442\u044C \u0432\u0435\u0441\u044C \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442 \u0441\u0440\u0430\u0437\u0443. \u041C\u043E\u0436\u0435\u0442 \u0432\u044B\u0437\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0434\u043B\u0435\u043D\u0438\u0435 \u043D\u0430 \u0431\u043E\u043B\u044C\u0448\u0438\u0445 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430\u0445, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u0441 \u043E\u0441\u0442\u043E\u0440\u043E\u0436\u043D\u043E\u0441\u0442\u044C\u044E!",
      "lightweight_mode": "\u041B\u0435\u0433\u043A\u043E\u0432\u0435\u0441\u043D\u044B\u0439 \u0440\u0435\u0436\u0438\u043C (\u042D\u043A\u0441\u043F\u0435\u0440\u0438\u043C\u0435\u043D\u0442\u0430\u043B\u044C\u043D\u043E)",
      "lightweight_mode_desc": "\u0417\u043D\u0430\u0447\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0441\u043D\u0438\u0436\u0430\u0435\u0442 \u043D\u0430\u0433\u0440\u0443\u0437\u043A\u0443 \u043F\u0440\u0438 \u043D\u0430\u0431\u043E\u0440\u0435 \u0442\u0435\u043A\u0441\u0442\u0430. \u041C\u043E\u0436\u0435\u0442 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u0442\u044C \u043D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u044F.",
      "disable_coloring_current_file": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u043B\u044F \u0442\u0435\u043A\u0443\u0449\u0435\u0433\u043E \u0444\u0430\u0439\u043B\u0430",
      "disable_coloring_current_file_desc": "\u0414\u043E\u0431\u0430\u0432\u043B\u044F\u0435\u0442 \u043F\u0440\u0430\u0432\u0438\u043B\u043E \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F \u0434\u043B\u044F \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430 \u0432 \u0440\u0430\u0437\u0434\u0435\u043B \xAB\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432 \u0438 \u043F\u0430\u043F\u043E\u043A\xBB.",
      "btn_disable_for_this_file": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0434\u043B\u044F \u044D\u0442\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430",
      // Coloring Settings
      "coloring_settings_header": "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F",
      "regex_support": "\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u043A\u0430 Regex",
      "regex_support_desc": "\u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u0445 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0432 \u043A\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0448\u0430\u0431\u043B\u043E\u043D\u043E\u0432. \u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0435 regex \u0431\u0443\u0434\u0443\u0442 \u043F\u0440\u043E\u0438\u0433\u043D\u043E\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u044B \u0432 \u0446\u0435\u043B\u044F\u0445 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438.",
      "disable_regex_safety": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0443 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438 Regex",
      "disable_regex_safety_desc": "\u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C \u0441\u043B\u043E\u0436\u043D\u044B\u0435 \u0438\u043B\u0438 \u043F\u043E\u0442\u0435\u043D\u0446\u0438\u0430\u043B\u044C\u043D\u043E \u043E\u043F\u0430\u0441\u043D\u044B\u0435 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u044F. \u041C\u043E\u0436\u0435\u0442 \u0432\u044B\u0437\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0434\u043B\u0435\u043D\u0438\u0435 \u0438\u043B\u0438 \u0437\u0430\u0432\u0438\u0441\u0430\u043D\u0438\u0435.",
      "case_sensitive": "\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u043A \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0443",
      "case_sensitive_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \xAB\u0421\u043B\u043E\u0432\u043E\xBB \u0438 \xAB\u0441\u043B\u043E\u0432\u043E\xBB \u0441\u0447\u0438\u0442\u0430\u044E\u0442\u0441\u044F \u0440\u0430\u0437\u043D\u044B\u043C\u0438. \u0415\u0441\u043B\u0438 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u043E\u043D\u0438 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u044E\u0442\u0441\u044F \u043E\u0434\u0438\u043D\u0430\u043A\u043E\u0432\u043E.",
      "partial_match": "\u0427\u0430\u0441\u0442\u0438\u0447\u043D\u043E\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u0435",
      "partial_match_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u0441\u0451 \u0441\u043B\u043E\u0432\u043E, \u0435\u0441\u043B\u0438 \u0432\u043D\u0443\u0442\u0440\u0438 \u043D\u0430\u0439\u0434\u0435\u043D\u043E \u043E\u043A\u0440\u0430\u0448\u0435\u043D\u043D\u043E\u0435 \u0441\u043B\u043E\u0432\u043E (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \xAB\u0442\u0435\u043A\u0441\u0442\xBB \u043E\u043A\u0440\u0430\u0441\u0438\u0442 \xAB\u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\xBB).",
      // One-Time Actions
      "one_time_actions_header": "\u041E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u044B\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F",
      "setting_color_once": "\u041E\u043A\u0440\u0430\u0441\u0438\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E",
      "setting_color_once_desc": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C inline HTML \u0441\u0442\u0438\u043B\u044C \u0434\u043B\u044F \u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430. \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u0442\u0441\u044F \u0434\u0430\u0436\u0435 \u0435\u0441\u043B\u0438 \u043F\u043B\u0430\u0433\u0438\u043D \u043E\u0442\u043A\u043B\u044E\u0447\u0451\u043D.",
      "setting_highlight_once": "\u041F\u043E\u0434\u0441\u0432\u0435\u0442\u0438\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E",
      "setting_highlight_once_desc": "\u0412\u0441\u0442\u0430\u0432\u0438\u0442\u044C inline HTML \u0441\u0442\u0438\u043B\u044C \u0441 \u0444\u043E\u043D\u043E\u043C. \u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0435\u0442\u0441\u044F \u0434\u0430\u0436\u0435 \u0435\u0441\u043B\u0438 \u043F\u043B\u0430\u0433\u0438\u043D \u043E\u0442\u043A\u043B\u044E\u0447\u0451\u043D.",
      "setting_color_highlight_once": "\u0426\u0432\u0435\u0442 \u0438 \u041F\u043E\u0434\u0441\u0432\u0435\u0442\u0438\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E",
      // added
      "setting_color_highlight_once_desc": "\u041E\u0442\u043A\u0440\u044B\u0432\u0430\u0435\u0442 \u0443\u043D\u0438\u0444\u0438\u0446\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0441\u0435\u043B\u0435\u043A\u0442\u043E\u0440 \u0446\u0432\u0435\u0442\u0430 \u0434\u043B\u044F \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u043A\u0430\u043A \u0446\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430, \u0442\u0430\u043A \u0438 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 \u0444\u043E\u043D\u0430 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442 \u0443\u043D\u0438\u0444\u0438\u0446\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E\u0435 \u043C\u0435\u043D\u044E.",
      // added
      "highlight_once_preview": "\u041F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440 \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "highlight_once_preview_text": "\u0422\u0430\u043A \u0431\u0443\u0434\u0435\u0442 \u0432\u044B\u0433\u043B\u044F\u0434\u0435\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u0430\u044F \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430!",
      // Highlight Once Settings
      "highlight_once_opacity": "\u041D\u0435\u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "highlight_once_border_radius": "\u0420\u0430\u0434\u0438\u0443\u0441 \u0441\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u044F \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 (px)",
      "reset_to_8": "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0434\u043E 8",
      "highlight_horizontal_padding": "\u0413\u043E\u0440\u0438\u0437\u043E\u043D\u0442\u0430\u043B\u044C\u043D\u044B\u0439 \u043E\u0442\u0441\u0442\u0443\u043F \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 (px)",
      "highlight_vertical_padding": "\u0412\u0435\u0440\u0442\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0439 \u043E\u0442\u0441\u0442\u0443\u043F \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 (px)",
      "reset_to_4": "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0434\u043E 4",
      "enable_border_highlight_once": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0440\u0430\u043C\u043A\u0443 \u0434\u043B\u044F \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "enable_border_highlight_once_desc": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0440\u0430\u043C\u043A\u0443 \u043A inline \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0435. \u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0439 HTML/CSS \u0431\u0443\u0434\u0435\u0442 \u0434\u043B\u0438\u043D\u043D\u044B\u043C.",
      "highlight_once_border_style": "\u0421\u0442\u043E\u0440\u043E\u043D\u0430 \u0440\u0430\u043C\u043A\u0438 \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "highlight_once_border_line_style": "\u0421\u0442\u0438\u043B\u044C \u0440\u0430\u043C\u043A\u0438",
      "opt_border_full": "\u041F\u043E\u043B\u043D\u0430\u044F \u0440\u0430\u043C\u043A\u0430 (\u0412\u0441\u0435 \u0441\u0442\u043E\u0440\u043E\u043D\u044B)",
      "opt_border_top_bottom": "\u0412\u0435\u0440\u0445 \u0438 \u041D\u0438\u0437",
      "opt_border_left_right": "\u041B\u0435\u0432\u043E \u0438 \u041F\u0440\u0430\u0432\u043E",
      "opt_border_top_left_right": "\u0412\u0435\u0440\u0445, \u041B\u0435\u0432\u043E \u0438 \u041F\u0440\u0430\u0432\u043E",
      "opt_border_bottom_left_right": "\u041D\u0438\u0437, \u041B\u0435\u0432\u043E \u0438 \u041F\u0440\u0430\u0432\u043E",
      "opt_border_top_right": "\u0412\u0435\u0440\u0445 \u0438 \u041F\u0440\u0430\u0432\u043E",
      "opt_border_top_left": "\u0412\u0435\u0440\u0445 \u0438 \u041B\u0435\u0432\u043E",
      "opt_border_bottom_right": "\u041D\u0438\u0437 \u0438 \u041F\u0440\u0430\u0432\u043E",
      "opt_border_bottom_left": "\u041D\u0438\u0437 \u0438 \u041B\u0435\u0432\u043E",
      "opt_border_top": "\u0422\u043E\u043B\u044C\u043A\u043E \u0412\u0435\u0440\u0445",
      "opt_border_bottom": "\u0422\u043E\u043B\u044C\u043A\u043E \u041D\u0438\u0437",
      "opt_border_left": "\u0422\u043E\u043B\u044C\u043A\u043E \u041B\u0435\u0432\u043E",
      "opt_border_right": "\u0422\u043E\u043B\u044C\u043A\u043E \u041F\u0440\u0430\u0432\u043E",
      "highlight_once_border_opacity": "\u041D\u0435\u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0440\u0430\u043C\u043A\u0438 \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "highlight_once_border_thickness": "\u0422\u043E\u043B\u0449\u0438\u043D\u0430 \u0440\u0430\u043C\u043A\u0438 \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 (px)",
      "reset_to_1": "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0434\u043E 1",
      "use_global_highlight_style": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0433\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u044B\u0439 \u0441\u0442\u0438\u043B\u044C \u0434\u043B\u044F \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "use_global_highlight_style_desc": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0432\u0430\u0448\u0438 \u0433\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u044B\u0435 \u0441\u0442\u0438\u043B\u0438 inline. \u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0439 HTML/CSS \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0434\u043B\u0438\u043D\u043D\u044B\u043C.",
      "style_highlight_once": "\u0421\u0442\u0438\u043B\u044C \u043E\u0434\u043D\u043E\u043A\u0440\u0430\u0442\u043D\u043E\u0439 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "style_highlight_once_desc": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0432\u0430\u0448\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u0441\u0442\u0438\u043B\u0438 inline. \u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0439 HTML/CSS \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0434\u043B\u0438\u043D\u043D\u044B\u043C.",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "\u0413\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u044B\u0439 \u0432\u0438\u0434 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "highlight_opacity": "\u041D\u0435\u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "highlight_opacity_desc": "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043D\u0435\u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 (0-100%)",
      "highlight_border_radius": "\u0420\u0430\u0434\u0438\u0443\u0441 \u0441\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u044F \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 (px)",
      "highlight_border_radius_desc": "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0430\u0434\u0438\u0443\u0441 \u0441\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u044F \u0443\u0433\u043B\u043E\u0432 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438 \u0432 px",
      "highlight_horizontal_padding_desc": "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043B\u0435\u0432\u044B\u0439/\u043F\u0440\u0430\u0432\u044B\u0439 \u043E\u0442\u0441\u0442\u0443\u043F \u0434\u043B\u044F \u043F\u043E\u0434\u0441\u0432\u0435\u0447\u0435\u043D\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430 \u0432 px",
      "highlight_vertical_padding_desc": "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0432\u0435\u0440\u0445\u043D\u0438\u0439/\u043D\u0438\u0436\u043D\u0438\u0439 \u043E\u0442\u0441\u0442\u0443\u043F \u0434\u043B\u044F \u043F\u043E\u0434\u0441\u0432\u0435\u0447\u0435\u043D\u043D\u043E\u0433\u043E \u0442\u0435\u043A\u0441\u0442\u0430 \u0432 px",
      "rounded_corners_wrapping": "\u0421\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u043D\u044B\u0435 \u0443\u0433\u043B\u044B \u043F\u0440\u0438 \u043F\u0435\u0440\u0435\u043D\u043E\u0441\u0435",
      "rounded_corners_wrapping_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430 \u0438\u043C\u0435\u0435\u0442 \u0441\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u043D\u044B\u0435 \u0443\u0433\u043B\u044B \u0441\u043E \u0432\u0441\u0435\u0445 \u0441\u0442\u043E\u0440\u043E\u043D, \u0434\u0430\u0436\u0435 \u043A\u043E\u0433\u0434\u0430 \u0442\u0435\u043A\u0441\u0442 \u043F\u0435\u0440\u0435\u043D\u043E\u0441\u0438\u0442\u0441\u044F \u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443.",
      "enable_highlight_border": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0440\u0430\u043C\u043A\u0443 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "enable_highlight_border_desc": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0440\u0430\u043C\u043A\u0443 \u0432\u043E\u043A\u0440\u0443\u0433 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438. \u0420\u0430\u043C\u043A\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0446\u0432\u0435\u0442\u0443 \u0442\u0435\u043A\u0441\u0442\u0430 \u0438\u043B\u0438 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438.",
      "border_style": "\u0421\u0442\u043E\u0440\u043E\u043D\u0430 \u0440\u0430\u043C\u043A\u0438",
      "border_style_desc": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u0442\u043E\u0440\u043E\u043D\u044B, \u043A \u043A\u043E\u0442\u043E\u0440\u044B\u043C \u043F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u0440\u0430\u043C\u043A\u0443",
      "border_line_style": "\u0421\u0442\u0438\u043B\u044C \u0440\u0430\u043C\u043A\u0438",
      "border_line_style_desc": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u0442\u0438\u043B\u044C \u043B\u0438\u043D\u0438\u0438 \u0440\u0430\u043C\u043A\u0438",
      "border_opacity": "\u041D\u0435\u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0440\u0430\u043C\u043A\u0438",
      "border_opacity_desc": "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043D\u0435\u043F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0440\u0430\u043C\u043A\u0438 (0-100%)",
      "border_thickness": "\u0422\u043E\u043B\u0449\u0438\u043D\u0430 \u0440\u0430\u043C\u043A\u0438 (px)",
      "border_thickness_desc": "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0442\u043E\u043B\u0449\u0438\u043D\u0443 \u0440\u0430\u043C\u043A\u0438 \u043E\u0442 0 \u0434\u043E 5 \u043F\u0438\u043A\u0441\u0435\u043B\u0435\u0439 (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, 1, 2.5, 5)",
      "highlight_preview": "\u041F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "highlight_preview_text": "\u0422\u0430\u043A \u0431\u0443\u0434\u0435\u0442 \u0432\u044B\u0433\u043B\u044F\u0434\u0435\u0442\u044C \u0432\u0430\u0448\u0430 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430!",
      "opt_line_solid": "\u0421\u043F\u043B\u043E\u0448\u043D\u0430\u044F",
      "opt_line_dashed": "\u0428\u0442\u0440\u0438\u0445\u043E\u0432\u0430\u044F",
      "opt_line_dotted": "\u0422\u043E\u0447\u0435\u0447\u043D\u0430\u044F",
      "opt_line_double": "\u0414\u0432\u043E\u0439\u043D\u0430\u044F",
      "opt_line_groove": "\u0412\u0434\u0430\u0432\u043B\u0435\u043D\u043D\u0430\u044F",
      "opt_line_ridge": "\u0412\u044B\u043F\u0443\u043A\u043B\u0430\u044F",
      "opt_line_inset": "\u0412\u0441\u0442\u0430\u0432\u043A\u0430",
      "opt_line_outset": "\u0412\u044B\u0441\u0442\u0443\u043F",
      // Color Swatches
      "color_swatches_header": "\u041F\u0430\u043B\u0438\u0442\u0440\u044B \u0446\u0432\u0435\u0442\u043E\u0432",
      "color_picker_layout": "\u041C\u0430\u043A\u0435\u0442 \u0432\u044B\u0431\u043E\u0440\u0430 \u0446\u0432\u0435\u0442\u0430",
      "color_picker_layout_desc": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0438\u043F\u044B \u0446\u0432\u0435\u0442\u043E\u0432 \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043F\u0440\u0438 \u0432\u044B\u0431\u043E\u0440\u0435 \u0446\u0432\u0435\u0442\u0430 \u0434\u043B\u044F \u0441\u043B\u043E\u0432\u0430",
      "opt_both_text_left": "\u041E\u0431\u0430: \u0422\u0435\u043A\u0441\u0442 \u0421\u043B\u0435\u0432\u0430, \u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430 \u0421\u043F\u0440\u0430\u0432\u0430",
      "opt_both_bg_left": "\u041E\u0431\u0430: \u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430 \u0421\u043B\u0435\u0432\u0430, \u0422\u0435\u043A\u0441\u0442 \u0421\u043F\u0440\u0430\u0432\u0430",
      "opt_both_text_top": "\u041E\u0431\u0430 (\u0412\u0435\u0440\u0442\u0438\u043A\u0430\u043B\u044C\u043D\u043E): \u0422\u0435\u043A\u0441\u0442 \u0421\u0432\u0435\u0440\u0445\u0443, \u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430 \u0421\u043D\u0438\u0437\u0443",
      "opt_both_bg_top": "\u041E\u0431\u0430 (\u0412\u0435\u0440\u0442\u0438\u043A\u0430\u043B\u044C\u043D\u043E): \u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430 \u0421\u0432\u0435\u0440\u0445\u0443, \u0422\u0435\u043A\u0441\u0442 \u0421\u043D\u0438\u0437\u0443",
      "opt_text_only": "\u0422\u043E\u043B\u044C\u043A\u043E \u0446\u0432\u0435\u0442 \u0442\u0435\u043A\u0441\u0442\u0430",
      "opt_background_only": "\u0422\u043E\u043B\u044C\u043A\u043E \u0446\u0432\u0435\u0442 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "replace_default_swatches": "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u044B\u0435 \u043F\u0430\u043B\u0438\u0442\u0440\u044B",
      "replace_default_swatches_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0432 \u0432\u044B\u0431\u043E\u0440\u0435 \u0431\u0443\u0434\u0443\u0442 \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E \u0432\u0430\u0448\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u0446\u0432\u0435\u0442\u0430, \u0430 \u043D\u0435 \u0441\u0442\u0430\u043D\u0434\u0430\u0440\u0442\u043D\u044B\u0435!",
      "enable_custom_swatches": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0430\u043B\u0438\u0442\u0440\u044B",
      "enable_custom_swatches_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0432\u0430\u0448\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0430\u043B\u0438\u0442\u0440\u044B \u043F\u043E\u044F\u0432\u044F\u0442\u0441\u044F \u0432 \u0432\u044B\u0431\u043E\u0440\u0435 \u0446\u0432\u0435\u0442\u0430.",
      "use_swatch_names": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u0442\u0435\u043A\u0441\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044F \u0438\u043C\u0435\u043D\u0430 \u043F\u0430\u043B\u0438\u0442\u0440",
      "use_swatch_names_desc": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0432\u044B\u043F\u0430\u0434\u0430\u044E\u0449\u0438\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u0438\u043C\u0435\u043D \u043F\u0430\u043B\u0438\u0442\u0440 \u0440\u044F\u0434\u043E\u043C \u0441 \u0432\u0432\u043E\u0434\u043E\u043C \u0441\u043B\u043E\u0432\u0430/\u0448\u0430\u0431\u043B\u043E\u043D\u0430",
      "link_swatches_to_entries": "\u0421\u0432\u044F\u0437\u0430\u0442\u044C \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u043F\u0430\u043B\u0438\u0442\u0440 \u0441 \u043E\u043A\u0440\u0430\u0448\u0435\u043D\u043D\u044B\u043C\u0438 \u0442\u0435\u043A\u0441\u0442\u0430\u043C\u0438",
      "link_swatches_to_entries_desc": "\u041E\u0431\u043D\u043E\u0432\u043B\u044F\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043F\u0438\u0441\u0438, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0449\u0438\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0443\u044E \u043F\u0430\u043B\u0438\u0442\u0440\u0443, \u043A\u043E\u0433\u0434\u0430 \u0446\u0432\u0435\u0442 \u044D\u0442\u043E\u0439 \u043F\u0430\u043B\u0438\u0442\u0440\u044B \u043C\u0435\u043D\u044F\u0435\u0442\u0441\u044F",
      "default_colors_header": "\u0426\u0432\u0435\u0442\u0430 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
      "custom_swatches_header": "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0435 \u043F\u0430\u043B\u0438\u0442\u0440\u044B",
      "btn_add_color": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0446\u0432\u0435\u0442",
      "no_custom_swatches_yet": "\u041F\u043E\u043A\u0430 \u043D\u0435\u0442 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0445 \u043F\u0430\u043B\u0438\u0442\u0440. \u041D\u0430\u0436\u043C\u0438\u0442\u0435 \xAB+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0446\u0432\u0435\u0442\xBB, \u0447\u0442\u043E\u0431\u044B \u0441\u043E\u0437\u0434\u0430\u0442\u044C.",
      "label_built_in": "(\u0412\u0441\u0442\u0440\u043E\u0435\u043D\u043D\u044B\u0439)",
      // Color Picker
      "pick_color_header": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0446\u0432\u0435\u0442",
      "selected_text_preview": "\u0412\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442",
      "text_color_title": "\u0426\u0432\u0435\u0442 \u0442\u0435\u043A\u0441\u0442\u0430",
      "select_swatch": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043B\u0438\u0442\u0440\u0443...",
      "highlight_color_title": "\u0426\u0432\u0435\u0442 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "select_highlight_swatch": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043B\u0438\u0442\u0440\u0443 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438...",
      "settings_tab_general": "\u041E\u0431\u0449\u0438\u0435",
      "settings_tab_colored_texts": "\u041E\u043A\u0440\u0430\u0448\u0435\u043D\u043D\u044B\u0435 \u0442\u0435\u043A\u0441\u0442\u044B",
      "settings_tab_blacklists": "\u0427\u0451\u0440\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438",
      "settings_tab_file_folder_rules": "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u0444\u0430\u0439\u043B\u043E\u0432 / \u043F\u0430\u043F\u043E\u043A",
      "settings_tab_data": "\u0414\u0430\u043D\u043D\u044B\u0435",
      // Always Colored Texts
      "always_colored_texts_header": "\u0412\u0441\u0435\u0433\u0434\u0430 \u043E\u043A\u0440\u0430\u0448\u0435\u043D\u043D\u044B\u0435 \u0442\u0435\u043A\u0441\u0442\u044B",
      "always_colored_texts_desc": "\u0417\u0434\u0435\u0441\u044C \u0432\u044B \u0443\u043F\u0440\u0430\u0432\u043B\u044F\u0435\u0442\u0435 \u0432\u0430\u0448\u0438\u043C\u0438 \u0441\u043B\u043E\u0432\u0430\u043C\u0438/\u0448\u0430\u0431\u043B\u043E\u043D\u0430\u043C\u0438 \u0438 \u0438\u0445 \u0446\u0432\u0435\u0442\u0430\u043C\u0438.",
      "colored_texts_header": "\u041E\u043A\u0440\u0430\u0448\u0435\u043D\u043D\u044B\u0435 \u0442\u0435\u043A\u0441\u0442\u044B",
      "grouped_entries_header": "\u0413\u0440\u0443\u043F\u043F\u044B \u0441\u043B\u043E\u0432",
      "grouped_entries_desc": "\u0423\u043F\u0440\u0430\u0432\u043B\u044F\u0439\u0442\u0435 \u0433\u0440\u0443\u043F\u043F\u0430\u043C\u0438 \u0441\u043B\u043E\u0432. \u041F\u043E\u0438\u0441\u043A \u0444\u0438\u043B\u044C\u0442\u0440\u0443\u0435\u0442 \u043F\u043E \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044E.",
      "search_groups_placeholder": "\u041F\u043E\u0438\u0441\u043A \u0433\u0440\u0443\u043F\u043F\u2026",
      "edit_word_group_modal_title": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0443 \u0441\u043B\u043E\u0432",
      "btn_save_group": "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0443",
      "btn_delete_group": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0443",
      "group_active_label": "\u0410\u043A\u0442\u0438\u0432\u043D\u0430",
      "group_inactive_label": "\u041D\u0435\u0430\u043A\u0442\u0438\u0432\u043D\u0430",
      "tooltip_duplicate_group": "\u0414\u0443\u0431\u043B\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0443",
      "tooltip_edit_group_settings": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0433\u0440\u0443\u043F\u043F\u044B",
      "tooltip_delete_all_groups": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0433\u0440\u0443\u043F\u043F\u044B \u0441\u043B\u043E\u0432",
      "btn_create_new_group": "+ \u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043D\u043E\u0432\u0443\u044E \u0433\u0440\u0443\u043F\u043F\u0443",
      "no_entries_found": "\u0417\u0430\u043F\u0438\u0441\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B.",
      "search_colored_words_placeholder": "\u041F\u043E\u0438\u0441\u043A \u043E\u043A\u0440\u0430\u0448\u0435\u043D\u043D\u044B\u0445 \u0441\u043B\u043E\u0432 \u0438\u043B\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u043E\u0432\u2026",
      "sort_label_last-added": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u041F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0435",
      "sort_label_a-z": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u0410-\u042F",
      "sort_label_reverse-a-z": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u042F-\u0410",
      "sort_label_style-order": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u041F\u043E \u0441\u0442\u0438\u043B\u044E",
      "sort_label_color": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u0426\u0432\u0435\u0442",
      "btn_add_new_word": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043D\u043E\u0432\u043E\u0435 \u0441\u043B\u043E\u0432\u043E / \u0448\u0430\u0431\u043B\u043E\u043D",
      "style_type_text": "\u0426\u0432\u0435\u0442",
      "style_type_highlight": "\u041F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430",
      "style_type_both": "\u041E\u0431\u0430",
      "word_pattern_placeholder_long": "\u0448\u0430\u0431\u043B\u043E\u043D, \u0441\u043B\u043E\u0432\u043E \u0438\u043B\u0438 \u0441\u043B\u043E\u0432\u0430 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0440\u0438\u0432\u0435\u0442, \u043C\u0438\u0440, foo)",
      "word_pattern_placeholder_short": "\u043A\u043B\u044E\u0447\u0435\u0432\u043E\u0435 \u0441\u043B\u043E\u0432\u043E \u0438\u043B\u0438 \u0448\u0430\u0431\u043B\u043E\u043D, \u0438\u043B\u0438 \u0441\u043B\u043E\u0432\u0430 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E",
      "use_regex": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C Regex",
      "flags_placeholder": "\u0424\u043B\u0430\u0433\u0438",
      "text_or_regex_placeholder": "\u0412\u0432\u043E\u0434 \u0422\u0435\u043A\u0441\u0442\u0430/Regex",
      "duplicate_entry": "\u0414\u0443\u0431\u043B\u0438\u043A\u0430\u0442 \u0437\u0430\u043F\u0438\u0441\u0438",
      "open_in_regex_tester": "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0432 \u0442\u0435\u0441\u0442\u0435\u0440\u0435 Regex",
      "no_rules_configured": "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043D\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D\u044B.",
      "no_rules_found": "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B.",
      "match_option_exact": "\u0422\u043E\u0447\u043D\u043E\u0435",
      "match_option_contains": "\u0421\u043E\u0434\u0435\u0440\u0436\u0438\u0442",
      "match_option_starts_with": "\u041D\u0430\u0447\u0438\u043D\u0430\u0435\u0442\u0441\u044F \u0441",
      "match_option_ends_with": "\u0417\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u043D\u0430",
      // Presets
      "btn_presets": "\u041F\u0440\u0435\u0441\u0435\u0442\u044B",
      "preset_all_headings": "\u0412\u0441\u0435 \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438 (H1-H6)",
      "preset_bullet_points": "\u041C\u0430\u0440\u043A\u0435\u0440\u044B \u0441\u043F\u0438\u0441\u043A\u0430",
      "preset_numbered_lists": "\u041D\u0443\u043C\u0435\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438",
      "preset_task_checked": "\u0421\u043F\u0438\u0441\u043A\u0438 \u0437\u0430\u0434\u0430\u0447 (\u0412\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u043D\u044B\u0435)",
      "preset_task_unchecked": "\u0421\u043F\u0438\u0441\u043A\u0438 \u0437\u0430\u0434\u0430\u0447 (\u041D\u0435\u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u043D\u044B\u0435)",
      "preset_dates_yyyy_mm_dd": "\u0414\u0430\u0442\u044B (\u0413\u0413\u0413\u0413-\u041C\u041C-\u0414\u0414)",
      "preset_times_am_pm": "\u0412\u0440\u0435\u043C\u044F (AM/PM)",
      "preset_times_24h": "\u0412\u0440\u0435\u043C\u044F (24h)",
      "preset_dates_yyyy_mmm_dd": "\u0414\u0430\u0442\u044B (\u0413\u0413\u0413\u0413-\u041C\u041C\u041C-\u0414\u0414)",
      "preset_relative_dates": "\u041E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u0434\u0430\u0442\u044B",
      "preset_basic_urls": "\u0411\u0430\u0437\u043E\u0432\u044B\u0435 URL",
      "preset_markdown_links": "Markdown \u0441\u0441\u044B\u043B\u043A\u0438",
      "preset_domain_names": "\u0414\u043E\u043C\u0435\u043D\u043D\u044B\u0435 \u0438\u043C\u0435\u043D\u0430",
      "preset_email_addresses": "Email \u0430\u0434\u0440\u0435\u0441\u0430",
      "preset_at_username": "@\u0418\u043C\u044F\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F",
      "preset_currency": "\u0412\u0430\u043B\u044E\u0442\u0430",
      "preset_measurements": "\u0418\u0437\u043C\u0435\u0440\u0435\u043D\u0438\u044F",
      "preset_phone_numbers": "\u0422\u0435\u043B\u0435\u0444\u043E\u043D\u043D\u044B\u0435 \u043D\u043E\u043C\u0435\u0440\u0430",
      "preset_all_texts": "\u0412\u0435\u0441\u044C \u0442\u0435\u043A\u0441\u0442",
      "preset_codeblocks": "\u0411\u043B\u043E\u043A\u0438 \u043A\u043E\u0434\u0430",
      "preset_inline_comments": "\u041A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0438 (%%...%%)",
      "preset_highlighted_text": "\u0412\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442 (==...)",
      "preset_parentheses": "\u041A\u0440\u0443\u0433\u043B\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438 ()",
      "preset_square_brackets": "\u041A\u0432\u0430\u0434\u0440\u0430\u0442\u043D\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438 []",
      "preset_curly_braces": "\u0424\u0438\u0433\u0443\u0440\u043D\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438 {}",
      "preset_angle_brackets": "\u0423\u0433\u043B\u043E\u0432\u044B\u0435 \u0441\u043A\u043E\u0431\u043A\u0438 <>",
      "preset_colons": "\u0414\u0432\u043E\u0435\u0442\u043E\u0447\u0438\u044F :",
      "preset_double_quotes": "\u0414\u0432\u043E\u0439\u043D\u044B\u0435 \u043A\u0430\u0432\u044B\u0447\u043A\u0438",
      "preset_single_quotes": "\u041E\u0434\u0438\u043D\u0430\u0440\u043D\u044B\u0435 \u043A\u0430\u0432\u044B\u0447\u043A\u0438",
      "preset_single_quotes_word_bounded": "\u041E\u0434\u0438\u043D\u0430\u0440\u043D\u044B\u0435 \u043A\u0430\u0432\u044B\u0447\u043A\u0438 (\u0412\u043E\u043A\u0440\u0443\u0433 \u0441\u043B\u043E\u0432)",
      "preset_group_markdown_formatting": "Markdown \u0444\u043E\u0440\u043C\u0430\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435",
      "preset_group_other_patterns": "\u0414\u0440\u0443\u0433\u0438\u0435 \u0448\u0430\u0431\u043B\u043E\u043D\u044B",
      "preset_group_brackets": "\u0421\u043A\u043E\u0431\u043A\u0438",
      // Preset Examples
      "preset_example_heading": "# \u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043E\u043A",
      "preset_example_bullet": "- \u041F\u0443\u043D\u043A\u0442",
      "preset_example_numbered": "1. \u041F\u0435\u0440\u0432\u044B\u0439 \u044D\u043B\u0435\u043C\u0435\u043D\u0442",
      "preset_example_task_checked": "- [x] \u0412\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u043E",
      "preset_example_task_unchecked": "- [ ] \u0421\u0434\u0435\u043B\u0430\u0442\u044C",
      "preset_example_codeblock": "``` \u043A\u043E\u0434 ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[\u0421\u0441\u044B\u043B\u043A\u0430](https://example.com)",
      "preset_example_comment": "%% \u043A\u043E\u043C\u043C\u0435\u043D\u0442\u0430\u0440\u0438\u0439 %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "name@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "$29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( \u0442\u0435\u043A\u0441\u0442 )",
      "preset_example_square_brackets": "[ \u0434\u0430 ]",
      "preset_example_curly_braces": "{ \u043D\u0435\u0442 }",
      "preset_example_angle_brackets": "< \u0442\u0435\u043A\u0441\u0442 >",
      "preset_example_colons": ": \u0442\u0435\u043A\u0441\u0442 :",
      "preset_example_double_quotes": '"\u0442\u0435\u043A\u0441\u0442"',
      "preset_example_single_quotes": "'\u0442\u0435\u043A\u0441\u0442'",
      "preset_example_single_quotes_word": "'\u0441\u043B\u043E\u0432\u043E'",
      "preset_example_highlight": "==\u0432\u044B\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0439 \u0442\u0435\u043A\u0441\u0442==",
      "preset_example_all_text": "\u042D\u0442\u043E \u0432\u044B\u0431\u0435\u0440\u0435\u0442 \u0432\u0435\u0441\u044C \u0442\u0435\u043A\u0441\u0442.",
      // Blacklist Settings
      "blacklist_words_header": "\u0427\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u0441\u043B\u043E\u0432",
      "blacklist_words_desc": "\u041A\u043B\u044E\u0447\u0435\u0432\u044B\u0435 \u0441\u043B\u043E\u0432\u0430 \u0438\u043B\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0435 \u0441\u044E\u0434\u0430 \u041D\u0418\u041A\u041E\u0413\u0414\u0410 \u043D\u0435 \u0431\u0443\u0434\u0443\u0442 \u043E\u043A\u0440\u0430\u0448\u0435\u043D\u044B, \u0434\u0430\u0436\u0435 \u043F\u0440\u0438 \u0447\u0430\u0441\u0442\u0438\u0447\u043D\u043E\u043C \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u0438.",
      "search_blacklist_placeholder": "\u041F\u043E\u0438\u0441\u043A \u0441\u043B\u043E\u0432 \u0438\u043B\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u043E\u0432, \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0445 \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A\u2026",
      "blacklist_sort_label_last-added": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u041F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0435",
      "blacklist_sort_label_a-z": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u0410-\u042F",
      "blacklist_sort_label_reverse-a-z": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u042F-\u0410",
      "btn_add_blacklist": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E \u0438\u043B\u0438 \u0448\u0430\u0431\u043B\u043E\u043D \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "btn_add_to_blacklist": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "btn_add_blacklist_word": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "btn_add_blacklist_regex": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C regex \u0432 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      // File & Folder Rules
      "file_folder_rules_header": "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432 \u0438 \u043F\u0430\u043F\u043E\u043A",
      "file_folder_rules_desc": "\u0423\u043F\u0440\u0430\u0432\u043B\u044F\u0439\u0442\u0435 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435\u043C \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u0439 \u043F\u043E \u0438\u043C\u0435\u043D\u0430\u043C, \u0442\u043E\u0447\u043D\u044B\u0445 \u043F\u0443\u0442\u0435\u0439 \u0438\u043B\u0438 regex \u0448\u0430\u0431\u043B\u043E\u043D\u043E\u0432. \u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u043E\u0435 \u043F\u043E\u043B\u0435 \u0432\u0432\u043E\u0434\u0430 \u0441 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u043E\u043C \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435, \u0447\u0442\u043E\u0431\u044B \u043E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E \u0432\u0441\u0435\u043C\u0443 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0443.",
      "search_file_folder_rules_placeholder": "\u041F\u043E\u0438\u0441\u043A \u043F\u0440\u0430\u0432\u0438\u043B \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u043E\u0432/\u043F\u0430\u043F\u043E\u043A\u2026",
      "path_sort_label_last-added": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u041F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043D\u044B\u0435",
      "path_sort_label_a-z": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u0410-\u042F",
      "path_sort_label_reverse-a-z": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u042F-\u0410",
      "path_sort_label_mode": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u0420\u0435\u0436\u0438\u043C",
      "path_sort_label_type": "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C: \u0422\u0438\u043F",
      "btn_add_file_folder_rule": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E \u0434\u043B\u044F \u0444\u0430\u0439\u043B\u0430/\u043F\u0430\u043F\u043A\u0438",
      "disabled_files_header": "\u0424\u0430\u0439\u043B\u044B \u0441 \u043E\u0442\u043A\u043B\u044E\u0447\u0451\u043D\u043D\u044B\u043C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u0435\u043C:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C",
      "path_rule_mode_exclude": "\u0418\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C",
      "text_rule_mode_include": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u0432 (\u0441\u043F\u0438\u0441\u043E\u043A \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438\u0439)",
      "text_rule_mode_exclude": "\u041D\u0435 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u0432 (\u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A)",
      "mode_only_colors_in": "\u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0442\u043E\u043B\u044C\u043A\u043E \u0432",
      "mode_does_not_color_in": "\u043D\u0435 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432",
      "label_text_include": "\u0411\u0435\u043B\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "label_text_exclude": "\u0427\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "label_enable_in": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432",
      "label_disable_in": "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0432",
      "enter_path_or_pattern": "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u0443\u0442\u044C, \u0448\u0430\u0431\u043B\u043E\u043D \u0438\u043B\u0438 \u0442\u0435\u0433\u0438",
      "label_regex": "Regex",
      // Advanced Rules
      "advanced_rules_header": "\u0421\u043F\u0435\u0446\u0438\u0444\u0438\u0447\u0435\u0441\u043A\u0438\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0430 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F/\u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
      "advanced_rules_modal_header": "\u0421\u043F\u0435\u0446\u0438\u0444\u0438\u0447\u0435\u0441\u043A\u0438\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0430 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F/\u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
      "advanced_rules_manage_button": "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u0441\u043F\u0435\u0446\u0438\u0444\u0438\u0447\u0435\u0441\u043A\u0438\u043C\u0438 \u043F\u0440\u0430\u0432\u0438\u043B\u0430\u043C\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F/\u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
      "edit_rule_header": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E",
      "add_rule_header": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043D\u043E\u0432\u043E\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u043E",
      "btn_add_rule": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E",
      "btn_save_rule": "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E",
      "btn_add_words": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E",
      "btn_add_regex": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C Regex",
      "btn_save_regex": "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C Regex",
      // Regex Tester
      "regex_tester_header": "\u041A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u0445 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
      "regex_tester_blacklist": "\u041A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440 regex - \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "regex_expression_placeholder": "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u043E\u0435 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
      "regex_subject_placeholder": "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u043A\u0441\u0442...",
      "regex_name_placeholder": "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 Regex",
      "matches": "\u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u044F",
      "matches_found": "\u043D\u0430\u0439\u0434\u0435\u043D\u043E \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u0439",
      // Regex Flags
      "flag_g": "\u0433\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u044B\u0439 \u0444\u043B\u0430\u0433: \u043D\u0430\u0439\u0442\u0438 \u0432\u0441\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u044F",
      "flag_i": "\u0444\u043B\u0430\u0433 \u0431\u0435\u0437 \u0443\u0447\u0435\u0442\u0430 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430",
      "flag_m": "\u043C\u043D\u043E\u0433\u043E\u0441\u0442\u0440\u043E\u0447\u043D\u044B\u0439 \u0444\u043B\u0430\u0433: ^ \u0438 $ \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u044E\u0442 \u0441 \u0433\u0440\u0430\u043D\u0438\u0446\u0430\u043C\u0438 \u0441\u0442\u0440\u043E\u043A",
      "flag_s": "\u0444\u043B\u0430\u0433 dotAll: . \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442 \u0441 \u0440\u0430\u0437\u0440\u044B\u0432\u0430\u043C\u0438 \u0441\u0442\u0440\u043E\u043A",
      "flag_u": "\u0444\u043B\u0430\u0433 unicode: \u043E\u0431\u0440\u0430\u0431\u0430\u0442\u044B\u0432\u0430\u0442\u044C \u043A\u0430\u043A \u0442\u043E\u0447\u043A\u0438 \u043A\u043E\u0434\u0430 unicode",
      "flag_y": "\u043B\u0438\u043F\u043A\u0438\u0439 \u0444\u043B\u0430\u0433: \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u0435 \u0441 \u043F\u043E\u0437\u0438\u0446\u0438\u0438 lastIndex",
      // Data Export/Import
      "data_export_import_header": "\u042D\u043A\u0441\u043F\u043E\u0440\u0442/\u0418\u043C\u043F\u043E\u0440\u0442 \u0434\u0430\u043D\u043D\u044B\u0445",
      "export_plugin_data": "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u0434\u0430\u043D\u043D\u044B\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
      "export_plugin_data_desc": "\u042D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438, \u0441\u043B\u043E\u0432\u0430 \u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u044B \u0432 \u0444\u0430\u0439\u043B JSON.",
      "btn_export": "\u042D\u043A\u0441\u043F\u043E\u0440\u0442",
      "import_plugin_data": "\u0418\u043C\u043F\u043E\u0440\u0442 \u0434\u0430\u043D\u043D\u044B\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
      "import_plugin_data_desc": "\u0418\u043C\u043F\u043E\u0440\u0442 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A \u0438\u0437 JSON \u0444\u0430\u0439\u043B\u0430",
      "btn_import": "\u0418\u043C\u043F\u043E\u0440\u0442",
      "limit_input_placeholder": "\u043B\u0438\u043C\u0438\u0442",
      "limit_input_tooltip": "0=\u0432\u0441\u0435; \u0447\u0438\u0441\u043B\u043E=\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435 N; r=\u0442\u043E\u043B\u044C\u043A\u043E regex; h=\u0442\u043E\u043B\u044C\u043A\u043E \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0430; c=\u0442\u043E\u043B\u044C\u043A\u043E \u0442\u0435\u043A\u0441\u0442; b=\u0442\u0435\u043A\u0441\u0442+\u0444\u043E\u043D; sw=\u043D\u0430\u0447\u0438\u043D\u0430\u0435\u0442\u0441\u044F \u0441; ew=\u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u043D\u0430; e=\u0442\u043E\u0447\u043D\u043E\u0435",
      // Missing Keys Added
      "highlight_styling_header": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0442\u0438\u043B\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "edit_entry_header": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043F\u0438\u0441\u044C",
      "opt_case_sensitive": "\u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D \u043A \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0443",
      "opt_not_case_sensitive": "\u043D\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D \u043A \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0443",
      "opt_case_all": "\u0427\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u043A \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0443 (\u0412\u0441\u0435)",
      "opt_match_all": "\u0422\u0438\u043F \u0441\u043E\u0432\u043F\u0430\u0434\u0435\u043D\u0438\u044F (\u0412\u0441\u0435)",
      "edit_highlight_styling_btn": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0442\u0438\u043B\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "inclusion_exclusion_header": "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F / \u0438\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F",
      "btn_save_entry": "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0437\u0430\u043F\u0438\u0441\u044C",
      "edit_entry_details": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0434\u0435\u0442\u0430\u043B\u0438 \u0437\u0430\u043F\u0438\u0441\u0438",
      "prompt_search_existing": "\u041F\u043E\u0438\u0441\u043A \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0445 \u0437\u0430\u043F\u0438\u0441\u0435\u0439\u2026",
      "command_add_to_existing_entry": "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043A \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0435\u0439 \u0437\u0430\u043F\u0438\u0441\u0438",
      "context_remove_from_entry": '\u0423\u0434\u0430\u043B\u0438\u0442\u044C "{word}" \u0438\u0437 \u0437\u0430\u043F\u0438\u0441\u0438',
      "context_delete_entry": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0437\u0430\u043F\u0438\u0441\u044C",
      "btn_reset": "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C",
      "btn_reset_all": "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0441\u0442\u0438\u043B\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "btn_add_word": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E",
      "btn_add_regex_short": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C Regex",
      "section_highlight_border_styling": "\u0421\u0442\u0438\u043B\u044C \u0440\u0430\u043C\u043A\u0438 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "section_highlight_styling": "\u0421\u0442\u0438\u043B\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "label_highlight_opacity": "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "label_highlight_radius": "\u0420\u0430\u0434\u0438\u0443\u0441 \u0440\u0430\u043C\u043A\u0438 \u043F\u043E\u0434\u0441\u0432\u0435\u0442\u043A\u0438",
      "label_horizontal_padding": "\u0413\u043E\u0440\u0438\u0437\u043E\u043D\u0442\u0430\u043B\u044C\u043D\u044B\u0439 \u043E\u0442\u0441\u0442\u0443\u043F",
      "label_vertical_padding": "\u0412\u0435\u0440\u0442\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0439 \u043E\u0442\u0441\u0442\u0443\u043F",
      "label_enable_border": "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0440\u0430\u043C\u043A\u0443",
      "label_border_sides": "\u0421\u0442\u043E\u0440\u043E\u043D\u044B \u0440\u0430\u043C\u043A\u0438",
      "label_border_style": "\u0421\u0442\u0438\u043B\u044C \u0440\u0430\u043C\u043A\u0438",
      "label_border_opacity": "\u041F\u0440\u043E\u0437\u0440\u0430\u0447\u043D\u043E\u0441\u0442\u044C \u0440\u0430\u043C\u043A\u0438",
      "label_border_thickness": "\u0422\u043E\u043B\u0449\u0438\u043D\u0430 \u0440\u0430\u043C\u043A\u0438",
      "btn_save_style": "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0441\u0442\u0438\u043B\u044C",
      // Quick Colors / Styles
      "quick_actions_header": "\u0411\u044B\u0441\u0442\u0440\u044B\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F",
      // added
      "quick_colors_header": "\u0411\u044B\u0441\u0442\u0440\u044B\u0435 \u0446\u0432\u0435\u0442\u0430",
      "quick_colors_desc": "\u041F\u043E\u0437\u0432\u043E\u043B\u044F\u0435\u0442 \u0431\u044B\u0441\u0442\u0440\u043E \u043F\u043E\u0434\u0441\u0432\u0435\u0447\u0438\u0432\u0430\u0442\u044C \u0438\u043B\u0438 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u0442\u0435\u043A\u0441\u0442, \u043F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u044F \u0446\u0432\u0435\u0442\u0430 \u0432 \u043A\u043E\u043D\u0442\u0435\u043A\u0441\u0442\u043D\u043E\u043C \u043C\u0435\u043D\u044E. \u0415\u0441\u043B\u0438 \u0411\u044B\u0441\u0442\u0440\u044B\u0435 \u0446\u0432\u0435\u0442\u0430 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u044B, \u0431\u0443\u0434\u0443\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0446\u0432\u0435\u0442\u0430 \u0441\u0442\u0438\u043B\u0435\u0439 \u0438\u0437 \u0411\u044B\u0441\u0442\u0440\u044B\u0445 \u0441\u0442\u0438\u043B\u0435\u0439.",
      "quick_colors_apply_mode_label": "\u041E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044C \u0442\u0435\u043A\u0441\u0442 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E",
      "quick_colors_apply_mode_act": "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
      "quick_colors_apply_mode_html": "\u041F\u0440\u0438 \u043F\u043E\u043C\u043E\u0449\u0438 HTML \u043A\u043E\u0434\u0430",
      "quick_styles_header": "\u0411\u044B\u0441\u0442\u0440\u044B\u0435 \u0441\u0442\u0438\u043B\u0438",
      "quick_styles_desc": "\u041E\u043F\u0440\u0435\u0434\u0435\u043B\u0438\u0442\u0435 \u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0441\u0442\u0438\u043B\u0438 \u0434\u043B\u044F \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0446\u0432\u0435\u0442\u0430 \u0442\u0435\u043A\u0441\u0442\u0430 \u0438 \u0432\u044B\u0434\u0435\u043B\u0435\u043D\u0438\u044F. \u0415\u0441\u043B\u0438 \u0411\u044B\u0441\u0442\u0440\u044B\u0435 \u0446\u0432\u0435\u0442\u0430 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u044B, \u0431\u0443\u0434\u0443\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0446\u0432\u0435\u0442\u0430 \u0441\u0442\u0438\u043B\u0435\u0439 \u0437\u0434\u0435\u0441\u044C.",
      "btn_add_style": "+ \u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0441\u0442\u0438\u043B\u044C",
      "quick_styles_menu_option": "\u0411\u044B\u0441\u0442\u0440\u044B\u0435 \u0441\u0442\u0438\u043B\u0438",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "\u0421\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0447\u0451\u0440\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438 \u0441\u043B\u043E\u0432",
      "show_blacklist_groups_in_commands": "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u0447\u0451\u0440\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438 \u0441\u043B\u043E\u0432 \u0432 \u043A\u043E\u043C\u0430\u043D\u0434\u0430\u0445",
      "show_blacklist_groups_in_commands_desc": "\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0447\u0451\u0440\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438 \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\u0441\u044F \u0432 \u043F\u0430\u043B\u0438\u0442\u0440\u0435 \u043A\u043E\u043C\u0430\u043D\u0434 \u0441 \u043A\u043E\u043C\u0430\u043D\u0434\u0430\u043C\u0438 \u0410\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C/\u0434\u0435\u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C.",
      "search_blacklist_groups_placeholder": "\u041F\u043E\u0438\u0441\u043A \u0447\u0451\u0440\u043D\u043E\u0433\u043E \u0441\u043F\u0438\u0441\u043A\u0430\u2026",
      "btn_create_new_blacklist_group": "+ \u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043D\u043E\u0432\u044B\u0439 \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "edit_blacklist_group_modal_title": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "tooltip_delete_all_blacklist_groups": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0447\u0451\u0440\u043D\u044B\u0435 \u0441\u043F\u0438\u0441\u043A\u0438",
      "btn_duplicate_entry": "\u0414\u0443\u0431\u043B\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043F\u0438\u0441\u044C",
      "btn_open_in_regex_tester": "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0432 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0442\u043E\u0440\u0435 Regex",
      "move_to_blacklist_group": "\u041F\u0435\u0440\u0435\u043D\u0435\u0441\u0442\u0438 \u0432 \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A",
      "btn_delete_entry": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0437\u0430\u043F\u0438\u0441\u044C",
      "edit_group_highlight_styling": "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0442\u0438\u043B\u044C \u0432\u044B\u0434\u0435\u043B\u0435\u043D\u0438\u044F \u0433\u0440\u0443\u043F\u043F\u044B",
      // added
      "light_mode_fixer_desc": "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0437\u0430\u0442\u0435\u043C\u043D\u044F\u0435\u0442 \u0446\u0432\u0435\u0442\u043D\u043E\u0439 \u0442\u0435\u043A\u0441\u0442 \u043F\u0440\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0438 \u0441\u0432\u0435\u0442\u043B\u043E\u0439 \u0442\u0435\u043C\u044B \u0434\u043B\u044F \u0443\u043B\u0443\u0447\u0448\u0435\u043D\u0438\u044F \u0432\u0438\u0434\u0438\u043C\u043E\u0441\u0442\u0438.",
      // added
      "dark_mode_fixer_desc": "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043E\u0441\u0432\u0435\u0442\u043B\u044F\u0435\u0442 \u0446\u0432\u0435\u0442\u043D\u043E\u0439 \u0442\u0435\u043A\u0441\u0442 \u043F\u0440\u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0438 \u0442\u0435\u043C\u043D\u043E\u0439 \u0442\u0435\u043C\u044B \u0434\u043B\u044F \u0443\u043B\u0443\u0447\u0448\u0435\u043D\u0438\u044F \u0432\u0438\u0434\u0438\u043C\u043E\u0441\u0442\u0438.",
      // added
      "preset_bold": "\u0416\u0438\u0440\u043D\u044B\u0439",
      // added
      "preset_italic": "\u041A\u0443\u0440\u0441\u0438\u0432",
      // added
      "preset_bold_italic": "\u0416\u0438\u0440\u043D\u044B\u0439 \u043A\u0443\u0440\u0441\u0438\u0432",
      // added
      // Blacklist Group Commands
      "notice_blacklist_group_activated": "\u0421\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u043D",
      "notice_blacklist_group_deactivated": "\u0421\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A \u0434\u0435\u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u043D",
      "command_activate_blacklist_group": "\u0410\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A {groupName}",
      "command_deactivate_blacklist_group": "\u0414\u0435\u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0447\u0451\u0440\u043D\u044B\u0439 \u0441\u043F\u0438\u0441\u043E\u043A {groupName}"
    };
  }
});

// src/i18n/zh_cn.js
var require_zh_cn = __commonJS({
  "src/i18n/zh_cn.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "\u7B80\u4F53\u4E2D\u6587",
      "settings_title": "\u6587\u5B57\u81EA\u52A8\u7740\u8272\u8BBE\u7F6E",
      "header_plugin_name": "\u6587\u5B57\u81EA\u52A8\u7740\u8272",
      "ribbon_title": "\u6587\u5B57\u81EA\u52A8\u7740\u8272",
      // Language Settings
      "language_label": "\u8BED\u8A00",
      "language_desc": "\u9009\u62E9\u63D2\u4EF6\u4F7F\u7528\u7684\u8BED\u8A00",
      "language_en": "\u82F1\u8BED",
      "language_es": "\u897F\u73ED\u7259\u8BED",
      "language_fr": "\u6CD5\u8BED",
      "language_eu": "\u5DF4\u65AF\u514B\u8BED",
      "language_ru": "\u4FC4\u8BED",
      "language_auto": "\u7CFB\u7EDF\u9ED8\u8BA4",
      "default": "\u9ED8\u8BA4",
      // Release Notes
      "latest_release_notes_label": "\u6700\u65B0\u53D1\u5E03\u8BF4\u660E",
      "latest_release_notes_desc": "\u67E5\u770B\u63D2\u4EF6\u7684\u6700\u65B0\u53D1\u5E03\u8BF4\u660E",
      "open_changelog_button": "\u6253\u5F00\u66F4\u65B0\u65E5\u5FD7",
      "command_show_release_notes": "\u663E\u793A\u6700\u65B0\u53D1\u5E03\u8BF4\u660E",
      "changelog_view_on_github": "\u5728GitHub\u4E0A\u67E5\u770B",
      "changelog_loading": "\u52A0\u8F7D\u53D1\u5E03\u2026",
      "changelog_no_info": "\u6CA1\u6709\u53EF\u7528\u7684\u53D1\u5E03\u4FE1\u606F\u3002",
      "changelog_release": "\u53D1\u5E03",
      "changelog_no_notes": "\u6CA1\u6709\u8BF4\u660E",
      "changelog_failed_to_load": "\u52A0\u8F7D\u53D1\u5E03\u8BF4\u660E\u5931\u8D25\u3002",
      // UI Elements & Menus
      "file_menu_enable": "\u4E3A\u6B64\u6587\u4EF6\u542F\u7528\u6587\u5B57\u81EA\u52A8\u7740\u8272",
      "file_menu_disable": "\u4E3A\u6B64\u6587\u4EF6\u7981\u7528\u6587\u5B57\u81EA\u52A8\u7740\u8272",
      "menu_color_once": "\u7740\u8272\u4E00\u6B21",
      "menu_highlight_once": "\u9AD8\u4EAE\u4E00\u6B21",
      "menu_color_highlight_once": "\u989C\u8272 / \u9AD8\u4EAE\u4E00\u6B21",
      "menu_remove_inline_color": "\u79FB\u9664\u5185\u8054\u989C\u8272",
      "menu_always_color_text": "\u6587\u5B57\u81EA\u52A8\u7740\u8272",
      "menu_remove_always_color_text": "\u79FB\u9664\u6587\u5B57\u81EA\u52A8\u7740\u8272",
      "menu_blacklist_word": "\u5C06\u5355\u8BCD\u52A0\u5165\u7740\u8272\u9ED1\u540D\u5355",
      "show_toggle_statusbar": "\u5728\u72B6\u6001\u680F\u663E\u793A\u5207\u6362\u6309\u94AE",
      "show_toggle_ribbon": "\u5728\u529F\u80FD\u533A\u663E\u793A\u5207\u6362\u56FE\u6807",
      "show_toggle_command": "\u5728\u547D\u4EE4\u4E2D\u663E\u793A\u5207\u6362",
      "menu_options_header": "\u83DC\u5355\u9009\u9879",
      "show_blacklist_menu": "\u5728\u53F3\u952E\u83DC\u5355\u4E2D\u663E\u793A\u201C\u9ED1\u540D\u5355\u5355\u8BCD\u201D",
      "show_blacklist_menu_desc": "\u6DFB\u52A0\u53F3\u952E\u83DC\u5355\u9879\uFF0C\u5C06\u9009\u4E2D\u7684\u6587\u5B57\u52A0\u5165\u7740\u8272\u9ED1\u540D\u5355\u3002",
      "show_add_to_existing_menu": "\u5728\u53F3\u952E\u83DC\u5355\u4E2D\u663E\u793A\u201C\u6DFB\u52A0\u5230\u73B0\u6709\u6761\u76EE\u201D",
      "show_add_to_existing_menu_desc": "\u6DFB\u52A0\u53F3\u952E\u83DC\u5355\u9879\uFF0C\u5C06\u9009\u4E2D\u7684\u6587\u5B57\u6DFB\u52A0\u5230\u73B0\u6709\u6761\u76EE\u3002",
      "show_always_color_text_menu": "\u5728\u53F3\u952E\u83DC\u5355\u4E2D\u663E\u793A\u201C\u6587\u5B57\u81EA\u52A8\u7740\u8272\u201D",
      "show_always_color_text_menu_desc": "\u6DFB\u52A0\u53F3\u952E\u83DC\u5355\u9879\uFF0C\u4E3A\u9009\u4E2D\u7684\u6587\u5B57\u7740\u8272\u3002",
      "hide_inactive_groups_in_dropdowns": "\u5728\u4E0B\u62C9\u83DC\u5355\u4E2D\u9690\u85CF\u4E0D\u6D3B\u8DC3\u7684\u7EC4",
      "hide_inactive_groups_in_dropdowns_desc": "\u5728\u4E0B\u62C9\u83DC\u5355\u4E2D\u663E\u793A\u7EC4\u5217\u8868\u65F6\u9690\u85CF\u4E0D\u6D3B\u8DC3\u7684\u5355\u8BCD\u7EC4\u3002",
      "show_word_groups_in_commands": "\u5728\u547D\u4EE4\u4E2D\u663E\u793A\u8BCD\u7EC4",
      "show_word_groups_in_commands_desc": "\u542F\u7528\u540E\uFF0C\u8BCD\u7EC4\u4F1A\u5728\u547D\u4EE4\u9762\u677F\u4E2D\u4EE5\u201C\u542F\u7528/\u505C\u7528\u201D\u547D\u4EE4\u663E\u793A\u3002",
      "tooltip_enable_for_file": "\u4E3A\u6B64\u6587\u4EF6\u542F\u7528",
      "tooltip_delete_all_words": "\u5220\u9664\u6240\u6709\u5DF2\u5B9A\u4E49\u7684\u5355\u8BCD/\u6A21\u5F0F",
      "tooltip_delete_all_blacklist": "\u5220\u9664\u6240\u6709\u9ED1\u540D\u5355\u5355\u8BCD/\u6A21\u5F0F",
      "tooltip_use_regex": "\u4F5C\u4E3A\u6B63\u5219\u8868\u8FBE\u5F0F\u6A21\u5F0F\u4F7F\u7528",
      "drag_to_reorder": "\u62D6\u52A8\u4EE5\u91CD\u65B0\u6392\u5E8F",
      "reset_text_color": "\u91CD\u7F6E\u6587\u672C\u989C\u8272",
      "reset_highlight": "\u91CD\u7F6E\u9AD8\u4EAE",
      // Commands
      "command_color_selected": "\u7740\u8272\u9009\u4E2D\u6587\u5B57",
      "command_toggle_current": "\u542F\u7528/\u7981\u7528\u5F53\u524D\u6587\u6863\u7740\u8272",
      "command_enable_current": "\u542F\u7528\u5F53\u524D\u6587\u6863\u7740\u8272",
      "command_disable_current": "\u7981\u7528\u5F53\u524D\u6587\u6863\u7740\u8272",
      "command_toggle_global": "\u542F\u7528/\u7981\u7528\u5168\u5C40\u7740\u8272",
      "command_enable_global": "\u542F\u7528\u5168\u5C40\u7740\u8272",
      "command_disable_global": "\u7981\u7528\u5168\u5C40\u7740\u8272",
      "command_enable_lightweight_mode": "\u542F\u7528\u8F7B\u91CF\u6A21\u5F0F",
      "command_disable_lightweight_mode": "\u7981\u7528\u8F7B\u91CF\u6A21\u5F0F",
      "command_color_highlight_once": "\u4E00\u6B21\u6027\u7740\u8272/\u9AD8\u4EAE\u9009\u4E2D\u53CA\u6587\u672C",
      "notice_select_text_first_once": "\u8BF7\u5148\u9009\u62E9\u6587\u672C\u3002",
      "enable_document_color": "\u542F\u7528\u5168\u5C40\u989C\u8272",
      "color_rendering_header": "\u989C\u8272\u6E32\u67D3\u4E0E\u6027\u80FD",
      "theme_support_header": "\u4E3B\u9898\u652F\u6301",
      "matching_behavior_header": "\u5339\u914D\u884C\u4E3A",
      "smart_update_mode": "\u667A\u80FD\u66F4\u65B0 (\u5B9E\u9A8C\u6027)",
      "smart_update_mode_desc": "\u4EC5\u5728\u8F93\u5165\u65F6\u66F4\u65B0\u5F53\u524D\u884C\u7684\u7740\u8272\uFF0C\u5E76\u51BB\u7ED3\u5176\u4ED6\u884C\u4EE5\u63D0\u9AD8\u6027\u80FD\u3002",
      "light_mode_fixer": "\u4EAE\u8272\u6A21\u5F0F\u6587\u672C\u989C\u8272\u4FEE\u590D\u5668",
      "dark_mode_fixer": "\u6697\u8272\u6A21\u5F0F\u6587\u672C\u989C\u8272\u4FEE\u590D\u5668",
      "command_manage_advanced_rules": "\u7BA1\u7406\u7279\u5B9A\u5305\u542B/\u6392\u9664\u89C4\u5219",
      "command_open_regex_tester": "\u6DFB\u52A0\u6B63\u5219\u8868\u8FBE\u5F0F\uFF08\u6253\u5F00\u6B63\u5219\u8868\u8FBE\u5F0F\u6D4B\u8BD5\u5668\uFF09",
      "command_open_blacklist_regex_tester": "\u6DFB\u52A0\u9ED1\u540D\u5355\u6B63\u5219\u8868\u8FBE\u5F0F",
      "command_manage_colored_texts": "\u7BA1\u7406\u5DF2\u7740\u8272\u7684\u6587\u672C",
      "command_toggle_hide_text_colors": "\u9690\u85CF/\u663E\u793A\u6587\u672C\u989C\u8272",
      "command_toggle_hide_highlights": "\u9690\u85CF/\u663E\u793A\u9AD8\u4EAE",
      "command_hide_text_colors": "\u9690\u85CF\u6587\u672C\u989C\u8272",
      "command_unhide_text_colors": "\u663E\u793A\u6587\u672C\u989C\u8272",
      "command_hide_highlights": "\u9690\u85CF\u9AD8\u4EAE",
      "command_unhide_highlights": "\u663E\u793A\u9AD8\u4EAE",
      "command_activate_word_group": "\u542F\u7528 {groupName} \u8BCD\u7EC4",
      "command_deactivate_word_group": "\u505C\u7528 {groupName} \u8BCD\u7EC4",
      // Notifications
      "notice_lightweight_mode_enabled": "\u8F7B\u91CF\u6A21\u5F0F\u5DF2\u542F\u7528",
      "notice_lightweight_mode_disabled": "\u8F7B\u91CF\u6A21\u5F0F\u5DF2\u7981\u7528",
      "notice_enabled": "\u6587\u5B57\u81EA\u52A8\u7740\u8272\u5DF2\u542F\u7528",
      "notice_disabled": "\u6587\u5B57\u81EA\u52A8\u7740\u8272\u5DF2\u7981\u7528",
      "notice_blacklisted_cannot_color": '"{word}" \u5DF2\u52A0\u5165\u9ED1\u540D\u5355\uFF0C\u65E0\u6CD5\u7740\u8272\u3002',
      "notice_removed_always_color": '\u5DF2\u79FB\u9664 "{word}" \u7684\u81EA\u52A8\u7740\u8272\u3002',
      "notice_added_to_blacklist": '"{word}" \u5DF2\u52A0\u5165\u9ED1\u540D\u5355\u3002',
      "notice_already_blacklisted": '"{word}" \u5DF2\u5728\u9ED1\u540D\u5355\u4E2D\u3002',
      "notice_select_text_first": "\u8BF7\u5148\u9009\u62E9\u4E00\u4E9B\u6587\u5B57\u3002",
      "notice_no_active_file": "\u6CA1\u6709\u6D3B\u52A8\u6587\u4EF6\u53EF\u5207\u6362\u7740\u8272\u3002",
      "notice_coloring_enabled_for_path": "\u5DF2\u4E3A {path} \u542F\u7528\u7740\u8272",
      "notice_coloring_disabled_for_path": "\u5DF2\u4E3A {path} \u7981\u7528\u7740\u8272",
      "notice_global_enabled": "\u6587\u5B57\u81EA\u52A8\u7740\u8272\u5DF2\u542F\u7528",
      "notice_global_disabled": "\u6587\u5B57\u81EA\u52A8\u7740\u8272\u5DF2\u7981\u7528",
      "notice_unable_open_changelog": "\u65E0\u6CD5\u6253\u5F00\u66F4\u65B0\u65E5\u5FD7\u7A97\u53E3\u3002",
      "notice_pattern_blocked": "\u6A21\u5F0F\u56E0\u5185\u5B58\u5B89\u5168\u88AB\u963B\u6B62:",
      "notice_pattern_too_complex": "\u6A21\u5F0F\u8FC7\u4E8E\u590D\u6742:",
      "notice_invalid_hex_format": "\u65E0\u6548\u7684\u5341\u516D\u8FDB\u5236\u989C\u8272\u683C\u5F0F\u3002\u4F7F\u7528 #RRGGBB \u6216 #RGB\u3002",
      "notice_error_saving_changes": "\u4FDD\u5B58\u66F4\u6539\u65F6\u51FA\u9519\u3002\u8BF7\u91CD\u8BD5\u3002",
      "notice_invalid_color_format": "\u65E0\u6548\u7684\u989C\u8272\u683C\u5F0F\u3002",
      "notice_exported": "\u5DF2\u5BFC\u51FA: {fname}",
      "notice_export_failed": "\u5BFC\u51FA\u5931\u8D25",
      "notice_import_completed": "\u5BFC\u5165\u5B8C\u6210",
      "notice_import_failed": "\u5BFC\u5165\u5931\u8D25",
      "notice_invalid_regex": "\u65E0\u6548\u7684\u6B63\u5219\u8868\u8FBE\u5F0F",
      "notice_empty_pattern": "\u6A21\u5F0F\u4E3A\u7A7A",
      "notice_added_regex": "\u6B63\u5219\u8868\u8FBE\u5F0F\u5DF2\u6DFB\u52A0",
      "notice_rule_updated": "\u89C4\u5219\u5DF2\u66F4\u65B0",
      "notice_regex_updated": "\u6B63\u5219\u8868\u8FBE\u5F0F\u5DF2\u66F4\u65B0",
      "notice_entry_updated": "\u6761\u76EE\u5DF2\u66F4\u65B0",
      "notice_entry_duplicated": "\u6761\u76EE\u5DF2\u91CD\u590D",
      "notice_error_opening_regex_tester": "\u6253\u5F00\u6B63\u5219\u8868\u8FBE\u5F0F\u6D4B\u8BD5\u5668\u51FA\u9519",
      "notice_error_opening_blacklist_regex_tester": "\u6253\u5F00\u9ED1\u540D\u5355\u6B63\u5219\u8868\u8FBE\u5F0F\u6D4B\u8BD5\u5668\u51FA\u9519",
      "notice_error_opening_advanced_rules": "\u6253\u5F00\u9AD8\u7EA7\u89C4\u5219\u6A21\u6001\u6846\u51FA\u9519",
      "notice_text_color_reset": "\u6587\u672C\u989C\u8272\u5DF2\u91CD\u7F6E",
      "notice_highlight_reset": "\u9AD8\u4EAE\u5DF2\u91CD\u7F6E",
      "notice_text_colors_hidden": "\u6587\u672C\u989C\u8272\u5DF2\u9690\u85CF",
      "notice_text_colors_visible": "\u6587\u672C\u989C\u8272\u53EF\u89C1",
      "notice_highlights_hidden": "\u9AD8\u4EAE\u5DF2\u9690\u85CF",
      "notice_highlights_visible": "\u9AD8\u4EAE\u53EF\u89C1",
      "notice_regex_support_disabled": "\u6B63\u5219\u8868\u8FBE\u5F0F\u652F\u6301\u5DF2\u7981\u7528\u3002\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528\u4EE5\u4F7F\u7528\u6B63\u5219\u8868\u8FBE\u5F0F\u6A21\u5F0F\u3002",
      "notice_no_active_file_to_disable": "\u6CA1\u6709\u6D3B\u52A8\u6587\u4EF6\u53EF\u7981\u7528\u7740\u8272\u3002",
      "notice_already_disabled_for_path": "\u5DF2\u4E3A {path} \u7981\u7528\u7740\u8272",
      "notice_filter_disabled": "\u8FC7\u6EE4\u5668\u5DF2\u7981\u7528",
      // Confirmation Dialogs
      "confirm_delete_all_title": "\u5220\u9664\u6240\u6709\u5355\u8BCD",
      "confirm_delete_all_desc": "\u60A8\u786E\u5B9A\u8981\u5220\u9664\u6240\u6709\u5DF2\u7740\u8272\u7684\u5355\u8BCD/\u6A21\u5F0F\u5417\uFF1F\u6B64\u64CD\u4F5C\u65E0\u6CD5\u64A4\u9500\uFF01",
      "confirm_delete_all_blacklist_title": "\u5220\u9664\u6240\u6709\u9ED1\u540D\u5355\u5355\u8BCD",
      "confirm_delete_all_blacklist_desc": "\u60A8\u786E\u5B9A\u8981\u5220\u9664\u6240\u6709\u9ED1\u540D\u5355\u6761\u76EE\u5417\uFF1F\u6B64\u64CD\u4F5C\u65E0\u6CD5\u64A4\u9500\uFF01",
      "confirm_delete_all_groups_title": "\u5220\u9664\u6240\u6709\u8BCD\u7EC4",
      "confirm_delete_all_groups_desc": "\u60A8\u786E\u5B9A\u8981\u5220\u9664\u6240\u6709\u8BCD\u7EC4\u5417\uFF1F\u6B64\u64CD\u4F5C\u65E0\u6CD5\u64A4\u9500\uFF01",
      "restart_required_title": "\u9700\u8981\u91CD\u542F",
      "restart_required_desc": "\u7981\u7528\u547D\u4EE4\u9762\u677F\u4E2D\u7684\u6FC0\u6D3B\u9700\u8981\u91CD\u542F Obsidian \u624D\u80FD\u4ECE\u547D\u4EE4\u9762\u677F\u4E2D\u5B8C\u5168\u79FB\u9664\u8BE5\u547D\u4EE4\u3002\u73B0\u5728\u91CD\u542F\u5417\uFF1F",
      // Basic Settings
      "color_in_live_preview_mode": "\u5728\u5B9E\u65F6\u9884\u89C8\u6A21\u5F0F\u4E0B\u7740\u8272",
      "color_in_reading_mode": "\u5728\u9605\u8BFB\u6A21\u5F0F\u4E0B\u7740\u8272",
      "force_full_render_reading": "\u9605\u8BFB\u6A21\u5F0F\u4E0B\u5F3A\u5236\u5B8C\u6574\u6E32\u67D3",
      "force_full_render_reading_desc": "\u5982\u679C\u542F\u7528\uFF0C\u9605\u8BFB\u6A21\u5F0F\u5C06\u5C1D\u8BD5\u4E00\u6B21\u6027\u7740\u8272\u6574\u4E2A\u6587\u6863\u3002\u5728\u5927\u578B\u6587\u6863\u4E0A\u53EF\u80FD\u4F1A\u5BFC\u81F4\u5361\u987F\uFF0C\u8BF7\u8C28\u614E\u4F7F\u7528\uFF01",
      "lightweight_mode": "\u8F7B\u91CF\u6A21\u5F0F\uFF08\u5B9E\u9A8C\u6027\uFF09",
      "lightweight_mode_desc": "\u5927\u5E45\u51CF\u5C11\u8F93\u5165\u65F6\u7684\u5904\u7406\u91CF\u3002\u53EF\u80FD\u4F1A\u8DF3\u8FC7\u67D0\u4E9B\u5339\u914D\u3002",
      "disable_coloring_current_file": "\u7981\u7528\u5F53\u524D\u6587\u4EF6\u7740\u8272",
      "disable_coloring_current_file_desc": "\u5728\u6587\u4EF6\u548C\u6587\u4EF6\u5939\u7740\u8272\u89C4\u5219\u4E0B\u4E3A\u6D3B\u52A8\u6587\u4EF6\u6DFB\u52A0\u6392\u9664\u89C4\u5219\u3002",
      "btn_disable_for_this_file": "\u4E3A\u6B64\u6587\u4EF6\u7981\u7528",
      // Coloring Settings
      "coloring_settings_header": "\u7740\u8272\u8BBE\u7F6E",
      "regex_support": "\u6B63\u5219\u8868\u8FBE\u5F0F\u652F\u6301",
      "regex_support_desc": "\u5141\u8BB8\u6A21\u5F0F\u4E3A\u6B63\u5219\u8868\u8FBE\u5F0F\u3002\u65E0\u6548\u7684\u6B63\u5219\u8868\u8FBE\u5F0F\u5C06\u88AB\u5FFD\u7565\u4EE5\u786E\u4FDD\u5B89\u5168\u3002",
      "disable_regex_safety": "\u7981\u7528\u6B63\u5219\u8868\u8FBE\u5F0F\u5B89\u5168\u68C0\u67E5",
      "disable_regex_safety_desc": "\u5141\u8BB8\u590D\u6742\u6216\u6F5C\u5728\u5371\u9669\u7684\u8868\u8FBE\u5F0F\u3002\u53EF\u80FD\u4F1A\u5BFC\u81F4\u5361\u987F\u6216\u51BB\u7ED3\u3002",
      "case_sensitive": "\u533A\u5206\u5927\u5C0F\u5199",
      "case_sensitive_desc": '\u5982\u679C\u542F\u7528\uFF0C"Word" \u548C "word" \u662F\u4E0D\u540C\u7684\u3002\u5982\u679C\u7981\u7528\uFF0C\u5B83\u4EEC\u5C06\u4EE5\u76F8\u540C\u65B9\u5F0F\u7740\u8272\u3002',
      "partial_match": "\u90E8\u5206\u5339\u914D",
      "partial_match_desc": '\u5982\u679C\u542F\u7528\uFF0C\u5982\u679C\u53D1\u73B0\u7740\u8272\u8BCD\u5728\u5185\u90E8\uFF08\u4F8B\u5982 "as" \u7740\u8272 "Jasper"\uFF09\uFF0C\u5219\u7740\u8272\u6574\u4E2A\u5355\u8BCD\u3002',
      // One-Time Actions
      "one_time_actions_header": "\u4E00\u6B21\u6027\u64CD\u4F5C",
      "setting_color_once": "\u7740\u8272\u4E00\u6B21",
      "setting_color_once_desc": "\u4E3A\u9009\u5B9A\u7684\u6587\u672C\u63D2\u5165\u5185\u8054 HTML \u6837\u5F0F\u3002\u5373\u4F7F\u7981\u7528\u63D2\u4EF6\u4E5F\u4F1A\u4FDD\u7559\u3002",
      "setting_highlight_once": "\u9AD8\u4EAE\u4E00\u6B21",
      "setting_highlight_once_desc": "\u63D2\u5165\u5E26\u80CC\u666F\u7684\u5185\u8054 HTML \u6837\u5F0F\u3002\u5373\u4F7F\u7981\u7528\u63D2\u4EF6\u4E5F\u4F1A\u4FDD\u7559\u3002",
      "setting_color_highlight_once": "\u989C\u8272\u548C\u9AD8\u4EAE\u4E00\u6B21",
      "setting_color_highlight_once_desc": "\u6253\u5F00\u7EDF\u4E00\u7684\u989C\u8272\u9009\u62E9\u5668\u4EE5\u5E94\u7528\u5185\u8054\u6587\u672C\u989C\u8272\u548C\u80CC\u666F\u9AD8\u4EAE\u3002\u4F7F\u7528\u7EDF\u4E00\u83DC\u5355\u3002",
      "highlight_once_preview": "\u9AD8\u4EAE\u4E00\u6B21\u9884\u89C8",
      "highlight_once_preview_text": "\u8FD9\u5C31\u662F\u9AD8\u4EAE\u4E00\u6B21\u7684\u6837\u5B50\uFF01",
      // Highlight Once Settings
      "highlight_once_opacity": "\u9AD8\u4EAE\u4E00\u6B21\u4E0D\u900F\u660E\u5EA6",
      "highlight_once_border_radius": "\u9AD8\u4EAE\u4E00\u6B21\u8FB9\u6846\u534A\u5F84 (px)",
      "reset_to_8": "\u91CD\u7F6E\u4E3A 8",
      "highlight_horizontal_padding": "\u9AD8\u4EAE\u6C34\u5E73\u5185\u8FB9\u8DDD (px)",
      "highlight_vertical_padding": "\u9AD8\u4EAE\u5782\u76F4\u5185\u8FB9\u8DDD (px)",
      "reset_to_4": "\u91CD\u7F6E\u4E3A 4",
      "enable_border_highlight_once": "\u542F\u7528\u9AD8\u4EAE\u4E00\u6B21\u8FB9\u6846",
      "enable_border_highlight_once_desc": "\u4E3A\u5185\u8054\u9AD8\u4EAE\u6DFB\u52A0\u8FB9\u6846\u3002\u6DFB\u52A0\u7684 HTML/CSS \u4F1A\u5F88\u957F\u3002",
      "highlight_once_border_style": "\u9AD8\u4EAE\u4E00\u6B21\u8FB9\u6846\u8FB9",
      "highlight_once_border_line_style": "\u8FB9\u6846\u6837\u5F0F",
      "opt_border_full": "\u5B8C\u6574\u8FB9\u6846\uFF08\u6240\u6709\u8FB9\uFF09",
      "opt_border_top_bottom": "\u4E0A\u4E0B",
      "opt_border_left_right": "\u5DE6\u53F3",
      "opt_border_top_left_right": "\u4E0A\u3001\u5DE6\u3001\u53F3",
      "opt_border_bottom_left_right": "\u4E0B\u3001\u5DE6\u3001\u53F3",
      "opt_border_top_right": "\u53F3\u4E0A",
      "opt_border_top_left": "\u5DE6\u4E0A",
      "opt_border_bottom_right": "\u53F3\u4E0B",
      "opt_border_bottom_left": "\u5DE6\u4E0B",
      "opt_border_top": "\u4EC5\u4E0A",
      "opt_border_bottom": "\u4EC5\u4E0B",
      "opt_border_left": "\u4EC5\u5DE6",
      "opt_border_right": "\u4EC5\u53F3",
      "highlight_once_border_opacity": "\u9AD8\u4EAE\u4E00\u6B21\u8FB9\u6846\u4E0D\u900F\u660E\u5EA6",
      "highlight_once_border_thickness": "\u9AD8\u4EAE\u4E00\u6B21\u8FB9\u6846\u7C97\u7EC6 (px)",
      "reset_to_1": "\u91CD\u7F6E\u4E3A 1",
      "use_global_highlight_style": "\u4F7F\u7528\u5168\u5C40\u6837\u5F0F\u8FDB\u884C\u9AD8\u4EAE\u4E00\u6B21",
      "use_global_highlight_style_desc": "\u4F7F\u7528\u60A8\u7684\u5168\u5C40\u5185\u8054\u6837\u5F0F\u3002\u6DFB\u52A0\u7684 HTML/CSS \u53EF\u80FD\u4F1A\u5F88\u957F\u3002",
      "style_highlight_once": "\u9AD8\u4EAE\u4E00\u6B21\u6837\u5F0F",
      "style_highlight_once_desc": "\u4F7F\u7528\u60A8\u7684\u81EA\u5B9A\u4E49\u5185\u8054\u6837\u5F0F\u3002\u6DFB\u52A0\u7684 HTML/CSS \u53EF\u80FD\u4F1A\u5F88\u957F\u3002",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "\u5168\u5C40\u9AD8\u4EAE\u5916\u89C2",
      "highlight_opacity": "\u9AD8\u4EAE\u4E0D\u900F\u660E\u5EA6",
      "highlight_opacity_desc": "\u8BBE\u7F6E\u9AD8\u4EAE\u4E0D\u900F\u660E\u5EA6 (0-100%)",
      "highlight_border_radius": "\u9AD8\u4EAE\u8FB9\u6846\u534A\u5F84 (px)",
      "highlight_border_radius_desc": "\u8BBE\u7F6E\u9AD8\u4EAE\u89D2\u7684\u8FB9\u6846\u534A\u5F84\uFF08\u50CF\u7D20\uFF09",
      "highlight_horizontal_padding_desc": "\u8BBE\u7F6E\u9AD8\u4EAE\u6587\u672C\u7684\u5DE6\u53F3\u5185\u8FB9\u8DDD\uFF08\u50CF\u7D20\uFF09",
      "highlight_vertical_padding_desc": "\u8BBE\u7F6E\u9AD8\u4EAE\u6587\u672C\u7684\u4E0A\u4E0B\u5185\u8FB9\u8DDD\uFF08\u50CF\u7D20\uFF09",
      "rounded_corners_wrapping": "\u6362\u884C\u65F6\u5706\u89D2",
      "rounded_corners_wrapping_desc": "\u5982\u679C\u542F\u7528\uFF0C\u5373\u4F7F\u6587\u672C\u6362\u884C\u5230\u4E0B\u4E00\u884C\uFF0C\u9AD8\u4EAE\u663E\u793A\u4E5F\u4F1A\u5728\u6240\u6709\u8FB9\u4E0A\u5177\u6709\u5706\u89D2\u3002",
      "enable_highlight_border": "\u542F\u7528\u9AD8\u4EAE\u8FB9\u6846",
      "enable_highlight_border_desc": "\u5728\u9AD8\u4EAE\u5468\u56F4\u6DFB\u52A0\u8FB9\u6846\u3002\u8FB9\u6846\u4E0E\u6587\u672C\u6216\u9AD8\u4EAE\u989C\u8272\u5339\u914D\u3002",
      "border_style": "\u8FB9\u6846\u8FB9",
      "border_style_desc": "\u9009\u62E9\u8981\u5E94\u7528\u8FB9\u6846\u7684\u8FB9",
      "border_line_style": "\u8FB9\u6846\u6837\u5F0F",
      "border_line_style_desc": "\u9009\u62E9\u8FB9\u6846\u7EBF\u6837\u5F0F",
      "border_opacity": "\u8FB9\u6846\u4E0D\u900F\u660E\u5EA6",
      "border_opacity_desc": "\u8BBE\u7F6E\u8FB9\u6846\u4E0D\u900F\u660E\u5EA6 (0-100%)",
      "border_thickness": "\u8FB9\u6846\u7C97\u7EC6 (px)",
      "border_thickness_desc": "\u8BBE\u7F6E\u8FB9\u6846\u7C97\u7EC6\u4ECE 0 \u5230 5 \u50CF\u7D20\uFF08\u4F8B\u5982 1, 2.5, 5\uFF09",
      "highlight_preview": "\u9AD8\u4EAE\u9884\u89C8",
      "highlight_preview_text": "\u8FD9\u5C31\u662F\u60A8\u7684\u9AD8\u4EAE\u6837\u5B50\u7684\uFF01",
      "opt_line_solid": "\u5B9E\u7EBF",
      "opt_line_dashed": "\u865A\u7EBF",
      "opt_line_dotted": "\u70B9\u7EBF",
      "opt_line_double": "\u53CC\u7EBF",
      "opt_line_groove": "\u51F9\u69FD",
      "opt_line_ridge": "\u810A\u72B6",
      "opt_line_inset": "\u5185\u5D4C",
      "opt_line_outset": "\u5916\u51F8",
      // Color Swatches
      "color_swatches_header": "\u989C\u8272\u7BA1\u7406",
      "color_picker_layout": "\u989C\u8272\u9009\u62E9\u5668\u5E03\u5C40",
      "color_picker_layout_desc": "\u9009\u62E9\u4E3A\u5355\u8BCD\u9009\u62E9\u989C\u8272\u65F6\u663E\u793A\u7684\u989C\u8272\u7C7B\u578B",
      "opt_both_text_left": "\u4E24\u8005\uFF1A\u6587\u672C\u5DE6\uFF0C\u9AD8\u4EAE\u53F3",
      "opt_both_bg_left": "\u4E24\u8005\uFF1A\u9AD8\u4EAE\u5DE6\uFF0C\u6587\u672C\u53F3",
      "opt_both_text_top": "\u4E24\u8005\uFF08\u5782\u76F4\uFF09\uFF1A\u6587\u672C\u4E0A\uFF0C\u9AD8\u4EAE\u4E0B",
      "opt_both_bg_top": "\u4E24\u8005\uFF08\u5782\u76F4\uFF09\uFF1A\u9AD8\u4EAE\u4E0A\uFF0C\u6587\u672C\u4E0B",
      "opt_text_only": "\u4EC5\u6587\u672C\u989C\u8272",
      "opt_background_only": "\u4EC5\u9AD8\u4EAE\u989C\u8272",
      "replace_default_swatches": "\u66FF\u6362\u9ED8\u8BA4\u8272\u677F",
      "replace_default_swatches_desc": "\u5982\u679C\u542F\u7528\uFF0C\u9009\u62E9\u5668\u4E2D\u53EA\u4F1A\u663E\u793A\u60A8\u7684\u81EA\u5B9A\u4E49\u989C\u8272\uFF0C\u800C\u4E0D\u4F1A\u663E\u793A\u9ED8\u8BA4\u989C\u8272\uFF01",
      "enable_custom_swatches": "\u542F\u7528\u81EA\u5B9A\u4E49\u8272\u677F",
      "enable_custom_swatches_desc": "\u5982\u679C\u542F\u7528\uFF0C\u60A8\u7684\u81EA\u5B9A\u4E49\u8272\u677F\u5C06\u51FA\u73B0\u5728\u989C\u8272\u9009\u62E9\u5668\u4E2D\u3002",
      "use_swatch_names": "\u4F7F\u7528\u8272\u677F\u540D\u79F0\u7740\u8272\u6587\u672C",
      "use_swatch_names_desc": "\u5728\u5355\u8BCD/\u6A21\u5F0F\u8F93\u5165\u65C1\u8FB9\u663E\u793A\u8272\u677F\u540D\u79F0\u4E0B\u62C9\u5217\u8868",
      "link_swatches_to_entries": "\u5C06\u8272\u677F\u66F4\u65B0\u94FE\u63A5\u5230\u7740\u8272\u6587\u672C",
      "link_swatches_to_entries_desc": "\u5F53\u81EA\u5B9A\u4E49\u8272\u677F\u7684\u989C\u8272\u66F4\u6539\u65F6\uFF0C\u66F4\u65B0\u6240\u6709\u4F7F\u7528\u8BE5\u8272\u677F\u7684\u6761\u76EE",
      "default_colors_header": "\u9ED8\u8BA4\u8272\u677F",
      "custom_swatches_header": "\u81EA\u5B9A\u4E49\u8272\u677F",
      "btn_add_color": "+ \u6DFB\u52A0\u989C\u8272",
      "no_custom_swatches_yet": '\u5C1A\u65E0\u81EA\u5B9A\u4E49\u8272\u677F\u3002\u70B9\u51FB "+ \u6DFB\u52A0\u989C\u8272" \u521B\u5EFA\u4E00\u4E2A\u3002',
      "label_built_in": "\uFF08\u5185\u7F6E\uFF09",
      // Color Picker
      "pick_color_header": "\u9009\u62E9\u989C\u8272",
      "selected_text_preview": "\u9009\u4E2D\u6587\u672C",
      "text_color_title": "\u6587\u672C\u989C\u8272",
      "select_swatch": "\u9009\u62E9\u8272\u677F...",
      "highlight_color_title": "\u9AD8\u4EAE\u989C\u8272",
      "select_highlight_swatch": "\u9009\u62E9\u9AD8\u4EAE\u8272\u677F...",
      "settings_tab_general": "\u5E38\u89C4",
      "settings_tab_colored_texts": "\u7740\u8272\u6587\u672C",
      "settings_tab_blacklists": "\u9ED1\u540D\u5355",
      "settings_tab_file_folder_rules": "\u6587\u4EF6 / \u6587\u4EF6\u5939 \u89C4\u5219",
      "settings_tab_data": "\u6570\u636E",
      // Always Colored Texts
      "always_colored_texts_header": "\u59CB\u7EC8\u7740\u8272\u6587\u672C",
      "always_colored_texts_desc": "\u5728\u8FD9\u91CC\u7BA1\u7406\u60A8\u7684\u5355\u8BCD/\u6A21\u5F0F\u53CA\u5176\u989C\u8272\u3002",
      "colored_texts_header": "\u7740\u8272\u6587\u672C",
      "grouped_entries_header": "\u5206\u7EC4\u6761\u76EE",
      "grouped_entries_desc": "\u7BA1\u7406\u8BCD\u7EC4\u3002\u641C\u7D22\u6309\u540D\u79F0\u7B5B\u9009\u3002",
      "search_groups_placeholder": "\u641C\u7D22\u5206\u7EC4\u2026",
      "edit_word_group_modal_title": "\u7F16\u8F91\u8BCD\u7EC4",
      "btn_save_group": "\u4FDD\u5B58\u7EC4",
      "btn_delete_group": "\u5220\u9664\u7EC4",
      "group_active_label": "\u542F\u7528",
      "group_inactive_label": "\u505C\u7528",
      "tooltip_duplicate_group": "\u590D\u5236\u7EC4",
      "tooltip_edit_group_settings": "\u7F16\u8F91\u7EC4\u8BBE\u7F6E",
      "tooltip_delete_all_groups": "\u5220\u9664\u6240\u6709\u8BCD\u7EC4",
      "btn_create_new_group": "+ \u521B\u5EFA\u65B0\u7EC4",
      "no_entries_found": "\u672A\u627E\u5230\u4EFB\u4F55\u6761\u76EE\u3002",
      "search_colored_words_placeholder": "\u641C\u7D22\u7740\u8272\u5355\u8BCD\u6216\u6A21\u5F0F\u2026",
      "sort_label_last-added": "\u6392\u5E8F\uFF1A\u6700\u540E\u6DFB\u52A0",
      "sort_label_a-z": "\u6392\u5E8F\uFF1AA-Z",
      "sort_label_reverse-a-z": "\u6392\u5E8F\uFF1AZ-A",
      "sort_label_style-order": "\u6392\u5E8F\uFF1A\u6837\u5F0F\u987A\u5E8F",
      "sort_label_color": "\u6392\u5E8F\uFF1A\u989C\u8272",
      "btn_add_new_word": "+ \u6DFB\u52A0\u65B0\u5355\u8BCD / \u6A21\u5F0F",
      "style_type_text": "\u989C\u8272",
      "style_type_highlight": "\u9AD8\u4EAE",
      "style_type_both": "\u4E24\u8005",
      "word_pattern_placeholder_long": "\u6A21\u5F0F\u3001\u5355\u8BCD\u6216\u9017\u53F7\u5206\u9694\u7684\u5355\u8BCD\uFF08\u4F8B\u5982 hello, world, foo\uFF09",
      "word_pattern_placeholder_short": "\u5173\u952E\u8BCD\u6216\u6A21\u5F0F\uFF0C\u6216\u9017\u53F7\u5206\u9694\u7684\u5355\u8BCD",
      "use_regex": "\u4F7F\u7528\u6B63\u5219",
      "flags_placeholder": "\u6807\u5FD7",
      "text_or_regex_placeholder": "\u6587\u672C/\u6B63\u5219\u8F93\u5165",
      "duplicate_entry": "\u91CD\u590D\u6761\u76EE",
      "open_in_regex_tester": "\u5728\u6B63\u5219\u6D4B\u8BD5\u5668\u4E2D\u6253\u5F00",
      "no_rules_configured": "\u672A\u914D\u7F6E\u89C4\u5219\u3002",
      "no_rules_found": "\u672A\u627E\u5230\u89C4\u5219\u3002",
      "match_option_exact": "\u7CBE\u786E",
      "match_option_contains": "\u5305\u542B",
      "match_option_starts_with": "\u5F00\u59CB\u4E8E",
      "match_option_ends_with": "\u7ED3\u675F\u4E8E",
      // Presets
      "btn_presets": "\u9884\u8BBE",
      "preset_all_headings": "\u6240\u6709\u6807\u9898 (H1-H6)",
      "preset_bullet_points": "\u9879\u76EE\u7B26\u53F7",
      "preset_numbered_lists": "\u7F16\u53F7\u5217\u8868",
      "preset_task_checked": "\u4EFB\u52A1\u5217\u8868\uFF08\u5DF2\u9009\uFF09",
      "preset_task_unchecked": "\u4EFB\u52A1\u5217\u8868\uFF08\u672A\u9009\uFF09",
      "preset_dates_yyyy_mm_dd": "\u65E5\u671F (YYYY-MM-DD)",
      "preset_times_am_pm": "\u65F6\u95F4 (AM/PM)",
      "preset_times_24h": "\u65F6\u95F4 (24h)",
      "preset_dates_yyyy_mmm_dd": "\u65E5\u671F (YYYY-MMM-DD)",
      "preset_relative_dates": "\u76F8\u5BF9\u65E5\u671F",
      "preset_basic_urls": "\u57FA\u672C URL",
      "preset_markdown_links": "Markdown \u94FE\u63A5",
      "preset_domain_names": "\u57DF\u540D",
      "preset_email_addresses": "\u7535\u5B50\u90AE\u4EF6\u5730\u5740",
      "preset_at_username": "@\u7528\u6237\u540D",
      "preset_currency": "\u8D27\u5E01",
      "preset_measurements": "\u6D4B\u91CF\u5355\u4F4D",
      "preset_phone_numbers": "\u7535\u8BDD\u53F7\u7801",
      "preset_all_texts": "\u6240\u6709\u6587\u672C",
      "preset_codeblocks": "\u4EE3\u7801\u5757",
      "preset_inline_comments": "\u6CE8\u91CA (%%...%%)",
      "preset_highlighted_text": "\u9AD8\u4EAE\u6587\u672C (==...==)",
      "preset_parentheses": "\u5706\u62EC\u53F7 ()",
      "preset_square_brackets": "\u65B9\u62EC\u53F7 []",
      "preset_curly_braces": "\u5927\u62EC\u53F7 {}",
      "preset_angle_brackets": "\u5C16\u62EC\u53F7 <>",
      "preset_colons": "\u5192\u53F7 :",
      "preset_double_quotes": "\u53CC\u5F15\u53F7",
      "preset_single_quotes": "\u5355\u5F15\u53F7",
      "preset_single_quotes_word_bounded": "\u5355\u5F15\u53F7\uFF08\u5355\u8BCD\u8FB9\u754C\uFF09",
      "preset_group_markdown_formatting": "Markdown \u683C\u5F0F",
      "preset_group_other_patterns": "\u5176\u4ED6\u6A21\u5F0F",
      "preset_group_brackets": "\u62EC\u53F7",
      // Preset Examples
      "preset_example_heading": "# \u6807\u9898",
      "preset_example_bullet": "- \u5217\u8868\u9879",
      "preset_example_numbered": "1. \u7B2C\u4E00\u9879",
      "preset_example_task_checked": "- [x] \u5DF2\u5B8C\u6210",
      "preset_example_task_unchecked": "- [ ] \u5F85\u529E",
      "preset_example_codeblock": "``` \u4EE3\u7801 ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "today, tomorrow",
      "preset_example_url": "https://example.com",
      "preset_example_markdown_link": "[\u94FE\u63A5](https://example.com)",
      "preset_example_comment": "%% \u6CE8\u91CA %%",
      "preset_example_domain": "example.com",
      "preset_example_email": "name@example.com",
      "preset_example_username": "@username",
      "preset_example_currency": "\xA529.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( \u6587\u672C )",
      "preset_example_square_brackets": "[ \u662F ]",
      "preset_example_curly_braces": "{ \u5426 }",
      "preset_example_angle_brackets": "< \u6587\u672C >",
      "preset_example_colons": ": \u6587\u672C :",
      "preset_example_double_quotes": '"\u6587\u672C"',
      "preset_example_single_quotes": "'\u6587\u672C'",
      "preset_example_single_quotes_word": "'\u5355\u8BCD'",
      "preset_example_highlight": "==\u9AD8\u4EAE\u6587\u672C==",
      "preset_example_all_text": "\u8FD9\u5C06\u9009\u4E2D\u6240\u6709\u6587\u672C\u3002",
      // Blacklist Settings
      "blacklist_words_header": "\u9ED1\u540D\u5355\u5355\u8BCD",
      "blacklist_words_desc": "\u8FD9\u91CC\u7684\u5173\u952E\u8BCD\u6216\u6A21\u5F0F\u6C38\u8FDC\u4E0D\u4F1A\u88AB\u7740\u8272\uFF0C\u5373\u4F7F\u662F\u90E8\u5206\u5339\u914D\u3002",
      "search_blacklist_placeholder": "\u641C\u7D22\u9ED1\u540D\u5355\u5355\u8BCD\u6216\u6A21\u5F0F\u2026",
      "blacklist_sort_label_last-added": "\u6392\u5E8F\uFF1A\u6700\u540E\u6DFB\u52A0",
      "blacklist_sort_label_a-z": "\u6392\u5E8F\uFF1AA-Z",
      "blacklist_sort_label_reverse-a-z": "\u6392\u5E8F\uFF1AZ-A",
      "btn_add_blacklist": "+ \u6DFB\u52A0\u9ED1\u540D\u5355\u5355\u8BCD\u6216\u6A21\u5F0F",
      "btn_add_to_blacklist": "+ \u6DFB\u52A0\u5230\u9ED1\u540D\u5355",
      "btn_add_blacklist_word": "+ \u6DFB\u52A0\u9ED1\u540D\u5355\u5355\u8BCD",
      "btn_add_blacklist_regex": "+ \u6DFB\u52A0\u9ED1\u540D\u5355\u6B63\u5219\u8868\u8FBE\u5F0F",
      // File & Folder Rules
      "file_folder_rules_header": "\u6587\u4EF6\u548C\u6587\u4EF6\u5939\u7740\u8272\u89C4\u5219",
      "file_folder_rules_desc": "\u901A\u8FC7\u540D\u79F0\u5339\u914D\u3001\u7CBE\u786E\u8DEF\u5F84\u6216\u6B63\u5219\u8868\u8FBE\u5F0F\u6A21\u5F0F\u63A7\u5236\u7740\u8272\u3002\u7559\u7A7A\u6392\u9664\u6761\u76EE\u4EE5\u5728\u6574\u4E2A\u5E93\u4E2D\u7981\u7528\u7740\u8272\u3002",
      "search_file_folder_rules_placeholder": "\u641C\u7D22\u6587\u4EF6/\u6587\u4EF6\u5939\u89C4\u5219\u2026",
      "path_sort_label_last-added": "\u6392\u5E8F\uFF1A\u6700\u540E\u6DFB\u52A0",
      "path_sort_label_a-z": "\u6392\u5E8F\uFF1AA-Z",
      "path_sort_label_reverse-a-z": "\u6392\u5E8F\uFF1AZ-A",
      "path_sort_label_mode": "\u6392\u5E8F\uFF1A\u6A21\u5F0F",
      "path_sort_label_type": "\u6392\u5E8F\uFF1A\u7C7B\u578B",
      "btn_add_file_folder_rule": "+ \u6DFB\u52A0\u6587\u4EF6/\u6587\u4EF6\u5939\u89C4\u5219",
      "disabled_files_header": "\u5DF2\u7981\u7528\u7740\u8272\u7684\u6587\u4EF6:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "\u5305\u542B",
      "path_rule_mode_exclude": "\u6392\u9664",
      "text_rule_mode_include": "\u4EC5\u5728\uFF08\u767D\u540D\u5355\uFF09\u4E2D\u7740\u8272",
      "text_rule_mode_exclude": "\u4E0D\u5728\uFF08\u9ED1\u540D\u5355\uFF09\u4E2D\u7740\u8272",
      "mode_only_colors_in": "\u4EC5\u5728\u5176\u4E2D\u7740\u8272",
      "mode_does_not_color_in": "\u4E0D\u5728\u5176\u4E2D\u7740\u8272",
      "label_text_include": "\u767D\u540D\u5355",
      "label_text_exclude": "\u9ED1\u540D\u5355",
      "label_enable_in": "\u542F\u7528\u8303\u56F4",
      "label_disable_in": "\u7981\u7528\u8303\u56F4",
      "enter_path_or_pattern": "\u8F93\u5165\u8DEF\u5F84\u3001\u6A21\u5F0F\u6216\u6807\u7B7E",
      "label_regex": "\u6B63\u5219\u8868\u8FBE\u5F0F",
      // Advanced Rules
      "advanced_rules_header": "\u7279\u5B9A\u5305\u542B/\u6392\u9664\u89C4\u5219",
      "advanced_rules_modal_header": "\u7279\u5B9A\u5305\u542B/\u6392\u9664\u89C4\u5219",
      "advanced_rules_manage_button": "\u7BA1\u7406\u7279\u5B9A\u5305\u542B/\u6392\u9664\u89C4\u5219",
      "edit_rule_header": "\u7F16\u8F91\u89C4\u5219",
      "add_rule_header": "\u6DFB\u52A0\u65B0\u89C4\u5219",
      "btn_add_rule": "+ \u6DFB\u52A0\u89C4\u5219",
      "btn_save_rule": "\u4FDD\u5B58\u89C4\u5219",
      "btn_add_words": "+ \u6DFB\u52A0\u5355\u8BCD",
      "btn_add_regex": "+ \u6DFB\u52A0\u6B63\u5219\u8868\u8FBE\u5F0F",
      "btn_save_regex": "\u4FDD\u5B58\u6B63\u5219\u8868\u8FBE\u5F0F",
      // Regex Tester
      "regex_tester_header": "\u6B63\u5219\u8868\u8FBE\u5F0F\u6D4B\u8BD5\u5668",
      "regex_tester_blacklist": "\u6B63\u5219\u8868\u8FBE\u5F0F\u6D4B\u8BD5\u5668 - \u9ED1\u540D\u5355",
      "regex_expression_placeholder": "\u5728\u6B64\u8F93\u5165\u60A8\u7684\u6B63\u5219\u8868\u8FBE\u5F0F",
      "regex_subject_placeholder": "\u5728\u6B64\u8F93\u5165\u8981\u6D4B\u8BD5\u7684\u6587\u672C...",
      "regex_name_placeholder": "\u547D\u540D\u60A8\u7684\u6B63\u5219\u8868\u8FBE\u5F0F",
      "matches": "\u5339\u914D\u9879",
      "matches_found": "\u627E\u5230\u5339\u914D\u9879",
      // Regex Flags
      "flag_g": "\u5168\u5C40\u6807\u5FD7\uFF1A\u67E5\u627E\u6240\u6709\u5339\u914D\u9879",
      "flag_i": "\u4E0D\u533A\u5206\u5927\u5C0F\u5199\u6807\u5FD7",
      "flag_m": "\u591A\u884C\u6807\u5FD7\uFF1A^ \u548C $ \u5339\u914D\u884C\u8FB9\u754C",
      "flag_s": "dotAll \u6807\u5FD7\uFF1A. \u5339\u914D\u6362\u884C\u7B26",
      "flag_u": "unicode \u6807\u5FD7\uFF1A\u89C6\u4E3A unicode \u4EE3\u7801\u70B9",
      "flag_y": "\u7C98\u6027\u6807\u5FD7\uFF1A\u4ECE lastIndex \u4F4D\u7F6E\u5339\u914D",
      // Data Export/Import
      "data_export_import_header": "\u6570\u636E\u5BFC\u51FA/\u5BFC\u5165",
      "export_plugin_data": "\u5BFC\u51FA\u63D2\u4EF6\u6570\u636E",
      "export_plugin_data_desc": "\u5C06\u8BBE\u7F6E\u3001\u5355\u8BCD\u548C\u89C4\u5219\u5BFC\u51FA\u5230JSON\u6587\u4EF6\u3002",
      "btn_export": "\u5BFC\u51FA",
      "import_plugin_data": "\u5BFC\u5165\u63D2\u4EF6\u6570\u636E",
      "import_plugin_data_desc": "\u4ECEJSON\u6587\u4EF6\u5BFC\u5165\u8BBE\u7F6E",
      "btn_import": "\u5BFC\u5165",
      "limit_input_placeholder": "\u9650\u5236",
      "limit_input_tooltip": "0=\u5168\u90E8\uFF1B\u6570\u5B57=\u6700\u8FD1 N\uFF1Br=\u4EC5\u6B63\u5219\uFF1Bh=\u4EC5\u9AD8\u4EAE\uFF1Bc=\u4EC5\u6587\u5B57\uFF1Bb=\u6587\u5B57+\u80CC\u666F\uFF1Bsw=\u4EE5\u2026\u5F00\u59CB\uFF1Bew=\u4EE5\u2026\u7ED3\u675F\uFF1Be=\u7CBE\u786E\u5339\u914D",
      // Missing Keys Added
      "highlight_styling_header": "\u7F16\u8F91\u9AD8\u4EAE\u6837\u5F0F",
      "edit_entry_header": "\u7F16\u8F91\u6761\u76EE",
      "opt_case_sensitive": "\u533A\u5206\u5927\u5C0F\u5199",
      "opt_not_case_sensitive": "\u4E0D\u533A\u5206\u5927\u5C0F\u5199",
      "opt_case_all": "\u533A\u5206\u5927\u5C0F\u5199\uFF08\u5168\u90E8\uFF09",
      "opt_match_all": "\u5339\u914D\u7C7B\u578B\uFF08\u5168\u90E8\uFF09",
      "edit_highlight_styling_btn": "\u7F16\u8F91\u9AD8\u4EAE\u6837\u5F0F",
      "inclusion_exclusion_header": "\u5305\u542B / \u6392\u9664\u89C4\u5219",
      "btn_save_entry": "\u4FDD\u5B58\u6761\u76EE",
      "edit_entry_details": "\u7F16\u8F91\u6761\u76EE\u8BE6\u60C5",
      "prompt_search_existing": "\u641C\u7D22\u73B0\u6709\u6761\u76EE\u2026",
      "command_add_to_existing_entry": "\u6DFB\u52A0\u5230\u73B0\u6709\u6761\u76EE",
      "context_remove_from_entry": '\u4ECE\u6761\u76EE\u4E2D\u79FB\u9664 "{word}"',
      "context_delete_entry": "\u5220\u9664\u6761\u76EE",
      "btn_reset": "\u91CD\u7F6E",
      "btn_reset_all": "\u91CD\u7F6E\u9AD8\u4EAE\u6837\u5F0F",
      "btn_add_word": "+ \u6DFB\u52A0\u5355\u8BCD",
      "btn_add_regex_short": "+ \u6DFB\u52A0\u6B63\u5219",
      "section_highlight_border_styling": "\u9AD8\u4EAE\u8FB9\u6846\u6837\u5F0F",
      "section_highlight_styling": "\u9AD8\u4EAE\u6837\u5F0F",
      "label_highlight_opacity": "\u9AD8\u4EAE\u4E0D\u900F\u660E\u5EA6",
      "label_highlight_radius": "\u9AD8\u4EAE\u8FB9\u6846\u5706\u89D2",
      "label_horizontal_padding": "\u6C34\u5E73\u5185\u8FB9\u8DDD",
      "label_vertical_padding": "\u5782\u76F4\u5185\u8FB9\u8DDD",
      "label_enable_border": "\u542F\u7528\u8FB9\u6846",
      "label_border_sides": "\u8FB9\u6846\u4F4D\u7F6E",
      "label_border_style": "\u8FB9\u6846\u6837\u5F0F",
      "label_border_opacity": "\u8FB9\u6846\u4E0D\u900F\u660E\u5EA6",
      "label_border_thickness": "\u8FB9\u6846\u539A\u5EA6",
      "btn_save_style": "\u4FDD\u5B58\u6837\u5F0F",
      // Quick Colors / Styles
      "quick_actions_header": "Quick Actions",
      "quick_colors_header": "\u5FEB\u901F\u989C\u8272",
      "quick_colors_desc": "\u5141\u8BB8\u901A\u8FC7\u5728\u53F3\u952E\u83DC\u5355\u4E2D\u663E\u793A\u989C\u8272\u6765\u5FEB\u901F\u9AD8\u4EAE\u6216\u7740\u8272\u6587\u672C\u3002\u5982\u679C\u5173\u95ED\u5FEB\u901F\u989C\u8272\uFF0C\u5C06\u4F7F\u7528\u5FEB\u901F\u6837\u5F0F\u4E2D\u7684\u6BCF\u79CD\u6837\u5F0F\u989C\u8272\u3002",
      "quick_colors_apply_mode_label": "\u6587\u672C\u7740\u8272\u5C06\u5E94\u7528\u4E3A",
      "quick_colors_apply_mode_act": "\u59CB\u7EC8\u4E3A\u6587\u672C\u7740\u8272",
      "quick_colors_apply_mode_html": "\u5185\u8054 HTML",
      "quick_styles_header": "\u5FEB\u901F\u6837\u5F0F",
      "quick_styles_desc": "\u5B9A\u4E49\u7528\u4E8E\u5E94\u7528\u6587\u672C\u989C\u8272\u548C\u9AD8\u4EAE\u663E\u793A\u7684\u547D\u540D\u6837\u5F0F\u3002\u5982\u679C\u5173\u95ED\u5FEB\u901F\u989C\u8272\uFF0C\u5C06\u4F7F\u7528\u6B64\u5904\u7684\u6BCF\u79CD\u6837\u5F0F\u989C\u8272\u3002",
      "btn_add_style": "+ \u6DFB\u52A0\u6837\u5F0F",
      "quick_styles_menu_option": "\u5FEB\u901F\u6837\u5F0F",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "\u9ED1\u540D\u5355\u7EC4\u6761\u76EE",
      "show_blacklist_groups_in_commands": "\u5728\u547D\u4EE4\u4E2D\u663E\u793A\u9ED1\u540D\u5355\u7EC4",
      "show_blacklist_groups_in_commands_desc": "\u542F\u7528\u540E\uFF0C\u9ED1\u540D\u5355\u7EC4\u5C06\u5728\u547D\u4EE4\u9762\u677F\u4E2D\u663E\u793A\uFF0C\u5E76\u5E26\u6709\u6FC0\u6D3B/\u505C\u7528\u547D\u4EE4\u3002",
      "search_blacklist_groups_placeholder": "\u641C\u7D22\u9ED1\u540D\u5355\u7EC4\u2026",
      "btn_create_new_blacklist_group": "+ \u521B\u5EFA\u65B0\u9ED1\u540D\u5355\u7EC4",
      "edit_blacklist_group_modal_title": "\u7F16\u8F91\u9ED1\u540D\u5355\u7EC4",
      "tooltip_delete_all_blacklist_groups": "\u5220\u9664\u6240\u6709\u9ED1\u540D\u5355\u7EC4",
      "confirm_delete_all_blacklist_groups_title": "\u5220\u9664\u6240\u6709\u9ED1\u540D\u5355\u7EC4",
      "confirm_delete_all_blacklist_groups_desc": "\u786E\u5B9A\u8981\u5220\u9664\u6240\u6709\u9ED1\u540D\u5355\u7EC4\u5417\uFF1F\u6B64\u64CD\u4F5C\u65E0\u6CD5\u64A4\u9500\uFF01",
      "confirm_delete_blacklist_group_title": "\u5220\u9664\u9ED1\u540D\u5355\u7EC4",
      "confirm_delete_blacklist_group_desc": "\u786E\u5B9A\u8981\u5220\u9664\u6B64\u9ED1\u540D\u5355\u7EC4\u5417\uFF1F\u6B64\u64CD\u4F5C\u65E0\u6CD5\u64A4\u9500\u3002",
      "notice_blacklist_group_activated": "\u9ED1\u540D\u5355\u7EC4\u5DF2\u6FC0\u6D3B",
      "notice_blacklist_group_deactivated": "\u9ED1\u540D\u5355\u7EC4\u5DF2\u505C\u7528",
      "command_activate_blacklist_group": "\u6FC0\u6D3B {groupName} \u9ED1\u540D\u5355\u7EC4",
      "command_deactivate_blacklist_group": "\u505C\u7528 {groupName} \u9ED1\u540D\u5355\u7EC4",
      "btn_duplicate_entry": "\u590D\u5236\u6761\u76EE",
      "btn_open_in_regex_tester": "\u5728\u6B63\u5219\u8868\u8FBE\u5F0F\u6D4B\u8BD5\u5668\u4E2D\u6253\u5F00",
      "move_to_blacklist_group": "\u79FB\u5230\u9ED1\u540D\u5355\u7EC4",
      "btn_delete_entry": "\u5220\u9664\u6761\u76EE",
      "btn_cancel": "\u53D6\u6D88",
      "btn_confirm": "\u786E\u8BA4",
      "requires_regex_safety_disabled": "\u9700\u8981\u7981\u7528\u6B63\u5219\u5B89\u5168",
      "share_export_title": "Always Color Text \u5BFC\u51FA",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "\u6837\u5F0F\u540D\u79F0",
      "preview_text": "\u6587\u672C",
      "edit_group_highlight_styling": "\u7F16\u8F91\u7EC4\u9AD8\u4EAE\u6837\u5F0F",
      "light_mode_fixer_desc": "\u4F7F\u7528\u6D45\u8272\u4E3B\u9898\u65F6\u81EA\u52A8\u52A0\u6DF1\u5F69\u8272\u6587\u672C\u4EE5\u63D0\u9AD8\u53EF\u89C1\u6027\u3002",
      "dark_mode_fixer_desc": "\u4F7F\u7528\u6DF1\u8272\u4E3B\u9898\u65F6\u81EA\u52A8\u53D8\u6D45\u5F69\u8272\u6587\u672C\u4EE5\u63D0\u9AD8\u53EF\u89C1\u6027\u3002",
      "preset_bold": "\u7C97\u4F53",
      "preset_italic": "\u659C\u4F53",
      "preset_bold_italic": "\u7C97\u659C\u4F53"
    };
  }
});

// src/i18n/de.js
var require_de = __commonJS({
  "src/i18n/de.js"(exports2, module2) {
    module2.exports = {
      // Plugin Metadata & Basic Labels
      "__name": "Deutsch",
      "settings_title": "Always Color Text Einstellungen",
      "header_plugin_name": "Always Color Text",
      "ribbon_title": "Always Color Text",
      // Language Settings
      "language_label": "Sprache",
      "language_desc": "W\xE4hlen Sie die Sprache f\xFCr das Plugin",
      "language_en": "English",
      "language_es": "Espa\xF1ol",
      "language_fr": "Fran\xE7ais",
      "language_eu": "Baskisch",
      "language_ru": "Russisch",
      "language_auto": "Systemstandard",
      "default": "Standard",
      // Release Notes
      "latest_release_notes_label": "Neueste Versionshinweise",
      "latest_release_notes_desc": "Pr\xFCfen Sie die neuesten Versionshinweise f\xFCr das Plugin",
      "open_changelog_button": "\xC4nderungsprotokoll \xF6ffnen",
      "command_show_release_notes": "Neueste Versionshinweise anzeigen",
      "changelog_view_on_github": "Auf GitHub ansehen",
      "changelog_loading": "Lade Versionen...",
      "changelog_no_info": "Keine Versionsinformationen verf\xFCgbar.",
      "changelog_release": "Version",
      "changelog_no_notes": "Keine Notizen",
      "changelog_failed_to_load": "Laden der Versionshinweise fehlgeschlagen.",
      // UI Elements & Menus
      "file_menu_enable": "Always Color Text f\xFCr diese Datei aktivieren",
      "file_menu_disable": "Always Color Text f\xFCr diese Datei deaktivieren",
      "menu_color_once": "Einmal f\xE4rben",
      "menu_highlight_once": "Einmal hervorheben",
      "menu_color_highlight_once": "Einmal f\xE4rben / hervorheben",
      "menu_remove_inline_color": "Inline-Farbe entfernen",
      "menu_always_color_text": "Always Color Text",
      "menu_remove_always_color_text": "Always Color Text entfernen",
      "menu_blacklist_word": "Wort auf die schwarze Liste setzen",
      "show_toggle_statusbar": "Umschalter in der Statusleiste anzeigen",
      "show_toggle_ribbon": "Umschalt-Symbol im Men\xFCband anzeigen",
      "show_toggle_command": "Umschalter in Befehlen anzeigen",
      "menu_options_header": "Men\xFCoptionen",
      "show_blacklist_menu": '"Wort auf die schwarze Liste setzen" im Rechtsklick-Men\xFC anzeigen',
      "show_blacklist_menu_desc": "F\xFCgt einen Rechtsklick-Men\xFCpunkt hinzu, um ausgew\xE4hlten Text von der F\xE4rbung auszuschlie\xDFen.",
      "show_add_to_existing_menu": '"Zu vorhandenem Eintrag hinzuf\xFCgen" im Rechtsklick-Men\xFC anzeigen',
      "show_add_to_existing_menu_desc": "F\xFCgt einen Rechtsklick-Men\xFCpunkt hinzu, um ausgew\xE4hlten Text zu einem vorhandenen Eintrag hinzuzuf\xFCgen.",
      "show_always_color_text_menu": '"Always Color Text" im Rechtsklick-Men\xFC anzeigen',
      "show_always_color_text_menu_desc": "F\xFCgt einen Rechtsklick-Men\xFCpunkt hinzu, um ausgew\xE4hlten Text zu f\xE4rben.",
      "hide_inactive_groups_in_dropdowns": "Inaktive Gruppen in Dropdowns ausblenden",
      "hide_inactive_groups_in_dropdowns_desc": "Inaktive Wortgruppen beim Anzeigen von Gruppenlisten in Dropdowns ausblenden.",
      "show_word_groups_in_commands": "Wortgruppen in Befehlen anzeigen",
      "show_word_groups_in_commands_desc": "Wenn aktiviert, erscheinen Wortgruppen in der Befehlspalette mit Befehlen zum Aktivieren/Deaktivieren.",
      "tooltip_enable_for_file": "F\xFCr diese Datei aktivieren",
      "tooltip_delete_all_words": "Alle definierten W\xF6rter/Muster l\xF6schen",
      "tooltip_delete_all_blacklist": "Alle W\xF6rter/Muster der schwarzen Liste l\xF6schen",
      "tooltip_use_regex": "Als Regex-Muster verwenden",
      "drag_to_reorder": "Zum Neuordnen ziehen",
      "reset_text_color": "Textfarbe zur\xFCcksetzen",
      "reset_highlight": "Hervorhebung zur\xFCcksetzen",
      "tooltip_duplicate_group": "Gruppe duplizieren",
      "tooltip_edit_group_settings": "Gruppeneinstellungen bearbeiten",
      "tooltip_delete_all_groups": "Alle Wortgruppen l\xF6schen",
      "grouped_entries_desc": "Wortgruppen verwalten. Suchfilter nach Gruppennamen.",
      "search_groups_placeholder": "Gruppen suchen\u2026",
      "no_entries_found": "Keine Eintr\xE4ge gefunden.",
      // Commands
      "command_color_selected": "Ausgew\xE4hlten Text f\xE4rben",
      "command_toggle_current": "F\xE4rbung f\xFCr aktuelles Dokument aktivieren/deaktivieren",
      "command_toggle_global": "Globale F\xE4rbung aktivieren/deaktivieren",
      "command_enable_current": "F\xE4rbung f\xFCr aktuelles Dokument aktivieren",
      "command_disable_current": "F\xE4rbung f\xFCr aktuelles Dokument deaktivieren",
      "command_enable_global": "Globale F\xE4rbung aktivieren",
      "command_disable_global": "Globale F\xE4rbung deaktivieren",
      "command_manage_advanced_rules": "Spezifische Einschluss-/Ausschlussregeln verwalten",
      "command_open_regex_tester": "Regex hinzuf\xFCgen (Regex-Tester \xF6ffnen)",
      "command_open_blacklist_regex_tester": "Blacklist-Regex hinzuf\xFCgen",
      "command_manage_colored_texts": "Gef\xE4rbte Texte verwalten",
      "command_toggle_hide_text_colors": "Textfarben ausblenden/einblenden",
      "command_toggle_hide_highlights": "Hervorhebungen ausblenden/einblenden",
      "command_hide_text_colors": "Textfarben ausblenden",
      "command_unhide_text_colors": "Textfarben einblenden",
      "command_hide_highlights": "Hervorhebungen ausblenden",
      "command_unhide_highlights": "Hervorhebungen einblenden",
      "command_enable_lightweight_mode": "Leichtgewichtsmodus aktivieren",
      "command_disable_lightweight_mode": "Leichtgewichtsmodus deaktivieren",
      "command_color_highlight_once": "Ausgew\xE4hlten Text einmal f\xE4rben / hervorheben",
      "notice_select_text_first_once": "Bitte w\xE4hlen Sie zuerst Text aus, um ihn einmal zu f\xE4rben/hervorzuheben.",
      "command_activate_word_group": "Wortgruppe {groupName} aktivieren",
      "command_deactivate_word_group": "Wortgruppe {groupName} deaktivieren",
      // Notifications
      "notice_lightweight_mode_enabled": "Leichtgewichtsmodus aktiviert",
      "notice_lightweight_mode_disabled": "Leichtgewichtsmodus deaktiviert",
      "notice_enabled": "Always Color Text Aktiviert",
      "notice_disabled": "Always Color Text Deaktiviert",
      "notice_blacklisted_cannot_color": '"{word}" steht auf der schwarzen Liste und kann nicht gef\xE4rbt werden.',
      "notice_removed_always_color": 'Always Color Text f\xFCr "{word}" entfernt.',
      "notice_added_to_blacklist": '"{word}" zur schwarzen Liste hinzugef\xFCgt.',
      "notice_already_blacklisted": '"{word}" steht bereits auf der schwarzen Liste.',
      "notice_select_text_first": "Bitte w\xE4hlen Sie zuerst etwas Text aus.",
      "notice_no_active_file": "Keine aktive Datei zum Umschalten der F\xE4rbung.",
      "notice_coloring_enabled_for_path": "F\xE4rbung aktiviert f\xFCr {path}",
      "notice_coloring_disabled_for_path": "F\xE4rbung deaktiviert f\xFCr {path}",
      "notice_global_enabled": "Always Color Text Aktiviert",
      "notice_global_disabled": "Always Color Text Deaktiviert",
      "notice_unable_open_changelog": "\xC4nderungsprotokoll-Modal kann nicht ge\xF6ffnet werden.",
      "notice_pattern_blocked": "Muster aus Sicherheitsgr\xFCnden blockiert:",
      "notice_pattern_too_complex": "Muster zu komplex:",
      "notice_invalid_hex_format": "Ung\xFCltiges Hex-Farbformat. Verwenden Sie #RRGGBB oder #RGB.",
      "notice_error_saving_changes": "Fehler beim Speichern der \xC4nderungen. Bitte versuchen Sie es erneut.",
      "notice_invalid_color_format": "Ung\xFCltiges Farbformat.",
      "notice_exported": "Exportiert: {fname}",
      "notice_export_failed": "Export fehlgeschlagen",
      "notice_import_completed": "Import abgeschlossen",
      "notice_import_failed": "Import fehlgeschlagen",
      "notice_invalid_regex": "Ung\xFCltiger Regex",
      "notice_empty_pattern": "Muster ist leer",
      "notice_added_regex": "Regex hinzugef\xFCgt",
      "notice_rule_updated": "Regel aktualisiert",
      "notice_regex_updated": "Regex aktualisiert",
      "notice_entry_updated": "Eintrag aktualisiert",
      "notice_entry_duplicated": "Eintrag dupliziert",
      "notice_error_opening_regex_tester": "Fehler beim \xD6ffnen des Regex-Testers",
      "notice_error_opening_blacklist_regex_tester": "Fehler beim \xD6ffnen des Blacklist-Regex-Testers",
      "notice_error_opening_advanced_rules": "Fehler beim \xD6ffnen des Modals f\xFCr erweiterte Regeln",
      "notice_text_color_reset": "Textfarbe zur\xFCckgesetzt",
      "notice_highlight_reset": "Hervorhebung zur\xFCckgesetzt",
      "notice_text_colors_hidden": "Textfarben ausgeblendet",
      "notice_text_colors_visible": "Textfarben sichtbar",
      "notice_highlights_hidden": "Hervorhebungen ausgeblendet",
      "notice_highlights_visible": "Hervorhebungen sichtbar",
      "notice_regex_support_disabled": "Regex-Unterst\xFCtzung ist deaktiviert. Aktivieren Sie sie in den Einstellungen, um Regex-Muster zu verwenden.",
      "notice_no_active_file_to_disable": "Keine aktive Datei, um F\xE4rbung zu deaktivieren.",
      "notice_already_disabled_for_path": "F\xE4rbung bereits deaktiviert f\xFCr {path}",
      "notice_filter_disabled": "Filter deaktiviert",
      // Confirmation Dialogs
      "confirm_delete_all_title": "Alle W\xF6rter l\xF6schen",
      "confirm_delete_all_desc": "Sind Sie sicher, dass Sie ALLE gef\xE4rbten W\xF6rter/Muster l\xF6schen m\xF6chten? Dies kann nicht r\xFCckg\xE4ngig gemacht werden!",
      "confirm_delete_all_blacklist_title": "Alle W\xF6rter der schwarzen Liste l\xF6schen",
      "confirm_delete_all_blacklist_desc": "Sind Sie sicher, dass Sie ALLE Eintr\xE4ge der schwarzen Liste l\xF6schen m\xF6chten? Dies kann nicht r\xFCckg\xE4ngig gemacht werden!",
      "restart_required_title": "Neustart erforderlich",
      "restart_required_desc": "Das Deaktivieren des Befehlspaletten-Umschalters erfordert einen Neustart von Obsidian, um den Befehl vollst\xE4ndig aus der Palette zu entfernen. Jetzt neu starten?",
      "btn_cancel": "Abbrechen",
      "btn_confirm": "Best\xE4tigen",
      // Basic Settings
      "enable_document_color": "Globale Farbe aktivieren",
      "color_rendering_header": "Farbwiedergabe & Leistung",
      "theme_support_header": "Themenunterst\xFCtzung",
      "matching_behavior_header": "\xDCbereinstimmungsverhalten",
      "smart_update_mode": "Intelligente Aktualisierungen (Experimentell)",
      "smart_update_mode_desc": "Aktualisiert intelligent nur sichtbare, ge\xE4nderte Zeilen w\xE4hrend des Tippens. Verbessert die Tippleistung erheblich.",
      "light_mode_fixer": "Textfarbkorrektur f\xFCr hellen Modus",
      "dark_mode_fixer": "Textfarbkorrektur f\xFCr dunklen Modus",
      "color_in_live_preview_mode": "Im Live-Vorschau-Modus f\xE4rben",
      "color_in_reading_mode": "Im Lesemodus f\xE4rben",
      "force_full_render_reading": "Vollst\xE4ndiges Rendern im Lesemodus erzwingen",
      "force_full_render_reading_desc": "Wenn aktiviert, versucht der Lesemodus, das gesamte Dokument auf einmal zu f\xE4rben. Kann bei gro\xDFen Dokumenten zu Verz\xF6gerungen f\xFChren, vorsichtig verwenden!",
      "lightweight_mode": "Leichtgewichtsmodus (Experimentell)",
      "lightweight_mode_desc": "Optimiert f\xFCr Geschwindigkeit. \xDCberspringt teure Pr\xFCfungen und Teil\xFCbereinstimmungen. Automatisch aktiviert f\xFCr gro\xDFe Dateien.",
      "disable_coloring_current_file": "F\xE4rbung f\xFCr aktuelle Datei deaktivieren",
      "disable_coloring_current_file_desc": "F\xFCgt eine Ausschlussregel f\xFCr die aktive Datei unter Datei- & Ordner-F\xE4rbungsregeln hinzu.",
      "btn_disable_for_this_file": "F\xFCr diese Datei deaktivieren",
      // Coloring Settings
      "coloring_settings_header": "F\xE4rbungseinstellungen",
      "regex_support": "Regex-Unterst\xFCtzung",
      "regex_support_desc": "Erlaubt Muster als Regex. Ung\xFCltige Regex werden aus Sicherheitsgr\xFCnden ignoriert.",
      "disable_regex_safety": "Regex-Sicherheitspr\xFCfung deaktivieren",
      "disable_regex_safety_desc": "Erlaubt komplexe oder potenziell gef\xE4hrliche Ausdr\xFCcke. Kann zu Verz\xF6gerungen oder Einfrieren f\xFChren.",
      "requires_regex_safety_disabled": "Erfordert deaktivierte Regex-Sicherheit",
      "case_sensitive": "Gro\xDF-/Kleinschreibung beachten",
      "case_sensitive_desc": 'Wenn aktiviert, sind "Wort" und "wort" unterschiedlich. Wenn deaktiviert, werden sie gleich gef\xE4rbt.',
      "partial_match": "Teil\xFCbereinstimmung",
      "partial_match_desc": 'Wenn aktiviert, wird das ganze Wort gef\xE4rbt, wenn ein gef\xE4rbtes Wort darin gefunden wird (z.B. "ein" f\xE4rbt "klein").',
      // One-Time Actions
      "one_time_actions_header": "Einmalige Aktionen",
      "setting_color_once": "Einmal f\xE4rben",
      "setting_color_once_desc": "F\xFCgt HTML-Inline-Stil f\xFCr ausgew\xE4hlten Text ein. Bleibt bestehen, auch wenn das Plugin ausgeschaltet ist.",
      "setting_highlight_once": "Einmal hervorheben",
      "setting_highlight_once_desc": "F\xFCgt HTML-Inline-Stil mit Hintergrund ein. Bleibt bestehen, auch wenn das Plugin ausgeschaltet ist.",
      "setting_color_highlight_once": "Einmal f\xE4rben & hervorheben",
      "setting_color_highlight_once_desc": "\xD6ffnet den einheitlichen Farbw\xE4hler, um sowohl Textfarbe als auch Hintergrundhervorhebung inline anzuwenden. Verwendet einheitliches Men\xFC.",
      "highlight_once_preview": "Vorschau f\xFCr Einmal hervorheben",
      "highlight_once_preview_text": "So sieht einmal hervorheben aus!",
      // Highlight Once Settings
      "highlight_once_opacity": "Deckkraft f\xFCr Einmal hervorheben",
      "highlight_once_border_radius": "Rahmenradius f\xFCr Einmal hervorheben (px)",
      "reset_to_8": "Auf 8 zur\xFCcksetzen",
      "highlight_horizontal_padding": "Horizontale Polsterung f\xFCr Hervorhebung (px)",
      "highlight_vertical_padding": "Vertikale Polsterung f\xFCr Hervorhebung (px)",
      "reset_to_4": "Auf 4 zur\xFCcksetzen",
      "enable_border_highlight_once": "Rahmen f\xFCr Einmal hervorheben aktivieren",
      "enable_border_highlight_once_desc": "F\xFCgt einen Rahmen zur Inline-Hervorhebung hinzu. Hinzugef\xFCgtes HTML/CSS wird lang sein.",
      "highlight_once_border_style": "Rahmenseite f\xFCr Einmal hervorheben",
      "highlight_once_border_line_style": "Rahmenstil",
      "opt_border_full": "Vollst\xE4ndiger Rahmen (Alle Seiten)",
      "opt_border_top_bottom": "Oben & Unten",
      "opt_border_left_right": "Links & Rechts",
      "opt_border_top_left_right": "Oben, Links & Rechts",
      "opt_border_bottom_left_right": "Unten, Links & Rechts",
      "opt_border_top_right": "Oben & Rechts",
      "opt_border_top_left": "Oben & Links",
      "opt_border_bottom_right": "Unten & Rechts",
      "opt_border_bottom_left": "Unten & Links",
      "opt_border_top": "Nur Oben",
      "opt_border_bottom": "Nur Unten",
      "opt_border_left": "Nur Links",
      "opt_border_right": "Nur Rechts",
      "highlight_once_border_opacity": "Rahmendeckkraft f\xFCr Einmal hervorheben",
      "highlight_once_border_thickness": "Rahmendicke f\xFCr Einmal hervorheben (px)",
      "reset_to_1": "Auf 1 zur\xFCcksetzen",
      "use_global_highlight_style": "Globalen Hervorhebungsstil f\xFCr Einmal hervorheben verwenden",
      "use_global_highlight_style_desc": "Verwendet Ihre globalen Inline-Stile. Hinzugef\xFCgtes HTML/CSS kann lang sein.",
      "style_highlight_once": "Einmal hervorheben stylen",
      "style_highlight_once_desc": "Verwendet Ihre benutzerdefinierten Inline-Stile. Hinzugef\xFCgtes HTML/CSS kann lang sein.",
      // Global Highlight Appearance
      "global_highlight_appearance_header": "Erscheinungsbild der globalen Hervorhebungsf\xE4rbung",
      "highlight_opacity": "Deckkraft der Hervorhebung",
      "highlight_opacity_desc": "Stellen Sie die Deckkraft der Hervorhebung ein (0-100%)",
      "highlight_border_radius": "Rahmenradius der Hervorhebung (px)",
      "highlight_border_radius_desc": "Stellen Sie den Rahmenradius der Hervorhebungsecken in px ein",
      "highlight_horizontal_padding_desc": "Stellen Sie die linke/rechte Polsterung f\xFCr hervorgehobenen Text in px ein",
      "highlight_vertical_padding_desc": "Stellen Sie die obere/untere Polsterung f\xFCr hervorgehobenen Text in px ein",
      "rounded_corners_wrapping": "Abgerundete Ecken bei Umbruch",
      "rounded_corners_wrapping_desc": "Wenn aktiviert, haben Hervorhebungen abgerundete Ecken auf allen Seiten, auch wenn Text in eine neue Zeile umbricht.",
      "enable_highlight_border": "Hervorhebungsrahmen aktivieren",
      "enable_highlight_border_desc": "F\xFCgt einen Rahmen um Hervorhebungen hinzu. Rahmen entspricht Text- oder Hervorhebungsfarbe.",
      "border_style": "Rahmenseite",
      "border_style_desc": "W\xE4hlen Sie, auf welchen Seiten der Rahmen angewendet werden soll",
      "border_line_style": "Rahmenstil",
      "border_line_style_desc": "W\xE4hlen Sie den Rahmenlinienstil",
      "border_opacity": "Rahmendeckkraft",
      "border_opacity_desc": "Stellen Sie die Deckkraft des Rahmens ein (0-100%)",
      "border_thickness": "Rahmendicke (px)",
      "border_thickness_desc": "Stellen Sie die Rahmendicke von 0-5 Pixeln ein (z.B. 1, 2.5, 5)",
      "highlight_preview": "Hervorhebungsvorschau",
      "highlight_preview_text": "So sieht Ihre Hervorhebung aus!",
      "opt_line_solid": "Durchgezogen",
      "opt_line_dashed": "Gestrichelt",
      "opt_line_dotted": "Gepunktet",
      "opt_line_double": "Doppelt",
      "opt_line_groove": "Rille",
      "opt_line_ridge": "Grat",
      "opt_line_inset": "Eingelassen",
      "opt_line_outset": "Hervorstehend",
      // Color Swatches
      "color_swatches_header": "Farbverwaltung",
      "color_picker_layout": "Farbw\xE4hler-Layout",
      "color_picker_layout_desc": "W\xE4hlen Sie, welche Farbtypen beim Ausw\xE4hlen von Farben f\xFCr Text angezeigt werden sollen",
      "enable_custom_swatches": "Benutzerdefinierte Farbfelder aktivieren",
      "enable_custom_swatches_desc": "Aktivieren Sie dies, wenn Sie Ihre eigenen Farben f\xFCr den Farbw\xE4hler ausw\xE4hlen m\xF6chten.",
      "replace_default_swatches": "Standard-Farbfelder ersetzen",
      "replace_default_swatches_desc": "Wenn aktiviert, werden nur Ihre benutzerdefinierten Farbfelder angezeigt. Wenn deaktiviert, werden sie an die Standardfelder angeh\xE4ngt.",
      "use_swatch_names": "Farbfeldnamen zum F\xE4rben von Text verwenden",
      "use_swatch_names_desc": "Wenn aktiviert, wird der Text unter Verwendung des Namens des Farbfelds (z.B. 'Rot') anstelle des Hex-Codes gef\xE4rbt.",
      "link_swatch_updates": "Farbfeldaktualisierungen mit Textfarben verkn\xFCpfen",
      "link_swatch_updates_desc": "Wenn aktiviert, aktualisiert eine \xC4nderung der Farbfeldfarbe alle mit diesem Farbfeld gef\xE4rbten Texte.",
      "default_colors_header": "Standard-Farbfelder",
      "custom_swatches_header": "Benutzerdefinierte Farbfelder",
      "btn_add_color": "+ Farbe hinzuf\xFCgen",
      "no_custom_swatches_yet": 'Noch keine benutzerdefinierten Farbfelder. Klicken Sie auf "+ Farbe hinzuf\xFCgen", um eines zu erstellen.',
      "label_built_in": "(Eingebaut)",
      // Color Picker
      "pick_color_header": "Farbe w\xE4hlen",
      "selected_text_preview": "Ausgew\xE4hlter Text",
      "text_color_title": "Textfarbe",
      "select_swatch": "Farbfeld w\xE4hlen...",
      "highlight_color_title": "Hervorhebungsfarbe",
      "select_highlight_swatch": "Hervorhebungsfarbfeld w\xE4hlen...",
      "settings_tab_general": "Allgemein",
      "settings_tab_colored_texts": "Gef\xE4rbte Texte",
      "settings_tab_blacklists": "Schwarze Listen",
      "settings_tab_file_folder_rules": "Datei / Ordner Regeln",
      "settings_tab_data": "Daten",
      // Always Colored Texts
      "colored_texts_header": "Gef\xE4rbte Texte",
      "always_colored_texts_desc": "Hier verwalten Sie Ihre W\xF6rter/Muster und deren Farben.",
      "grouped_entries_header": "Gruppierte Eintr\xE4ge",
      "btn_create_new_group": "+ Neue Gruppe erstellen",
      "edit_word_group_modal_title": "Wortgruppe bearbeiten",
      "group_name_placeholder": "Benennen Sie Ihre Gruppe",
      "btn_save_group": "Gruppe speichern",
      "btn_delete_group": "Gruppe l\xF6schen",
      "group_active_label": "Aktiv",
      "group_inactive_label": "Inaktiv",
      "confirm_delete_group_title": "Gruppe l\xF6schen",
      "confirm_delete_group_desc": "Sind Sie sicher, dass Sie diese Gruppe l\xF6schen m\xF6chten? Dies kann nicht r\xFCckg\xE4ngig gemacht werden.",
      "confirm_delete_all_groups_title": "Alle Wortgruppen l\xF6schen",
      "confirm_delete_all_groups_desc": "Sind Sie sicher, dass Sie ALLE Wortgruppen l\xF6schen m\xF6chten? Dies kann nicht r\xFCckg\xE4ngig gemacht werden!",
      "search_colored_words_placeholder": "Suche gef\xE4rbte W\xF6rter oder Muster...",
      "btn_add_new_word": "+ Neues Wort hinzuf\xFCgen",
      "sort_label_last-added": "Sortierung: Zuletzt hinzugef\xFCgt",
      "sort_label_a-z": "Sortierung: A-Z",
      "sort_label_reverse-a-z": "Sortierung: Z-A",
      "sort_label_style-order": "Sortierung: Stilreihenfolge",
      "sort_label_color": "Sortierung: Farbe",
      "style_type_text": "Farbe",
      "style_type_highlight": "Hervorhebung",
      "style_type_both": "Beides",
      "word_pattern_placeholder_long": "Muster, Wort oder kommagetrennte W\xF6rter (z.B. hallo, welt, foo)",
      "word_pattern_placeholder_short": "Schl\xFCsselwort oder Muster, oder kommagetrennte W\xF6rter",
      "use_regex": "Regex verwenden",
      "flags_placeholder": "Flags",
      "text_or_regex_placeholder": "Text/Regex Eingabe",
      "duplicate_entry": "Eintrag duplizieren",
      "open_in_regex_tester": "Im Regex-Tester \xF6ffnen",
      "no_rules_configured": "Keine Regeln konfiguriert.",
      "no_rules_found": "Keine Regeln gefunden.",
      "match_option_exact": "Exakt",
      "match_option_contains": "Enth\xE4lt",
      "match_option_starts_with": "Beginnt mit",
      "match_option_ends_with": "Endet mit",
      // Presets
      "btn_presets": "Voreinstellungen",
      "preset_all_headings": "Alle \xDCberschriften (H1-H6)",
      "preset_headings_h3": "\xDCberschriften (H3)",
      "preset_bullet_points": "Aufz\xE4hlungspunkte",
      "preset_numbered_lists": "Nummerierte Listen",
      "preset_task_checked": "Aufgabenlisten (Erledigt)",
      "preset_task_unchecked": "Aufgabenlisten (Unerledigt)",
      "preset_dates_yyyy_mm_dd": "Daten (JJJJ-MM-TT)",
      "preset_times_am_pm": "Zeiten (AM/PM)",
      "preset_times_24h": "Zeiten (24h)",
      "preset_dates_yyyy_mmm_dd": "Daten (JJJJ-MMM-TT)",
      "preset_relative_dates": "Relative Daten",
      "preset_basic_urls": "Einfache URLs",
      "preset_markdown_links": "Markdown-Links",
      "preset_domain_names": "Domain-Namen",
      "preset_email_addresses": "E-Mail-Adressen",
      "preset_at_username": "@Benutzername",
      "preset_currency": "W\xE4hrung",
      "preset_measurements": "Ma\xDFeinheiten",
      "preset_phone_numbers": "Telefonnummern",
      "preset_all_texts": "S\xE4mtlicher Text",
      "preset_codeblocks": "Codebl\xF6cke",
      "preset_inline_comments": "Kommentare (%%...%%)",
      "preset_highlighted_text": "Hervorgehobener Text (==...==)",
      "preset_parentheses": "Klammern ()",
      "preset_square_brackets": "Eckige Klammern []",
      "preset_curly_braces": "Geschweifte Klammern {}",
      "preset_angle_brackets": "Spitze Klammern <>",
      "preset_colons": "Doppelpunkte :",
      "preset_double_quotes": "Doppelte Anf\xFChrungszeichen",
      "preset_single_quotes": "Einfache Anf\xFChrungszeichen",
      "preset_single_quotes_word_bounded": "Einfache Anf\xFChrungszeichen (Wortgebunden)",
      "preset_bold": "Fett",
      "preset_italic": "Kursiv",
      "preset_bold_italic": "Fett Kursiv",
      "preset_group_markdown_formatting": "Markdown-Formatierung",
      "preset_group_other_patterns": "Andere Muster",
      "preset_group_brackets": "Klammern",
      // Preset Examples
      "preset_example_heading": "# \xDCberschrift",
      "preset_example_heading_h3": "### \xDCberschrift",
      "preset_example_bullet": "- Aufz\xE4hlungspunkt",
      "preset_example_numbered": "1. Erstes Element",
      "preset_example_task_checked": "- [x] Erledigt",
      "preset_example_task_unchecked": "- [ ] Zu erledigen",
      "preset_example_codeblock": "``` code ```",
      "preset_example_date_iso": "2009-01-19",
      "preset_example_date_text": "2025-Jan-19",
      "preset_example_time_ampm": "9:05pm",
      "preset_example_time_24h": "13:00",
      "preset_example_relative": "heute, morgen",
      "preset_example_url": "https://beispiel.de",
      "preset_example_markdown_link": "[Link](https://beispiel.de)",
      "preset_example_comment": "%% kommentar %%",
      "preset_example_domain": "beispiel.de",
      "preset_example_email": "name@beispiel.de",
      "preset_example_username": "@benutzername",
      "preset_example_currency": "$29.99",
      "preset_example_measurement": "25kg",
      "preset_example_phone": "123-456-7890",
      "preset_example_parentheses": "( text )",
      "preset_example_square_brackets": "[ ja ]",
      "preset_example_curly_braces": "{ nein }",
      "preset_example_angle_brackets": "< text >",
      "preset_example_colons": ": text :",
      "preset_example_double_quotes": '"text"',
      "preset_example_single_quotes": "'text'",
      "preset_example_single_quotes_word": "'wort'",
      "preset_example_highlight": "==hervorgehobener text==",
      "preset_example_all_text": "Dies zielt auf alle Texte ab.",
      // Blacklist Settings
      "blacklist_words_header": "Schwarze Listen",
      "blacklist_words_desc": "Schl\xFCsselw\xF6rter oder Muster hier werden nie gef\xE4rbt, auch nicht bei Teil\xFCbereinstimmungen.",
      "search_blacklist_placeholder": "Suche W\xF6rter oder Muster der schwarzen Liste\u2026",
      "blacklist_sort_label_last-added": "Sortierung: Zuletzt hinzugef\xFCgt",
      "blacklist_sort_label_a-z": "Sortierung: A-Z",
      "blacklist_sort_label_reverse-a-z": "Sortierung: Z-A",
      "btn_add_blacklist": "+ Wort oder Muster zur schwarzen Liste hinzuf\xFCgen",
      "btn_add_to_blacklist": "+ Zur schwarzen Liste hinzuf\xFCgen",
      "btn_add_blacklist_word": "+ Wort zur schwarzen Liste hinzuf\xFCgen",
      "btn_add_blacklist_regex": "+ Regex zur schwarzen Liste hinzuf\xFCgen",
      // File & Folder Rules
      "file_folder_rules_header": "Datei & Ordner F\xE4rbungsregeln",
      "file_folder_rules_desc": "Steuern Sie die F\xE4rbung mit Namens\xFCbereinstimmung, exakten Pfaden oder Regex-Mustern. Lassen Sie einen leeren Ausschlusseintrag, um die F\xE4rbung tresorweit zu deaktivieren.",
      "search_file_folder_rules_placeholder": "Suche Datei/Ordner Regeln\u2026",
      "path_sort_label_last-added": "Sortierung: Zuletzt hinzugef\xFCgt",
      "path_sort_label_a-z": "Sortierung: A-Z",
      "path_sort_label_reverse-a-z": "Sortierung: Z-A",
      "path_sort_label_mode": "Sortierung: Modus",
      "path_sort_label_type": "Sortierung: Typ",
      "btn_add_file_folder_rule": "+ Datei/Ordner Regel hinzuf\xFCgen",
      "disabled_files_header": "Dateien mit deaktivierter F\xE4rbung:",
      // Advanced Settings - Inclusion Exclusion Labels
      "path_rule_mode_include": "Einschlie\xDFen",
      "path_rule_mode_exclude": "Ausschlie\xDFen",
      "text_rule_mode_include": "f\xE4rbt nur in (Whitelist)",
      "text_rule_mode_exclude": "f\xE4rbt nicht in (Blacklist)",
      "mode_only_colors_in": "f\xE4rbt nur in",
      "mode_does_not_color_in": "f\xE4rbt nicht in",
      "label_text_include": "Whitelist",
      "label_text_exclude": "Blacklist",
      "label_enable_in": "Aktivieren in",
      "label_disable_in": "Deaktivieren in",
      "enter_path_or_pattern": "Pfad, Muster oder Tags eingeben",
      "label_regex": "Regex",
      // Advanced Rules
      "advanced_rules_header": "Spezifische Einschluss-/Ausschlussregeln",
      "advanced_rules_modal_header": "Spezifische Einschluss-/Ausschlussregeln",
      "advanced_rules_manage_button": "spezifische Einschluss-/Ausschlussregeln verwalten",
      "edit_rule_header": "Regel bearbeiten",
      "add_rule_header": "Neue Regel hinzuf\xFCgen",
      "btn_add_rule": "+ Regel hinzuf\xFCgen",
      "btn_save_rule": "Regel speichern",
      "btn_add_words": "+ W\xF6rter hinzuf\xFCgen",
      "btn_add_regex": "+ Regex hinzuf\xFCgen",
      "btn_save_regex": "Regex speichern",
      // Regex Tester
      "regex_tester_header": "Regex-Tester",
      "regex_tester_blacklist": "Regex-Tester - Blacklist",
      "regex_expression_placeholder": "Setzen Sie Ihren Regex-Ausdruck hier ein",
      "regex_subject_placeholder": "Geben Sie Ihr Subjekt / Teststring hier ein...",
      "regex_name_placeholder": "Benennen Sie Ihren Regex",
      "matches": "\xDCbereinstimmungen",
      "matches_found": "\xDCbereinstimmungen gefunden",
      // Regex Flags
      "flag_g": "Global Flag: Alle \xDCbereinstimmungen finden",
      "flag_i": "Gro\xDF-/Kleinschreibung ignorieren Flag",
      "flag_m": "Mehrzeilen Flag: ^ und $ passen auf Zeilengrenzen",
      "flag_s": "dotAll Flag: . passt auf Zeilenumbr\xFCche",
      "flag_u": "Unicode Flag: als Unicode-Code-Points behandeln",
      "flag_y": "Sticky Flag: \xDCbereinstimmung ab lastIndex Position",
      // Data Export/Import
      "data_export_import_header": "Daten Export/Import",
      "export_plugin_data": "Plugin-Daten exportieren",
      "export_plugin_data_desc": "Einstellungen, W\xF6rter und Regeln in eine JSON-Datei exportieren.",
      "btn_export": "Exportieren",
      "import_plugin_data": "Plugin-Daten importieren",
      "import_plugin_data_desc": "Einstellungen aus einer JSON-Datei importieren",
      "btn_import": "Importieren",
      "limit_input_placeholder": "Limit",
      "limit_input_tooltip": "0=alle; Zahl=letzte N; r=regex; h=hervorhebung; c=text; b=text+hg; sw=beginnt; ew=endet; e=exakt",
      // Missing Keys Added
      "highlight_styling_header": "Hervorhebungsstyling bearbeiten",
      "edit_entry_header": "Eintrag bearbeiten",
      "opt_case_sensitive": "Gro\xDF-/Kleinschreibung beachten",
      "opt_not_case_sensitive": "Gro\xDF-/Kleinschreibung ignorieren",
      "opt_case_all": "Gro\xDF-/Kleinschreibung (Alle)",
      "opt_match_all": "\xDCbereinstimmungstyp (Alle)",
      "edit_highlight_styling_btn": "Hervorhebungsstyling bearbeiten",
      "inclusion_exclusion_header": "Einschluss- / Ausschlussregeln",
      "btn_save_entry": "Eintrag speichern",
      "edit_entry_details": "Eintragsdetails bearbeiten",
      "prompt_search_existing": "Suche vorhandene Eintr\xE4ge\u2026",
      "command_add_to_existing_entry": "Zu vorhandenem Eintrag hinzuf\xFCgen",
      "context_remove_from_entry": '"{word}" aus Eintrag entfernen',
      "context_delete_entry": "Eintrag l\xF6schen",
      "btn_reset": "Zur\xFCcksetzen",
      "btn_reset_all": "Hervorhebungsstil zur\xFCcksetzen",
      "btn_add_word": "+ Wort hinzuf\xFCgen",
      "btn_add_regex_short": "+ Regex hinzuf\xFCgen",
      "section_highlight_border_styling": "Hervorhebungsrahmen-Styling",
      "section_highlight_styling": "Hervorhebungsstyling",
      "label_highlight_opacity": "Hervorhebungsdeckkraft",
      "label_highlight_radius": "Hervorhebungsrahmenradius",
      "label_horizontal_padding": "Horizontale Polsterung",
      "label_vertical_padding": "Vertikale Polsterung",
      "label_enable_border": "Rahmen aktivieren",
      "label_border_sides": "Rahmenseiten",
      "label_border_style": "Rahmenstil",
      "label_border_opacity": "Rahmendeckkraft",
      "label_border_thickness": "Rahmendicke",
      "btn_save_style": "Stil speichern",
      "share_export_title": "Always Color Text Export",
      "delete_button_text": "\u2715",
      "style_name_placeholder": "Stilname",
      "preview_text": "Text",
      // Quick Colors / Styles
      "quick_actions_header": "Schnellaktionen",
      "quick_colors_header": "Schnellfarben",
      "quick_colors_desc": "Erlaubt es Ihnen, Text schnell hervorzuheben oder zu f\xE4rben, indem Farben im Rechtsklick-Men\xFC angezeigt werden. Wenn Schnellfarben deaktiviert sind, werden Farben pro Stil in Schnellstilen verwendet.",
      "quick_colors_apply_mode_label": "Die Textf\xE4rbung wird angewendet als",
      "quick_colors_apply_mode_act": "Always Color Text",
      "quick_colors_apply_mode_html": "Inline HTML",
      "quick_styles_header": "Schnellstile",
      "quick_styles_desc": "Definieren Sie benannte Stile zum Anwenden von Textfarbe und Hervorhebungen. Wenn Schnellfarben deaktiviert sind, werden Farben pro Stil hier verwendet.",
      "btn_add_style": "+ Stil hinzuf\xFCgen",
      "quick_styles_menu_option": "Schnellstile",
      // Blacklist Groups
      "blacklist_grouped_entries_header": "Blacklist-Gruppeneintr\xE4ge",
      "show_blacklist_groups_in_commands": "Blacklist-Gruppen in Befehlen anzeigen",
      "show_blacklist_groups_in_commands_desc": "Wenn aktiviert, erscheinen Blacklist-Gruppen in der Befehlspalette mit Befehlen zum Aktivieren/Deaktivieren.",
      "search_blacklist_groups_placeholder": "Suche Blacklist-Gruppen\u2026",
      "btn_create_new_blacklist_group": "+ Neue Blacklist-Gruppe erstellen",
      "edit_blacklist_group_modal_title": "Blacklist-Gruppe bearbeiten",
      "tooltip_delete_all_blacklist_groups": "Alle Blacklist-Gruppen l\xF6schen",
      "confirm_delete_all_blacklist_groups_title": "Alle Blacklist-Gruppen l\xF6schen",
      "confirm_delete_all_blacklist_groups_desc": "Sind Sie sicher, dass Sie ALLE Blacklist-Gruppen l\xF6schen m\xF6chten? Dies kann nicht r\xFCckg\xE4ngig gemacht werden!",
      "confirm_delete_blacklist_group_title": "Blacklist-Gruppe l\xF6schen",
      "confirm_delete_blacklist_group_desc": "Sind Sie sicher, dass Sie diese Blacklist-Gruppe l\xF6schen m\xF6chten? Dies kann nicht r\xFCckg\xE4ngig gemacht werden.",
      "notice_blacklist_group_activated": "Blacklist-Gruppe aktiviert",
      "notice_blacklist_group_deactivated": "Blacklist-Gruppe deaktiviert",
      "command_activate_blacklist_group": "Blacklist-Gruppe {groupName} aktivieren",
      "command_deactivate_blacklist_group": "Blacklist-Gruppe {groupName} deaktivieren",
      "btn_duplicate_entry": "Eintrag duplizieren",
      "btn_open_in_regex_tester": "Im Regex-Tester \xF6ffnen",
      "move_to_blacklist_group": "In Blacklist-Gruppe verschieben",
      "btn_delete_entry": "Eintrag l\xF6schen",
      "edit_group_highlight_styling": "Gruppen-Hervorhebungsstyling bearbeiten",
      "light_mode_fixer_desc": "Dunkelt gef\xE4rbten Text automatisch ab, wenn das helle Design verwendet wird, um die Lesbarkeit zu verbessern.",
      "dark_mode_fixer_desc": "Hellt gef\xE4rbten Text automatisch auf, wenn das dunkle Design verwendet wird, um die Lesbarkeit zu verbessern."
    };
  }
});

// src/i18n.js
var require_i18n = __commonJS({
  "src/i18n.js"(exports2, module2) {
    var en = require_en();
    var es = require_es();
    var fr = require_fr();
    var hi = require_hi();
    var it = require_it();
    var bn = require_bn();
    var ru = require_ru();
    var zh_cn = require_zh_cn();
    var de = require_de();
    module2.exports = {
      en,
      es,
      fr,
      hi,
      it,
      bn,
      ru,
      zh_cn,
      de
    };
  }
});

// src/main.js
var {
  Plugin,
  PluginSettingTab,
  Setting,
  Modal,
  MarkdownView,
  Notice,
  FuzzySuggestModal,
  debounce,
  MarkdownRenderer,
  Menu,
  setIcon,
  Component
} = require("obsidian");
var moment = window.moment;
var RangeSetBuilder;
var Decoration;
var ViewPlugin;
var StateEffect;
var syntaxTree;
try {
  const cmState = require("@codemirror/state");
  RangeSetBuilder = cmState.RangeSetBuilder;
  StateEffect = cmState.StateEffect;
  Decoration = require("@codemirror/view").Decoration;
  ViewPlugin = require("@codemirror/view").ViewPlugin;
  try {
    syntaxTree = require("@codemirror/language").syntaxTree;
  } catch (e) {
    console.warn("Always Color Text: syntaxTree not available");
  }
} catch (e) {
  RangeSetBuilder = class {
  };
  Decoration = { mark: () => ({}) };
  ViewPlugin = { fromClass: () => ({}) };
  StateEffect = { define: () => ({ of: () => ({}) }) };
}
var forceRebuildEffect = StateEffect.define();
var locales = require_i18n();
var { show_toggle_command } = require_fr();
var EDITOR_PERFORMANCE_CONSTANTS = {
  MAX_PATTERNS_STANDARD: 20,
  // Use standard processing for <= 20 patterns (reduced)
  MAX_TEXT_LENGTH_STANDARD: 5e3,
  // Use standard processing for <= 5k chars (reduced)
  PATTERN_CHUNK_SIZE: 20,
  // INCREASED: Process 20 patterns per chunk (better throughput)
  TEXT_CHUNK_SIZE: 2e3,
  // REDUCED: Process 2k chars per chunk during typing
  MAX_MATCHES_PER_PATTERN: 500,
  // Max matches per pattern (increased for better UX)
  MAX_TOTAL_MATCHES: 4e3,
  // Absolute limit for decorations (increased)
  LIGHTWEIGHT_MAX_TOTAL_MATCHES: 1e3,
  // Reduced limit for lightweight mode
  TYPING_DEBOUNCE_MS: 500,
  // INCREASED: Delay rebuilds while typing - 500ms (wait longer before recomputing)
  TYPING_GRACE_PERIOD_MS: 1500,
  // INCREASED: Skip decoration during active typing (1.5 seconds after last keystroke)
  VIEWPORT_EXTENSION: 200,
  // INCREASED: Buffer beyond viewport to include in text processing
  CALLOUT_THROTTLE_MS: 1e3,
  // Throttle callout processing to 1 second
  TABLE_THROTTLE_MS: 1e3
  // Throttle table processing to 1 second
};
var REGEX_CONSTANTS = {
  // List item content extraction
  CHECKBOX_PREFIX: /^\s*\[[\s\xX]\]\s*/,
  TASK_MARKER_PREFIX: /^\s*[\-\*]\s+\[[^\]]*\]\s+/,
  BULLET_PREFIX: /^\s*[\-\*]\s+/,
  NUMBERED_PREFIX: /^\s*\d+\.\s+/,
  // Markdown formatting patterns
  TASK_CHECKED: /^(\s*)([\-\*])(\s+)(\[[xX]\])(\s+)(.*)$/,
  TASK_UNCHECKED: /^(\s*)([\-\*])(\s+)(\[\s\])(\s+)(.*)$/,
  NUMBERED_LIST: /^(\s*)(\d+\.)(\s+)(.*)$/,
  BULLET_POINT: /^(\s*)([\-\*])(\s+)(.*)$/
};
function getHeadingLevelsFromPattern(pattern) {
  try {
    if (!pattern || typeof pattern !== "string") return [];
    const levels = /* @__PURE__ */ new Set();
    const quantMatch = pattern.match(/#\{(\d+)(?:,(\d+))?\}/);
    if (quantMatch) {
      let start = parseInt(quantMatch[1], 10);
      let end = quantMatch[2] ? parseInt(quantMatch[2], 10) : start;
      if (!Number.isFinite(start) || start < 1) start = 1;
      if (!Number.isFinite(end) || end > 6) end = 6;
      for (let l = start; l <= end; l++) levels.add(l);
    } else {
      const hashRun = pattern.match(/#+/);
      if (hashRun) {
        const len = hashRun[0].length;
        if (len >= 1 && len <= 6) levels.add(len);
      }
    }
    return Array.from(levels);
  } catch (e) {
    return [];
  }
}
function getEntryForHeadingLevel(entries, level) {
  if (!Array.isArray(entries) || level < 1 || level > 6) return null;
  let match = null;
  let bestSpan = Infinity;
  try {
    for (const entry of entries) {
      if (!entry || !entry.pattern) continue;
      const pattern = String(entry.pattern);
      const levels = getHeadingLevelsFromPattern(pattern);
      if (Array.isArray(levels) && levels.length > 0 && levels.includes(level)) {
        const span = levels.length;
        if (span < bestSpan) {
          bestSpan = span;
          match = entry;
        }
      }
    }
    if (match) return match;
  } catch (e) {
  }
  for (const entry of entries) {
    if (!entry || !entry.pattern) continue;
    const pattern = String(entry.pattern);
    if (/#\{1,6\}/.test(pattern)) {
      return entry;
    }
  }
  return null;
}
var IS_DEVELOPMENT = true;
var debugLog = (tag, ...args) => {
};
var debugError = (tag, ...args) => {
};
var debugWarn = (tag, ...args) => {
};
var escapeHtml = (str) => {
  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
};
var GLOBAL_STYLE_KEYS = [
  "borderLineStyle",
  "borderOpacity",
  "borderThickness",
  "enableBorderThickness",
  "highlightHorizontalPadding",
  "highlightVerticalPadding",
  "backgroundOpacity",
  "highlightBorderRadius"
];
var RegexCache = class {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.map = /* @__PURE__ */ new Map();
    this.hits = 0;
    this.misses = 0;
    this.entryMap = /* @__PURE__ */ new WeakMap();
  }
  _key(pattern, flags) {
    return `${pattern}::${flags || ""}`;
  }
  getOrCreate(pattern, flags) {
    const k = this._key(pattern, flags);
    if (this.map.has(k)) {
      const r2 = this.map.get(k);
      this.map.delete(k);
      this.map.set(k, r2);
      this.hits++;
      return r2;
    }
    let r;
    try {
      if (pattern && typeof pattern === "string" && pattern.length > 1e4) {
        return null;
      }
      r = flags && flags !== "" ? new RegExp(pattern, flags) : new RegExp(pattern);
    } catch (_) {
      r = null;
    }
    this.misses++;
    if (r) {
      this.map.set(k, r);
      if (this.map.size > this.maxSize) {
        const oldestKey = this.map.keys().next().value;
        this.map.delete(oldestKey);
      }
    }
    return r;
  }
  associate(entry, regex) {
    if (entry && regex) {
      try {
        this.entryMap.set(entry, regex);
      } catch (_) {
      }
    }
  }
  clear() {
    this.map.clear();
    this.hits = 0;
    this.misses = 0;
  }
  stats() {
    return { hits: this.hits, misses: this.misses, size: this.map.size };
  }
};
var AddToExistingEntryModal = class _AddToExistingEntryModal extends FuzzySuggestModal {
  constructor(app, plugin, selectedText, view) {
    super(app);
    this.plugin = plugin;
    this._activeTab = "general";
    this.selectedText = String(selectedText || "").trim();
    this.view = view;
    this._isRightClick = false;
    this._docCtx = null;
    this._lastAddedEntryUid = null;
    this._suggestionsContainerHandlers = [];
    this._menuReferences = [];
    this.setPlaceholder(this.plugin.t("prompt_search_existing", "Search existing entries\u2026"));
  }
  onOpen() {
    try {
      const root = this.modalEl.querySelector(".prompt") || this.modalEl;
      if (root) root.classList.add("act");
      const pic = this.modalEl.querySelector(".prompt-input-container");
      if (pic) pic.classList.add("act");
      const pi = this.modalEl.querySelector(".prompt-input");
      if (pi) {
        pi.classList.add("act");
        pi.style.borderRadius = "var(--input-radius)";
      }
      const pia = this.modalEl.querySelector(".prompt-input-cta");
      if (pia) pia.classList.add("act");
      const clr = this.modalEl.querySelector(".search-input-clear-button");
      if (clr) clr.classList.add("act");
      const pr = this.modalEl.querySelector(".prompt-results");
      if (pr) pr.classList.add("act");
      try {
        const existingRow = this.modalEl.querySelector("#act-prompt-bottom-row");
        if (existingRow) existingRow.remove();
      } catch (_) {
      }
      const buttonRow = document.createElement("div");
      buttonRow.id = "act-prompt-bottom-row";
      buttonRow.classList.add("act-prompt-bottom-row");
      const limitInput = document.createElement("input");
      limitInput.type = "text";
      limitInput.value = "0";
      limitInput.placeholder = this.plugin.t("limit_input_placeholder", "limit");
      limitInput.title = this.plugin.t("limit_input_tooltip", "0=all; number=last N; sw=starts; ew=ends; e=exact");
      limitInput.classList.add("act-limit-input");
      debugLog("LIMIT", "Created limit input element");
      limitInput.addEventListener("mousedown", (e) => {
        debugLog("LIMIT", "mousedown fired");
        if (e.button === 2) {
          e.stopPropagation();
        }
      }, false);
      limitInput.addEventListener("mouseup", (e) => {
        debugLog("LIMIT", "mouseup fired");
      }, false);
      limitInput.addEventListener("click", (e) => {
        debugLog("LIMIT", "click fired, attempting focus");
        setTimeout(() => {
          limitInput.focus();
          debugLog("LIMIT", "force focused input");
        }, 0);
      }, false);
      limitInput.addEventListener("focus", (e) => {
        debugLog("LIMIT", "focus fired");
      }, false);
      limitInput.addEventListener("pointerdown", (e) => {
        debugLog("LIMIT", "pointerdown fired");
        if (e.button === 2) {
          e.stopPropagation();
        }
      }, false);
      limitInput.addEventListener("dblclick", (e) => {
        e.preventDefault();
        e.stopPropagation();
        limitInput.select();
        debugLog("LIMIT", "dblclick fired, text selected");
      }, false);
      const originalGetItems = this.getItems.bind(this);
      let allItems = [];
      this._prevAddNewEntry = this.plugin.addNewEntry;
      const originalAddNewEntry = this.plugin.addNewEntry.bind(this.plugin);
      this.plugin.addNewEntry = async function(...args) {
        const result = await originalAddNewEntry(...args);
        const we = this.settings.wordEntries || [];
        if (we.length > 0) {
          const modalThis = this;
          for (let i = 0; i < (this.openModals?.length || 0); i++) {
            const m = this.openModals[i];
            if (m instanceof _AddToExistingEntryModal) {
              m._lastAddedEntryUid = we[we.length - 1].uid;
              debugLog("LIMIT", "Tracked new entry uid in modal:", m._lastAddedEntryUid);
              break;
            }
          }
        }
        return result;
      };
      this.getItems = () => {
        debugLog("LIMIT", "getItems called");
        allItems = originalGetItems();
        const raw = String(limitInput.value || "").trim().toLowerCase();
        debugLog("LIMIT", "raw limit value:", raw, "allItems count:", allItems.length);
        if (allItems.length > 0 && raw === "sw") {
          const entry = allItems[0].entry;
          debugLog("LIMIT", "First item match props:", "match:", entry?.match, "matchMode:", entry?.matchMode, "matchType:", entry?.matchType);
        }
        if (!raw || raw === "0") {
          debugLog("LIMIT", "no filter, returning all items:", allItems.length);
          return allItems;
        }
        const parts = raw.split(/[\s,]+/).filter(Boolean);
        debugLog("LIMIT", "parsed parts:", parts);
        const numPart = parts.find((p) => /^\d+$/.test(p));
        const limit = numPart ? parseInt(numPart, 10) : 0;
        const filterTokens = parts.filter((p) => !/^\d+$/.test(p));
        const hasRegexFilter = filterTokens.includes("r");
        const hasWordFilter = filterTokens.includes("w");
        const hasHighlightFilter = filterTokens.includes("h");
        const hasColorFilter = filterTokens.includes("c");
        const hasBothFilter = filterTokens.includes("b");
        const hasStartsWith = filterTokens.includes("sw");
        const hasEndsWith = filterTokens.includes("ew");
        const hasExact = filterTokens.includes("e");
        let lastAddedItem = null;
        let filtered = allItems;
        if (this._lastAddedEntryUid) {
          const lastIndex = allItems.findIndex((item) => item.entry?.uid === this._lastAddedEntryUid);
          if (lastIndex >= 0) {
            lastAddedItem = allItems[lastIndex];
            filtered = allItems.filter((_, idx) => idx !== lastIndex);
            debugLog("LIMIT", "Separated last added entry, remaining items:", filtered.length);
          }
        }
        if (hasRegexFilter) {
          filtered = filtered.filter((item) => item.entry && item.entry.isRegex);
          debugLog("LIMIT", "regex filter: found", filtered.length, "items");
        } else if (hasWordFilter) {
          filtered = filtered.filter((item) => item.entry && !item.entry.isRegex);
          debugLog("LIMIT", "word filter: found", filtered.length, "items");
        } else if (hasHighlightFilter) {
          filtered = filtered.filter((item) => item.entry && !item.entry.isRegex && item.style === "highlight");
          debugLog("LIMIT", "highlight filter: found", filtered.length, "items");
        } else if (hasColorFilter) {
          filtered = filtered.filter((item) => item.entry && !item.entry.isRegex && item.style === "color");
          debugLog("LIMIT", "color filter: found", filtered.length, "items");
        } else if (hasBothFilter) {
          filtered = filtered.filter((item) => item.entry && !item.entry.isRegex && item.style === "both");
          debugLog("LIMIT", "both filter: found", filtered.length, "items");
        }
        if (hasStartsWith || hasEndsWith || hasExact) {
          filtered = filtered.filter((item) => {
            const match = item.entry?.match || item.entry?.matchMode || item.entry?.matchType;
            let matches = false;
            if (hasStartsWith) matches = matches || match === "startswith";
            if (hasEndsWith) matches = matches || match === "endswith";
            if (hasExact) matches = matches || match === "exact";
            return matches;
          });
          debugLog("LIMIT", "match mode filter (sw:", hasStartsWith, "ew:", hasEndsWith, "e:", hasExact, "): found", filtered.length, "items");
        }
        if (limit > 0) {
          debugLog("LIMIT", "filtering to last", limit, "items");
          filtered = filtered.slice(-limit);
        }
        if (lastAddedItem) {
          filtered = [lastAddedItem, ...filtered];
          debugLog("LIMIT", "Prepended last added entry, total items:", filtered.length);
        }
        return filtered;
      };
      limitInput.addEventListener("input", () => {
        debugLog("LIMIT", "input event fired, value:", limitInput.value);
        debugLog("LIMIT", "dispatching input event on searchbar");
        this.inputEl.dispatchEvent(new Event("input", { bubbles: true }));
      }, false);
      debugLog("LIMIT", "appending limit input to button row");
      buttonRow.appendChild(limitInput);
      const spacer = document.createElement("div");
      spacer.classList.add("act-flex-spacer");
      buttonRow.appendChild(spacer);
      const addWordBtn = document.createElement("button");
      addWordBtn.textContent = this.plugin.t("btn_add_word", "+ Add Word");
      addWordBtn.classList.add("act-modal-action-btn");
      addWordBtn.addEventListener("mousedown", (e) => {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }, true);
      addWordBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
          const selColor = color && this.plugin.isValidHexColor(color) ? color : result && result.textColor && this.plugin.isValidHexColor(result.textColor) ? result.textColor : null;
          if (!selColor) return;
          const selGroupUid = result && result.selectedGroupUid ? result.selectedGroupUid : null;
          const matchType = result && result.matchType ? result.matchType : this.plugin.settings.partialMatch ? "contains" : "exact";
          const word = this.selectedText;
          if (selGroupUid) {
            const group = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups.find((g) => g && g.uid === selGroupUid) : null;
            if (group) {
              if (!Array.isArray(group.entries)) group.entries = [];
              group.entries.push({ pattern: word, color: selColor, isRegex: false, flags: "", styleType: "text", matchType });
              await this.plugin.saveSettings();
              this.plugin.compileWordEntries();
            } else {
              await this.plugin.addNewEntry(word, selColor, false);
            }
          } else {
            await this.plugin.addNewEntry(word, selColor, false);
          }
          try {
            this.plugin.refreshEditor(this.view, true);
          } catch (_) {
          }
        }, "text", this.selectedText);
        modal.open();
      }, true);
      buttonRow.appendChild(addWordBtn);
      if (this.plugin.settings.enableRegexSupport) {
        const addRegexBtn = document.createElement("button");
        addRegexBtn.textContent = this.plugin.t("btn_add_regex_short", "+ Add Regex");
        addRegexBtn.classList.add("act-modal-action-btn");
        addRegexBtn.addEventListener("mousedown", (e) => {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }, true);
        addRegexBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          new BlacklistRegexTesterModal(this.app, this.plugin, async (pattern, flags, name) => {
            const currentLength = this.plugin.settings.wordEntries?.length || 0;
            await this.plugin.addNewEntry(pattern, "#ff0000", true, flags, name);
            const we = this.plugin.settings.wordEntries || [];
            if (we.length > currentLength) {
              this._lastAddedEntryUid = we[we.length - 1].uid;
              debugLog("LIMIT", "Set _lastAddedEntryUid for new regex entry:", this._lastAddedEntryUid);
              this.inputEl.dispatchEvent(new Event("input", { bubbles: true }));
            }
            try {
              this.plugin.refreshEditor(this.view, true);
            } catch (_) {
            }
          }).open();
        }, true);
        buttonRow.appendChild(addRegexBtn);
      }
      const pr_el = this.modalEl.querySelector(".prompt-results");
      if (pr_el && pr_el.parentNode) {
        pr_el.parentNode.insertBefore(buttonRow, pr_el.nextSibling);
      }
      let style = document.getElementById("act-suggest-modal");
      if (!style) {
        style = document.createElement("style");
        style.id = "act-suggest-modal";
        style.textContent = `
          .prompt.act .suggestion-item.mod-complex { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
          .prompt.act .suggestion-content { display: flex; align-items: center; gap: 6px; }
          .prompt.act .suggestion-title { display: inline-flex; gap: 6px; }
          .prompt.act .suggestion-title span { color: var(--text-normal); }
          .prompt.act .suggestion-aux { display: inline-flex; align-items: center; }
          .prompt.act kbd.suggestion-hotkey.act { opacity: 0.9; }
        `;
        document.head.appendChild(style);
      }
      const suggestionsContainer = this.modalEl.querySelector(".prompt-results");
      if (suggestionsContainer) {
        const setRightClickFlag = (evt) => {
          this._isRightClick = evt && evt.button === 2;
        };
        const clearRightClickFlag = () => {
          this._isRightClick = false;
        };
        const captureRightClick = (evt) => {
          if (evt.target === limitInput || limitInput.contains(evt.target)) {
            debugLog("LIMIT", "mousedown/pointerdown on limit input, skipping capture");
            return;
          }
          if (evt && evt.button === 2) {
            setRightClickFlag(evt);
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
          }
        };
        const suppressContextMenu = (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          evt.stopImmediatePropagation();
          evt.returnValue = false;
        };
        this._modalCaptureHandlers = [
          { el: this.modalEl, event: "mousedown", handler: captureRightClick, opts: true },
          { el: this.modalEl, event: "pointerdown", handler: captureRightClick, opts: true },
          { el: this.modalEl, event: "mouseup", handler: captureRightClick, opts: true },
          { el: this.modalEl, event: "contextmenu", handler: suppressContextMenu, opts: true }
        ];
        this._modalClickSuppress = (evt) => {
          if (evt.target === limitInput || limitInput.contains(evt.target)) {
            debugLog("LIMIT", "click on limit input, not suppressing");
            return;
          }
          if (evt.target === this.inputEl || this.inputEl.contains(evt.target)) {
            debugLog("LIMIT", "click on searchbar, forcing focus");
            setTimeout(() => {
              this.inputEl.focus();
              debugLog("LIMIT", "forced searchbar focus");
            }, 0);
            return;
          }
          if (this._isRightClick) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
            clearRightClickFlag();
          }
        };
        this.modalEl.addEventListener("click", this._modalClickSuppress, true);
        this._modalCaptureHandlers.forEach((h) => {
          h.el.addEventListener(h.event, h.handler, h.opts);
        });
        suggestionsContainer.addEventListener("mousedown", (evt) => {
          if (evt.target === limitInput || limitInput.contains(evt.target)) {
            debugLog("LIMIT", "mousedown on limit input in suggestionsContainer handler, skipping");
            return;
          }
          setRightClickFlag(evt);
          if (evt.button === 2) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
          }
        }, true);
        suggestionsContainer.addEventListener("pointerdown", (evt) => {
          setRightClickFlag(evt);
          if (evt.button === 2) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
          }
        }, true);
        suggestionsContainer.addEventListener("mouseup", (evt) => {
          if (evt.button === 2) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
          }
          clearRightClickFlag();
        }, true);
        suggestionsContainer.addEventListener("click", (evt) => {
          if (this._isRightClick) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
            clearRightClickFlag();
          }
        }, true);
        suggestionsContainer.addEventListener("contextmenu", (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          evt.stopImmediatePropagation();
          evt.returnValue = false;
        }, true);
      }
      this._docCtx = (evt) => {
        try {
          if (this.modalEl && this.modalEl.contains(evt.target)) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
          }
        } catch (_) {
        }
      };
      document.addEventListener("contextmenu", this._docCtx, true);
      document.addEventListener("mousedown", this._docCtx, true);
      document.addEventListener("pointerdown", this._docCtx, true);
      this._docAux = (evt) => {
        if (evt && evt.button === 2) {
          evt.preventDefault();
          evt.stopPropagation();
          evt.stopImmediatePropagation();
          evt.returnValue = false;
        }
      };
      document.addEventListener("auxclick", this._docAux, true);
      this._docRightClick = (evt) => {
        debugLog("RIGHTCLICK", "DOC-RIGHTCLICK - CONTEXTMENU FIRED!", evt.target);
        const target = evt.target;
        debugLog("RIGHTCLICK", "checking target:", { className: target.className, tagName: target.tagName });
        if (!target) return;
        let suggestionEl = target.closest('[class*="suggestion-item"]');
        if (!suggestionEl) suggestionEl = target.closest(".suggestion-item");
        if (!suggestionEl && target.classList && target.classList.contains("suggestion-item")) suggestionEl = target;
        debugLog("RIGHTCLICK", "suggestionEl found:", !!suggestionEl, { suggestionEl });
        if (suggestionEl) {
          debugLog("RIGHTCLICK", "Checking if in modal...");
          const inModal = this.modalEl && this.modalEl.contains(suggestionEl);
          debugLog("RIGHTCLICK", "inModal:", inModal);
          if (inModal) {
            debugLog("RIGHTCLICK", "*** FOUND SUGGESTION IN MODAL, SHOWING MENU ***");
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
            evt.returnValue = false;
            const items = this.getItems();
            debugLog("RIGHTCLICK", "Got items:", items.length);
            const allSuggestions = Array.from(this.modalEl.querySelectorAll('[class*="suggestion-item"]'));
            debugLog("RIGHTCLICK", "Found suggestion elements:", allSuggestions.length);
            const idx = allSuggestions.indexOf(suggestionEl);
            debugLog("RIGHTCLICK", "Item index:", idx);
            if (idx >= 0 && items[idx]) {
              debugLog("RIGHTCLICK", "Creating menu for:", items[idx].label);
              const actualItem = items[idx];
              setTimeout(() => {
                const menu = new Menu();
                debugLog("RIGHTCLICK", "Menu created");
                debugLog("RIGHTCLICK", "actualItem:", JSON.stringify(actualItem, null, 2));
                debugLog("RIGHTCLICK", "actualItem.entry.isRegex:", actualItem.entry?.isRegex);
                menu.addItem((item) => {
                  item.setTitle(this.plugin.t("edit_entry_header", "Edit Entry")).setIcon("pencil").onClick(() => {
                    debugLog("RIGHTCLICK", "Edit entry clicked");
                    this.close();
                    try {
                      this.plugin.settingTab.display();
                      const searchInput = document.querySelector('.setting-item input[placeholder*="search"], .setting-search input');
                      if (searchInput) {
                        searchInput.value = actualItem.label;
                        searchInput.dispatchEvent(new Event("input", { bubbles: true }));
                      }
                    } catch (_) {
                    }
                  });
                });
                if (actualItem.entry && actualItem.entry.isRegex) {
                  menu.addItem((item) => {
                    item.setTitle(this.plugin.t("open_in_regex_tester", "Open in Regex Tester")).setIcon("code").onClick(() => {
                      const entry2 = actualItem.entry;
                      const modal = new RealTimeRegexTesterModal(this.app, this.plugin, async (updatedEntry) => {
                      }, null);
                      modal._editingEntry = entry2;
                      modal._preFillPattern = entry2.pattern || "";
                      modal._preFillFlags = entry2.flags || "";
                      modal._preFillName = entry2.presetLabel || "";
                      modal._preFillStyleType = entry2.styleType || "both";
                      modal._preFillTextColor = (entry2.textColor && entry2.textColor !== "currentColor" ? entry2.textColor : this.plugin.isValidHexColor(entry2.color) ? entry2.color : "#87c760") || "#87c760";
                      modal._preFillBgColor = entry2.backgroundColor || "#1d5010";
                      modal._parentModal = this;
                      modal.open();
                    });
                  });
                }
                menu.addItem((item) => {
                  item.setTitle(this.plugin.t("context_delete_entry", "Delete entry")).setIcon("trash").onClick(async () => {
                    debugLog("RIGHTCLICK", "Delete entry clicked");
                    const entry2 = actualItem.entry;
                    const entryUid = entry2.uid;
                    let foundIdx = -1;
                    let foundArray = null;
                    for (let i = 0; i < this.plugin.settings.wordEntries.length; i++) {
                      if (this.plugin.settings.wordEntries[i].uid === entryUid) {
                        foundIdx = i;
                        foundArray = this.plugin.settings.wordEntries;
                        break;
                      }
                    }
                    if (foundIdx === -1) {
                      for (let i = 0; i < this.plugin.settings.textBgColoringEntries.length; i++) {
                        if (this.plugin.settings.textBgColoringEntries[i].uid === entryUid) {
                          foundIdx = i;
                          foundArray = this.plugin.settings.textBgColoringEntries;
                          break;
                        }
                      }
                    }
                    if (foundIdx >= 0 && foundArray) {
                      foundArray.splice(foundIdx, 1);
                      await this.plugin.saveSettings();
                      this.plugin.compileWordEntries();
                      this.plugin.compileTextBgColoringEntries();
                      try {
                        this.plugin.reconfigureEditorExtensions();
                      } catch (_) {
                      }
                      try {
                        this.plugin.refreshEditor(this.view, true);
                      } catch (_) {
                      }
                      this.refreshSuggestions();
                      new Notice(`Entry "${actualItem.label}" deleted`);
                    }
                  });
                });
                menu.addItem((item) => {
                  item.setTitle(this.plugin.t("duplicate_entry", "Duplicate Entry")).setIcon("copy").onClick(async () => {
                    debugLog("RIGHTCLICK", "Duplicate entry clicked");
                    try {
                      const entry2 = actualItem.entry;
                      const dup = JSON.parse(JSON.stringify(entry2));
                      const targetArray = this.plugin.settings.wordEntries.includes(entry2) ? this.plugin.settings.wordEntries : this.plugin.settings.textBgColoringEntries;
                      targetArray.push(dup);
                      await this.plugin.saveSettings();
                      this.plugin.compileWordEntries();
                      this.plugin.compileTextBgColoringEntries();
                      try {
                        this.plugin.reconfigureEditorExtensions();
                      } catch (_) {
                      }
                      try {
                        this.plugin.refreshEditor(this.view, true);
                      } catch (_) {
                      }
                      this.refreshSuggestions();
                      new Notice(this.plugin.t("notice_entry_duplicated", "Entry duplicated"));
                      this.close();
                      new _AddToExistingEntryModal(this.app, this.plugin, this.selectedText, this.view).open();
                    } catch (e) {
                      debugError("RIGHTCLICK", "duplicate entry error", e);
                    }
                  });
                });
                const entry = actualItem.entry;
                const matchesWord = () => {
                  if (entry.isRegex) return false;
                  const cmp = (a, b) => {
                    if (this.plugin.settings.caseSensitive) return String(a) === String(b);
                    return String(a).toLowerCase() === String(b).toLowerCase();
                  };
                  if (cmp(entry.pattern, this.selectedText)) return true;
                  if (Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.some((p) => cmp(p, this.selectedText))) return true;
                  return false;
                };
                if (matchesWord()) {
                  menu.addItem((item) => {
                    item.setTitle(this.plugin.t("context_remove_from_entry", 'Remove "{word}" from entry').replace("{word}", this.selectedText)).setIcon("minus").onClick(async () => {
                      debugLog("RIGHTCLICK", "Remove word clicked");
                      if (Array.isArray(entry.groupedPatterns)) {
                        entry.groupedPatterns = entry.groupedPatterns.filter((p) => {
                          const cmp = this.plugin.settings.caseSensitive ? String(p) === String(this.selectedText) : String(p).toLowerCase() === String(this.selectedText).toLowerCase();
                          return !cmp;
                        });
                      } else {
                        entry.pattern = "";
                      }
                      await this.plugin.saveSettings();
                      this.plugin.compileWordEntries();
                      this.plugin.compileTextBgColoringEntries();
                      try {
                        this.plugin.reconfigureEditorExtensions();
                      } catch (_) {
                      }
                      try {
                        this.plugin.refreshEditor(this.view, true);
                      } catch (_) {
                      }
                      this.refreshSuggestions();
                      new Notice(`"${this.selectedText}" removed from entry`);
                    });
                  });
                }
                debugLog("RIGHTCLICK", "Showing menu");
                menu.showAtMouseEvent(evt);
                menu.dom.classList.add("act-menu-elevated");
              }, 0);
            }
          }
        }
      };
      debugLog("ATTACH", "Attaching modalEl contextmenu listener for right-click");
      if (this.modalEl) {
        this.modalEl.addEventListener("contextmenu", this._docRightClick, true);
      }
      setTimeout(() => {
        try {
          this.updateSuggestions();
        } catch (_) {
        }
      }, 100);
    } catch (_) {
    }
  }
  onClose() {
    try {
      if (this._docCtx) {
        document.removeEventListener("contextmenu", this._docCtx, true);
        document.removeEventListener("mousedown", this._docCtx, true);
        document.removeEventListener("pointerdown", this._docCtx, true);
        this._docCtx = null;
      }
      if (this._docAux) {
        document.removeEventListener("auxclick", this._docAux, true);
        this._docAux = null;
      }
      if (this._docRightClick && this.modalEl) {
        this.modalEl.removeEventListener("contextmenu", this._docRightClick, true);
        this._docRightClick = null;
      }
      try {
        const existingRow = this.modalEl && this.modalEl.querySelector ? this.modalEl.querySelector("#act-prompt-bottom-row") : null;
        if (existingRow) existingRow.remove();
      } catch (_) {
      }
      try {
        if (this._prevAddNewEntry) {
          this.plugin.addNewEntry = this._prevAddNewEntry;
          this._prevAddNewEntry = null;
        }
      } catch (_) {
      }
      if (this._modalCaptureHandlers && Array.isArray(this._modalCaptureHandlers)) {
        this._modalCaptureHandlers.forEach((h) => {
          try {
            h.el && h.el.removeEventListener && h.el.removeEventListener(h.event, h.handler, h.opts);
          } catch (_) {
          }
        });
        this._modalCaptureHandlers = [];
      }
      if (this._modalClickSuppress && this.modalEl) {
        this.modalEl.removeEventListener("click", this._modalClickSuppress, true);
        this._modalClickSuppress = null;
      }
      if (this._suggestionsContainerHandlers && Array.isArray(this._suggestionsContainerHandlers)) {
        this._suggestionsContainerHandlers.forEach((h) => {
          try {
            h.el && h.el.removeEventListener && h.el.removeEventListener(h.event, h.handler, h.opts);
          } catch (_) {
          }
        });
        this._suggestionsContainerHandlers = [];
      }
      if (this._menuReferences && Array.isArray(this._menuReferences)) {
        this._menuReferences.forEach((menu) => {
          try {
            menu && menu.dom && menu.dom.remove && menu.dom.remove();
          } catch (_) {
          }
        });
        this._menuReferences = [];
      }
    } catch (_) {
    }
    this._isRightClick = false;
  }
  getItems() {
    const we = Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries : [];
    const items = [];
    const lastUid = this._lastAddedEntryUid;
    for (const e of we) {
      if (!e) continue;
      if (!e.uid) {
        try {
          e.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
        } catch (_) {
          e.uid = Date.now();
        }
      }
      let label = "";
      if (e.isRegex) {
        const patRaw = String(e.pattern || "");
        const patTrim = patRaw.trim();
        if (!patTrim) {
          if (e.uid !== lastUid) continue;
          label = e.presetLabel ? String(e.presetLabel) : "[new regex]";
        } else {
          const name = e.presetLabel ? String(e.presetLabel) : "regex";
          label = `${name}: ${patTrim}`;
        }
      } else {
        const patsArr = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "").trim()];
        const pats = patsArr.map((x) => String(x || "").trim()).filter((x) => x.length > 0);
        if (pats.length === 0) {
          if (e.uid !== lastUid) continue;
          label = "[new entry]";
        } else {
          label = pats.join(", ");
        }
      }
      label = String(label || "").trim();
      if (!label) continue;
      let st = "color";
      if (e.styleType === "text") st = "color";
      else if (e.styleType === "highlight") st = "highlight";
      else if (e.styleType === "both") st = "both";
      else {
        const hasBg = !!e.backgroundColor;
        const hasText = !!e.color && String(e.color).trim() !== "" || !!e.textColor && e.textColor && e.textColor !== "currentColor";
        st = hasBg && hasText ? "both" : hasBg ? "highlight" : "color";
      }
      items.push({ entry: e, label, style: st });
    }
    items.sort((a, b) => String(a.label).toLowerCase().localeCompare(String(b.label).toLowerCase()));
    return items;
  }
  getItemText(item) {
    return String(item.label || "");
  }
  refreshSuggestions() {
    try {
      const currentItems = this.getItems();
      this._updateSuggestions(currentItems);
    } catch (e) {
      debugLog("REFRESH", "Error refreshing suggestions:", e);
    }
  }
  renderSuggestion(item, el) {
    const actualItem = item.item || item;
    try {
      el.empty();
    } catch (_) {
      el.textContent = "";
    }
    try {
      el.classList.add("mod-complex");
    } catch (_) {
    }
    try {
      el.classList.add("act");
    } catch (_) {
    }
    const content = el.createDiv({ cls: "suggestion-content act" });
    const title = content.createDiv({ cls: "suggestion-title act" });
    title.createEl("span", { text: actualItem.label });
    const aux = el.createDiv({ cls: "suggestion-aux act" });
    const textMap = { color: "color", highlight: "highlight", both: "both" };
    const k = aux.createEl("kbd", { text: textMap[actualItem.style] || "color" });
    try {
      k.classList.add("suggestion-hotkey");
    } catch (_) {
    }
    try {
      k.classList.add("act");
    } catch (_) {
    }
    el.addEventListener("mousedown", (evt) => {
      if (evt.button === 2) {
        evt.stopPropagation();
        evt.stopImmediatePropagation();
        this._isRightClick = true;
      }
    });
    el.addEventListener("pointerdown", (evt) => {
      if (evt.button === 2) {
        debugLog("ELEMENT", "pointerdown with button 2 detected");
        evt.stopPropagation();
        evt.stopImmediatePropagation();
        this._isRightClick = true;
      }
    });
    el.addEventListener("mouseup", (evt) => {
      if (evt.button === 2) {
        evt.stopPropagation();
        evt.stopImmediatePropagation();
        this._isRightClick = false;
      }
    });
    el.addEventListener("click", (evt) => {
      if (this._isRightClick) {
        evt.preventDefault();
        evt.stopPropagation();
        evt.stopImmediatePropagation();
        this._isRightClick = false;
      }
    });
    el.addEventListener("contextmenu", (evt) => {
      debugLog("ELEMENT", "RENDER-CONTEXTMENU EVENT FIRED");
      debugLog("ELEMENT", "contextmenu event fired on element");
      evt.preventDefault();
      evt.stopPropagation();
      evt.stopImmediatePropagation();
      debugLog("ELEMENT", "showing menu for:", actualItem.label);
      debugLog("ELEMENT", "actualItem:", JSON.stringify(actualItem, null, 2));
      debugLog("ELEMENT", "actualItem.entry.isRegex:", actualItem.entry?.isRegex);
      const menu = new Menu();
      menu.addItem((item2) => {
        item2.setTitle(this.plugin.t("edit_entry_header", "Edit Entry")).setIcon("pencil").onClick(() => {
          let entry2 = actualItem.entry;
          if (entry2 && !entry2.uid) {
            try {
              entry2.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
            } catch (_) {
              entry2.uid = Date.now();
            }
          }
          if (entry2 && entry2.uid) {
            let reloadedEntry = this.plugin.settings.wordEntries.find((e) => e && e.uid === entry2.uid) || this.plugin.settings.textBgColoringEntries.find((e) => e && e.uid === entry2.uid);
            if (!reloadedEntry && Array.isArray(this.plugin.settings.wordEntryGroups)) {
              for (const group of this.plugin.settings.wordEntryGroups) {
                if (Array.isArray(group.entries)) {
                  reloadedEntry = group.entries.find((e) => e && e.uid === entry2.uid);
                  if (reloadedEntry) break;
                }
              }
            }
            if (reloadedEntry) {
              entry2 = reloadedEntry;
              debugLog("EDIT_ENTRY", `Reloaded entry ${entry2.uid}: opacity=${entry2.backgroundOpacity}, radius=${entry2.highlightBorderRadius}`);
            }
          }
          const modal = new EditEntryModal(this.app, this.plugin, entry2, null, this);
          modal.open();
        });
      });
      if (actualItem.entry && actualItem.entry.isRegex) {
        menu.addItem((item2) => {
          item2.setTitle(this.plugin.t("open_in_regex_tester", "Open in Regex Tester")).setIcon("code").onClick(() => {
            const entry2 = actualItem.entry;
            const modal = new RealTimeRegexTesterModal(this.app, this.plugin, async (updatedEntry) => {
            }, null);
            modal._editingEntry = entry2;
            modal._preFillPattern = entry2.pattern || "";
            modal._preFillFlags = entry2.flags || "";
            modal._preFillName = entry2.presetLabel || "";
            modal._preFillStyleType = entry2.styleType || "both";
            modal._preFillTextColor = (entry2.textColor && entry2.textColor !== "currentColor" ? entry2.textColor : this.plugin.isValidHexColor(entry2.color) ? entry2.color : "#87c760") || "#87c760";
            modal._preFillBgColor = entry2.backgroundColor || "#1d5010";
            modal._parentModal = this;
            modal.open();
          });
        });
      }
      menu.addItem((item2) => {
        item2.setTitle(this.plugin.t("context_delete_entry", "Delete entry")).setIcon("trash").onClick(async () => {
          const entry2 = actualItem.entry;
          const entryUid = entry2.uid;
          let foundIdx = -1;
          let foundArray = null;
          for (let i = 0; i < this.plugin.settings.wordEntries.length; i++) {
            if (this.plugin.settings.wordEntries[i].uid === entryUid) {
              foundIdx = i;
              foundArray = this.plugin.settings.wordEntries;
              break;
            }
          }
          if (foundIdx === -1) {
            for (let i = 0; i < this.plugin.settings.textBgColoringEntries.length; i++) {
              if (this.plugin.settings.textBgColoringEntries[i].uid === entryUid) {
                foundIdx = i;
                foundArray = this.plugin.settings.textBgColoringEntries;
                break;
              }
            }
          }
          if (foundIdx >= 0 && foundArray) {
            foundArray.splice(foundIdx, 1);
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            try {
              this.plugin.reconfigureEditorExtensions();
            } catch (_) {
            }
            try {
              this.plugin.refreshEditor(this.view, true);
            } catch (_) {
            }
            new Notice(`Entry "${actualItem.label}" deleted`);
            this.close();
          }
        });
      });
      const entry = actualItem.entry;
      const matchesWord = () => {
        if (entry.isRegex) return false;
        const cmp = (a, b) => {
          if (this.plugin.settings.caseSensitive) return String(a) === String(b);
          return String(a).toLowerCase() === String(b).toLowerCase();
        };
        if (cmp(entry.pattern, this.selectedText)) return true;
        if (Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.some((p) => cmp(p, this.selectedText))) return true;
        return false;
      };
      if (matchesWord()) {
        menu.addItem((item2) => {
          item2.setTitle(this.plugin.t("context_remove_from_entry", 'Remove "{word}" from entry').replace("{word}", this.selectedText)).setIcon("minus").onClick(async () => {
            if (Array.isArray(entry.groupedPatterns)) {
              entry.groupedPatterns = entry.groupedPatterns.filter((p) => {
                const cmp = this.plugin.settings.caseSensitive ? String(p) === String(this.selectedText) : String(p).toLowerCase() === String(this.selectedText).toLowerCase();
                return !cmp;
              });
            } else {
              entry.pattern = "";
            }
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            try {
              this.plugin.reconfigureEditorExtensions();
            } catch (_) {
            }
            try {
              this.plugin.refreshEditor(this.view, true);
            } catch (_) {
            }
            new Notice(`"${this.selectedText}" removed from entry`);
            this.close();
          });
        });
      }
      const existingMenus = document.querySelectorAll(".menu");
      existingMenus.forEach((m) => {
        if (m !== menu.dom) m.remove();
      });
      menu.showAtMouseEvent(evt);
      menu.dom.classList.add("act-menu-elevated");
      const closeMenu = (e) => {
        if (!menu.dom.contains(e.target) && e.target !== el) {
          menu.dom.remove();
          document.removeEventListener("click", closeMenu);
        }
      };
      setTimeout(() => {
        document.addEventListener("click", closeMenu);
      }, 100);
    }, true);
    el.addEventListener("pointerup", (evt) => {
      if (evt.button === 2) {
        debugLog("ELEMENT", "pointerup with button 2 - contextmenu fallback");
        debugLog("ELEMENT", "actualItem in pointerup:", JSON.stringify(actualItem, null, 2));
        debugLog("ELEMENT", "actualItem.entry.isRegex in pointerup:", actualItem.entry?.isRegex);
        evt.preventDefault();
        evt.stopPropagation();
        evt.stopImmediatePropagation();
        const menu = new Menu();
        menu.addItem((item2) => {
          item2.setTitle(this.plugin.t("edit_entry_header", "Edit Entry")).setIcon("pencil").onClick(() => {
            let entry2 = actualItem.entry;
            if (entry2 && !entry2.uid) {
              try {
                entry2.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
              } catch (_) {
                entry2.uid = Date.now();
              }
            }
            if (entry2 && entry2.uid) {
              let reloadedEntry = this.plugin.settings.wordEntries.find((e) => e && e.uid === entry2.uid) || this.plugin.settings.textBgColoringEntries.find((e) => e && e.uid === entry2.uid);
              if (!reloadedEntry && Array.isArray(this.plugin.settings.wordEntryGroups)) {
                for (const group of this.plugin.settings.wordEntryGroups) {
                  if (Array.isArray(group.entries)) {
                    reloadedEntry = group.entries.find((e) => e && e.uid === entry2.uid);
                    if (reloadedEntry) break;
                  }
                }
              }
              if (reloadedEntry) {
                entry2 = reloadedEntry;
              }
            }
            const modal = new EditEntryModal(this.app, this.plugin, entry2, null, this);
            modal.open();
          });
        });
        if (actualItem.entry && actualItem.entry.isRegex) {
          menu.addItem((item2) => {
            item2.setTitle(this.plugin.t("open_in_regex_tester", "Open in Regex Tester")).setIcon("code").onClick(() => {
              const entry2 = actualItem.entry;
              const modal = new RealTimeRegexTesterModal(this.app, this.plugin, async (updatedEntry) => {
              }, null);
              modal._editingEntry = entry2;
              modal._preFillPattern = entry2.pattern || "";
              modal._preFillFlags = entry2.flags || "";
              modal._preFillName = entry2.presetLabel || "";
              modal._preFillStyleType = entry2.styleType || "both";
              modal._preFillTextColor = (entry2.textColor && entry2.textColor !== "currentColor" ? entry2.textColor : this.plugin.isValidHexColor(entry2.color) ? entry2.color : "#87c760") || "#87c760";
              modal._preFillBgColor = entry2.backgroundColor || "#1d5010";
              modal._parentModal = this;
              modal.open();
            });
          });
        }
        menu.addItem((item2) => {
          item2.setTitle(this.plugin.t("context_delete_entry", "Delete entry")).setIcon("trash").onClick(async () => {
            const entry2 = actualItem.entry;
            const entryUid = entry2.uid;
            let foundIdx = -1;
            let foundArray = null;
            for (let i = 0; i < this.plugin.settings.wordEntries.length; i++) {
              if (this.plugin.settings.wordEntries[i].uid === entryUid) {
                foundIdx = i;
                foundArray = this.plugin.settings.wordEntries;
                break;
              }
            }
            if (foundIdx === -1) {
              for (let i = 0; i < this.plugin.settings.textBgColoringEntries.length; i++) {
                if (this.plugin.settings.textBgColoringEntries[i].uid === entryUid) {
                  foundIdx = i;
                  foundArray = this.plugin.settings.textBgColoringEntries;
                  break;
                }
              }
            }
            if (foundIdx >= 0 && foundArray) {
              foundArray.splice(foundIdx, 1);
              await this.plugin.saveSettings();
              this.plugin.compileWordEntries();
              this.plugin.compileTextBgColoringEntries();
              try {
                this.plugin.reconfigureEditorExtensions();
              } catch (_) {
              }
              try {
                this.plugin.refreshEditor(this.view, true);
              } catch (_) {
              }
              new Notice(`Entry "${actualItem.label}" deleted`);
              this.close();
              new _AddToExistingEntryModal(this.app, this.plugin, this.selectedText, this.view).open();
            }
          });
        });
        menu.addItem((item2) => {
          item2.setTitle(this.plugin.t("duplicate_entry", "Duplicate Entry")).setIcon("copy").onClick(async () => {
            try {
              const entry2 = actualItem.entry;
              const dup = JSON.parse(JSON.stringify(entry2));
              const targetArray = this.plugin.settings.wordEntries.includes(entry2) ? this.plugin.settings.wordEntries : this.plugin.settings.textBgColoringEntries;
              targetArray.push(dup);
              await this.plugin.saveSettings();
              this.plugin.compileWordEntries();
              this.plugin.compileTextBgColoringEntries();
              try {
                this.plugin.reconfigureEditorExtensions();
              } catch (_) {
              }
              try {
                this.plugin.refreshEditor(this.view, true);
              } catch (_) {
              }
              this.refreshSuggestions();
              new Notice(this.plugin.t("notice_entry_duplicated", "Entry duplicated"));
              this.close();
              new _AddToExistingEntryModal(this.app, this.plugin, this.selectedText, this.view).open();
            } catch (e) {
              debugError("RIGHTCLICK", "duplicate entry error", e);
            }
          });
        });
        const entry = actualItem.entry;
        const matchesWord = () => {
          if (entry.isRegex) return false;
          const cmp = (a, b) => {
            if (this.plugin.settings.caseSensitive) return String(a) === String(b);
            return String(a).toLowerCase() === String(b).toLowerCase();
          };
          if (cmp(entry.pattern, this.selectedText)) return true;
          if (Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.some((p) => cmp(p, this.selectedText))) return true;
          return false;
        };
        if (matchesWord()) {
          menu.addItem((item2) => {
            item2.setTitle(this.plugin.t("context_remove_from_entry", 'Remove "{word}" from entry').replace("{word}", this.selectedText)).setIcon("minus").onClick(async () => {
              if (Array.isArray(entry.groupedPatterns)) {
                entry.groupedPatterns = entry.groupedPatterns.filter((p) => {
                  const cmp = this.plugin.settings.caseSensitive ? String(p) === String(this.selectedText) : String(p).toLowerCase() === String(this.selectedText).toLowerCase();
                  return !cmp;
                });
              } else {
                entry.pattern = "";
              }
              await this.plugin.saveSettings();
              this.plugin.compileWordEntries();
              this.plugin.compileTextBgColoringEntries();
              try {
                this.plugin.reconfigureEditorExtensions();
              } catch (_) {
              }
              try {
                this.plugin.refreshEditor(this.view, true);
              } catch (_) {
              }
              this.refreshSuggestions();
              new Notice(`"${this.selectedText}" removed from entry`);
            });
          });
        }
        const existingMenus = document.querySelectorAll(".menu");
        existingMenus.forEach((m) => {
          if (m !== menu.dom) m.remove();
        });
        menu.showAtMouseEvent(evt);
        menu.dom.classList.add("act-menu-elevated");
        const closeMenu = (e) => {
          if (!menu.dom.contains(e.target) && e.target !== el) {
            menu.dom.remove();
            document.removeEventListener("click", closeMenu);
          }
        };
        setTimeout(() => {
          document.addEventListener("click", closeMenu);
        }, 100);
      }
    });
  }
  onChooseItem(item, evt) {
    if (evt && evt.button === 2) return;
    const actualItem = item.item || item;
    const e = actualItem.entry;
    const s = this.selectedText;
    if (!s) return;
    const cmp = (a, b) => {
      if (this.plugin.settings.caseSensitive) return String(a) === String(b);
      return String(a).toLowerCase() === String(b).toLowerCase();
    };
    const has = (arr, val) => Array.isArray(arr) && arr.some((p) => cmp(p, val));
    if (e.isRegex && this.plugin.settings.enableRegexSupport) {
      try {
        const pattern = String(e.pattern || "");
        const flags = String(e.flags || "");
        const regexStructure = /^\\b\((.+?)\)\\w\*\\b$/;
        let m = pattern.match(regexStructure);
        if (m) {
          const core = m[1];
          const parts = core.split("|").map((x) => x.trim()).filter((x) => x.length > 0);
          const caseInsensitive = flags.includes("i") || !this.plugin.settings.caseSensitive;
          const containsWord = parts.some((p) => caseInsensitive ? p.toLowerCase() === s.toLowerCase() : p === s);
          if (containsWord) {
            new Notice(this.plugin.t("notice_already_in_entry", `"${s}" already exists in entry`, { word: s }));
            return;
          }
          const esc = this.plugin.helpers && this.plugin.helpers.escapeRegex ? this.plugin.helpers.escapeRegex(s) : s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const newCore = core + "|" + esc;
          const newPattern = `\\b(${newCore})\\w*\\b`;
          e.pattern = newPattern;
          e.groupedPatterns = null;
          (async () => {
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            try {
              this.plugin.reconfigureEditorExtensions();
            } catch (_) {
            }
            try {
              this.plugin.refreshEditor(this.view, true);
            } catch (_) {
            }
            new Notice(this.plugin.t("notice_added_to_existing", `"${s}" added to existing entry`, { word: s }));
          })();
          return;
        }
        const singleWordStructure = /^\\b([^\\|()]+)\\w\*\\b$/;
        m = pattern.match(singleWordStructure);
        if (m) {
          const word = m[1];
          const caseInsensitive = flags.includes("i") || !this.plugin.settings.caseSensitive;
          const cmp2 = caseInsensitive ? word.toLowerCase() === s.toLowerCase() : word === s;
          if (cmp2) {
            new Notice(this.plugin.t("notice_already_in_entry", `"${s}" already exists in entry`, { word: s }));
            return;
          }
          const esc = this.plugin.helpers && this.plugin.helpers.escapeRegex ? this.plugin.helpers.escapeRegex(s) : s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const newPattern = `\\b(${word}|${esc})\\w*\\b`;
          e.pattern = newPattern;
          e.groupedPatterns = null;
          (async () => {
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            try {
              this.plugin.reconfigureEditorExtensions();
            } catch (_) {
            }
            try {
              this.plugin.refreshEditor(this.view, true);
            } catch (_) {
            }
            new Notice(this.plugin.t("notice_added_to_existing", `"${s}" added to existing entry`, { word: s }));
          })();
          return;
        }
        if (pattern.includes("|")) {
          const esc = this.plugin.helpers && this.plugin.helpers.escapeRegex ? this.plugin.helpers.escapeRegex(s) : s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const newPattern = pattern + "|" + esc;
          e.pattern = newPattern;
          e.groupedPatterns = null;
          (async () => {
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            try {
              this.plugin.reconfigureEditorExtensions();
            } catch (_) {
            }
            try {
              this.plugin.refreshEditor(this.view, true);
            } catch (_) {
            }
            new Notice(this.plugin.t("notice_added_to_existing", `"${s}" added to existing entry`, { word: s }));
          })();
          return;
        }
      } catch (_) {
      }
    }
    if (cmp(e.pattern || "", s) || has(e.groupedPatterns, s)) {
      new Notice(this.plugin.t("notice_already_in_entry", `"${s}" already exists in entry`, { word: s }));
      return;
    }
    if (!Array.isArray(e.groupedPatterns) || e.groupedPatterns.length === 0) {
      e.groupedPatterns = [String(e.pattern || "").trim(), s];
    } else {
      e.groupedPatterns.push(s);
    }
    (async () => {
      await this.plugin.saveSettings();
      this.plugin.compileWordEntries();
      this.plugin.compileTextBgColoringEntries();
      try {
        this.plugin.reconfigureEditorExtensions();
      } catch (_) {
      }
      try {
        this.plugin.refreshEditor(this.view, true);
      } catch (_) {
      }
      new Notice(this.plugin.t("notice_added_to_existing", `"${s}" added to existing entry`, { word: s }));
    })();
  }
};
var BloomFilter = class {
  constructor(size = 2048) {
    this.size = size;
    this.bits = new Uint8Array(size);
    this._singleChars = "";
  }
  reset() {
    this.bits.fill(0);
    this._singleChars = "";
  }
  _hashes(s) {
    let h1 = 0, h2 = 0, h3 = 0;
    for (let i = 0; i < s.length; i++) {
      const c = s.charCodeAt(i);
      h1 = (h1 << 5) - h1 + c >>> 0;
      h2 = (h2 << 7 ^ c) >>> 0;
      h3 = h3 * 33 + c >>> 0;
    }
    return [h1 % this.size, h2 % this.size, h3 % this.size];
  }
  _setToken(token) {
    const idx = this._hashes(token);
    for (const i of idx) this.bits[i] = 1;
  }
  addPattern(pattern, isRegex) {
    if (!pattern) return;
    const p = String(pattern).toLowerCase();
    let base = p;
    if (isRegex) {
      const m = p.match(/[a-z0-9\u4e00-\u9fa5]{1,}/i);
      base = m ? m[0].toLowerCase() : "";
    }
    if (!base) return;
    if (base.length === 1) {
      if (!this._singleChars.includes(base)) {
        this._singleChars += base;
      }
      return;
    }
    if (base.length < 3) {
      this._setToken(base);
    } else {
      for (let i = 0; i <= base.length - 3; i++) {
        const tok = base.slice(i, i + 3);
        this._setToken(tok);
      }
    }
  }
  mightContain(text) {
    if (!text) return false;
    const t = String(text).toLowerCase();
    if (this._singleChars) {
      for (let i = 0; i < this._singleChars.length; i++) {
        if (t.includes(this._singleChars[i])) {
          return true;
        }
      }
    }
    const L = t.length;
    if (L < 2) return true;
    for (let i = 0; i < L; i++) {
      if (i <= L - 3) {
        const tok3 = t.slice(i, i + 3);
        const [a3, b3, c3] = this._hashes(tok3);
        if (this.bits[a3] && this.bits[b3] && this.bits[c3]) return true;
      }
      if (i <= L - 2) {
        const tok2 = t.slice(i, i + 2);
        const [a2, b2, c2] = this._hashes(tok2);
        if (this.bits[a2] && this.bits[b2] && this.bits[c2]) return true;
      }
    }
    return false;
  }
};
var PatternMatcher = class {
  constructor(settings, helpers) {
    this.settings = settings || {};
    this.helpers = helpers || {};
    this.counters = { regexExecs: 0, matchesFound: 0 };
  }
  compilePattern(entry, cache) {
    if (!entry || !entry.pattern) return entry;
    const isRegex = !!entry.isRegex;
    const rawFlags = String(entry.flags || "").replace(/[^gimsuy]/g, "");
    let flags = rawFlags || "";
    if (!flags.includes("g")) flags += "g";
    const effectiveCS = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
    if (!effectiveCS && !flags.includes("i")) flags += "i";
    try {
      if (isRegex && this.settings.enableRegexSupport) {
        entry.regex = cache ? cache.getOrCreate(entry.pattern, flags) : this._createRegexSafe(entry.pattern, flags);
        const tf = flags.replace(/g/g, "");
        entry.testRegex = cache ? cache.getOrCreate(entry.pattern, tf) : tf === "" ? this._createRegexSafe(entry.pattern, "") : this._createRegexSafe(entry.pattern, tf);
      } else {
        const esc = this.helpers.escapeRegex ? this.helpers.escapeRegex(entry.pattern) : entry.pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const lf = effectiveCS ? "g" : "gi";
        entry.regex = cache ? cache.getOrCreate(esc, lf) : this._createRegexSafe(esc, lf);
        entry.testRegex = effectiveCS ? cache ? cache.getOrCreate(esc, "") : this._createRegexSafe(esc, "") : cache ? cache.getOrCreate(esc, "i") : this._createRegexSafe(esc, "i");
      }
    } catch (_) {
      entry.invalid = true;
    }
    return entry;
  }
  _createRegexSafe(pattern, flags) {
    try {
      return new RegExp(pattern, flags);
    } catch (_) {
      return null;
    }
  }
  isWordCharacter(char) {
    return /[A-Za-z0-9]/.test(char) || char === "-" || char === "'";
  }
  extractFullWordAtPosition(text, start, end) {
    let wordStart = start;
    let wordEnd = end;
    while (wordStart > 0 && this.isWordCharacter(text[wordStart - 1])) {
      wordStart--;
    }
    while (wordEnd < text.length && this.isWordCharacter(text[wordEnd])) {
      wordEnd++;
    }
    return text.substring(wordStart, wordEnd);
  }
  matchSatisfiesType(text, start, end, entry) {
    const matchType = String(entry?.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
    const pattern = entry?.pattern || "";
    const isSentence = this.helpers.isSentenceLikePattern ? this.helpers.isSentenceLikePattern(pattern) : /[\s,\.;:!\?"'\(\)\[\]\{\}<>]/.test(pattern || "");
    const cs = typeof entry?._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry?.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
    if (isSentence) {
      return true;
    }
    const fullWord = pattern && pattern.length <= 2 ? text.substring(start, end) : this.extractFullWordAtPosition(text, start, end);
    switch (matchType) {
      case "exact":
        const exactMatch = cs ? fullWord === pattern : fullWord.toLowerCase() === pattern.toLowerCase();
        return exactMatch;
      case "contains":
        const containsMatch = cs ? fullWord.includes(pattern) : fullWord.toLowerCase().includes(pattern.toLowerCase());
        return containsMatch;
      case "startswith":
        try {
          const flags = cs ? "" : "i";
          const esc = this.helpers.escapeRegex ? this.helpers.escapeRegex(pattern) : pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const re = new RegExp(`^${esc}[A-Za-z]*$`, flags);
          return re.test(fullWord);
        } catch (_) {
          const startsWithMatch = cs ? fullWord.startsWith(pattern) : fullWord.toLowerCase().startsWith(pattern.toLowerCase());
          return startsWithMatch;
        }
      case "endswith":
        try {
          const flags = cs ? "" : "i";
          const esc = this.helpers.escapeRegex ? this.helpers.escapeRegex(pattern) : pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const re = new RegExp(`${esc}(?:[^A-Za-z0-9_]|$)`, flags);
          return re.test(fullWord);
        } catch (_) {
          const endsWithMatch = cs ? fullWord.endsWith(pattern) : fullWord.toLowerCase().endsWith(pattern.toLowerCase());
          return endsWithMatch;
        }
      default:
        return true;
    }
  }
  match(text, entries, folderEntry) {
    const out = [];
    const isSentence = (p) => this.helpers.isSentenceLikePattern ? this.helpers.isSentenceLikePattern(p) : /[\s,\.;:!\?"'\(\)\[\]\{\}<>]/.test(p || "");
    const wholeWord = (t, s, e) => {
      const lc = s > 0 ? t[s - 1] : "";
      const rc = e < t.length ? t[e] : "";
      const isW = (ch) => /[A-Za-z0-9]/.test(ch) || ch === "-" || ch === "'";
      return (s === 0 || !isW(lc)) && (e === t.length || !isW(rc));
    };
    for (const entry of entries) {
      if (!entry || entry.invalid) continue;
      try {
        if (entry.fastTest && typeof entry.fastTest === "function") {
          if (!entry.fastTest(text)) continue;
        }
      } catch (_) {
      }
      const regex = entry.regex;
      if (!regex) continue;
      const matches = this.helpers.safeMatchLoop ? this.helpers.safeMatchLoop(regex, text) : (text.match(regex) || []).map((m) => ({ 0: m, index: text.indexOf(m) }));
      let iters = 0;
      for (const m of matches) {
        const matchedText = m[0];
        const ms = m.index;
        const me = m.index + matchedText.length;
        if (!this.matchSatisfiesType(text, ms, me, entry)) {
          iters++;
          continue;
        }
        let fws = ms;
        let fwe = me;
        if (!isSentence(entry.pattern)) {
          while (fws > 0 && (/[A-Za-z0-9]/.test(text[fws - 1]) || text[fws - 1] === "-" || text[fws - 1] === "'")) fws--;
          while (fwe < text.length && (/[A-Za-z0-9]/.test(text[fwe]) || text[fwe] === "-" || text[fwe] === "'")) fwe++;
        }
        const mtLower = String(entry && entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
        const useExpanded = !isSentence(entry.pattern) && (mtLower === "contains" || mtLower === "startswith" || mtLower === "endswith");
        const useStart = useExpanded ? fws : ms;
        const useEnd = useExpanded ? fwe : me;
        const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
        const priority = me - ms + (entry.isTextBg ? -10 : 0);
        if (entry.pattern === "hello") {
          debugLog("[MATCH_CREATE]", `Pattern: hello, has bgOpacity=${typeof entry.backgroundOpacity}, value=${entry.backgroundOpacity}, textColor=${entry.textColor}, bgColor=${entry.backgroundColor}`);
        }
        out.push({
          start: useStart,
          end: useEnd,
          color: useColor,
          word: matchedText,
          styleType: entry.styleType,
          textColor: entry.textColor,
          backgroundColor: entry.backgroundColor,
          isTextBg: entry.isTextBg === true,
          priority,
          entryRef: entry,
          // Copy custom styling properties directly to match object for rendering
          backgroundOpacity: entry.backgroundOpacity,
          highlightBorderRadius: entry.highlightBorderRadius,
          highlightHorizontalPadding: entry.highlightHorizontalPadding,
          highlightVerticalPadding: entry.highlightVerticalPadding,
          enableBorderThickness: entry.enableBorderThickness,
          borderStyle: entry.borderStyle,
          borderLineStyle: entry.borderLineStyle,
          borderOpacity: entry.borderOpacity,
          borderThickness: entry.borderThickness
        });
        iters++;
      }
      if (iters > 0) {
        this.counters.regexExecs += iters;
        this.counters.matchesFound += out.length;
      }
    }
    if (out.length > 1) {
      out.sort((a, b) => {
        const la = a.end - a.start;
        const lb = b.end - b.start;
        if (la !== lb) return lb - la;
        const ar = a.entryRef && !!a.entryRef.isRegex;
        const br = b.entryRef && !!b.entryRef.isRegex;
        if (ar !== br) return ar ? 1 : -1;
        if (a.start !== b.start) return a.start - b.start;
        return (b.priority || 0) - (a.priority || 0);
      });
      const no = [];
      for (const m of out) {
        let ov = false;
        for (const s of no) {
          if (m.start < s.end && m.end > s.start) {
            ov = true;
            break;
          }
        }
        if (!ov) no.push(m);
      }
      return no;
    }
    return out;
  }
};
var SettingsIndex = class {
  constructor(settings) {
    this.settings = settings || {};
    this.firstChar = /* @__PURE__ */ new Map();
    this.lengthRanges = /* @__PURE__ */ new Map();
    this.regexPrefixes = /* @__PURE__ */ new Map();
  }
  rebuild(entries) {
    this.firstChar.clear();
    this.lengthRanges.clear();
    this.regexPrefixes.clear();
    for (const e of entries || []) {
      if (!e || e.invalid || !e.pattern) continue;
      const p = String(e.pattern);
      if (!e.isRegex) {
        const d = p[0] || "";
        const bucket = this.firstChar.get(d) || [];
        bucket.push(e);
        this.firstChar.set(d, bucket);
        const len = p.length;
        const rangeKey = len < 5 ? "lt5" : len < 10 ? "lt10" : len < 20 ? "lt20" : "ge20";
        const lr = this.lengthRanges.get(rangeKey) || [];
        lr.push(e);
        this.lengthRanges.set(rangeKey, lr);
      } else {
        const m = p.match(/[A-Za-z0-9]{3,}/);
        if (m) {
          const pref = m[0][0];
          const list = this.regexPrefixes.get(pref) || [];
          list.push(e);
          this.regexPrefixes.set(pref, list);
        }
      }
    }
  }
  query(text) {
    if (!text) return [];
    const t = String(text);
    const set = /* @__PURE__ */ new Set();
    const d = t[0] || "";
    const cands = this.firstChar.get(d) || [];
    for (const e of cands) set.add(e);
    const len = t.length;
    const rk = len < 5 ? "lt5" : len < 10 ? "lt10" : len < 20 ? "lt20" : "ge20";
    const lr = this.lengthRanges.get(rk) || [];
    for (const e of lr) set.add(e);
    if (t.length >= 1) {
      const rp = this.regexPrefixes.get(t[0]) || [];
      for (const e of rp) set.add(e);
    }
    return Array.from(set);
  }
};
var PriorityQueue = class {
  constructor() {
    this.a = [];
  }
  push(item, pr) {
    this.a.push({ item, pr });
    this.a.sort((x, y) => y.pr - x.pr);
  }
  pop() {
    return this.a.length ? this.a.shift().item : null;
  }
  size() {
    return this.a.length;
  }
  clear() {
    this.a.length = 0;
  }
};
var SmartEventManager = class {
  constructor() {
    this.registry = [];
    this.rafQueue = /* @__PURE__ */ new Set();
    this.pq = new PriorityQueue();
    this.running = false;
  }
  add(el, event, handler, opts = {}) {
    const priority = opts.priority || 0;
    const debounceMs = typeof opts.debounceMs === "number" ? opts.debounceMs : this._defaultDebounce(event, opts.viewType);
    const useRaf = !!opts.useRaf;
    let wrapped = handler;
    if (debounceMs > 0) {
      let t;
      wrapped = (...args) => {
        clearTimeout(t);
        t = setTimeout(() => handler(...args), debounceMs);
      };
    }
    if (useRaf) {
      const key = `${event}:${Math.random()}`;
      const fn = (...args) => {
        this.rafQueue.add(() => handler(...args));
        this._drainRaf();
      };
      wrapped = fn;
    }
    el.addEventListener(event, wrapped, opts);
    this.registry.push({ el, event, wrapped, priority });
    return wrapped;
  }
  remove(el, event, wrapped) {
    try {
      el.removeEventListener(event, wrapped);
    } catch (_) {
    }
    this.registry = this.registry.filter((r) => r.el !== el || r.event !== event || r.wrapped !== wrapped);
  }
  _drainRaf() {
    if (this.running) return;
    this.running = true;
    const run = () => {
      const tasks = Array.from(this.rafQueue);
      this.rafQueue.clear();
      for (const fn of tasks) {
        try {
          fn();
        } catch (_) {
        }
      }
      if (this.rafQueue.size > 0) {
        requestAnimationFrame(run);
      } else {
        this.running = false;
      }
    };
    requestAnimationFrame(run);
  }
  _defaultDebounce(event, viewType) {
    if (viewType === "editor") {
      if (event === "scroll" || event === "resize") return 50;
      if (event === "mousemove") return 25;
      return 0;
    }
    if (event === "scroll" || event === "resize") return 100;
    if (event === "mousemove") return 50;
    return 0;
  }
  clear() {
    for (const r of this.registry) {
      try {
        r.el.removeEventListener(r.event, r.wrapped);
      } catch (_) {
      }
    }
    this.registry = [];
    this.rafQueue.clear();
    this.pq.clear();
  }
};
var CircuitBreaker = class {
  constructor(threshold = 5, timeoutMs = 5e3) {
    this.threshold = threshold;
    this.timeoutMs = timeoutMs;
    this.failures = 0;
    this.state = "closed";
    this.openedAt = 0;
  }
  canExecute() {
    if (this.state === "open") {
      const now = Date.now();
      if (now - this.openedAt > this.timeoutMs) {
        this.state = "half";
        return true;
      }
      return false;
    }
    return true;
  }
  recordSuccess() {
    this.failures = 0;
    if (this.state !== "closed") this.state = "closed";
  }
  recordFailure() {
    this.failures++;
    if (this.failures >= this.threshold) {
      this.state = "open";
      this.openedAt = Date.now();
    }
  }
};
var ErrorRecovery = class {
  constructor() {
    this.breakers = /* @__PURE__ */ new Map();
  }
  getBreaker(key) {
    const b = this.breakers.get(key) || new CircuitBreaker();
    this.breakers.set(key, b);
    return b;
  }
  wrap(key, fn, fallback) {
    const br = this.getBreaker(key);
    if (!br.canExecute()) {
      return typeof fallback === "function" ? fallback() : null;
    }
    try {
      const res = fn();
      br.recordSuccess();
      return res;
    } catch (_) {
      br.recordFailure();
      try {
        return typeof fallback === "function" ? fallback() : null;
      } catch (_2) {
        return null;
      }
    }
  }
};
var MemoryManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.interval = 2e3;
    this.timer = null;
    this.spanPool = [];
  }
  start() {
    if (this.timer) return;
    this.timer = setInterval(() => {
      this.tick();
    }, this.interval);
  }
  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
  setIntervalMs(ms) {
    this.interval = ms;
    if (this.timer) {
      this.stop();
      this.start();
    }
  }
  tick() {
    try {
      if (performance && performance.memory) {
        const usedMB = performance.memory.usedJSHeapSize / (1024 * 1024);
        if (usedMB > 800) {
          try {
            if (this.plugin._regexCache) this.plugin._regexCache.clear();
          } catch (_) {
          }
        }
      }
    } catch (_) {
    }
  }
  getSpan(text) {
    let span = null;
    if (this.spanPool.length) {
      const wr = this.spanPool.pop();
      const obj = wr && wr.deref ? wr.deref() : null;
      if (obj) span = obj;
    }
    if (!span) span = document.createElement("span");
    span.textContent = text || "";
    return span;
  }
  returnSpan(span) {
    try {
      span.textContent = "";
      this.spanPool.push(new WeakRef(span));
    } catch (_) {
    }
  }
  hintGC() {
    try {
      const arr = new Array(1e5);
      for (let i = 0; i < arr.length; i++) arr[i] = i;
      setTimeout(() => {
        arr.length = 0;
      }, 0);
    } catch (_) {
    }
  }
};
module.exports = class AlwaysColorText extends Plugin {
  constructor(...args) {
    super(...args);
    (function() {
      let lastOperationTime = 0;
      let operationCount = 0;
      const isOverloaded = () => {
        try {
          const now = Date.now();
          if (now - lastOperationTime < 50) {
            operationCount++;
            if (operationCount > 5) return true;
          } else {
            operationCount = 0;
          }
          lastOperationTime = now;
        } catch (e) {
          return false;
        }
        return false;
      };
      this.performanceMonitor = { isOverloaded };
    }).call(this);
    this._perfCounters = {
      totalRegexExecs: 0,
      avoidedRegexExecs: 0
    };
    this.getPerfCounters = () => Object.assign({}, this._perfCounters);
    this._cachedSortedEntries = null;
    this._cacheDirty = true;
    try {
      this._domRefs = /* @__PURE__ */ new WeakMap();
    } catch (e) {
      this._domRefs = null;
    }
    try {
      this._viewportObservers = /* @__PURE__ */ new Map();
    } catch (e) {
      this._viewportObservers = /* @__PURE__ */ new Map();
    }
    this._lastPerfWarning = 0;
    this._commandsRegistered = false;
    this._registeredCommandIds = [];
    this._translations = typeof locales === "object" && locales ? locales : {};
    this._externalTranslations = {};
    this._regexCache = new RegexCache(200);
    this._compiledWordPatterns = {};
    this._wordPatternsCompilationDirty = true;
    this._compiledTextBgPatterns = {};
    this._textBgPatternsCompilationDirty = true;
    this._compiledBlacklistWords = [];
    this._compiledBlacklistEntries = [];
    this._compiledBlacklistGroups = {};
    this._blacklistCompilationDirty = true;
    this._bloomFilter = new BloomFilter(2048);
    this._patternMatcher = new PatternMatcher(this.settings, {
      escapeRegex: (s) => this.escapeRegex(s),
      isSentenceLikePattern: (p) => this.isSentenceLikePattern(p),
      safeMatchLoop: (re, t) => this.safeMatchLoop(re, t)
    });
    this._settingsIndex = new SettingsIndex(this.settings);
    this._eventManager = new SmartEventManager();
    this._errorRecovery = new ErrorRecovery();
    this._memoryManager = new MemoryManager(this);
    try {
      this._memoryManager.start();
    } catch (_) {
    }
    try {
      this._lpObservers = /* @__PURE__ */ new Map();
    } catch (_) {
      this._lpObservers = /* @__PURE__ */ new Map();
    }
    try {
      this._readingModeIntervals = /* @__PURE__ */ new Map();
    } catch (_) {
      this._readingModeIntervals = /* @__PURE__ */ new Map();
    }
    try {
      this._pathRulesCache = /* @__PURE__ */ new Map();
    } catch (_) {
      this._pathRulesCache = /* @__PURE__ */ new Map();
    }
    this._isTyping = false;
    this._lastTypingTime = 0;
    this._typingFlagTimer = null;
    this._lpCalloutRaf = null;
    this._lpTableRaf = null;
  }
  applyDisabledNeutralizerStyles() {
    try {
      let style = document.getElementById("act-inline-neutralizer");
      if (!style) {
        style = document.createElement("style");
        style.id = "act-inline-neutralizer";
        style.textContent = `
          span.always-color-text-highlight { color: inherit !important; background-color: transparent !important; padding: 0 !important; border: none !important; }
          .callout span.always-color-text-highlight { color: inherit !important; background-color: transparent !important; padding: 0 !important; border: none !important; }
          .is-live-preview .callout span.always-color-text-highlight { color: inherit !important; background-color: transparent !important; padding: 0 !important; border: none !important; }
          .is-live-preview .cm-callout span.always-color-text-highlight { color: inherit !important; background-color: transparent !important; padding: 0 !important; border: none !important; }
          .callout .always-color-text-highlight,
          .cm-callout .always-color-text-highlight,
          .markdown-reading-view .callout .always-color-text-highlight,
          .markdown-rendered .callout .always-color-text-highlight {
            --text-normal: inherit !important;
            --link-color: inherit !important;
            --link-external-color: inherit !important;
            --link-unresolved-color: inherit !important;
            --link-color-hover: inherit !important;
            --link-external-color-hover: inherit !important;
            --highlight-color: inherit !important;
          }
        `;
        document.head.appendChild(style);
      }
    } catch (_) {
    }
  }
  removeDisabledNeutralizerStyles() {
    try {
      const style = document.getElementById("act-inline-neutralizer");
      if (style) style.remove();
    } catch (_) {
    }
  }
  applyHideHighlightsNeutralizerStyles() {
    try {
      let style = document.getElementById("act-hide-highlights-neutralizer");
      if (!style) {
        style = document.createElement("style");
        style.id = "act-hide-highlights-neutralizer";
        style.textContent = `
          span.always-color-text-highlight { background-color: transparent !important; padding: 0 !important; border: none !important; display: inline !important; box-shadow: none !important; }
          .always-color-text-highlight { background-color: transparent !important; padding: 0 !important; border: none !important; box-shadow: none !important; }
          .callout .always-color-text-highlight,
          .cm-callout .always-color-text-highlight,
          .markdown-reading-view .always-color-text-highlight,
          .markdown-rendered .always-color-text-highlight,
          .cm-content .always-color-text-highlight,
          .cm-line .always-color-text-highlight,
          .is-live-preview .cm-content .always-color-text-highlight { background-color: transparent !important; padding: 0 !important; border: none !important; box-shadow: none !important; }
        `;
        document.head.appendChild(style);
      }
    } catch (_) {
    }
  }
  removeHideHighlightsNeutralizerStyles() {
    try {
      const style = document.getElementById("act-hide-highlights-neutralizer");
      if (style) style.remove();
    } catch (_) {
    }
  }
  applyHighlightPresetTransparency() {
    try {
      const hasHighlightPreset = Array.isArray(this.settings.wordEntries) && this.settings.wordEntries.some(
        (e) => e.pattern === "==[\\s\\S]*?==" || e.pattern === "==.*?=="
      );
      let style = document.getElementById("act-highlight-preset-transparency");
      if (hasHighlightPreset) {
        if (!style) {
          style = document.createElement("style");
          style.id = "act-highlight-preset-transparency";
          style.textContent = `
            .markdown-rendered mark:not(.always-color-text-highlight-marks) {
              background-color: transparent !important;
              color: inherit !important;
            }
            .cm-highlight {
              background-color: transparent !important;
              color: inherit !important;
            }
            .cm-s-obsidian span.cm-highlight {
              background-color: transparent !important;
              color: inherit !important;
            }
          `;
          document.head.appendChild(style);
        }
      } else {
        if (style) style.remove();
      }
    } catch (_) {
    }
  }
  removeHighlightPresetTransparency() {
    try {
      const style = document.getElementById("act-highlight-preset-transparency");
      if (style) style.remove();
    } catch (_) {
    }
  }
  removeFormattingPresetStyles() {
    try {
      const style = document.getElementById("act-formatting-preset-styles");
      if (style) style.remove();
    } catch (_) {
    }
  }
  applyFormattingPresetStyles() {
    try {
      const entries = Array.isArray(this.settings.wordEntries) ? this.settings.wordEntries : [];
      const hasBold = entries.some((e) => e.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1");
      const hasItalic = entries.some((e) => e.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1");
      const hasBoldItalic = entries.some((e) => e.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1");
      let style = document.getElementById("act-formatting-preset-styles");
      if (hasBold || hasItalic || hasBoldItalic) {
        if (!style) {
          style = document.createElement("style");
          style.id = "act-formatting-preset-styles";
          document.head.appendChild(style);
        }
        let css = "";
        if (hasBold) {
          css += `
                .cm-strong, strong {
                    color: inherit !important;
                    background-color: transparent !important;
                }
                .cm-s-obsidian span.cm-strong {
                    color: inherit !important;
                    background-color: transparent !important;
                }
            `;
        }
        if (hasItalic) {
          css += `
                .cm-em, em {
                    color: inherit !important;
                    background-color: transparent !important;
                }
                .cm-s-obsidian span.cm-em {
                    color: inherit !important;
                    background-color: transparent !important;
                }
            `;
        }
        if (hasBoldItalic) {
          css += `
                .cm-strong.cm-em, strong em, em strong {
                    color: inherit !important;
                    background-color: transparent !important;
                }
                 .cm-s-obsidian span.cm-strong.cm-em {
                    color: inherit !important;
                    background-color: transparent !important;
                }
            `;
        }
        style.textContent = css;
      } else {
        if (style) style.remove();
      }
    } catch (_) {
    }
  }
  neutralizeExistingHighlightBackgrounds() {
    try {
      document.querySelectorAll(".always-color-text-highlight").forEach((el) => {
        try {
          el.style.setProperty("background-color", "transparent", "important");
        } catch (_) {
          el.style.backgroundColor = "transparent";
        }
        el.style.paddingLeft = "0px";
        el.style.paddingRight = "0px";
        el.style.border = "";
        el.style.borderRadius = "";
        el.style.boxShadow = "";
        el.style.display = "inline";
      });
    } catch (_) {
    }
  }
  applyEnabledLivePreviewCalloutStyles() {
    try {
      let style = document.getElementById("act-livepreview-callout");
      if (!style) {
        style = document.createElement("style");
        style.id = "act-livepreview-callout";
        style.textContent = `
          .is-live-preview .callout .always-color-text-highlight,
          .is-live-preview .callout .always-color-text-highlight *,
          .is-live-preview .cm-callout .always-color-text-highlight,
          .is-live-preview .cm-callout .always-color-text-highlight * {
            --text-normal: var(--highlight-color);
            --link-color: var(--highlight-color);
            --link-external-color: var(--highlight-color);
            --link-unresolved-color: var(--highlight-color);
            --link-color-hover: var(--highlight-color);
            --link-external-color-hover: var(--highlight-color);
            color: var(--highlight-color);
          }
        `;
        document.head.appendChild(style);
      }
    } catch (_) {
    }
  }
  removeEnabledLivePreviewCalloutStyles() {
    try {
      const style = document.getElementById("act-livepreview-callout");
      if (style) style.remove();
    } catch (_) {
    }
  }
  applyEnabledLivePreviewTextColorStyles() {
    try {
      let style = document.getElementById("act-livepreview-textcolor");
      if (!style) {
        style = document.createElement("style");
        style.id = "act-livepreview-textcolor";
        style.textContent = `
          .is-live-preview .cm-content .always-color-text-highlight,
          .is-live-preview .cm-content .always-color-text-highlight * {
            color: var(--highlight-color);
          }
        `;
        document.head.appendChild(style);
      }
    } catch (_) {
    }
  }
  removeEnabledLivePreviewTextColorStyles() {
    try {
      const style = document.getElementById("act-livepreview-textcolor");
      if (style) style.remove();
    } catch (_) {
    }
  }
  applyEnabledReadingCalloutStyles() {
    try {
      let style = document.getElementById("act-reading-callout");
      if (!style) {
        style = document.createElement("style");
        style.id = "act-reading-callout";
        style.textContent = `
          .markdown-reading-view .callout .always-color-text-highlight,
          .markdown-reading-view .callout .always-color-text-highlight *,
          .markdown-rendered .callout .always-color-text-highlight,
          .markdown-rendered .callout .always-color-text-highlight *,
          .callout .always-color-text-highlight,
          .callout .always-color-text-highlight * {
            --text-normal: var(--highlight-color);
            --link-color: var(--highlight-color);
            --link-external-color: var(--highlight-color);
            --link-unresolved-color: var(--highlight-color);
            --link-color-hover: var(--highlight-color);
            --link-external-color-hover: var(--highlight-color);
            color: var(--highlight-color);
          }
        `;
        document.head.appendChild(style);
      }
    } catch (_) {
    }
  }
  removeEnabledReadingCalloutStyles() {
    try {
      const style = document.getElementById("act-reading-callout");
      if (style) style.remove();
      try {
        document.querySelectorAll(".callout .always-color-text-highlight, .cm-callout .always-color-text-highlight, .markdown-reading-view .always-color-text-highlight, .markdown-rendered .always-color-text-highlight").forEach((el) => {
          el.style.removeProperty("--highlight-color");
          el.style.removeProperty("--text-normal");
          el.style.removeProperty("--link-color");
          el.style.removeProperty("--link-external-color");
          el.style.removeProperty("--link-unresolved-color");
          el.style.removeProperty("--link-color-hover");
          el.style.removeProperty("--link-external-color-hover");
          el.style.removeProperty("color");
        });
      } catch (e) {
      }
    } catch (_) {
    }
  }
  t(key, fallback, params) {
    try {
      const pref = this.settings && this.settings.language || "en";
      const lang = pref === "auto" ? this.resolveSystemLanguageCode() : pref;
      const base = this._translations && typeof this._translations === "object" ? this._translations : typeof locales === "object" && locales ? locales : {};
      const dict = base && base[lang] || base && base.en || {};
      let str = dict && dict[key] ? dict[key] : fallback || key;
      if (params && str && typeof str === "string") {
        try {
          for (const k of Object.keys(params)) {
            const v = String(params[k]);
            str = str.replace(new RegExp(`\\{${k}\\}`, "g"), v);
          }
        } catch (_) {
        }
      }
      return str;
    } catch (e) {
      return fallback || key;
    }
  }
  resolveSystemLanguageCode() {
    try {
      let raw = "en";
      try {
        raw = moment && typeof moment.locale === "function" ? moment.locale() : raw;
      } catch (_) {
      }
      if (!raw && navigator && navigator.language) raw = navigator.language;
      const code = String(raw).toLowerCase().split("-")[0].split("_")[0];
      const aliases = { bd: "bn", zh: "zh_cn" };
      const resolved = aliases[code] || code;
      const dict = this._translations && typeof this._translations === "object" ? this._translations : typeof locales === "object" && locales ? locales : {};
      if (dict && dict[resolved]) return resolved;
      return "en";
    } catch (e) {
      return "en";
    }
  }
  getPluginFolderPath() {
    try {
      const id = this.manifest && this.manifest.id || "always-color-text";
      return `.obsidian/plugins/${id}`;
    } catch (e) {
      return `.obsidian/plugins/always-color-text`;
    }
  }
  async loadExternalTranslations() {
    try {
      const safeLocales = typeof locales === "object" && locales ? locales : {};
      this._externalTranslations = safeLocales;
      this._translations = safeLocales;
    } catch (e) {
      this._translations = {};
    }
  }
  getAvailableLanguages() {
    try {
      const dict = this._translations && typeof this._translations === "object" ? this._translations : typeof locales === "object" && locales ? locales : {};
      const list = Object.keys(dict);
      return ["auto", ...list];
    } catch (e) {
      return ["auto"];
    }
  }
  async onload() {
    await this.loadSettings();
    this.updateLightModeFixer();
    if (typeof this.settings.quickColorsEnabled === "undefined") this.settings.quickColorsEnabled = false;
    if (!this.settings.quickColorsApplyMode) this.settings.quickColorsApplyMode = "html";
    if (!Array.isArray(this.settings.quickColors)) this.settings.quickColors = [];
    if (!Array.isArray(this.settings.quickStyles)) this.settings.quickStyles = [];
    if (typeof this.settings.quickStylesEnabled === "undefined") this.settings.quickStylesEnabled = true;
    if (typeof this.settings.enableQuickColorHighlightOnce === "undefined") this.settings.enableQuickColorHighlightOnce = false;
    try {
      this.migrateAdvancedRulesToPerEntry();
      await this.saveSettings();
    } catch (_) {
    }
    try {
      await this.loadExternalTranslations();
    } catch (_) {
    }
    try {
      this.settingTab = new ColorSettingTab(this.app, this);
      this.addSettingTab(this.settingTab);
    } catch (e) {
      try {
        debugError("SETTINGS_TAB", "Failed to initialize settings tab", e);
      } catch (_) {
      }
    }
    if (this.settings.enabled) {
      this.removeDisabledNeutralizerStyles();
      if (!this.settings.disableLivePreviewColoring) {
        try {
          this.applyEnabledLivePreviewCalloutStyles();
        } catch (_) {
        }
        try {
          this.applyEnabledLivePreviewTextColorStyles();
        } catch (_) {
        }
      } else {
        try {
          this.removeEnabledLivePreviewCalloutStyles();
        } catch (_) {
        }
        try {
          this.removeEnabledLivePreviewTextColorStyles();
        } catch (_) {
        }
      }
      try {
        this.applyEnabledReadingCalloutStyles();
      } catch (_) {
      }
      if (this.settings.hideHighlights) {
        this.applyHideHighlightsNeutralizerStyles();
        this.neutralizeExistingHighlightBackgrounds();
      } else {
        this.removeHideHighlightsNeutralizerStyles();
      }
      setTimeout(() => {
        if (!this.settings.disableLivePreviewColoring) {
          try {
            this.refreshAllLivePreviewCallouts();
          } catch (_) {
          }
          try {
            this.refreshAllLivePreviewTables();
          } catch (_) {
          }
        }
        try {
          this.refreshAllBasesViews();
        } catch (_) {
        }
        try {
          this.forceRefreshAllReadingViews();
        } catch (_) {
        }
      }, 250);
    } else {
      this.applyDisabledNeutralizerStyles();
      try {
        this.removeEnabledLivePreviewCalloutStyles();
      } catch (_) {
      }
      try {
        this.removeEnabledReadingCalloutStyles();
      } catch (_) {
      }
    }
    if (!this.settings.disableToggleModes.ribbon) {
      this.ribbonIcon = this.addRibbonIcon("palette", this.t("ribbon_title", "Always color text"), async () => {
        this.settings.enabled = !this.settings.enabled;
        await this.saveSettings();
        this.updateStatusBar();
        this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
        this.reconfigureEditorExtensions();
        this.forceRefreshAllEditors();
        this.forceRefreshAllReadingViews();
        if (this.settings.enabled) new Notice(this.t("notice_enabled", "Always color text enabled"));
        else new Notice(this.t("notice_disabled", "Always color text disabled"));
        if (this.settings.enabled) {
          this.removeDisabledNeutralizerStyles();
        } else {
          this.applyDisabledNeutralizerStyles();
        }
        if (!this.settings.enabled) {
          try {
            this.clearAllHighlights();
          } catch (_) {
          }
        }
        try {
          if (this.settings.enabled) {
            if (!this.settings.disableLivePreviewColoring) {
              this.applyEnabledLivePreviewCalloutStyles();
              this.applyEnabledLivePreviewTextColorStyles();
            } else {
              this.removeEnabledLivePreviewCalloutStyles();
              this.removeEnabledLivePreviewTextColorStyles();
            }
            this.applyEnabledReadingCalloutStyles();
            if (this.settings.hideHighlights) {
              this.applyHideHighlightsNeutralizerStyles();
            } else {
              this.removeHideHighlightsNeutralizerStyles();
            }
          } else {
            this.removeEnabledLivePreviewCalloutStyles();
            this.removeEnabledLivePreviewTextColorStyles();
            this.removeEnabledReadingCalloutStyles();
            this.removeHideHighlightsNeutralizerStyles();
          }
          if (!this.settings.disableLivePreviewColoring) {
            this.refreshAllLivePreviewCallouts();
            this.forceReprocessLivePreviewCallouts();
            this.refreshAllLivePreviewTables();
            this.forceReprocessLivePreviewTables();
          }
          this.refreshAllBasesViews();
          this.forceReprocessBasesViews();
        } catch (_) {
        }
      });
    }
    if (!this.settings.disableToggleModes.statusBar) {
      this.statusBar = this.addStatusBarItem();
      this.updateStatusBar();
      this.statusBar.onclick = () => {
        this.settings.enabled = !this.settings.enabled;
        this.saveSettings();
        this.updateStatusBar();
        this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
        this.reconfigureEditorExtensions();
        this.forceRefreshAllEditors();
        this.forceRefreshAllReadingViews();
        if (this.settings.enabled) new Notice(this.t("notice_enabled", "Always color text enabled"));
        else new Notice(this.t("notice_disabled", "Always color text disabled"));
        if (this.settings.enabled) {
          this.removeDisabledNeutralizerStyles();
        } else {
          this.applyDisabledNeutralizerStyles();
        }
        if (!this.settings.enabled) {
          try {
            this.clearAllHighlights();
          } catch (_) {
          }
        }
        try {
          if (this.settings.enabled) {
            if (!this.settings.disableLivePreviewColoring) {
              this.applyEnabledLivePreviewCalloutStyles();
              this.applyEnabledLivePreviewTextColorStyles();
            } else {
              this.removeEnabledLivePreviewCalloutStyles();
              this.removeEnabledLivePreviewTextColorStyles();
            }
            this.applyEnabledReadingCalloutStyles();
            if (this.settings.hideHighlights) {
              this.applyHideHighlightsNeutralizerStyles();
            } else {
              this.removeHideHighlightsNeutralizerStyles();
            }
          } else {
            this.removeEnabledLivePreviewCalloutStyles();
            this.removeEnabledLivePreviewTextColorStyles();
            this.removeEnabledReadingCalloutStyles();
            this.removeHideHighlightsNeutralizerStyles();
          }
          if (!this.settings.disableLivePreviewColoring) {
            this.refreshAllLivePreviewCallouts();
            this.forceReprocessLivePreviewCallouts();
            this.refreshAllLivePreviewTables();
            this.forceReprocessLivePreviewTables();
          }
          this.refreshAllBasesViews();
          this.forceReprocessBasesViews();
        } catch (_) {
        }
      };
    } else {
      this.statusBar = null;
    }
    const { TFile } = require("obsidian");
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
      if (!(file instanceof TFile)) return;
      menu.addItem((item) => {
        const isDisabled = this.settings.disabledFiles.includes(file.path);
        item.setTitle(isDisabled ? this.t("file_menu_enable", "Enable always color text for this file") : this.t("file_menu_disable", "Disable always color text for this file")).setIcon(isDisabled ? "eye" : "eye-off").onClick(async () => {
          if (isDisabled) {
            const index = this.settings.disabledFiles.indexOf(file.path);
            if (index > -1) {
              this.settings.disabledFiles.splice(index, 1);
            }
          } else {
            this.settings.disabledFiles.push(file.path);
          }
          await this.saveSettings();
          this.forceRefreshAllEditors();
          this.forceRefreshAllReadingViews();
        });
      });
    }));
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (file === this.app.workspace.getActiveFile()) {
          try {
            if (this._pathRulesCache && file && file.path) {
              this._pathRulesCache.delete(file.path);
            }
          } catch (_) {
          }
          this.forceRefreshAllEditors();
          this.forceRefreshAllReadingViews();
        }
      })
    );
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      const selectedText = editor.getSelection().trim();
      if (selectedText.length > 0) {
        if (this.settings.enableQuickColorOnce) {
          menu.addItem((item) => {
            item.setTitle(this.t("menu_color_once", "Color Once")).setIcon("palette").onClick(() => {
              new ColorPickerModal(this.app, this, async (color) => {
                if (color && this.isValidHexColor(color)) {
                  const html = `<span style="color: ${color}">${selectedText}</span>`;
                  editor.replaceSelection(html);
                }
              }, "text", selectedText, true).open();
            });
          });
        }
        if (this.settings.enableQuickHighlightOnce) {
          menu.addItem((item) => {
            item.setTitle(this.t("menu_highlight_once", "Highlight Once")).setIcon("highlighter").onClick(() => {
              new ColorPickerModal(this.app, this, async (color, result) => {
                const bg = result && result.backgroundColor && this.isValidHexColor(result.backgroundColor) ? result.backgroundColor : this.isValidHexColor(color) ? color : null;
                if (!bg) return;
                let style = "";
                if (this.settings.quickHighlightUseGlobalStyle) {
                  const rgba = this.hexToRgba(bg, this.settings.backgroundOpacity ?? 25);
                  const radius = this.settings.highlightBorderRadius ?? 8;
                  const pad = this.settings.highlightHorizontalPadding ?? 4;
                  const border = this.generateBorderStyle(null, bg);
                  style = `background-color: ${rgba}; border-radius: ${radius}px; padding-left: ${pad}px; padding-right: ${pad}px;${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}${border}`;
                } else if (this.settings.quickHighlightStyleEnable) {
                  const hexWithAlpha = this.hexToHexWithAlpha(bg, this.settings.quickHighlightOpacity ?? 25);
                  const radius = this.settings.quickHighlightBorderRadius ?? 8;
                  const pad = this.settings.quickHighlightHorizontalPadding ?? 4;
                  const vpad = this.settings.quickHighlightVerticalPadding ?? 0;
                  const border = this.generateOnceBorderStyle(bg);
                  style = `background-color: ${hexWithAlpha}; border-radius: ${radius}px; padding-left: ${pad}px; padding-right: ${pad}px; padding-top: ${vpad}px; padding-bottom: ${vpad}px;${border}`;
                } else {
                  const rgba = this.hexToRgba(bg, 25);
                  style = `background-color: ${rgba};`;
                }
                const html = `<span style="${style}">${selectedText}</span>`;
                editor.replaceSelection(html);
              }, "background", selectedText, true).open();
            });
          });
        }
        const cpm = this.settings.colorPickerMode || "both";
        const isBoth = cpm === "both" || cpm === "both-bg-left" || cpm === "both-v-text-top" || cpm === "both-v-bg-top";
        if (this.settings.enableQuickColorHighlightOnce && isBoth) {
          menu.addItem((item) => {
            item.setTitle(this.t("menu_color_highlight_once", "Color / Highlight Once")).setIcon("paintbrush").onClick(() => {
              new ColorPickerModal(this.app, this, async (color, result) => {
                const tc = result && result.textColor && this.isValidHexColor(result.textColor) ? result.textColor : null;
                const bg = result && result.backgroundColor && this.isValidHexColor(result.backgroundColor) ? result.backgroundColor : null;
                if (!tc && !bg) return;
                let style = "";
                if (tc) style += `color: ${tc}; `;
                if (bg) {
                  if (this.settings.quickHighlightUseGlobalStyle) {
                    const rgba = this.hexToRgba(bg, this.settings.backgroundOpacity ?? 25);
                    const radius = this.settings.highlightBorderRadius ?? 8;
                    const pad = this.settings.highlightHorizontalPadding ?? 4;
                    const border = this.generateBorderStyle(null, bg);
                    style += `background-color: ${rgba}; border-radius: ${radius}px; padding-left: ${pad}px; padding-right: ${pad}px;${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}${border}`;
                  } else if (this.settings.quickHighlightStyleEnable) {
                    const hexWithAlpha = this.hexToHexWithAlpha(bg, this.settings.quickHighlightOpacity ?? 25);
                    const radius = this.settings.quickHighlightBorderRadius ?? 8;
                    const pad = this.settings.quickHighlightHorizontalPadding ?? 4;
                    const vpad = this.settings.quickHighlightVerticalPadding ?? 0;
                    const border = this.generateOnceBorderStyle(bg);
                    style += `background-color: ${hexWithAlpha}; border-radius: ${radius}px; padding-left: ${pad}px; padding-right: ${pad}px; padding-top: ${vpad}px; padding-bottom: ${vpad}px;${border}`;
                  } else {
                    const rgba = this.hexToRgba(bg, 25);
                    style += `background-color: ${rgba};`;
                  }
                }
                const html = `<span style="${style.trim()}">${selectedText}</span>`;
                editor.replaceSelection(html);
              }, "text-and-background", selectedText, true).open();
            });
          });
        }
        const isHtmlColor = /^<span\s+(?:style="[^"]*(?:color|background-color):[^"]*"|class="always-color-text-highlight"[^>]*)(?:>)(.*)<\/span>$/s.test(selectedText);
        if (isHtmlColor) {
          menu.addItem((item) => {
            item.setTitle(this.t("menu_remove_inline_color", "Remove Inline Color")).setIcon("trash").onClick(() => {
              const match = selectedText.match(/^<span\s+(?:[^>]+)>(.*)<\/span>$/s);
              if (match && match[1]) {
                editor.replaceSelection(match[1]);
              }
            });
          });
        }
        if (this.settings.enableAddToExistingMenu && Array.isArray(this.settings.wordEntries) && this.settings.wordEntries.length > 0) {
          menu.addItem((item) => {
            item.setTitle(this.t("command_add_to_existing_entry", "add to existing entry")).setIcon("plus").onClick(() => {
              try {
                new AddToExistingEntryModal(this.app, this, selectedText, view).open();
              } catch (e) {
                new Notice(this.t("notice_error_opening_modal", "Unable to open modal"));
              }
            });
          });
        }
        if (this.settings.enableAlwaysColorTextMenu) {
          menu.addItem((item) => {
            item.setTitle(this.t("menu_always_color_text", "Always color text")).setIcon("palette").onClick(() => {
              if (this.isWordBlacklisted(selectedText, view.file.path)) {
                new Notice(this.t("notice_blacklisted_cannot_color", `"${selectedText}" is blacklisted and cannot be colored.`, { word: selectedText }));
                return;
              }
              new ColorPickerModal(this.app, this, async (color, result) => {
                const sel = result || {};
                const tc = sel.textColor && this.isValidHexColor(sel.textColor) ? sel.textColor : null;
                const bc = sel.backgroundColor && this.isValidHexColor(sel.backgroundColor) ? sel.backgroundColor : null;
                const selGroupUid = sel.selectedGroupUid || null;
                const matchType = sel.matchType || (this.settings.partialMatch ? "contains" : "exact");
                const applyToArr = (arr) => {
                  const idx = arr.findIndex((e) => e && e.pattern === selectedText && !e.isRegex);
                  if (idx !== -1) {
                    const entry = arr[idx];
                    if (tc && bc) {
                      entry.textColor = tc;
                      entry.backgroundColor = bc;
                      entry.color = "";
                      entry.styleType = "both";
                      entry._savedTextColor = tc;
                      entry._savedBackgroundColor = bc;
                    } else if (tc) {
                      entry.color = tc;
                      entry.styleType = "text";
                      entry.textColor = null;
                      entry.backgroundColor = null;
                      entry._savedTextColor = tc;
                    } else if (bc) {
                      entry.color = "";
                      entry.textColor = "currentColor";
                      entry.backgroundColor = bc;
                      entry.styleType = "highlight";
                      entry._savedBackgroundColor = bc;
                    } else if (color && this.isValidHexColor(color)) {
                      entry.color = color;
                      entry.styleType = "text";
                      entry._savedTextColor = color;
                    }
                    if (!entry.isRegex) entry.matchType = matchType;
                  } else {
                    if (tc && bc) {
                      arr.push({ pattern: selectedText, color: "", textColor: tc, backgroundColor: bc, isRegex: false, flags: "", styleType: "both", matchType, _savedTextColor: tc, _savedBackgroundColor: bc });
                    } else if (tc) {
                      arr.push({ pattern: selectedText, color: tc, isRegex: false, flags: "", styleType: "text", matchType, _savedTextColor: tc });
                    } else if (bc) {
                      arr.push({ pattern: selectedText, color: "", textColor: "currentColor", backgroundColor: bc, isRegex: false, flags: "", styleType: "highlight", matchType, _savedBackgroundColor: bc });
                    } else if (color && this.isValidHexColor(color)) {
                      arr.push({ pattern: selectedText, color, isRegex: false, flags: "", styleType: "text", matchType, _savedTextColor: color });
                    }
                  }
                };
                if (selGroupUid) {
                  const group = Array.isArray(this.settings.wordEntryGroups) ? this.settings.wordEntryGroups.find((g) => g && g.uid === selGroupUid) : null;
                  if (group) {
                    if (!Array.isArray(group.entries)) group.entries = [];
                    applyToArr(group.entries);
                  } else {
                    applyToArr(this.settings.wordEntries);
                  }
                } else {
                  applyToArr(this.settings.wordEntries);
                }
                await this.saveSettings();
                this.compileWordEntries();
                this.compileTextBgColoringEntries();
                this.reconfigureEditorExtensions();
                this.refreshEditor(view, true);
              }, "text-and-background", selectedText, false).open();
            });
          });
        }
        const stylesArr = Array.isArray(this.settings.quickStyles) ? this.settings.quickStyles : [];
        this._lastSelectedQuickColor = null;
        let closeMenuTimeout = null;
        const openStylesSubmenu = (anchorEvent, anchorElement = null) => {
          if (closeMenuTimeout) {
            clearTimeout(closeMenuTimeout);
            closeMenuTimeout = null;
          }
          if (!this.settings.quickStylesEnabled) return;
          if (this._openQuickStylesSubmenu) {
            try {
              this._openQuickStylesSubmenu.hide();
            } catch (_) {
            }
            this._openQuickStylesSubmenu = null;
          }
          const sub = new Menu();
          stylesArr.forEach((style) => {
            sub.addItem((subItem) => {
              const frag = document.createDocumentFragment();
              const wrapper = document.createElement("div");
              wrapper.style.display = "flex";
              wrapper.style.alignItems = "center";
              wrapper.style.gap = "8px";
              const nameEl = document.createElement("div");
              nameEl.textContent = style.name || "Style";
              const active = this._lastSelectedQuickColor || null;
              const styleType2 = style && style.styleType ? style.styleType : "both";
              const tc = active && (styleType2 === "text" || styleType2 === "both") && active.textColor ? active.textColor : style.textColor || style.color || null;
              const bc = active && (styleType2 === "highlight" || styleType2 === "both") && active.backgroundColor ? active.backgroundColor : style.backgroundColor || null;
              const params = this.getHighlightParams(style);
              const borderCss = this.generateBorderStyle(tc, bc, style);
              let styleStr = "";
              if (tc) styleStr += `color:${tc};`;
              if (bc) {
                try {
                  const hexWithAlpha = this.hexToHexWithAlpha(bc, params.opacity ?? 25);
                  styleStr += `background-color:${hexWithAlpha};`;
                } catch (_) {
                  styleStr += `background-color:${bc};`;
                }
              }
              styleStr += `border-radius:${params.radius ?? 8}px; padding:${params.vPad ?? 0}px ${params.hPad ?? 4}px;${borderCss}`;
              nameEl.setAttr("style", styleStr);
              wrapper.appendChild(nameEl);
              frag.appendChild(wrapper);
              subItem.setTitle(frag);
              subItem.onClick(async () => {
                try {
                  sub.hide();
                } catch (_) {
                }
                this._openQuickStylesSubmenu = null;
                await this._applyQuickStyleToSelection(style, this._lastSelectedQuickColor || null, selectedText, editor, view, this.settings.quickColorsApplyMode !== "act" && !(style && (style.groupUid || style.matchType)));
              });
            });
          });
          try {
            let targetEl = anchorElement;
            if (!targetEl && anchorEvent) {
              if (anchorEvent instanceof Element) targetEl = anchorEvent;
              else if (anchorEvent.target) targetEl = anchorEvent.target.closest(".menu-item") || anchorEvent.target;
            }
            let rect = null;
            if (targetEl && targetEl.getBoundingClientRect) {
              rect = targetEl.getBoundingClientRect();
            }
            if (rect) {
              const winWidth = window.innerWidth;
              const threshold = 350;
              const estimatedWidth = 160;
              const distToRight = winWidth - rect.right;
              let targetX, targetY;
              targetY = rect.top;
              if (distToRight < threshold) {
                targetX = rect.left - estimatedWidth + 5;
              } else {
                targetX = rect.right - 5;
              }
              if (targetX < 10) targetX = 10;
              sub.showAtPosition({ x: targetX, y: targetY });
            } else {
              sub.showAtMouseEvent(anchorEvent);
            }
          } catch (e) {
            sub.showAtMouseEvent(anchorEvent);
          }
          this._openQuickStylesSubmenu = sub;
          if (sub.dom) {
            sub.dom.addEventListener("mouseenter", () => {
              if (closeMenuTimeout) {
                clearTimeout(closeMenuTimeout);
                closeMenuTimeout = null;
              }
            });
            sub.dom.addEventListener("mouseleave", () => {
              closeMenuTimeout = setTimeout(() => {
                if (this._openQuickStylesSubmenu) {
                  try {
                    this._openQuickStylesSubmenu.hide();
                  } catch (_) {
                  }
                  this._openQuickStylesSubmenu = null;
                }
              }, 300);
            });
          }
        };
        if (this.settings.quickColorsEnabled && Array.isArray(this.settings.quickColors) && this.settings.quickColors.length > 0) {
          menu.addItem((item) => {
            const titleEl = document.createElement("div");
            titleEl.className = "menu-item tappable has-submenu";
            titleEl.classList.add("act-color-dots");
            titleEl.addEventListener("mouseenter", (ev) => {
              if (closeMenuTimeout) {
                clearTimeout(closeMenuTimeout);
                closeMenuTimeout = null;
              }
              if (this.settings.quickStylesEnabled && stylesArr.length > 0) {
                try {
                  openStylesSubmenu(ev, titleEl);
                } catch (e) {
                  openStylesSubmenu(ev, titleEl);
                }
              }
            });
            titleEl.addEventListener("mouseleave", () => {
              closeMenuTimeout = setTimeout(() => {
                if (this._openQuickStylesSubmenu) {
                  try {
                    this._openQuickStylesSubmenu.hide();
                  } catch (_) {
                  }
                  this._openQuickStylesSubmenu = null;
                }
              }, 300);
            });
            const iconLeft = document.createElement("div");
            iconLeft.className = "menu-item-icon";
            const titleText = document.createElement("div");
            titleText.className = "menu-item-title";
            const dotsContainer = document.createElement("div");
            dotsContainer.classList.add("act-color-dots-container");
            dotsContainer.style.display = "flex";
            dotsContainer.style.flexWrap = "wrap";
            dotsContainer.style.gap = "6px";
            dotsContainer.style.padding = "4px 0";
            dotsContainer.style.width = "100%";
            dotsContainer.style.alignItems = "center";
            let activeDotEl = null;
            this.settings.quickColors.forEach((pair) => {
              if (pair && pair.backgroundColor && this.isValidHexColor(pair.backgroundColor)) {
                const dotB = document.createElement("div");
                dotB.classList.add("act-color-dot", "act-color-dot-bg", "has-submenu");
                dotB.style.width = "20px";
                dotB.style.height = "20px";
                dotB.style.borderRadius = "50%";
                dotB.style.backgroundColor = pair.backgroundColor;
                dotB.style.cursor = "pointer";
                dotB.style.border = "1px solid var(--background-modifier-border)";
                dotB.addEventListener("click", async (ev) => {
                  ev.preventDefault();
                  ev.stopPropagation();
                  if (activeDotEl === dotB) {
                    try {
                      activeDotEl.style.outline = "";
                    } catch (_) {
                    }
                    try {
                      activeDotEl.classList.remove("act-color-dot-active");
                    } catch (_) {
                    }
                    activeDotEl = null;
                    this._lastSelectedQuickColor = null;
                    if (this.settings.quickStylesEnabled && stylesArr.length > 0) {
                      openStylesSubmenu(ev, titleEl);
                    }
                    return;
                  }
                  this._lastSelectedQuickColor = { textColor: pair.textColor || null, backgroundColor: pair.backgroundColor };
                  if (activeDotEl && activeDotEl !== dotB) {
                    try {
                      activeDotEl.style.outline = "";
                    } catch (_) {
                    }
                    try {
                      activeDotEl.classList.remove("act-color-dot-active");
                    } catch (_) {
                    }
                  }
                  activeDotEl = dotB;
                  try {
                    dotB.style.outline = "2px solid var(--interactive-accent)";
                  } catch (_) {
                  }
                  try {
                    dotB.classList.add("act-color-dot-active");
                  } catch (_) {
                  }
                  if (this.settings.quickStylesEnabled && stylesArr.length > 0) {
                    openStylesSubmenu(ev, titleEl);
                  } else {
                    const firstStyle = stylesArr[0] || null;
                    if (firstStyle) {
                      await this._applyQuickStyleToSelection(firstStyle, this._lastSelectedQuickColor, selectedText, editor, view, this.settings.quickColorsApplyMode !== "act" && !(firstStyle && (firstStyle.groupUid || firstStyle.matchType)));
                    } else {
                      if (this.settings.quickColorsApplyMode === "act") {
                        await this._applyQuickColorACT(selectedText, null, pair.backgroundColor, view);
                      } else {
                        const p = this.getHighlightParams(null);
                        const hexWithAlpha = this.hexToHexWithAlpha(pair.backgroundColor, p.opacity ?? 25);
                        const borderCss = this.generateBorderStyle(null, pair.backgroundColor, null);
                        const styleStr = `background-color: ${hexWithAlpha}; border-radius: ${p.radius ?? 8}px; padding: ${p.vPad ?? 0}px ${p.hPad ?? 4}px;${borderCss} box-decoration-break: clone; -webkit-box-decoration-break: clone;`;
                        const html = `<span class="always-color-text-highlight" style="${styleStr}">${selectedText}</span>`;
                        editor.replaceSelection(html);
                      }
                    }
                  }
                });
                dotsContainer.appendChild(dotB);
              }
            });
            titleText.appendChild(dotsContainer);
            const chevronIcon = document.createElement("div");
            chevronIcon.className = "menu-item-icon";
            chevronIcon.style.cursor = "pointer";
            chevronIcon.style.marginLeft = "auto";
            try {
              setIcon(chevronIcon, "chevron-right");
            } catch (_) {
            }
            chevronIcon.addEventListener("click", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              openStylesSubmenu(ev, titleEl);
            });
            const iconRight = document.createElement("div");
            iconRight.className = "menu-item-icon mod-submenu";
            try {
              iconRight.style.cursor = "pointer";
            } catch (_) {
            }
            iconRight.style.display = "none";
            iconRight.addEventListener("click", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              openStylesSubmenu(ev, titleEl);
            });
            titleEl.appendChild(iconLeft);
            titleEl.appendChild(titleText);
            if (this.settings.quickStylesEnabled && stylesArr.length > 0) {
              titleEl.appendChild(chevronIcon);
            }
            titleEl.appendChild(iconRight);
            item.setTitle(titleEl);
            item.onClick((evt) => {
              if (this.settings.quickStylesEnabled && stylesArr.length > 0) {
                openStylesSubmenu(evt, titleEl);
              }
            });
          });
        } else if (this.settings.quickStylesEnabled && Array.isArray(this.settings.quickStyles) && this.settings.quickStyles.length > 0) {
          menu.addItem((item) => {
            item.setIcon("heading-glyph");
            item.setTitle(this.t("quick_styles_menu_option", "Quick Styles"));
            try {
              item.dom?.classList.add("has-submenu");
            } catch (_) {
            }
            try {
              const iconRight = document.createElement("div");
              iconRight.className = "menu-item-icon mod-submenu";
              setIcon(iconRight, "chevron-right");
              item.dom?.appendChild(iconRight);
            } catch (_) {
            }
            try {
              if (item.dom) {
                item.dom.addEventListener("mouseenter", (ev) => {
                  openStylesSubmenu(ev, item.dom);
                });
                item.dom.addEventListener("mouseleave", () => {
                  closeMenuTimeout = setTimeout(() => {
                    if (this._openQuickStylesSubmenu) {
                      try {
                        this._openQuickStylesSubmenu.hide();
                      } catch (_) {
                      }
                      this._openQuickStylesSubmenu = null;
                    }
                  }, 300);
                });
              }
            } catch (_) {
            }
            item.onClick((evt) => {
              openStylesSubmenu(evt, item.dom);
            });
          });
        }
        const caseSensitive = !!this.settings.caseSensitive;
        const norm = (s) => caseSensitive ? String(s) : String(s).toLowerCase();
        const a = norm(selectedText);
        const wordEntries = Array.isArray(this.settings.wordEntries) ? this.settings.wordEntries : [];
        const groupsList = Array.isArray(this.settings.wordEntryGroups) ? this.settings.wordEntryGroups : [];
        const matchTypeVal = (mt) => {
          const v = String(mt || "").toLowerCase();
          if (v === "startswith" || v === "starts with") return "startswith";
          if (v === "endswith" || v === "ends with") return "endswith";
          if (v === "contains") return "contains";
          return "exact";
        };
        const matchPattern = (p, mt) => {
          const b = norm(p || "");
          const m = matchTypeVal(mt);
          if (m === "startswith") return a.startsWith(b);
          if (m === "endswith") return a.endsWith(b);
          if (m === "contains") return a.includes(b);
          return a === b;
        };
        const findManualMatch = () => {
          for (let i = 0; i < wordEntries.length; i++) {
            const e = wordEntries[i];
            if (!e || e.isRegex) continue;
            if (Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0) {
              for (const p of e.groupedPatterns) {
                if (matchPattern(p, e.matchType)) {
                  return { container: wordEntries, index: i, entry: e, kind: "grouped", matchedPattern: p };
                }
              }
            } else if (matchPattern(e.pattern || "", e.matchType)) {
              return { container: wordEntries, index: i, entry: e, kind: "literal", matchedPattern: e.pattern || "" };
            }
          }
          for (const g of groupsList) {
            if (!g || !Array.isArray(g.entries)) continue;
            for (let j = 0; j < g.entries.length; j++) {
              const e = g.entries[j];
              if (!e || e.isRegex) continue;
              if (Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0) {
                for (const p of e.groupedPatterns) {
                  if (matchPattern(p, e.matchType)) {
                    return { container: g.entries, index: j, entry: e, kind: "grouped", matchedPattern: p };
                  }
                }
              } else if (matchPattern(e.pattern || "", e.matchType)) {
                return { container: g.entries, index: j, entry: e, kind: "literal", matchedPattern: e.pattern || "" };
              }
            }
          }
          return null;
        };
        const findRegexMatch = () => {
          if (!this.settings.enableRegexSupport) return null;
          for (let i = 0; i < wordEntries.length; i++) {
            const e = wordEntries[i];
            if (!e || !e.isRegex) continue;
            try {
              const re = new RegExp(e.pattern, e.flags || (caseSensitive ? "" : "i"));
              if (re.test(selectedText)) return { container: wordEntries, index: i, entry: e, kind: "regex" };
            } catch (_) {
            }
          }
          for (const g of groupsList) {
            if (!g || !Array.isArray(g.entries)) continue;
            for (let j = 0; j < g.entries.length; j++) {
              const e = g.entries[j];
              if (!e || !e.isRegex) continue;
              try {
                const re = new RegExp(e.pattern, e.flags || (caseSensitive ? "" : "i"));
                if (re.test(selectedText)) return { container: g.entries, index: j, entry: e, kind: "regex" };
              } catch (_) {
              }
            }
          }
          return null;
        };
        const manualMatch = findManualMatch();
        const regexMatch = manualMatch ? null : findRegexMatch();
        if (manualMatch || regexMatch) {
          menu.addItem((item) => {
            item.setTitle(this.t("menu_remove_always_color_text", "Remove Always Color Text")).setIcon("eraser").onClick(async () => {
              if (manualMatch) {
                const { container, index, entry, kind, matchedPattern } = manualMatch;
                if (kind === "grouped" && Array.isArray(entry.groupedPatterns)) {
                  entry.groupedPatterns = entry.groupedPatterns.filter((p) => !(norm(p) === norm(matchedPattern)));
                  if (entry.groupedPatterns.length === 1) {
                    entry.pattern = entry.groupedPatterns[0];
                    entry.groupedPatterns = null;
                  } else if (entry.groupedPatterns.length === 0) {
                    container.splice(index, 1);
                  }
                } else {
                  container.splice(index, 1);
                }
              } else if (regexMatch) {
                const { container, index } = regexMatch;
                container.splice(index, 1);
              }
              await this.saveSettings();
              this.refreshEditor(view, true);
              new Notice(this.t("notice_removed_always_color", `Removed always coloring for "${selectedText}".`, { word: selectedText }));
              if (this.settingTab) {
                this.settingTab._initializedSettingsUI = false;
                this.settingTab.display();
              }
            });
          });
        }
        if (this.settings.enableBlacklistMenu) {
          menu.addItem((item) => {
            item.setTitle(this.t("menu_blacklist_word", "Blacklist Word from Coloring")).setIcon("ban").onClick(async () => {
              const existsLegacy = Array.isArray(this.settings.blacklistWords) && this.settings.blacklistWords.includes(selectedText);
              const existsNew = Array.isArray(this.settings.blacklistEntries) && this.settings.blacklistEntries.some((e) => e && !e.isRegex && String(e.pattern).toLowerCase() === String(selectedText).toLowerCase());
              if (!existsLegacy && !existsNew) {
                if (!Array.isArray(this.settings.blacklistEntries)) this.settings.blacklistEntries = [];
                this.settings.blacklistEntries.push({ pattern: selectedText, isRegex: false, flags: "", groupedPatterns: null });
                await this.saveSettings();
                new Notice(this.t("notice_added_to_blacklist", `"${selectedText}" added to blacklist.`, { word: selectedText }));
                this.refreshEditor(view, true);
                if (this.settingTab && this.settingTab._refreshBlacklistWords) {
                  this.settingTab._refreshBlacklistWords();
                }
              } else {
                new Notice(this.t("notice_already_blacklisted", `"${selectedText}" is already blacklisted.`, { word: selectedText }));
              }
            });
          });
        }
      }
    }));
    if (!this.settings.disableToggleModes.command) {
      this.registerCommandPalette();
    }
    if (this.settings.enabled) {
      this.enablePluginFeatures();
    }
    try {
      this.registerEvent(this.app.workspace.on("layout-ready", () => {
        try {
          this.refreshAllLivePreviewCallouts();
        } catch (_) {
        }
      }));
    } catch (_) {
    }
  }
  registerCommandPalette() {
    try {
      if (this.settings?.disableToggleModes?.command) return;
      if (this._commandsRegistered) return;
      const addTrackedCommand = (cmd) => {
        this._registeredCommandIds.push(cmd.id);
        return this.addCommand(cmd);
      };
      addTrackedCommand({
        id: "set-color-for-selection",
        name: this.t("command_color_selected", "Color Selected Text"),
        editorCallback: (editor, view) => {
          const word = editor.getSelection().trim();
          if (!word) {
            new Notice(this.t("notice_select_text_first", "Please select some text first."));
            return;
          }
          new ColorPickerModal(this.app, this, async (color, result) => {
            const sel = result || {};
            const tc = sel.textColor && this.isValidHexColor(sel.textColor) ? sel.textColor : null;
            const bc = sel.backgroundColor && this.isValidHexColor(sel.backgroundColor) ? sel.backgroundColor : null;
            const selGroupUid = sel.selectedGroupUid || null;
            const matchType = sel.matchType || (this.settings.partialMatch ? "contains" : "exact");
            const applyToArr = (arr) => {
              const idx = arr.findIndex((e) => e && e.pattern === word && !e.isRegex);
              if (idx !== -1) {
                const entry = arr[idx];
                if (tc && bc) {
                  entry.textColor = tc;
                  entry.backgroundColor = bc;
                  entry.color = "";
                  entry.styleType = "both";
                  entry._savedTextColor = tc;
                  entry._savedBackgroundColor = bc;
                } else if (tc) {
                  entry.color = tc;
                  entry.styleType = "text";
                  entry.textColor = null;
                  entry.backgroundColor = null;
                  entry._savedTextColor = tc;
                } else if (bc) {
                  entry.color = "";
                  entry.textColor = "currentColor";
                  entry.backgroundColor = bc;
                  entry.styleType = "highlight";
                  entry._savedBackgroundColor = bc;
                } else if (color && this.isValidHexColor(color)) {
                  entry.color = color;
                  entry.styleType = "text";
                  entry._savedTextColor = color;
                }
                if (!entry.isRegex) entry.matchType = matchType;
              } else {
                if (tc && bc) {
                  arr.push({ pattern: word, color: "", textColor: tc, backgroundColor: bc, isRegex: false, flags: "", styleType: "both", matchType, _savedTextColor: tc, _savedBackgroundColor: bc });
                } else if (tc) {
                  arr.push({ pattern: word, color: tc, isRegex: false, flags: "", styleType: "text", matchType, _savedTextColor: tc });
                } else if (bc) {
                  arr.push({ pattern: word, color: "", textColor: "currentColor", backgroundColor: bc, isRegex: false, flags: "", styleType: "highlight", matchType, _savedBackgroundColor: bc });
                } else if (color && this.isValidHexColor(color)) {
                  arr.push({ pattern: word, color, isRegex: false, flags: "", styleType: "text", matchType, _savedTextColor: color });
                }
              }
            };
            if (selGroupUid) {
              const group = Array.isArray(this.settings.wordEntryGroups) ? this.settings.wordEntryGroups.find((g) => g && g.uid === selGroupUid) : null;
              if (group) {
                if (!Array.isArray(group.entries)) group.entries = [];
                applyToArr(group.entries);
              } else {
                applyToArr(this.settings.wordEntries);
              }
            } else {
              applyToArr(this.settings.wordEntries);
            }
            await this.saveSettings();
            this.compileWordEntries();
            this.compileTextBgColoringEntries();
            this.reconfigureEditorExtensions();
            this.forceRefreshAllEditors();
          }, "text-and-background", word, false).open();
        }
      });
      addTrackedCommand({
        id: "add-to-existing-entry",
        name: this.t("command_add_to_existing_entry", "Add to Existing Entry"),
        editorCallback: (editor, view) => {
          const word = editor.getSelection().trim();
          if (!word) {
            new Notice(this.t("notice_select_text_first", "Please select some text first."));
            return;
          }
          new AddToExistingEntryModal(this.app, this, word, view).open();
        }
      });
      addTrackedCommand({
        id: "toggle-coloring-for-current-document",
        name: (() => {
          try {
            const md = this.app.workspace.getActiveFile();
            if (md && this.settings.disabledFiles && this.settings.disabledFiles.includes(md.path)) {
              return this.t("command_enable_current", "Enable coloring for current document");
            }
          } catch (_) {
          }
          return this.t("command_disable_current", "Disable coloring for current document");
        })(),
        callback: async () => {
          const md = this.app.workspace.getActiveFile();
          if (!md) {
            new Notice(this.t("notice_no_active_file", "No active file to toggle coloring for."));
            return;
          }
          if (this.settings.disabledFiles.includes(md.path)) {
            const index = this.settings.disabledFiles.indexOf(md.path);
            if (index > -1) this.settings.disabledFiles.splice(index, 1);
            await this.saveSettings();
            new Notice(this.t("notice_coloring_enabled_for_path", `Coloring enabled for ${md.path}`, { path: md.path }));
          } else {
            this.settings.disabledFiles.push(md.path);
            await this.saveSettings();
            new Notice(this.t("notice_coloring_disabled_for_path", `Coloring disabled for ${md.path}`, { path: md.path }));
          }
          try {
            this.reregisterCommandsWithLanguage();
          } catch (_) {
          }
        }
      });
      addTrackedCommand({
        id: "toggle-lightweight-mode",
        name: (() => {
          try {
            return this.settings.extremeLightweightMode ? this.t("command_disable_lightweight_mode", "Disable Lightweight Mode") : this.t("command_enable_lightweight_mode", "Enable Lightweight Mode");
          } catch (_) {
          }
          return this.t("command_enable_lightweight_mode", "Enable Lightweight Mode");
        })(),
        callback: async () => {
          this.settings.extremeLightweightMode = !this.settings.extremeLightweightMode;
          await this.saveSettings();
          new Notice(this.settings.extremeLightweightMode ? this.t("notice_lightweight_mode_enabled", "Lightweight Mode enabled") : this.t("notice_lightweight_mode_disabled", "Lightweight Mode disabled"));
          this.reregisterCommandsWithLanguage();
          this.forceRefreshAllEditors();
        }
      });
      addTrackedCommand({
        id: "color-highlight-once-selected-text",
        name: this.t("command_color_highlight_once", "Color / Highlight Once Selected Text"),
        editorCallback: (editor, view) => {
          const word = editor.getSelection().trim();
          if (!word) {
            new Notice(this.t("notice_select_text_first_once", "Please select text first to color/highlight once."));
            return;
          }
          new ColorPickerModal(this.app, this, async (color, result) => {
            const sel = result || {};
            const tc = sel.textColor && this.isValidHexColor(sel.textColor) ? sel.textColor : null;
            const bc = sel.backgroundColor && this.isValidHexColor(sel.backgroundColor) ? sel.backgroundColor : null;
            if (!tc && !bc) return;
            const styleParts = [];
            if (tc) styleParts.push(`color: ${tc}`);
            if (bc) {
              const op = typeof this.settings.backgroundOpacity === "number" ? this.settings.backgroundOpacity : 25;
              const rgba = this.hexToRgba(bc, op);
              styleParts.push(`background-color: ${rgba}`);
              let applyStyles = false;
              let hPad = 0, vPad = 0, radius = 0;
              let borderCss = "";
              if (this.settings.quickHighlightUseGlobalStyle) {
                applyStyles = true;
                hPad = typeof this.settings.highlightHorizontalPadding === "number" ? this.settings.highlightHorizontalPadding : 4;
                vPad = typeof this.settings.highlightVerticalPadding === "number" ? this.settings.highlightVerticalPadding : 0;
                radius = typeof this.settings.highlightBorderRadius === "number" ? this.settings.highlightBorderRadius : 8;
                if (this.settings.enableBorderThickness) {
                  borderCss = this.generateGlobalBorderStyle(bc);
                }
              } else if (this.settings.quickHighlightStyleEnable) {
                applyStyles = true;
                hPad = typeof this.settings.quickHighlightHorizontalPadding === "number" ? this.settings.quickHighlightHorizontalPadding : 4;
                vPad = typeof this.settings.quickHighlightVerticalPadding === "number" ? this.settings.quickHighlightVerticalPadding : 0;
                radius = typeof this.settings.quickHighlightBorderRadius === "number" ? this.settings.quickHighlightBorderRadius : 8;
                if (this.settings.quickHighlightEnableBorder) {
                  borderCss = this.generateOnceBorderStyle(bc);
                }
              }
              if (applyStyles) {
                styleParts.push(`padding: ${vPad}px ${hPad}px`);
                styleParts.push(`border-radius: ${radius}px`);
                if (this.settings.enableBoxDecorationBreak ?? true) {
                  styleParts.push(`box-decoration-break: clone`);
                  styleParts.push(`-webkit-box-decoration-break: clone`);
                }
                if (borderCss) {
                  const borderParts = borderCss.split(";").map((s) => s.trim()).filter((s) => s);
                  borderParts.forEach((bp) => styleParts.push(bp));
                }
              }
            }
            if (styleParts.length > 0) {
              const span = `<span style="${styleParts.join("; ")}">${word}</span>`;
              editor.replaceSelection(span);
            }
          }, "text-and-background", word, true).open();
        }
      });
      addTrackedCommand({
        id: "toggle-always-color-text",
        name: this.settings.enabled ? this.t("command_disable_global", "Disable Global Coloring") : this.t("command_enable_global", "Enable Global Coloring"),
        callback: async () => {
          this.settings.enabled = !this.settings.enabled;
          await this.saveSettings();
          new Notice(this.settings.enabled ? this.t("notice_global_enabled", "Always Color Text Enabled") : this.t("notice_global_disabled", "Always Color Text Disabled"));
          this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
          this.reconfigureEditorExtensions();
          this.forceRefreshAllEditors();
          this.forceRefreshAllReadingViews();
          if (this.settings.enabled) {
            this.removeDisabledNeutralizerStyles();
          } else {
            this.applyDisabledNeutralizerStyles();
            this.clearAllHighlights();
          }
          try {
            if (this.settings.enabled) {
              if (!this.settings.disableLivePreviewColoring) {
                this.applyEnabledLivePreviewCalloutStyles();
              } else {
                this.removeEnabledLivePreviewCalloutStyles();
              }
              this.applyEnabledReadingCalloutStyles();
            } else {
              this.removeEnabledLivePreviewCalloutStyles();
              this.removeEnabledReadingCalloutStyles();
            }
            if (!this.settings.disableLivePreviewColoring) {
              this.refreshAllLivePreviewCallouts();
              this.forceReprocessLivePreviewCallouts();
            }
          } catch (_) {
          }
          try {
            this.reregisterCommandsWithLanguage();
          } catch (_) {
          }
        }
      });
      addTrackedCommand({
        id: "show-latest-release-notes",
        name: this.t("command_show_release_notes", "Show Latest Release Notes"),
        callback: async () => {
          try {
            new ChangelogModal(this.app, this).open();
          } catch (e) {
            new Notice(this.t("notice_unable_open_changelog", "Unable to open changelog modal."));
          }
        }
      });
      addTrackedCommand({
        id: "manage-colored-texts",
        name: this.t("command_manage_colored_texts", "Manage Colored Texts"),
        callback: () => {
          try {
            this.app.setting.open();
            const tabId = this.manifest && this.manifest.id || "always-color-text";
            try {
              this.app.setting.openTabById(tabId);
            } catch (e) {
            }
            setTimeout(() => {
              try {
                const el = document.querySelector("#always-colored-texts-header");
                if (el && el.scrollIntoView) el.scrollIntoView({ behavior: "smooth", block: "start" });
              } catch (_) {
              }
            }, 100);
          } catch (_) {
          }
        }
      });
      addTrackedCommand({
        id: "open-regex-tester",
        name: this.t("command_open_regex_tester", "Add Regex (Open Regex Tester)"),
        callback: () => {
          try {
            new RealTimeRegexTesterModal(this.app, this, async (entry) => {
              if (!entry) return;
              try {
                this.settingTab && (this.settingTab._suspendSorting = true);
              } catch (e) {
              }
              if (!Array.isArray(this.settings.wordEntries)) this.settings.wordEntries = [];
              const idx = this.settings.wordEntries.findIndex((e) => e && e.pattern === entry.pattern && e.isRegex);
              if (idx !== -1) {
                const existing = this.settings.wordEntries[idx];
                existing.pattern = entry.pattern;
                existing.color = entry.color;
                existing.textColor = entry.textColor;
                existing.backgroundColor = entry.backgroundColor;
                existing.styleType = entry.styleType;
                existing.flags = entry.flags;
                existing.presetLabel = entry.presetLabel || existing.presetLabel || void 0;
                existing.persistAtEnd = true;
              } else {
                entry.persistAtEnd = true;
                this.settings.wordEntries.push(entry);
              }
              try {
                this.settingTab && entry && entry.uid && this.settingTab._newEntriesSet && this.settingTab._newEntriesSet.add(entry.uid);
              } catch (e) {
              }
              await this.saveSettings();
              this.compileWordEntries();
              this.compileTextBgColoringEntries();
              this.reconfigureEditorExtensions();
              this.forceRefreshAllEditors();
              this.forceRefreshAllReadingViews();
            }).open();
          } catch (e) {
            new Notice(this.t("notice_error_opening_regex_tester", "Error opening regex tester"));
          }
        }
      });
      addTrackedCommand({
        id: "open-blacklist-regex-tester",
        name: this.t("command_open_blacklist_regex_tester", "Add Blacklist Regex"),
        callback: () => {
          try {
            new BlacklistRegexTesterModal(this.app, this, async (entry) => {
              if (!entry) return;
              try {
                this.settingTab && (this.settingTab._suspendSorting = true);
              } catch (e) {
              }
              if (!Array.isArray(this.settings.blacklistEntries)) this.settings.blacklistEntries = [];
              const idx = this.settings.blacklistEntries.findIndex((e) => e && e.pattern === entry.pattern && e.isRegex);
              if (idx !== -1) {
                const existing = this.settings.blacklistEntries[idx];
                existing.pattern = entry.pattern;
                existing.flags = entry.flags;
                existing.presetLabel = entry.presetLabel || existing.presetLabel || void 0;
                existing.persistAtEnd = true;
              } else {
                entry.persistAtEnd = true;
                this.settings.blacklistEntries.push(entry);
              }
              try {
                this.settingTab && entry && entry.uid && this.settingTab._blacklistNewSet && this.settingTab._blacklistNewSet.add(entry.uid);
              } catch (e) {
              }
              await this.saveSettings();
              this.reconfigureEditorExtensions();
              this.forceRefreshAllEditors();
              this.forceRefreshAllReadingViews();
            }).open();
          } catch (e) {
            new Notice(this.t("notice_error_opening_blacklist_regex_tester", "Error opening blacklist regex tester"));
          }
        }
      });
      addTrackedCommand({
        id: "toggle-hide-text-colors",
        name: this.settings.hideTextColors ? this.t("command_unhide_text_colors", "Unhide Text Colors") : this.t("command_hide_text_colors", "Hide Text Colors"),
        callback: async () => {
          try {
            this.settings.hideTextColors = !this.settings.hideTextColors;
            if (this.settings.hideTextColors && this.settings.hideHighlights) {
              this.settings.hideHighlights = false;
            }
            await this.saveSettings();
            this.reregisterCommandsWithLanguage();
            this._cacheDirty = true;
            this.removeEnabledReadingCalloutStyles();
            if (this.settings.enabled && !this.settings.hideTextColors) {
              this.applyEnabledReadingCalloutStyles();
            }
            this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
            this.reconfigureEditorExtensions();
            this.forceRefreshAllEditors();
            this.forceRefreshAllReadingViews();
            if (!this.settings.disableLivePreviewColoring) {
              try {
                this.refreshAllLivePreviewCallouts();
              } catch (_) {
              }
              try {
                this.forceReprocessLivePreviewCallouts();
              } catch (_) {
              }
              try {
                this.refreshAllLivePreviewTables();
              } catch (_) {
              }
              try {
                this.forceReprocessLivePreviewTables();
              } catch (_) {
              }
            }
            try {
              this.refreshAllBasesViews();
            } catch (_) {
            }
            try {
              this.forceReprocessBasesViews();
            } catch (_) {
            }
            const msg = this.settings.hideTextColors ? this.t("notice_text_colors_hidden", "Text colors hidden") : this.t("notice_text_colors_visible", "Text colors visible");
            new Notice(msg);
          } catch (_) {
          }
        }
      });
      addTrackedCommand({
        id: "toggle-hide-highlights",
        name: this.settings.hideHighlights ? this.t("command_unhide_highlights", "Unhide Highlights") : this.t("command_hide_highlights", "Hide Highlights"),
        callback: async () => {
          try {
            this.settings.hideHighlights = !this.settings.hideHighlights;
            if (this.settings.hideHighlights && this.settings.hideTextColors) {
              this.settings.hideTextColors = false;
            }
            await this.saveSettings();
            this.reregisterCommandsWithLanguage();
            this._cacheDirty = true;
            this.removeEnabledReadingCalloutStyles();
            if (this.settings.enabled && !this.settings.hideHighlights) {
              this.applyEnabledReadingCalloutStyles();
            }
            if (this.settings.hideHighlights) {
              this.applyHideHighlightsNeutralizerStyles();
              this.neutralizeExistingHighlightBackgrounds();
            } else {
              this.removeHideHighlightsNeutralizerStyles();
            }
            this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
            this.reconfigureEditorExtensions();
            this.forceRefreshAllEditors();
            this.forceRefreshAllReadingViews();
            if (!this.settings.disableLivePreviewColoring) {
              try {
                this.refreshAllLivePreviewCallouts();
              } catch (_) {
              }
              try {
                this.forceReprocessLivePreviewCallouts();
              } catch (_) {
              }
              try {
                this.refreshAllLivePreviewTables();
              } catch (_) {
              }
              try {
                this.forceReprocessLivePreviewTables();
              } catch (_) {
              }
            }
            try {
              this.refreshAllBasesViews();
            } catch (_) {
            }
            try {
              this.forceReprocessBasesViews();
            } catch (_) {
            }
            const msg = this.settings.hideHighlights ? this.t("notice_highlights_hidden", "Highlights hidden") : this.t("notice_highlights_visible", "Highlights visible");
            new Notice(msg);
          } catch (_) {
          }
        }
      });
      if (this.settings?.showWordGroupsInCommands) {
        this.registerWordGroupCommands();
      }
      if (this.settings?.showBlacklistGroupsInCommands) {
        this.registerBlacklistGroupCommands();
      }
      this._commandsRegistered = true;
    } catch (e) {
    }
  }
  // Register word group commands
  registerWordGroupCommands() {
    try {
      const groups = Array.isArray(this.settings.wordEntryGroups) ? this.settings.wordEntryGroups : [];
      groups.forEach((group) => {
        if (!group) return;
        const groupName = String(group.name || "").trim();
        if (!groupName) return;
        if (!group.uid) {
          try {
            group.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (_) {
          }
        }
        const isActive = group.active;
        const commandId = `toggle-word-group-${group.uid}`;
        const commandName = isActive ? this.t("command_deactivate_word_group", "Deactivate {groupName} Word Group", { groupName }) : this.t("command_activate_word_group", "Activate {groupName} Word Group", { groupName });
        try {
          this._registeredCommandIds.push(commandId);
        } catch (_) {
        }
        this.addCommand({
          id: commandId,
          name: commandName,
          callback: async () => {
            try {
              const latestGroup = Array.isArray(this.settings.wordEntryGroups) ? this.settings.wordEntryGroups.find((g) => g && g.uid === group.uid) : null;
              if (!latestGroup) return;
              latestGroup.active = !latestGroup.active;
              await this.saveSettings();
              this.reregisterCommandsWithLanguage();
              const latestGroupName = String(latestGroup.name || groupName || "").trim();
              const status = latestGroup.active ? this.t("notice_word_group_activated", `Word group "${latestGroupName}" activated`) : this.t("notice_word_group_deactivated", `Word group "${latestGroupName}" deactivated`);
              new Notice(status);
              this._cacheDirty = true;
              this.reconfigureEditorExtensions();
              this.forceRefreshAllEditors();
              this.forceRefreshAllReadingViews();
            } catch (e) {
              debugError("COMMANDS", "Error toggling word group:", e);
            }
          }
        });
      });
    } catch (e) {
      debugError("COMMANDS", "Error registering word group commands:", e);
    }
  }
  // Register blacklist group commands
  registerBlacklistGroupCommands() {
    try {
      const groups = Array.isArray(this.settings.blacklistEntryGroups) ? this.settings.blacklistEntryGroups : [];
      groups.forEach((group) => {
        if (!group) return;
        const groupName = String(group.name || "").trim();
        if (!groupName) return;
        if (!group.uid) {
          try {
            group.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (_) {
          }
        }
        const isActive = group.active;
        const commandId = `toggle-blacklist-group-${group.uid}`;
        const commandName = isActive ? this.t("command_deactivate_blacklist_group", "Deactivate {groupName} Blacklist Group", { groupName }) : this.t("command_activate_blacklist_group", "Activate {groupName} Blacklist Group", { groupName });
        try {
          this._registeredCommandIds.push(commandId);
        } catch (_) {
        }
        this.addCommand({
          id: commandId,
          name: commandName,
          callback: async () => {
            try {
              const latestGroup = Array.isArray(this.settings.blacklistEntryGroups) ? this.settings.blacklistEntryGroups.find((g) => g && g.uid === group.uid) : null;
              if (!latestGroup) return;
              latestGroup.active = !latestGroup.active;
              await this.saveSettings();
              this.reregisterCommandsWithLanguage();
              const latestGroupName = String(latestGroup.name || groupName || "").trim();
              const status = latestGroup.active ? this.t("notice_blacklist_group_activated", `Blacklist group "${latestGroupName}" activated`) : this.t("notice_blacklist_group_deactivated", `Blacklist group "${latestGroupName}" deactivated`);
              new Notice(status);
              this._cacheDirty = true;
              this.reconfigureEditorExtensions();
              this.forceRefreshAllEditors();
              this.forceRefreshAllReadingViews();
            } catch (e) {
              debugError("COMMANDS", "Error toggling blacklist group:", e);
            }
          }
        });
      });
    } catch (e) {
      debugError("COMMANDS", "Error registering blacklist group commands:", e);
    }
  }
  removeRegisteredCommands() {
    try {
      const pluginId = this.manifest && this.manifest.id || "always-color-text";
      const removeCommandSafe = (fullId) => {
        try {
          if (this.app && this.app.commands && typeof this.app.commands.removeCommand === "function") {
            this.app.commands.removeCommand(fullId);
          }
        } catch (_) {
        }
      };
      const ids = Array.isArray(this._registeredCommandIds) ? Array.from(new Set(this._registeredCommandIds)) : [];
      ids.forEach((id) => {
        if (!id) return;
        removeCommandSafe(`${pluginId}:${id}`);
        removeCommandSafe(id);
      });
      try {
        const cmds = this.app && this.app.commands && this.app.commands.commands;
        if (cmds && typeof cmds === "object") {
          Object.keys(cmds).forEach((fullId) => {
            if (!fullId) return;
            if (fullId.startsWith(`${pluginId}:toggle-word-group-`) || fullId.startsWith(`${pluginId}:toggle-blacklist-group-`)) {
              removeCommandSafe(fullId);
            }
          });
        }
      } catch (_) {
      }
    } catch (_) {
    }
  }
  // Re-register commands with updated language
  reregisterCommandsWithLanguage() {
    try {
      if (this.settings?.disableToggleModes?.command) return;
      this.removeRegisteredCommands();
      this._commandsRegistered = false;
      this._registeredCommandIds = [];
      this.registerCommandPalette();
    } catch (e) {
      debugError("SETTINGS", "Error re-registering commands with new language:", e);
    }
  }
  // --- Regex complexity checker to avoid catastrophic patterns ---
  isRegexTooComplex(pattern) {
    if (!pattern || typeof pattern !== "string") return true;
    if (this.containsNonRomanCharacters(pattern)) {
      return false;
    }
    const safePatterns = [
      "\\b\\d+(?:\\.\\d+)?(?:kg|cm|m|km|\xB0C|\xB0F|lbs)\\b"
      // Measurements (kg, cm, m, km, C, F, lbs)
    ];
    if (safePatterns.includes(pattern)) return false;
    const dangerousPatterns = [
      /\(\?[=!<]/,
      // Lookarounds
      /\(\?[<][=!]/,
      // Lookbehinds
      /\*\+|\+\*/,
      // Adjacent quantifiers
      /\(\w+\)[*+][*+]/,
      // Nested quantifiers
      /\{[^}]*\{[^}]*\}/,
      // Nested quantifier ranges
      /\[[^\]]*\[[^\]]*\]/
      // Nested character classes
    ];
    if (dangerousPatterns.some((p) => p.test(pattern))) return true;
    if (pattern.length > 100) return true;
    const alternations = (pattern.match(/\|/g) || []).length;
    const quantifiers = (pattern.match(/[*+?{]/g) || []).length;
    const groups = (pattern.match(/\([^?]/g) || []).length;
    if (alternations > 5 || quantifiers > 10 || groups > 5) return true;
    try {
      const start = Date.now();
      new RegExp(pattern);
      if (Date.now() - start > 10) return true;
    } catch (e) {
      return true;
    }
    return false;
  }
  validateAndSanitizeRegex(pattern) {
    if (typeof pattern !== "string" || !pattern) return false;
    if (!this.settings.disableRegexSafety && this.isKnownProblematicPattern(pattern)) return false;
    if (!this.settings.disableRegexSafety && this.isRegexTooComplex(pattern)) return false;
    return true;
  }
  sanitizePattern(pattern, isRegex) {
    if (typeof pattern !== "string") return "";
    let p = String(pattern).trim();
    p = this.decodeHtmlEntities(p);
    if (isRegex && p.length > 200) throw new Error("Pattern too long");
    return p;
  }
  decodeHtmlEntities(text) {
    if (!text || typeof text !== "string") return text;
    text = text.replace(/&#(\d+);/g, (m, dec) => String.fromCharCode(dec));
    text = text.replace(/&#x([0-9A-Fa-f]+);/g, (m, hex) => String.fromCharCode(parseInt(hex, 16)));
    const entities = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'",
      "&nbsp;": " ",
      "&copy;": "\xA9",
      "&reg;": "\xAE",
      "&trade;": "\u2122",
      "&hellip;": "\u2026",
      "&mdash;": "\u2014",
      "&ndash;": "\u2013",
      "&bull;": "\u2022",
      "&check;": "\u2713",
      "&checkmark;": "\u2713",
      "&rarr;": "\u2192",
      "&rightarrow": "\u2192",
      "&larr;": "\u2190",
      "&leftarrow": "\u2190",
      "&uarr;": "\u2191",
      "&uparrow": "\u2191",
      "&darr;": "\u2193",
      "&downarrow": "\u2193"
    };
    return text.replace(/&[#a-zA-Z0-9]+;/g, (m) => entities[m] || m);
  }
  // NEW HELPER METHOD: Detect non-Roman characters
  containsNonRomanCharacters(text) {
    if (!text) return false;
    return /[^\u0000-\u007F\u00A0-\u00FF\u0100-\u017F\u0180-\u024F]/.test(text);
  }
  // NEW HELPER: Count non-Roman characters
  countNonRomanCharacters(text) {
    if (!text) return 0;
    const nonRomanMatches = text.match(/[^\u0000-\u007F\u00A0-\u00FF\u0100-\u017F\u0180-\u024F]/g);
    return nonRomanMatches ? nonRomanMatches.length : 0;
  }
  // NEW HELPER: Get the ratio of non-Roman characters in text
  getNonRomanCharacterRatio(text) {
    if (!text || typeof text !== "string") return 0;
    const totalChars = text.length;
    if (totalChars === 0) return 0;
    return this.countNonRomanCharacters(text) / totalChars;
  }
  // NEW METHOD: Detect if pattern is simple (no regex needed)
  isSimplePattern(pattern) {
    if (!pattern || typeof pattern !== "string") return false;
    const decodedPattern = this.decodeHtmlEntities(pattern);
    const isSimple = /^[\w\s\u00A0-\u00FF\u2000-\u206F\u25A0-\u25FF\u2700-\u27BF+\-=*/.()&;]+$/.test(decodedPattern);
    if (pattern.includes("\u2713") || decodedPattern.includes("\u2713")) {
      debugLog("ISIMPLE", { pattern, decodedPattern, isSimple });
    }
    return isSimple;
  }
  // NEW METHOD: Ultra-fast simple pattern processing
  processSimplePatternsOptimized(element, simpleEntries, folderEntry = null, options = {}) {
    debugLog("SIMPLE", `Processing ${simpleEntries.length} simple patterns`);
    const blockTags = ["P", "LI", "DIV", "SPAN", "TD", "TH", "BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6"];
    const effectiveStyle = "text";
    const allElements = element.querySelectorAll?.("*") || [];
    const blocks = [];
    for (const el of allElements) {
      if (blockTags.includes(el.nodeName) && !el.closest("code, pre")) {
        blocks.push(el);
      }
    }
    for (const block of blocks) {
      if (block.closest("code, pre")) continue;
      this.processBlockWithSimplePatterns(block, simpleEntries, folderEntry, effectiveStyle, options.filePath);
    }
  }
  // NEW METHOD: Process block with simple string matching
  processBlockWithSimplePatterns(block, simpleEntries, folderEntry, effectiveStyle, filePath = null) {
    try {
      if (block && (block.classList?.contains("act-skip-coloring") || block.closest?.(".act-skip-coloring"))) return;
    } catch (_) {
    }
    const walker = document.createTreeWalker(
      block,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: function(node2) {
          if (node2.parentElement?.closest("code, pre")) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node2.parentElement?.closest(".always-color-text-highlight")) {
            return NodeFilter.FILTER_REJECT;
          }
          try {
            if (node2.parentElement?.closest(".act-skip-coloring")) return NodeFilter.FILTER_REJECT;
          } catch (_) {
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      },
      false
    );
    let node;
    while (node = walker.nextNode()) {
      let text = node.textContent;
      if (!text) continue;
      const originalText = text;
      text = this.decodeHtmlEntities(text);
      let matches = [];
      for (const entry of simpleEntries) {
        let pattern = entry.pattern;
        pattern = this.decodeHtmlEntities(pattern);
        let pos = 0;
        while ((pos = text.indexOf(pattern, pos)) !== -1) {
          matches.push({
            start: pos,
            end: pos + pattern.length,
            entry,
            folderEntry
          });
          pos += pattern.length;
          if (matches.length > 50) break;
        }
        if (matches.length > 50) break;
      }
      {
        let vpInput;
        new Setting(containerEl).setName(this.plugin.t("highlight_vertical_padding", "Highlight vertical padding (px)")).setDesc(this.plugin.t("highlight_vertical_padding_desc", "Set the top and bottom padding (in px) for highlighted text")).addText((text2) => {
          vpInput = text2;
          text2.setPlaceholder("e.g. 0, 1, 2").setValue(String(this.plugin.settings.highlightVerticalPadding ?? 0)).onChange(async (v) => {
            let val = parseInt(v);
            if (isNaN(val)) val = 0;
            this.plugin.settings.highlightVerticalPadding = val;
            await this.debouncedSaveSettings();
            updatePreview();
          });
        }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_0", "Reset to 0")).onClick(async () => {
          this.plugin.settings.highlightVerticalPadding = 0;
          await this.debouncedSaveSettings();
          if (vpInput) vpInput.setValue("0");
          updatePreview();
        }));
      }
      if (matches.length > 0) {
        this.applySimpleHighlights(node, matches, text, filePath);
      }
    }
  }
  processMarkdownFormattingInReading(element, folderEntry = null, entries = null, filePath = null) {
    try {
      let we;
      if (Array.isArray(entries) && entries.length > 0) {
        we = entries;
      } else {
        let weAll2 = Array.isArray(this.settings.wordEntries) ? this.settings.wordEntries.slice() : [];
        if (Array.isArray(this.settings.wordEntryGroups)) {
          this.settings.wordEntryGroups.forEach((group) => {
            if (group && group.active && Array.isArray(group.entries)) {
              const groupCase = typeof group.caseSensitiveOverride === "boolean" ? group.caseSensitiveOverride : void 0;
              const groupMatch = typeof group.matchTypeOverride === "string" && group.matchTypeOverride ? group.matchTypeOverride : void 0;
              const mapped = group.entries.map((e) => {
                const copy = Object.assign({}, e);
                if (groupMatch) copy.matchType = groupMatch;
                if (groupCase !== void 0) copy._caseSensitiveOverride = groupCase;
                return copy;
              });
              weAll2 = weAll2.concat(mapped);
            }
          });
        }
        we = weAll2;
      }
      const blEntries = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
      try {
        const markElements = element && element.nodeName === "MARK" ? [element] : Array.from(element.querySelectorAll?.("mark") || []);
        for (const mark of markElements) {
          try {
            mark.classList.add("always-color-text-highlight-marks");
          } catch (_) {
          }
          const styledSpan = mark.querySelector("span.always-color-text-highlight");
          const fallbackSpan = styledSpan || mark.querySelector(".always-color-text-highlight") || mark;
          try {
            if (fallbackSpan && fallbackSpan !== mark && fallbackSpan.classList) {
              fallbackSpan.classList.add("always-color-text-highlight-marks");
            }
          } catch (_) {
          }
          const markText = mark.textContent || "";
          let folderForMark = null;
          try {
            folderForMark = this.getBestFolderEntry(filePath);
          } catch (_) {
          }
          const qsEnabled = !!this.settings.quickStylesEnabled;
          const qsArr = Array.isArray(this.settings.quickStyles) ? this.settings.quickStyles : [];
          const mt = String(markText || "").trim();
          let quickStyle = null;
          if (qsEnabled && qsArr.length > 0 && mt.length > 0) {
            const lc = mt.toLowerCase();
            quickStyle = qsArr.find((s) => s && typeof s.name === "string" && s.name.toLowerCase() === lc) || null;
          }
          const findHighlightEntry = (entries2) => {
            if (!Array.isArray(entries2)) return null;
            const reversed = [...entries2].reverse();
            return reversed.find((e) => e && (e.presetLabel === "Highlighted Text (==...)" || e.presetLabel === "Highlights (====)" || e.affectMarkElements || e.styleType === "highlight" && !e.targetElement));
          };
          const presetEntry = findHighlightEntry(we) || findHighlightEntry(weAll) || null;
          const highlightRegexEntry = presetEntry || (we.find((e) => e && e.isRegex && typeof e.pattern === "string" && e.pattern.includes("==[\\s\\S]*?==")) || weAll.find((e) => e && e.isRegex && typeof e.pattern === "string" && e.pattern.includes("==[\\s\\S]*?=="))) || null;
          if (quickStyle) {
            const params = this.getHighlightParams(quickStyle);
            const styleType2 = quickStyle.styleType || "both";
            const tc = quickStyle.textColor || quickStyle.color || null;
            const bc = quickStyle.backgroundColor || null;
            if (bc) {
              const bgRgba = this.hexToRgba(bc, params.opacity);
              fallbackSpan.style.setProperty("background-color", bgRgba, "important");
              try {
                mark.style.setProperty("background-color", bgRgba, "important");
              } catch (_) {
              }
              try {
                fallbackSpan.style.setProperty("--highlight-background", bgRgba);
              } catch (_) {
              }
              try {
                mark.style.setProperty("--highlight-background", bgRgba);
              } catch (_) {
              }
            }
            if (tc) {
              fallbackSpan.style.setProperty("color", tc, "important");
              fallbackSpan.style.setProperty("--highlight-color", tc);
              try {
                mark.style.setProperty("color", tc, "important");
              } catch (_) {
              }
              try {
                mark.style.setProperty("--highlight-color", tc);
              } catch (_) {
              }
            }
            fallbackSpan.style.setProperty("padding-left", params.hPad + "px", "important");
            fallbackSpan.style.setProperty("padding-right", params.hPad + "px", "important");
            const vpad = params.vPad;
            fallbackSpan.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
            fallbackSpan.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
            const br = params.hPad > 0 && params.radius === 0 ? 0 : params.radius;
            fallbackSpan.style.setProperty("border-radius", br + "px", "important");
            try {
              const borderCss = this.generateBorderStyle(tc, bc, quickStyle);
              if (borderCss) {
                fallbackSpan.style.cssText += borderCss;
              }
              if (borderCss) {
                mark.style.cssText += borderCss;
              }
            } catch (_) {
            }
          } else if (presetEntry || highlightRegexEntry) {
            const entryForMark = presetEntry || highlightRegexEntry;
            const params = this.getHighlightParams(entryForMark);
            const tc = entryForMark.textColor && entryForMark.textColor !== "currentColor" ? entryForMark.textColor : entryForMark.color || null;
            const bc = entryForMark.backgroundColor || null;
            if (bc) {
              const bgRgba = this.hexToRgba(bc, params.opacity);
              fallbackSpan.style.setProperty("background-color", bgRgba, "important");
              try {
                mark.style.setProperty("background-color", bgRgba, "important");
              } catch (_) {
              }
              try {
                fallbackSpan.style.setProperty("--highlight-background", bgRgba);
              } catch (_) {
              }
              try {
                mark.style.setProperty("--highlight-background", bgRgba);
              } catch (_) {
              }
            }
            if (tc) {
              fallbackSpan.style.setProperty("color", tc, "important");
              fallbackSpan.style.setProperty("--highlight-color", tc);
              try {
                mark.style.setProperty("color", tc, "important");
              } catch (_) {
              }
              try {
                mark.style.setProperty("--highlight-color", tc);
              } catch (_) {
              }
            }
            fallbackSpan.style.setProperty("padding-left", params.hPad + "px", "important");
            fallbackSpan.style.setProperty("padding-right", params.hPad + "px", "important");
            const vpad = params.vPad;
            fallbackSpan.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
            fallbackSpan.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
            const br = params.hPad > 0 && params.radius === 0 ? 0 : params.radius;
            fallbackSpan.style.setProperty("border-radius", br + "px", "important");
            try {
              const borderCss = this.generateBorderStyle(tc, bc, entryForMark);
              if (borderCss) {
                fallbackSpan.style.cssText += borderCss;
              }
              if (borderCss) {
                mark.style.cssText += borderCss;
              }
            } catch (_) {
            }
          }
        }
      } catch (e) {
        console.error("Always Color Text: Error handling mark elements", e);
      }
      const taskCheckedEntry = we.find((e) => e && e.presetLabel === "Task List (Checked)");
      const taskUncheckedEntry = we.find((e) => e && e.presetLabel === "Task List (Unchecked)");
      const bulletEntry = we.find((e) => e && e.presetLabel === "Bullet Points");
      const numberedEntry = we.find((e) => e && e.presetLabel === "Numbered Lists");
      const codeblockEntry = we.find((e) => e && e.presetLabel === "Codeblocks");
      const hasTaskCheckedBlacklist = !!blEntries.find((e) => e && e.presetLabel === "Task List (Checked)" && !!e.isRegex);
      const hasTaskUncheckedBlacklist = !!blEntries.find((e) => e && e.presetLabel === "Task List (Unchecked)" && !!e.isRegex);
      const hasBulletBlacklist = !!blEntries.find((e) => e && e.presetLabel === "Bullet Points" && !!e.isRegex);
      const hasNumberedBlacklist = !!blEntries.find((e) => e && e.presetLabel === "Numbered Lists" && !!e.isRegex);
      const hasCodeblockBlacklist = !!blEntries.find((e) => e && e.presetLabel === "Codeblocks" && !!e.isRegex);
      if (hasCodeblockBlacklist || codeblockEntry) {
        const potentialCodeblocks = [];
        element.querySelectorAll?.("pre, code").forEach((el) => potentialCodeblocks.push(el));
        element.querySelectorAll?.(".markdown-rendered pre").forEach((el) => {
          if (!potentialCodeblocks.includes(el)) potentialCodeblocks.push(el);
        });
        element.querySelectorAll?.("div").forEach((div) => {
          const text = div.textContent || "";
          const classes = (div.className || "").toLowerCase();
          if ((classes.includes("code") || classes.includes("language-") || div.querySelector("code") && div.children.length < 5) && !potentialCodeblocks.includes(div)) {
            potentialCodeblocks.push(div);
          }
        });
        if (element && (element.nodeName === "CODE" || element.nodeName === "PRE" || element.className && element.className.includes("language-"))) {
          if (!potentialCodeblocks.includes(element)) potentialCodeblocks.push(element);
        }
        const processedElements = /* @__PURE__ */ new Set();
        for (const cb of potentialCodeblocks) {
          if (processedElements.has(cb)) continue;
          processedElements.add(cb);
          if (hasCodeblockBlacklist) {
            try {
              cb.classList.add("act-skip-coloring");
              cb.style.color = "";
              const highlights = cb.querySelectorAll("span.always-color-text-highlight");
              for (const ex of highlights) {
                const tn = document.createTextNode(ex.textContent);
                ex.replaceWith(tn);
              }
            } catch (_) {
            }
          } else if (codeblockEntry) {
            try {
              this._colorCodeblockContent(cb, codeblockEntry);
            } catch (e) {
              debugError("CODEBLOCK_COLOR", "Failed to color codeblock", e);
            }
          }
        }
      }
      if (!taskCheckedEntry && !taskUncheckedEntry && !bulletEntry && !numberedEntry) return;
      let listItems = Array.from(element.querySelectorAll?.("li") || []);
      if (element && element.nodeName === "LI" && listItems.length === 0) listItems = [element];
      try {
        debugLog("MARKDOWN_FORMAT", `Found ${listItems.length} list items (node=${element.nodeName})`);
      } catch (_) {
      }
      for (const li of listItems) {
        if (li.closest("code, pre")) continue;
        const contentText = this.extractListItemContent(li);
        const contentBlacklisted = this.containsBlacklistedWord(contentText, filePath);
        try {
          debugLog("MARKDOWN_FORMAT", "LI", {
            innerHTML: (li.innerHTML || "").substring(0, 100),
            textContent: (li.textContent || "").substring(0, 100),
            hasCheckbox: !!li.querySelector('input[type="checkbox"]'),
            parentTag: li.parentElement?.tagName
          });
        } catch (_) {
        }
        const hasTaskAttr = li.getAttribute("data-task");
        const checkbox = li.querySelector('input[type="checkbox"]');
        const isTaskItem = hasTaskAttr !== null || checkbox !== null;
        if (isTaskItem && (taskCheckedEntry || taskUncheckedEntry)) {
          const isChecked = hasTaskAttr === "x" || hasTaskAttr === "X" || checkbox && checkbox.checked;
          const entry = isChecked ? taskCheckedEntry : taskUncheckedEntry;
          const blocked = isChecked && hasTaskCheckedBlacklist || !isChecked && hasTaskUncheckedBlacklist;
          if (blocked) {
            try {
              li.classList.add("act-skip-coloring");
              li.classList.remove("act-colored-list-item");
              li.style.removeProperty("--act-marker-color");
              li.style.color = "";
              const highlights = li.querySelectorAll("span.always-color-text-highlight");
              for (const ex of highlights) {
                const tn = document.createTextNode(ex.textContent);
                ex.replaceWith(tn);
              }
            } catch (_) {
            }
            continue;
          }
          if (entry) {
            if (!contentBlacklisted) this._colorListItemContent(li, entry);
            if (checkbox) this._styleCheckbox(checkbox, entry);
            else this._styleTaskMarker(li, entry);
          }
        } else if (!isTaskItem && (bulletEntry || numberedEntry)) {
          const isOrdered = li.parentElement?.tagName === "OL";
          const entry = isOrdered ? numberedEntry : bulletEntry;
          const blocked = isOrdered && hasNumberedBlacklist || !isOrdered && hasBulletBlacklist;
          if (blocked) {
            try {
              li.classList.add("act-skip-coloring");
              li.classList.remove("act-colored-list-item");
              li.style.removeProperty("--act-marker-color");
              li.style.color = "";
              const highlights = li.querySelectorAll("span.always-color-text-highlight");
              for (const ex of highlights) {
                const tn = document.createTextNode(ex.textContent);
                ex.replaceWith(tn);
              }
            } catch (_) {
            }
            continue;
          }
          if (entry) {
            if (!contentBlacklisted) this._colorListItemContent(li, entry);
            this._styleListMarker(li, entry, isOrdered);
          }
        }
      }
      let paragraphs = Array.from(element.querySelectorAll?.("p") || []);
      if (element && element.nodeName === "P" && paragraphs.length === 0) paragraphs = [element];
      for (const p of paragraphs) {
        const checkbox = p.querySelector('input[type="checkbox"]');
        if (!checkbox) continue;
        const isChecked = checkbox.checked;
        const entry = isChecked ? taskCheckedEntry : taskUncheckedEntry;
        const contentText = this.extractListItemContent(p);
        const contentBlacklistedP = this.containsBlacklistedWord(contentText, filePath);
        const blocked = isChecked && hasTaskCheckedBlacklist || !isChecked && hasTaskUncheckedBlacklist;
        if (blocked) {
          try {
            p.classList.add("act-skip-coloring");
            p.classList.remove("act-colored-list-item");
            p.style.removeProperty("--act-marker-color");
            p.style.color = "";
            const highlights = p.querySelectorAll("span.always-color-text-highlight");
            for (const ex of highlights) {
              const tn = document.createTextNode(ex.textContent);
              ex.replaceWith(tn);
            }
          } catch (_) {
          }
          continue;
        }
        if (entry) {
          this._styleCheckbox(checkbox, entry);
          if (!contentBlacklistedP) this._colorListItemContent(p, entry);
        }
      }
    } catch (e) {
      try {
      } catch (_) {
      }
    }
  }
  // Helper: Style checkbox elements
  _styleCheckbox(checkbox, entry) {
    try {
      const color = entry.color || entry.textColor || (entry.backgroundColor && entry.backgroundColor !== "currentColor" ? entry.backgroundColor : null);
      if (color) {
        checkbox.style.accentColor = color;
      }
    } catch (e) {
    }
  }
  // Helper: Style list markers (bullets/numbers)
  _styleListMarker(li, entry, isOrdered) {
    try {
      const color = entry.color || entry.textColor || (entry.backgroundColor && entry.backgroundColor !== "currentColor" ? entry.backgroundColor : null);
      if (color) {
        li.style.setProperty("--act-marker-color", color);
        const marker = li.querySelector(".list-bullet, .list-number");
        if (marker) {
          marker.style.color = color;
        }
        li.classList.add("act-colored-list-item");
        if (!document.getElementById("act-list-marker-style")) {
          const style = document.createElement("style");
          style.id = "act-list-marker-style";
          style.textContent = `
            .act-colored-list-item { position: relative; }
            li.act-colored-list-item::marker { color: var(--act-marker-color, inherit); }
            li.act-colored-list-item .list-bullet,
            li.act-colored-list-item .list-number { color: var(--act-marker-color, inherit); }
            .markdown-preview-view li.act-colored-list-item::marker { color: var(--act-marker-color, inherit); }
            .markdown-reading-view li.act-colored-list-item::marker { color: var(--act-marker-color, inherit); }
          `;
          try {
            document.head.appendChild(style);
          } catch (e) {
          }
        }
      }
    } catch (e) {
    }
  }
  _styleTaskMarker(li, entry) {
    try {
      const walker = document.createTreeWalker(
        li,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode(node) {
            const t = node.textContent || "";
            if (t.includes("[x]") || t.includes("[X]") || t.includes("[ ]")) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_REJECT;
          }
        },
        false
      );
      let n;
      while (n = walker.nextNode()) {
        const color = entry.color || entry.textColor || (entry.backgroundColor && entry.backgroundColor !== "currentColor" ? entry.backgroundColor : null);
        if (!color) continue;
        const span = document.createElement("span");
        try {
          span.style.setProperty("color", color, "important");
        } catch (_) {
          span.style.color = color;
        }
        span.textContent = n.textContent;
        n.replaceWith(span);
      }
    } catch (e) {
    }
  }
  // Helper: Color list item content
  _colorListItemContent(li, entry) {
    try {
      const isLivePreview = li.closest && li.closest(".is-live-preview");
      if (isLivePreview) {
        const contentText = this.extractListItemContent(li);
        if (!contentText || !contentText.trim()) return;
        const walker2 = document.createTreeWalker(
          li,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node3) {
              if (node3.parentElement?.closest("code, pre, .always-color-text-highlight")) {
                return NodeFilter.FILTER_REJECT;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          },
          false
        );
        const nodes2 = [];
        let node2;
        while (node2 = walker2.nextNode()) {
          const text = node2.textContent;
          if (!text.trim()) continue;
          const parent = node2.parentElement;
          if (parent && parent.classList && (parent.classList.contains("list-bullet") || parent.classList.contains("list-number") || parent.classList.contains("task-list-item-checkbox") || parent.classList.contains("checkbox-container"))) {
            continue;
          }
          if (parent && parent.nodeName === "INPUT") continue;
          nodes2.push(node2);
        }
        for (let i = nodes2.length - 1; i >= 0; i--) {
          this._wrapTextNodeWithColor(nodes2[i], entry);
        }
        return;
      }
      const walker = document.createTreeWalker(
        li,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode(node2) {
            if (node2.parentElement?.closest("code, pre, .always-color-text-highlight")) {
              return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        },
        false
      );
      const nodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.trim()) {
          nodes.push(node);
        }
      }
      for (let i = nodes.length - 1; i >= 0; i--) {
        this._wrapListTextNode(nodes[i], entry);
      }
    } catch (e) {
    }
  }
  // Helper: Wrap a single text node with color styling
  _wrapTextNodeWithColor(textNode, entry) {
    try {
      try {
        if (textNode.parentElement?.closest(".act-skip-coloring")) return;
      } catch (_) {
      }
      let text = textNode.textContent;
      if (!text.trim()) return;
      text = this.decodeHtmlEntities(text);
      const regex = entry.regex;
      if (!regex) return;
      const rawMatches = [];
      let match;
      const globalRegex = new RegExp(regex.source, regex.flags.includes("g") ? regex.flags : regex.flags + "g");
      while ((match = globalRegex.exec(text)) !== null) {
        rawMatches.push({ index: match.index, length: match[0].length });
      }
      if (rawMatches.length === 0) return;
      const isSentencePattern = /[\s,\.;:!\?"'\(\)\[\]\{\}<>]/.test(entry.pattern || "");
      const mtLower = String(entry && entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
      let ranges = [];
      for (const m of rawMatches) {
        let matchStart = m.index;
        let matchEnd = m.index + m.length;
        if (!this.matchSatisfiesType(text, matchStart, matchEnd, entry)) continue;
        let colorStart = matchStart;
        let colorEnd = matchEnd;
        if (!isSentencePattern && (mtLower === "contains" || mtLower === "startswith" || mtLower === "endswith")) {
          colorStart = this.findWordStart(text, matchStart);
          colorEnd = this.findWordEnd(text, matchEnd);
        }
        ranges.push({ start: colorStart, end: colorEnd });
      }
      if (ranges.length === 0) return;
      ranges.sort((a, b) => {
        const la = a.end - a.start, lb = b.end - b.start;
        if (la !== lb) return lb - la;
        return a.start - b.start;
      });
      const selected = [];
      for (const r of ranges) {
        let overlaps = false;
        for (const s of selected) {
          if (r.start < s.end && r.end > s.start) {
            overlaps = true;
            break;
          }
        }
        if (!overlaps) selected.push(r);
      }
      const frag = document.createDocumentFragment();
      let lastEnd = 0;
      for (const r of selected) {
        if (lastEnd < r.start) frag.appendChild(document.createTextNode(text.substring(lastEnd, r.start)));
        const span = document.createElement("span");
        span.className = "always-color-text-highlight";
        span.textContent = text.substring(r.start, r.end);
        const styleType2 = entry.styleType || "text";
        const hideText = this.settings.hideTextColors === true;
        const hideBg = this.settings.hideHighlights === true;
        const textColor = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : null;
        const resolvedTextColor = textColor || entry.color || null;
        if (resolvedTextColor && this.isDarkColor(resolvedTextColor)) {
          span.classList.add("act-dark-color");
        }
        if (styleType2 === "text") {
          if (resolvedTextColor && !hideText) {
            try {
              span.style.setProperty("color", resolvedTextColor, "important");
            } catch (_) {
              span.style.color = resolvedTextColor;
            }
            try {
              span.style.setProperty("--highlight-color", resolvedTextColor);
            } catch (_) {
              try {
                span.style["--highlight-color"] = resolvedTextColor;
              } catch (_2) {
              }
            }
          }
        } else if (styleType2 === "highlight") {
          if (!hideBg) {
            const base = entry.backgroundColor || entry.color || resolvedTextColor;
            const bgColor = this.hexToRgba(base, this.settings.backgroundOpacity ?? 25);
            try {
              span.style.setProperty("background-color", bgColor, "important");
            } catch (_) {
              span.style.backgroundColor = bgColor;
            }
            try {
              span.style.setProperty("display", "inline-block", "important");
            } catch (_) {
              span.style.display = "inline-block";
            }
            span.style.paddingLeft = span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
            try {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
              span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
              if (vpad < 0) {
                span.style.setProperty("margin-top", vpad + "px", "important");
                span.style.setProperty("margin-bottom", vpad + "px", "important");
              }
            } catch (_) {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
              if (vpad < 0) {
                span.style.marginTop = vpad + "px";
                span.style.marginBottom = vpad + "px";
              }
            }
            span.style.borderRadius = (this.settings.highlightBorderRadius ?? 8) + "px";
            if (this.settings.enableBoxDecorationBreak ?? true) {
              span.style.boxDecorationBreak = "clone";
              span.style.WebkitBoxDecorationBreak = "clone";
            }
          } else {
            try {
              span.style.setProperty("background-color", "transparent", "important");
            } catch (_) {
              span.style.backgroundColor = "transparent";
            }
            try {
              span.style.setProperty("display", "inline", "important");
            } catch (_) {
              span.style.display = "inline";
            }
            span.style.paddingLeft = span.style.paddingRight = "0px";
            span.style.border = "";
            span.style.borderRadius = "";
          }
        } else {
          if (resolvedTextColor && !hideText) {
            try {
              span.style.setProperty("color", resolvedTextColor, "important");
            } catch (_) {
              span.style.color = resolvedTextColor;
            }
            try {
              span.style.setProperty("--highlight-color", resolvedTextColor);
            } catch (_) {
              try {
                span.style["--highlight-color"] = resolvedTextColor;
              } catch (_2) {
              }
            }
          }
          if (!hideBg) {
            const base = entry.backgroundColor || entry.color || resolvedTextColor;
            const bgColor = this.hexToRgba(base, this.settings.backgroundOpacity ?? 25);
            try {
              span.style.setProperty("background-color", bgColor, "important");
            } catch (_) {
              span.style.backgroundColor = bgColor;
            }
            try {
              span.style.setProperty("display", "inline-block", "important");
            } catch (_) {
              span.style.display = "inline-block";
            }
            span.style.paddingLeft = span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
            try {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
              span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
              if (vpad < 0) {
                span.style.setProperty("margin-top", vpad + "px", "important");
                span.style.setProperty("margin-bottom", vpad + "px", "important");
              }
            } catch (_) {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
              if (vpad < 0) {
                span.style.marginTop = vpad + "px";
                span.style.marginBottom = vpad + "px";
              }
            }
            span.style.borderRadius = (this.settings.highlightBorderRadius ?? 8) + "px";
            if (this.settings.enableBoxDecorationBreak ?? true) {
              span.style.boxDecorationBreak = "clone";
              span.style.WebkitBoxDecorationBreak = "clone";
            }
          } else {
            try {
              span.style.setProperty("background-color", "transparent", "important");
            } catch (_) {
              span.style.backgroundColor = "transparent";
            }
            try {
              span.style.setProperty("display", "inline", "important");
            } catch (_) {
              span.style.display = "inline";
            }
            span.style.paddingLeft = span.style.paddingRight = "0px";
            span.style.border = "";
            span.style.borderRadius = "";
          }
        }
        frag.appendChild(span);
        lastEnd = r.end;
      }
      if (lastEnd < text.length) frag.appendChild(document.createTextNode(text.substring(lastEnd)));
      textNode.replaceWith(frag);
    } catch (e) {
      debugError("WRAP_TEXT_NODE", "Error wrapping text node", e);
    }
  }
  _wrapListTextNode(textNode, entry) {
    try {
      let text = textNode.textContent;
      if (!text || !text.trim()) return;
      text = this.decodeHtmlEntities(text);
      const regex = entry.regex;
      if (!regex) return;
      const rawMatches = [];
      let match;
      const globalRegex = new RegExp(regex.source, regex.flags.includes("g") ? regex.flags : regex.flags + "g");
      while ((match = globalRegex.exec(text)) !== null) {
        rawMatches.push({ index: match.index, length: match[0].length });
      }
      if (rawMatches.length === 0) return;
      const isSentencePattern = /[\s,\.;:!\?"'\(\)\[\]\{\}<>]/.test(entry.pattern || "");
      const mtLower = String(entry && entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
      let ranges = [];
      for (const m of rawMatches) {
        let matchStart = m.index;
        let matchEnd = m.index + m.length;
        if (!this.matchSatisfiesType(text, matchStart, matchEnd, entry)) continue;
        let colorStart = matchStart;
        let colorEnd = matchEnd;
        if (!isSentencePattern && (mtLower === "contains" || mtLower === "startswith" || mtLower === "endswith")) {
          colorStart = this.findWordStart(text, matchStart);
          colorEnd = this.findWordEnd(text, matchEnd);
        }
        ranges.push({ start: colorStart, end: colorEnd });
      }
      if (ranges.length === 0) return;
      ranges.sort((a, b) => {
        const la = a.end - a.start, lb = b.end - b.start;
        if (la !== lb) return lb - la;
        return a.start - b.start;
      });
      const selected = [];
      for (const r of ranges) {
        let overlaps = false;
        for (const s of selected) {
          if (r.start < s.end && r.end > s.start) {
            overlaps = true;
            break;
          }
        }
        if (!overlaps) selected.push(r);
      }
      const frag = document.createDocumentFragment();
      let lastEnd = 0;
      for (const r of selected) {
        if (lastEnd < r.start) frag.appendChild(document.createTextNode(text.substring(lastEnd, r.start)));
        const span = document.createElement("span");
        span.className = "always-color-text-highlight";
        span.textContent = text.substring(r.start, r.end);
        const styleType2 = entry.styleType || "text";
        const hideText = this.settings.hideTextColors === true;
        const hideBg = this.settings.hideHighlights === true;
        const textColor = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : null;
        const resolvedTextColor = textColor || entry.color || null;
        if (styleType2 === "text") {
          if (resolvedTextColor && !hideText) {
            try {
              span.style.setProperty("color", resolvedTextColor, "important");
            } catch (_) {
              span.style.color = resolvedTextColor;
            }
            try {
              span.style.setProperty("--highlight-color", resolvedTextColor);
            } catch (_) {
              try {
                span.style["--highlight-color"] = resolvedTextColor;
              } catch (_2) {
              }
            }
          }
        } else if (styleType2 === "highlight") {
          if (!hideBg) {
            const base = entry.backgroundColor || entry.color || resolvedTextColor;
            const bgColor = this.hexToRgba(base, this.settings.backgroundOpacity ?? 25);
            try {
              span.style.setProperty("background-color", bgColor, "important");
            } catch (_) {
              span.style.backgroundColor = bgColor;
            }
            try {
              span.style.setProperty("display", "inline-block", "important");
            } catch (_) {
              span.style.display = "inline-block";
            }
            span.style.paddingLeft = span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
            try {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
              span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
              if (vpad < 0) {
                span.style.setProperty("margin-top", vpad + "px", "important");
                span.style.setProperty("margin-bottom", vpad + "px", "important");
              }
            } catch (_) {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
              if (vpad < 0) {
                span.style.marginTop = vpad + "px";
                span.style.marginBottom = vpad + "px";
              }
            }
            span.style.borderRadius = (this.settings.highlightBorderRadius ?? 8) + "px";
            if (this.settings.enableBoxDecorationBreak ?? true) {
              span.style.boxDecorationBreak = "clone";
              span.style.WebkitBoxDecorationBreak = "clone";
            }
            this.applyBorderStyleToElement(span, null, base);
          } else {
            try {
              span.style.setProperty("background-color", "transparent", "important");
            } catch (_) {
              span.style.backgroundColor = "transparent";
            }
            try {
              span.style.setProperty("display", "inline", "important");
            } catch (_) {
              span.style.display = "inline";
            }
            span.style.paddingLeft = span.style.paddingRight = "0px";
            span.style.border = "";
            span.style.borderRadius = "";
          }
        } else {
          if (resolvedTextColor && !hideText) {
            try {
              span.style.setProperty("color", resolvedTextColor, "important");
            } catch (_) {
              span.style.color = resolvedTextColor;
            }
            try {
              span.style.setProperty("--highlight-color", resolvedTextColor);
            } catch (_) {
              try {
                span.style["--highlight-color"] = resolvedTextColor;
              } catch (_2) {
              }
            }
          }
          if (!hideBg) {
            const base = entry.backgroundColor || entry.color || resolvedTextColor;
            const bgColor = this.hexToRgba(base, this.settings.backgroundOpacity ?? 25);
            try {
              span.style.setProperty("background-color", bgColor, "important");
            } catch (_) {
              span.style.backgroundColor = bgColor;
            }
            try {
              span.style.setProperty("display", "inline-block", "important");
            } catch (_) {
              span.style.display = "inline-block";
            }
            span.style.paddingLeft = span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
            try {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
              span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
              if (vpad < 0) {
                span.style.setProperty("margin-top", vpad + "px", "important");
                span.style.setProperty("margin-bottom", vpad + "px", "important");
              }
            } catch (_) {
              const vpad = this.settings.highlightVerticalPadding ?? 0;
              span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
              if (vpad < 0) {
                span.style.marginTop = vpad + "px";
                span.style.marginBottom = vpad + "px";
              }
            }
            span.style.borderRadius = (this.settings.highlightBorderRadius ?? 8) + "px";
            if (this.settings.enableBoxDecorationBreak ?? true) {
              span.style.boxDecorationBreak = "clone";
              span.style.WebkitBoxDecorationBreak = "clone";
            }
            this.applyBorderStyleToElement(span, hideText ? null : resolvedTextColor, base);
          } else {
            try {
              span.style.setProperty("background-color", "transparent", "important");
            } catch (_) {
              span.style.backgroundColor = "transparent";
            }
            try {
              span.style.setProperty("display", "inline", "important");
            } catch (_) {
              span.style.display = "inline";
            }
            span.style.paddingLeft = span.style.paddingRight = "0px";
            span.style.border = "";
            span.style.borderRadius = "";
          }
        }
        frag.appendChild(span);
        lastEnd = r.end;
      }
      if (lastEnd < text.length) frag.appendChild(document.createTextNode(text.substring(lastEnd)));
      textNode.replaceWith(frag);
    } catch (e) {
    }
  }
  // NEW METHOD: Color all content within a codeblock  
  _colorCodeblockContent(codeblock, entry) {
    try {
      const hideText = this.settings.hideTextColors === true;
      const hideBg = this.settings.hideHighlights === true;
      const classes = (codeblock.className || "").toLowerCase();
      const isCodeBlock = codeblock.nodeName === "CODE" || codeblock.nodeName === "PRE" || classes.includes("code") || classes.includes("language-") || codeblock.querySelector("code") || codeblock.querySelector("pre");
      if (!isCodeBlock) {
        return;
      }
      const color = entry.color || entry.textColor;
      const bgColor = entry.backgroundColor;
      const styleType2 = entry.styleType || "text";
      if (styleType2 === "text" && hideText || (styleType2 === "highlight" || styleType2 === "both") && hideBg) {
        return;
      }
      const walker = document.createTreeWalker(
        codeblock,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode(node2) {
            const text = node2.textContent || "";
            if (text.trim()) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_REJECT;
          }
        },
        false
      );
      const nodes = [];
      let node;
      while (node = walker.nextNode()) {
        nodes.push(node);
      }
      for (let i = nodes.length - 1; i >= 0; i--) {
        const textNode = nodes[i];
        const text = textNode.textContent;
        if (!text.trim()) continue;
        const span = document.createElement("span");
        span.className = "always-color-text-highlight";
        if (color && this.isDarkColor(color) || bgColor && this.isDarkColor(bgColor)) {
          span.classList.add("act-dark-color");
        }
        span.textContent = text;
        if (styleType2 === "text" && color) {
          try {
            span.style.setProperty("color", color, "important");
          } catch (_) {
            span.style.color = color;
          }
        } else if (styleType2 === "highlight" && bgColor) {
          const rgba = this.hexToRgba(bgColor, this.settings.backgroundOpacity ?? 25);
          try {
            span.style.setProperty("background-color", rgba, "important");
          } catch (_) {
            span.style.backgroundColor = rgba;
          }
          span.style.paddingLeft = (this.settings.highlightHorizontalPadding ?? 4) + "px";
          span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
          try {
            span.style.setProperty("padding-top", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
            span.style.setProperty("padding-bottom", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
          } catch (_) {
            span.style.paddingTop = span.style.paddingBottom = (this.settings.highlightVerticalPadding ?? 0) + "px";
          }
          span.style.borderRadius = (this.settings.highlightBorderRadius ?? 8) + "px";
          if (this.settings.enableBoxDecorationBreak ?? true) {
            span.style.boxDecorationBreak = "clone";
            span.style.WebkitBoxDecorationBreak = "clone";
          }
        } else if (styleType2 === "both") {
          if (color) {
            try {
              span.style.setProperty("color", color, "important");
            } catch (_) {
              span.style.color = color;
            }
          }
          if (bgColor) {
            const rgba = this.hexToRgba(bgColor, this.settings.backgroundOpacity ?? 25);
            try {
              span.style.setProperty("background-color", rgba, "important");
            } catch (_) {
              span.style.backgroundColor = rgba;
            }
            span.style.paddingLeft = (this.settings.highlightHorizontalPadding ?? 4) + "px";
            span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
            try {
              span.style.setProperty("padding-top", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
              span.style.setProperty("padding-bottom", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
            } catch (_) {
              span.style.paddingTop = span.style.paddingBottom = (this.settings.highlightVerticalPadding ?? 0) + "px";
            }
            span.style.borderRadius = (this.settings.highlightBorderRadius ?? 8) + "px";
            if (this.settings.enableBoxDecorationBreak ?? true) {
              span.style.boxDecorationBreak = "clone";
              span.style.WebkitBoxDecorationBreak = "clone";
            }
          }
        }
        textNode.replaceWith(span);
      }
      debugLog("CODEBLOCK", `Colored codeblock with style: ${styleType2}`);
    } catch (e) {
      debugError("COLOR_CODEBLOCK", "Error coloring codeblock content", e);
    }
  }
  // NEW METHOD: Only use complex processing when absolutely necessary
  processComplexPatterns(element, complexEntries, folderEntry, options = {}) {
    const blockTags = ["P", "LI", "DIV", "SPAN", "TD", "TH", "BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6"];
    const blocks = element.querySelectorAll?.(blockTags.join(", ")) || [];
    const BATCH_SIZE = 10;
    let processed = 0;
    for (const block of blocks) {
      if (block.closest("code, pre")) continue;
      this.processSingleBlockComplex(block, complexEntries, folderEntry, options);
      processed++;
      if (processed % BATCH_SIZE === 0) {
        setTimeout(() => {
        }, 0);
        break;
      }
    }
  }
  // --- When the plugin is UNLOADING, remove all its UI and features ---
  onunload() {
    try {
      if (this._refreshTimeout) {
        clearTimeout(this._refreshTimeout);
        this._refreshTimeout = null;
      }
      if (this._editorRefreshTimeout) {
        clearTimeout(this._editorRefreshTimeout);
        this._editorRefreshTimeout = null;
      }
    } catch (e) {
    }
    try {
      if (this.activeLeafChangeListener) {
        this.app.workspace.off("active-leaf-change", this.activeLeafChangeListener);
        this.activeLeafChangeListener = null;
      }
    } catch (e) {
    }
    try {
      if (this._docCtx) {
        document.removeEventListener("contextmenu", this._docCtx, true);
        document.removeEventListener("mousedown", this._docCtx, true);
        document.removeEventListener("pointerdown", this._docCtx, true);
      }
      if (this._docAux) {
        document.removeEventListener("auxclick", this._docAux, true);
      }
      if (this._dropdownClickListener) {
        document.removeEventListener("click", this._dropdownClickListener);
      }
      if (this._dropdownKeyListener) {
        document.removeEventListener("keydown", this._dropdownKeyListener);
      }
      if (this._scrollListener) {
        document.removeEventListener("scroll", this._scrollListener, true);
      }
      window.removeEventListener("act-colors-changed", this.syncColorsFromParent);
      window.removeEventListener("act-style-updated", this.styleUpdateHandler);
    } catch (e) {
    }
    try {
      this.ribbonIcon?.remove();
    } catch (e) {
    }
    try {
      this.statusBar?.remove();
    } catch (e) {
    }
    try {
      if (Array.isArray(this._compiledWordEntries) && this._compiledWordEntries.length > 0) {
        const top = this._compiledWordEntries.slice().sort((a, b) => (b.execs || 0) - (a.execs || 0)).slice(0, 5);
        if (IS_DEVELOPMENT) {
          for (const e of top) {
            debugLog("UNLOAD", `pattern: ${e.pattern}, execs: ${e.execs || 0}, avoided: ${e.avoidedExecs || 0}, matches: ${e.matchesFound || 0}`);
          }
        }
      }
    } catch (e) {
    }
    try {
      try {
        this.stopMemoryMonitor();
      } catch (e) {
      }
      try {
        this.cleanup();
      } catch (e) {
      }
      try {
        this._compiledWordEntries = [];
        this._cachedSortedEntries = null;
        this._cacheDirty = true;
      } catch (e) {
      }
    } catch (e) {
    }
    try {
      if (this.settings && Array.isArray(this.settings.wordEntries)) this.settings.wordEntries.length = 0;
    } catch (e) {
    }
    try {
      if (Array.isArray(this._eventListeners)) {
        this._eventListeners.forEach(({ el, event, handler }) => {
          try {
            el && el.removeEventListener && el.removeEventListener(event, handler);
          } catch (e) {
          }
        });
        this._eventListeners = [];
      }
    } catch (e) {
    }
    try {
      this._domRefs = /* @__PURE__ */ new WeakMap();
    } catch (e) {
    }
    try {
      if (Array.isArray(this._dynamicHandlers)) {
        this._dynamicHandlers.forEach((fn) => {
          try {
            typeof fn === "function" && fn();
          } catch (e) {
          }
        });
        this._dynamicHandlers = [];
      }
    } catch (e) {
    }
    try {
      this._eventManager && this._eventManager.clear && this._eventManager.clear();
    } catch (_) {
    }
    try {
      this._memoryManager && this._memoryManager.stop && this._memoryManager.stop();
    } catch (_) {
    }
    try {
      if (this._readingModeIntervals && this._readingModeIntervals instanceof Map) {
        for (const interval of this._readingModeIntervals.values()) {
          try {
            clearInterval(interval);
          } catch (e) {
          }
        }
        this._readingModeIntervals.clear();
      }
    } catch (e) {
    }
    try {
      this.clearAllHighlights();
    } catch (e) {
    }
    this.disablePluginFeatures();
  }
  // --- Register CodeMirror, markdown, and listeners ---
  updateLightModeFixer() {
    try {
      if (this.settings.enabled && this.settings.lightModeFixer) {
        document.body.classList.add("act-light-mode-fix");
      } else {
        document.body.classList.remove("act-light-mode-fix");
      }
    } catch (e) {
    }
  }
  updateDarkModeFixer() {
    try {
      if (this.settings.enabled && this.settings.darkModeFixer) {
        document.body.classList.add("act-dark-mode-fix");
      } else {
        document.body.classList.remove("act-dark-mode-fix");
      }
    } catch (e) {
    }
  }
  enablePluginFeatures() {
    this.updateLightModeFixer();
    this.updateDarkModeFixer();
    this.applyFormattingPresetStyles();
    this.applyFormattingStyles();
    this.applyHighlightPresetTransparency();
    if (!this.cmExtensionRegistered) {
      this.extension = this.buildEditorExtension();
      this.registerEditorExtension(this.extension);
      this.cmExtensionRegistered = true;
    }
    if (!this.markdownPostProcessorRegistered) {
      this._unregisterMarkdownPostProcessor = this.registerMarkdownPostProcessor((el, ctx) => {
        if (!this.settings.enabled) return;
        try {
          const qaRoot = el && el.closest ? el.closest('[data-id="quickadd"], .quickadd-settings, .quickAdd-settings') : null;
          if (qaRoot) {
            try {
              qaRoot.classList.add("act-skip-coloring");
            } catch (_) {
            }
            return;
          }
        } catch (_) {
        }
        let sp = null;
        try {
          sp = ctx && typeof ctx.sourcePath === "string" ? ctx.sourcePath : this.app && this.app.workspace && this.app.workspace.getActiveFile && this.app.workspace.getActiveFile() ? this.app.workspace.getActiveFile().path : null;
        } catch (_) {
        }
        if (!sp) return;
        try {
          debugLog("POST_PROC", `Processing element: ${el.className}, nodeName: ${el.nodeName}, hasCallout: ${el.querySelector(".callout") ? "yes" : "no"}`);
        } catch (_) {
        }
        try {
          this.processActiveFileOnly(el, { sourcePath: sp });
        } catch (e) {
          debugWarn("ACT", "processActiveFileOnly failed", e);
        }
        try {
          const isReadingMode = el && (el.classList.contains("markdown-rendered") || el.closest(".markdown-reading-view"));
          if (isReadingMode) {
            debugLog("POST_PROC", "Detected reading mode, setting up highlight maintenance");
            this.setupReadingModeObserver(el, sp);
          }
        } catch (e) {
        }
      });
      this.markdownPostProcessorRegistered = true;
    }
    try {
      if (!this._canvasObserver) {
        this._canvasDebounceTimers = /* @__PURE__ */ new WeakMap();
        const resolveEmbedSourcePath = (embedEl) => {
          try {
            const host = embedEl.closest("[data-path]") || embedEl.querySelector("[data-path]");
            if (host && host.dataset && typeof host.dataset.path === "string" && host.dataset.path.length > 0) {
              return host.dataset.path;
            }
          } catch (_) {
          }
          try {
            const link = embedEl.closest(".markdown-embed")?.querySelector(".internal-link, a[href]");
            if (link && link.getAttribute) {
              const href = link.getAttribute("href") || "";
              if (href && !href.startsWith("http")) return href;
            }
          } catch (_) {
          }
          try {
            return this.app?.workspace?.getActiveFile()?.path || null;
          } catch (_) {
            return null;
          }
        };
        const scheduleCanvasProcess = (embedEl) => {
          if (!embedEl) return;
          const prev = this._canvasDebounceTimers.get(embedEl);
          if (prev) {
            try {
              clearTimeout(prev);
            } catch (_) {
            }
          }
          const sp = resolveEmbedSourcePath(embedEl);
          if (!sp) return;
          const timer = setTimeout(() => {
            try {
              this.processActiveFileOnly(embedEl, { sourcePath: sp });
            } catch (e) {
              debugWarn("CANVAS", "Failed to process canvas embed", e);
            }
          }, 80);
          try {
            this._canvasDebounceTimers.set(embedEl, timer);
          } catch (_) {
          }
        };
        try {
          const existingEmbeds = document.querySelectorAll(".canvas-node .markdown-embed-content");
          existingEmbeds.forEach((el) => scheduleCanvasProcess(el));
        } catch (_) {
        }
        this._canvasObserver = new MutationObserver((mutations) => {
          try {
            for (const m of mutations) {
              if (m.type === "childList") {
                const added = Array.from(m.addedNodes || []).filter((n) => n.nodeType === Node.ELEMENT_NODE);
                for (const node of added) {
                  try {
                    if (node.classList && node.classList.contains("markdown-embed-content") && node.closest(".canvas-node")) {
                      scheduleCanvasProcess(node);
                    }
                    const embeds = node.querySelectorAll ? node.querySelectorAll(".canvas-node .markdown-embed-content") : [];
                    embeds.forEach((el) => scheduleCanvasProcess(el));
                  } catch (_) {
                  }
                }
              } else if (m.type === "attributes" || m.type === "characterData") {
                try {
                  const el = m.target && m.target.closest ? m.target.closest(".canvas-node .markdown-embed-content") : null;
                  if (el) scheduleCanvasProcess(el);
                } catch (_) {
                }
              }
            }
          } catch (e) {
            debugWarn("CANVAS", "Mutation observer error", e);
          }
        });
        try {
          this._canvasObserver.observe(document.body, { childList: true, subtree: true, attributes: true, characterData: true });
        } catch (_) {
        }
      }
    } catch (e) {
      debugWarn("CANVAS", "Failed to initialize canvas observer", e);
    }
    if (!this.activeLeafChangeListenerRegistered) {
      this.activeLeafChangeListener = this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf && leaf.view instanceof MarkdownView) {
          try {
            if (leaf.view.getMode && leaf.view.getMode() === "preview") {
              try {
                if (leaf.view.previewMode && typeof leaf.view.previewMode.rerender === "function") {
                  leaf.view.previewMode.rerender(true);
                } else if (typeof leaf.view.rerender === "function") {
                  leaf.view.rerender();
                } else {
                  this.forceRefreshAllReadingViews();
                }
              } catch (e) {
                this.forceRefreshAllReadingViews();
              }
              setTimeout(() => {
                try {
                  const active = this.app.workspace.getActiveViewOfType(MarkdownView);
                  if (active && active.getMode && active.getMode() === "preview") {
                    const root = active.previewMode && active.previewMode.containerEl || active.contentEl || active.containerEl;
                    if (root && active.file && active.file.path) {
                      try {
                        this.processActiveFileOnly(root, { sourcePath: active.file.path });
                      } catch (e) {
                      }
                    }
                  }
                } catch (e) {
                }
              }, 120);
            } else {
              this.refreshEditor(leaf.view, true);
              try {
                const view = leaf.view && (leaf.view.editor?.cm?.view || leaf.view.editor?.view || leaf.view.view || null);
                if (view) {
                  this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
                  this._processLivePreviewCallouts(view);
                  this._processLivePreviewTables(view);
                }
              } catch (e) {
              }
            }
          } catch (e) {
          }
        }
      });
      this.registerEvent(this.activeLeafChangeListener);
      this.activeLeafChangeListenerRegistered = true;
    }
    this.setupSearchObserver();
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        const activeLeaf = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (activeLeaf && activeLeaf.getMode && activeLeaf.getMode() === "preview") {
          this.forceRefreshAllReadingViews();
        } else if (activeLeaf && activeLeaf.getMode && activeLeaf.getMode() === "source") {
          try {
            this.refreshAllLivePreviewCallouts();
          } catch (_) {
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        try {
          const activeFile = this.app.workspace.getActiveFile();
          if (activeFile && activeFile.path === file.path) {
            this.forceRefreshAllEditors();
            this.forceRefreshAllReadingViews();
          }
        } catch (e) {
          debugError("RENAME", "File rename handler failed", e);
        }
      })
    );
    this.refreshActiveEditor(true);
  }
  // --- Remove all CodeMirror extensions & listeners ---
  disablePluginFeatures() {
    this.removeHighlightPresetTransparency();
    this.removeFormattingPresetStyles();
    try {
      const s = document.getElementById("act-formatting-styles");
      if (s) s.remove();
    } catch (_) {
    }
    try {
      document.body.classList.remove("act-light-mode-fix");
    } catch (_) {
    }
    try {
      document.body.classList.remove("act-dark-mode-fix");
    } catch (_) {
    }
    if (this.cmExtensionRegistered && this.extension) {
      this.app.workspace.unregisterEditorExtension(this.extension);
      this.cmExtensionRegistered = false;
      this.extension = null;
    }
    if (this.markdownPostProcessorRegistered && this._unregisterMarkdownPostProcessor) {
      this._unregisterMarkdownPostProcessor();
      this.markdownPostProcessorRegistered = false;
      this._unregisterMarkdownPostProcessor = null;
    }
    try {
      if (this._canvasObserver) {
        try {
          this._canvasObserver.disconnect();
        } catch (_) {
        }
        this._canvasObserver = null;
      }
      try {
        if (this._canvasDebounceTimers) {
          const embeds = document.querySelectorAll(".canvas-node .markdown-embed-content");
          embeds.forEach((el) => {
            try {
              const t = this._canvasDebounceTimers.get(el);
              if (t) clearTimeout(t);
            } catch (_) {
            }
          });
          this._canvasDebounceTimers = /* @__PURE__ */ new WeakMap();
        }
      } catch (_) {
      }
    } catch (_) {
    }
    if (this.activeLeafChangeListenerRegistered && this.activeLeafChangeListener) {
      this.app.workspace.off("active-leaf-change", this.activeLeafChangeListener);
      this.activeLeafChangeListenerRegistered = false;
      this.activeLeafChangeListener = null;
    }
    this.teardownSearchObserver();
    this.refreshActiveEditor(true);
    try {
      if (!this._changelogCommandRegistered) {
        this.addCommand({
          id: "show-latest-release-notes",
          name: this.t("command_show_release_notes", "Show Latest Release Notes"),
          callback: async () => {
            try {
              new ChangelogModal(this.app, this).open();
            } catch (e) {
            }
          }
        });
        this._changelogCommandRegistered = true;
      }
    } catch (e) {
    }
  }
  // --- Search Results Support ---
  setupSearchObserver() {
    try {
      if (this._searchObserversMap) return;
      this._searchObserversMap = /* @__PURE__ */ new Map();
      const processSearchLeaf = (leaf) => {
        try {
          const container = leaf.view.containerEl;
          if (!container) return;
          const results = container.querySelectorAll(".search-result-file-match");
          if (results.length === 0) return;
          const sourcePath = "search-results";
          const folderEntry = this.getBestFolderEntry(sourcePath);
          const allEntries = this.getSortedWordEntries();
          const allowedEntries = this.filterEntriesByAdvancedRules(sourcePath, allEntries);
          if (allowedEntries.length === 0) return;
          for (const result of results) {
            try {
              this._processSearchResultBlock(result, allowedEntries, folderEntry);
            } catch (err) {
            }
          }
        } catch (e) {
          debugWarn("SEARCH", "Failed to process search leaf", e);
        }
      };
      const attachObserver = (leaf) => {
        if (this._searchObserversMap.has(leaf)) return;
        const container = leaf.view.containerEl;
        if (!container) return;
        const observer = new MutationObserver((mutations) => {
          let shouldUpdate = false;
          for (const m of mutations) {
            let isOurChange = false;
            if (m.type === "childList") {
              for (const node of m.addedNodes) {
                if (node.nodeType === 1 && node.classList.contains("always-color-text-highlight")) {
                  isOurChange = true;
                  break;
                }
              }
            }
            if (!isOurChange) {
              shouldUpdate = true;
              break;
            }
          }
          if (shouldUpdate) {
            if (leaf._actSearchDebounce) clearTimeout(leaf._actSearchDebounce);
            leaf._actSearchDebounce = setTimeout(() => processSearchLeaf(leaf), 60);
          }
        });
        observer.observe(container, { childList: true, subtree: true });
        this._searchObserversMap.set(leaf, observer);
        processSearchLeaf(leaf);
      };
      this.app.workspace.getLeavesOfType("search").forEach(attachObserver);
      this.registerEvent(this.app.workspace.on("layout-change", () => {
        const leaves = this.app.workspace.getLeavesOfType("search");
        leaves.forEach(attachObserver);
        for (const [leaf, obs] of this._searchObserversMap.entries()) {
          if (!leaves.includes(leaf)) {
            obs.disconnect();
            this._searchObserversMap.delete(leaf);
          }
        }
      }));
    } catch (e) {
      debugError("SEARCH", "Failed to setup search observer", e);
    }
  }
  _processSearchResultBlock(block, entries, folderEntry) {
    try {
      const textNodes = [];
      const walker = document.createTreeWalker(block, NodeFilter.SHOW_TEXT, {
        acceptNode(node) {
          if (node.parentElement?.closest(".always-color-text-highlight")) return NodeFilter.FILTER_REJECT;
          if (node.parentElement?.closest("code, pre")) return NodeFilter.FILTER_REJECT;
          return NodeFilter.FILTER_ACCEPT;
        }
      }, false);
      let n;
      while (n = walker.nextNode()) {
        const isMatch = !!(n.parentElement && n.parentElement.closest(".search-result-file-matched-text"));
        textNodes.push({ node: n, text: n.textContent || "", isMatch });
      }
      if (textNodes.length === 0) return;
      const combined = textNodes.map((s) => s.text).join("");
      if (!combined) return;
      const regexEntries = (entries || []).filter((e) => e && !e.invalid && e.isRegex);
      try {
        for (const entry of regexEntries) {
          if (!entry.regex && this._patternMatcher) this._patternMatcher.compilePattern(entry);
        }
      } catch (_) {
      }
      let matches = [];
      const textBgEntries = (entries || []).filter((e) => e && e.isTextBg === true);
      for (const entry of textBgEntries) {
        const re = entry.regex;
        if (!re) continue;
        const mlist = this.safeMatchLoop(re, combined);
        for (const m of mlist) {
          const s = m.index;
          const e = m.index + m[0].length;
          if (!this.matchSatisfiesType(combined, s, e, entry)) continue;
          matches.push({ start: s, end: e, textColor: entry.textColor, backgroundColor: entry.backgroundColor, isTextBg: true, entryRef: entry });
        }
      }
      const textOnlyCandidates = (entries || []).filter((e) => e && !e.isTextBg);
      const pm = this._patternMatcher ? this._patternMatcher.match(combined, textOnlyCandidates, folderEntry) : [];
      for (const m of pm) matches.push(m);
      if (matches.length === 0) return;
      matches.sort((a, b) => {
        const la = a.end - a.start;
        const lb = b.end - b.start;
        if (la !== lb) return lb - la;
        if (a.start !== b.start) return a.start - b.start;
        const aT = a.isTextBg ? !!(a.textColor && a.textColor !== "currentColor") : !!a.color;
        const bT = b.isTextBg ? !!(b.textColor && b.textColor !== "currentColor") : !!b.color;
        if (aT && !bT) return -1;
        if (!aT && bT) return 1;
        if (a.isTextBg && !b.isTextBg) return -1;
        if (!a.isTextBg && b.isTextBg) return 1;
        return 0;
      });
      const nonOverlap = [];
      for (const m of matches) {
        let ok = true;
        for (const s of nonOverlap) {
          if (m.start < s.end && m.end > s.start) {
            ok = false;
            break;
          }
        }
        if (ok) nonOverlap.push(m);
      }
      matches = nonOverlap.sort((a, b) => a.start - b.start);
      const segBounds = [];
      let acc = 0;
      for (const seg of textNodes) {
        const start = acc;
        const end = acc + seg.text.length;
        segBounds.push({ start, end, seg });
        acc = end;
      }
      const appendRange = (frag2, rStart, rEnd) => {
        if (rEnd <= rStart) return;
        let pos2 = rStart;
        for (const b of segBounds) {
          if (b.end <= pos2) continue;
          if (b.start >= rEnd) break;
          const s = Math.max(b.start, pos2);
          const e = Math.min(b.end, rEnd);
          const slice = b.seg.text.slice(s - b.start, e - b.start);
          if (b.seg.isMatch) {
            const span = document.createElement("span");
            span.className = "search-result-file-matched-text";
            span.textContent = slice;
            frag2.appendChild(span);
          } else {
            frag2.appendChild(document.createTextNode(slice));
          }
          pos2 = e;
        }
      };
      const frag = document.createDocumentFragment();
      let pos = 0;
      for (const m of matches) {
        if (m.start > pos) appendRange(frag, pos, m.start);
        const entry = m.entryRef || m.entry;
        const presetLabel = entry?.presetLabel || "";
        const isBoldItalicPreset = /bold|italic/i.test(presetLabel);
        let skipWrapper = false;
        if (isBoldItalicPreset) {
          for (const b of segBounds) {
            if (b.end <= m.start) continue;
            if (b.start >= m.end) break;
            const parent = b.seg.node.parentElement;
            if (parent && (parent.closest(".cm-strong, .cm-em, .markdown-rendered strong, .markdown-rendered em") || parent.matches && parent.matches(".cm-strong, .cm-em, .markdown-rendered strong, .markdown-rendered em"))) {
              skipWrapper = true;
              break;
            }
          }
        }
        if (skipWrapper) {
          appendRange(frag, m.start, m.end);
          pos = m.end;
          continue;
        }
        const span = document.createElement("span");
        span.className = "always-color-text-highlight";
        const styleType2 = m.isTextBg ? "both" : m.styleType || "text";
        const hideText = this.settings.hideTextColors === true;
        const hideBg = this.settings.hideHighlights === true;
        if (styleType2 === "text") {
          const color = m.color || (m.textColor && m.textColor !== "currentColor" ? m.textColor : null);
          if (!hideText && color) {
            try {
              span.style.setProperty("color", color, "important");
            } catch (_) {
              span.style.color = color;
            }
            try {
              span.style.setProperty("--highlight-color", color);
            } catch (_) {
            }
          }
        } else if (styleType2 === "highlight") {
          if (!hideBg) {
            const bgColor = m.backgroundColor || m.color || (m.textColor && m.textColor !== "currentColor" ? m.textColor : null) || (folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : null);
            span.style.background = "";
            const params = this.getHighlightParams(m.entryRef || m.entry || null);
            try {
              span.style.setProperty("background-color", this.hexToRgba(bgColor, params.opacity ?? 25), "important");
            } catch (_) {
              span.style.backgroundColor = this.hexToRgba(bgColor, params.opacity ?? 25);
            }
            const vpad = params.vPad;
            try {
              span.style.setProperty("padding-left", params.hPad + "px", "important");
              span.style.setProperty("padding-right", params.hPad + "px", "important");
              span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
              span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
            } catch (_) {
              span.style.paddingLeft = span.style.paddingRight = params.hPad + "px";
              span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
            }
            const br = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
            try {
              span.style.setProperty("border-radius", br, "important");
            } catch (_) {
              span.style.borderRadius = br;
            }
            const borderCss = this.generateBorderStyle(null, bgColor, m.entryRef || m.entry || null);
            if (borderCss) {
              span.style.cssText += borderCss;
            }
            if (this.settings.enableBoxDecorationBreak ?? true) {
              span.style.boxDecorationBreak = "clone";
              span.style.WebkitBoxDecorationBreak = "clone";
            }
          }
        } else {
          const textColor = m.textColor && m.textColor !== "currentColor" ? m.textColor : m.color || null;
          const bgColor = m.backgroundColor || m.color || (folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : null);
          if (!hideText && textColor) {
            try {
              span.style.setProperty("color", textColor, "important");
            } catch (_) {
              span.style.color = textColor;
            }
            try {
              span.style.setProperty("--highlight-color", textColor);
            } catch (_) {
            }
          }
          if (!hideBg) {
            span.style.background = "";
            const params = this.getHighlightParams(m.entryRef || m.entry || null);
            try {
              span.style.setProperty("background-color", this.hexToRgba(bgColor, params.opacity ?? 25), "important");
            } catch (_) {
              span.style.backgroundColor = this.hexToRgba(bgColor, params.opacity ?? 25);
            }
            const vpad = params.vPad;
            try {
              span.style.setProperty("padding-left", params.hPad + "px", "important");
              span.style.setProperty("padding-right", params.hPad + "px", "important");
              span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
              span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
            } catch (_) {
              span.style.paddingLeft = span.style.paddingRight = params.hPad + "px";
              span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
            }
            const br2 = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
            try {
              span.style.setProperty("border-radius", br2, "important");
            } catch (_) {
              span.style.borderRadius = br2;
            }
            const borderCss2 = this.generateBorderStyle(hideText ? null : textColor, hideBg ? null : bgColor, m.entryRef || m.entry || null);
            if (borderCss2) {
              span.style.cssText += borderCss2;
            }
            if (this.settings.enableBoxDecorationBreak ?? true) {
              span.style.boxDecorationBreak = "clone";
              span.style.WebkitBoxDecorationBreak = "clone";
            }
            this.applyBorderStyleToElement(span, hideText ? null : textColor, hideBg ? null : bgColor, m.entryRef || m.entry || null);
          }
        }
        const innerFrag = document.createDocumentFragment();
        appendRange(innerFrag, m.start, m.end);
        span.appendChild(innerFrag);
        frag.appendChild(span);
        pos = m.end;
      }
      if (pos < combined.length) appendRange(frag, pos, combined.length);
      while (block.firstChild) block.removeChild(block.firstChild);
      block.appendChild(frag);
    } catch (e) {
      try {
        debugError("SEARCH", "process block error", e);
      } catch (_) {
      }
    }
  }
  teardownSearchObserver() {
    try {
      if (this._searchObserversMap) {
        for (const obs of this._searchObserversMap.values()) {
          obs.disconnect();
        }
        this._searchObserversMap.clear();
        this._searchObserversMap = null;
      }
    } catch (_) {
    }
  }
  // --- REFACTOR HELPERS ---
  generateUid() {
    try {
      return Date.now().toString(36) + Math.random().toString(36).slice(2);
    } catch (e) {
      return Date.now().toString();
    }
  }
  migrateEntry(entry) {
    if (!entry) return null;
    if (!entry.uid) entry.uid = this.generateUid();
    if ((entry.textColor === void 0 || entry.textColor === null) && entry.color) {
      entry.textColor = entry.color;
    }
    delete entry._savedtextcolor;
    delete entry._savedbackgroundcolor;
    delete entry._savedTextColor;
    delete entry._savedBackgroundColor;
    return entry;
  }
  compressEntry(entry) {
    if (!entry) return null;
    const e = Object.assign({}, entry);
    const s = this.settings;
    if ((e.textColor === void 0 || e.textColor === null) && e.color) {
      e.textColor = e.color;
    }
    delete e._savedtextcolor;
    delete e._savedbackgroundcolor;
    delete e._savedTextColor;
    delete e._savedBackgroundColor;
    if (e.inclusionRules && e.inclusionRules.length === 0) delete e.inclusionRules;
    if (e.exclusionRules && e.exclusionRules.length === 0) delete e.exclusionRules;
    if (e.groupedPatterns && (e.groupedPatterns.length === 0 || e.groupedPatterns === null)) delete e.groupedPatterns;
    if (e.textColor === null) delete e.textColor;
    if (e.backgroundColor === null) delete e.backgroundColor;
    if (e.presetLabel === "") delete e.presetLabel;
    if (e.color === "") delete e.color;
    if (e.textColor === "") delete e.textColor;
    if (e.backgroundColor === "") delete e.backgroundColor;
    if (e.backgroundOpacity === s.backgroundOpacity) delete e.backgroundOpacity;
    if (e.highlightBorderRadius === s.highlightBorderRadius) delete e.highlightBorderRadius;
    if (e.highlightHorizontalPadding === s.highlightHorizontalPadding) delete e.highlightHorizontalPadding;
    if (e.highlightVerticalPadding === s.highlightVerticalPadding) delete e.highlightVerticalPadding;
    if (e.enableBoxDecorationBreak === s.enableBoxDecorationBreak) delete e.enableBoxDecorationBreak;
    if (e.enableBorderThickness === s.enableBorderThickness) delete e.enableBorderThickness;
    if (e.borderOpacity === s.borderOpacity) delete e.borderOpacity;
    if (e.borderThickness === s.borderThickness) delete e.borderThickness;
    if (e.borderStyle === s.borderStyle) delete e.borderStyle;
    if (e.borderLineStyle === s.borderLineStyle) delete e.borderLineStyle;
    return e;
  }
  // Helper to merge entry styles with global defaults
  getEffectiveStyles(entry) {
    if (!entry) return {};
    const s = this.settings;
    const effective = {};
    GLOBAL_STYLE_KEYS.forEach((key) => {
      effective[key] = entry[key] !== void 0 && entry[key] !== null ? entry[key] : s[key];
    });
    return Object.assign({}, entry, effective);
  }
  // --- Load plugin settings from disk, with defaults ---
  async loadSettings() {
    const loadedData = await this.loadData() || {};
    if (loadedData.globalStyles && typeof loadedData.globalStyles === "object") {
      Object.assign(loadedData, loadedData.globalStyles);
      delete loadedData.globalStyles;
    } else {
    }
    if (!Array.isArray(loadedData.wordEntries)) loadedData.wordEntries = [];
    if (!Array.isArray(loadedData.wordEntryGroups)) loadedData.wordEntryGroups = [];
    if (!Array.isArray(loadedData.blacklistEntries)) loadedData.blacklistEntries = [];
    if (!Array.isArray(loadedData.blacklistEntryGroups)) loadedData.blacklistEntryGroups = [];
    if (!Array.isArray(loadedData.pathRules)) loadedData.pathRules = [];
    try {
      const weWithCustom = (loadedData.wordEntries || []).filter((e) => e && (typeof e.backgroundOpacity === "number" || typeof e.highlightBorderRadius === "number"));
      if (weWithCustom.length > 0) {
        debugLog("[LOAD_FROM_DISK_WE]", `Found ${weWithCustom.length} entries with custom: ${weWithCustom.slice(0, 3).map((e) => `${e.pattern}(op=${e.backgroundOpacity}, rad=${e.highlightBorderRadius})`).join(", ")}`);
      }
      const tbgWithCustom = (loadedData.textBgColoringEntries || []).filter((e) => e && (typeof e.backgroundOpacity === "number" || typeof e.highlightBorderRadius === "number"));
      if (tbgWithCustom.length > 0) {
        debugLog("[LOAD_FROM_DISK_TBG]", `Found ${tbgWithCustom.length} tbg entries with custom: ${tbgWithCustom.slice(0, 3).map((e) => `${e.pattern}(op=${e.backgroundOpacity}, rad=${e.highlightBorderRadius})`).join(", ")}`);
      }
    } catch (e) {
    }
    this.settings = Object.assign({
      // legacy: wordColors map. New model below: wordEntries array
      wordColors: {},
      wordEntries: [],
      wordEntryGroups: [],
      blacklistEntryGroups: [],
      caseSensitive: false,
      enabled: true,
      highlightStyle: "text",
      backgroundOpacity: 35,
      // percent
      highlightBorderRadius: 4,
      // px
      highlightHorizontalPadding: 4,
      // px
      highlightVerticalPadding: 0,
      // px
      enableBoxDecorationBreak: true,
      // Toggle for rounded corners on text wrapping
      enableBorderThickness: false,
      // Toggle for border on background highlights
      borderOpacity: 100,
      // percent (0-100)
      borderThickness: 2,
      // px (0-5)
      borderStyle: "full",
      // 'full', 'top', 'bottom', 'left', 'right', 'top-bottom', 'left-right', 'top-right', 'top-left', 'bottom-right', 'bottom-left'
      borderLineStyle: "solid",
      disabledFiles: [],
      customSwatchesEnabled: false,
      replaceDefaultSwatches: false,
      customSwatches: [],
      // Default named swatches (never edited by user, only read-only display)
      swatches: [
        { name: "Red", color: "#eb3b5a" },
        { name: "Orange", color: "#fa8231" },
        { name: "Yellow", color: "#e5a216" },
        { name: "Green", color: "#20bf6b" },
        { name: "Cyan", color: "#0fb9b1" },
        { name: "Blue", color: "#2d98da" },
        { name: "Dark Blue", color: "#3867d6" },
        { name: "Indigo", color: "#5454d0" },
        { name: "Purple", color: "#8854d0" },
        { name: "Light Purple", color: "#b554d0" },
        { name: "Neon Pink", color: "#e832c1" },
        { name: "Hot Pink", color: "#e83289" },
        { name: "Brown", color: "#965b3b" },
        { name: "Gray", color: "#8392a4" }
      ],
      // User-added custom swatches (separate from defaults)
      userCustomSwatches: [],
      disableToggleModes: {
        statusBar: false,
        command: false,
        ribbon: false
      },
      enableAlwaysHighlight: false,
      enableAlwaysColor: true,
      partialMatch: true,
      blacklistWords: [],
      // New: pattern-capable blacklist entries
      blacklistEntries: [],
      enableBlacklistMenu: true,
      enableAddToExistingMenu: true,
      enableAlwaysColorTextMenu: true,
      hideInactiveGroupsInDropdowns: true,
      hideInactiveBlacklistGroupsInDropdowns: true,
      showWordGroupsInCommands: true,
      showBlacklistGroupsInCommands: true,
      symbolWordColoring: false,
      // Enable/disable regex support in the settings UI/runtime
      enableRegexSupport: false,
      // Opt-in: force full reading-mode render (WARNING: may freeze UI on large notes)
      forceFullRenderInReading: false,
      // Opt-in: extremely lightweight processing mode (experimental)
      extremeLightweightMode: false,
      // Opt-in: Smart Updates (Freeze non-active lines)
      enableSmartUpdates: false,
      // Disable coloring in reading/preview mode (editor remains colored)
      disableReadingModeColoring: false,
      disableLivePreviewColoring: false,
      // Text & Background Coloring entries
      textBgColoringEntries: [],
      // Enable/disable Text & Background Coloring option in right-click menu
      enableTextBgMenu: true,
      // Use swatch names for coloring entries
      useSwatchNamesForText: false,
      linkSwatchUpdatesToEntries: false,
      colorPickerMode: "both",
      advancedRules: [],
      pathRules: [],
      // Allow disabling regex safety checks (dangerous)
      disableRegexSafety: false,
      enableQuickColorHighlightOnce: false,
      enableQuickColorOnce: false,
      enableQuickHighlightOnce: false,
      quickHighlightStyleEnable: false,
      quickColorsEnabled: false,
      quickColorsApplyMode: "html",
      quickColors: [],
      // Array of { textColor, backgroundColor, uid }
      quickStyles: [],
      // Array of objects { id, name, style }
      quickHighlightUseGlobalStyle: false,
      quickHighlightOpacity: 25,
      quickHighlightBorderRadius: 8,
      quickHighlightHorizontalPadding: 4,
      quickHighlightVerticalPadding: 0,
      quickHighlightEnableBorder: false,
      quickHighlightBorderStyle: "full",
      quickHighlightBorderOpacity: 100,
      quickHighlightBorderThickness: 1,
      quickHighlightBorderLineStyle: "solid",
      wordsSortMode: "last-added",
      blacklistSortMode: "last-added",
      pathSortMode: "last-added",
      language: "en",
      customSwatchesFolded: false,
      globalHighlightFolded: false,
      readingModeHighlightFilter: null,
      // null: show all, 'highlight': show only highlights, 'text': show only text colors
      entriesSearchLimit: 0,
      blacklistSearchLimit: 0,
      pathSearchLimit: 0,
      showColoringReasonOnHover: false,
      // Show tooltip on hover explaining why text is colored
      lightModeFixer: false,
      darkModeFixer: false
    }, loadedData);
    try {
      if (typeof loadedData.quickColorsEnabled === "boolean") {
        this.settings.quickColorsEnabled = loadedData.quickColorsEnabled;
      } else if (typeof loadedData.enableQuickColors === "boolean" && typeof loadedData.quickColorsEnabled !== "boolean") {
        this.settings.quickColorsEnabled = loadedData.enableQuickColors;
      }
      if (Array.isArray(this.settings.quickColors) && this.settings.quickColors.length > 0 && typeof this.settings.quickColors[0] === "string") {
        this.settings.quickColors = this.settings.quickColors.map((hex) => ({ textColor: hex, backgroundColor: null, uid: Date.now().toString(36) + Math.random().toString(36).slice(2) }));
      }
    } catch (_) {
    }
    try {
      this.sanitizeSettings();
    } catch (e) {
    }
    try {
      if (Array.isArray(this.settings.wordEntries)) {
        this.settings.wordEntries.forEach((e) => this.migrateEntry(e));
      }
      if (Array.isArray(this.settings.wordEntryGroups)) {
        this.settings.wordEntryGroups.forEach((group) => {
          if (Array.isArray(group.entries)) {
            group.entries.forEach((e) => this.migrateEntry(e));
          }
        });
      }
    } catch (e) {
      debugError("MIGRATION", "Refactor migration failed", e);
    }
    try {
      const weAfterSanitize = (this.settings.wordEntries || []).filter((e) => e && (typeof e.backgroundOpacity === "number" || typeof e.highlightBorderRadius === "number"));
      if (weAfterSanitize.length > 0) {
        debugLog("[AFTER_SANITIZE_WE]", `Found ${weAfterSanitize.length} entries with custom: ${weAfterSanitize.slice(0, 3).map((e) => `${e.pattern}(op=${e.backgroundOpacity}, rad=${e.highlightBorderRadius})`).join(", ")}`);
      } else {
        debugLog("[AFTER_SANITIZE_WE]", `NO entries with custom properties found after sanitize`);
      }
      const tbgAfterSanitize = (this.settings.textBgColoringEntries || []).filter((e) => e && (typeof e.backgroundOpacity === "number" || typeof e.highlightBorderRadius === "number"));
      if (tbgAfterSanitize.length > 0) {
        debugLog("[AFTER_SANITIZE_TBG]", `Found ${tbgAfterSanitize.length} entries with custom: ${tbgAfterSanitize.slice(0, 3).map((e) => `${e.pattern}(op=${e.backgroundOpacity}, rad=${e.highlightBorderRadius})`).join(", ")}`);
      } else {
        debugLog("[AFTER_SANITIZE_TBG]", `NO TBG entries with custom properties found after sanitize`);
      }
    } catch (e) {
    }
    try {
      if (Array.isArray(this.settings.customSwatches) && this.settings.customSwatches.length > 0) {
        const hasStringItems = this.settings.customSwatches.some((s) => typeof s === "string");
        if (hasStringItems) {
          const migrated = this.settings.customSwatches.filter((s) => typeof s === "string").map((c, idx) => ({ name: `Swatch ${idx + 1}`, color: c }));
          if (!Array.isArray(this.settings.userCustomSwatches)) {
            this.settings.userCustomSwatches = [];
          }
          const existingColors = new Set(this.settings.userCustomSwatches.map((s) => s && s.color));
          migrated.forEach((ms) => {
            if (ms && !existingColors.has(ms.color)) this.settings.userCustomSwatches.push(ms);
          });
          this.settings.customSwatches = [];
        }
      } else {
        this.settings.customSwatches = Array.isArray(this.settings.userCustomSwatches) ? this.settings.userCustomSwatches.map((s) => s.color) : [];
      }
    } catch (e) {
    }
    try {
      const defaultSwatches = [
        { name: "Red", color: "#eb3b5a" },
        { name: "Orange", color: "#fa8231" },
        { name: "Yellow", color: "#e5a216" },
        { name: "Green", color: "#20bf6b" },
        { name: "Cyan", color: "#0fb9b1" },
        { name: "Blue", color: "#2d98da" },
        { name: "Dark Blue", color: "#3867d6" },
        { name: "Indigo", color: "#5454d0" },
        { name: "Purple", color: "#8854d0" },
        { name: "Light Purple", color: "#b554d0" },
        { name: "Neon Pink", color: "#e832c1" },
        { name: "Hot Pink", color: "#e83289" },
        { name: "Brown", color: "#965b3b" },
        { name: "Gray", color: "#8392a4" }
      ];
      if (Array.isArray(this.settings.swatches) && this.settings.swatches.length > defaultSwatches.length) {
        const userAddedSwatches = this.settings.swatches.slice(defaultSwatches.length);
        if (!Array.isArray(this.settings.userCustomSwatches)) {
          this.settings.userCustomSwatches = [];
        }
        const existingColors = new Set(this.settings.userCustomSwatches.map((s) => s && s.color));
        userAddedSwatches.forEach((swatch) => {
          if (swatch && swatch.color && !existingColors.has(swatch.color)) {
            this.settings.userCustomSwatches.push(swatch);
            existingColors.add(swatch.color);
          }
        });
        this.settings.swatches = defaultSwatches;
      }
    } catch (e) {
    }
    try {
      if (Array.isArray(this.settings.pathRules)) {
        this.settings.pathRules = this.settings.pathRules.map((r) => {
          if (!r) return r;
          const mt = r.matchType;
          if (mt === "wildcard") {
            const p = String(r.path || "").trim();
            if (p.includes("*")) {
              const raw = this.normalizePath(p);
              const esc = raw.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
              const re = "^" + esc.replace(/\*/g, ".*") + "$";
              return { ...r, matchType: "regex", path: re };
            } else {
              return { ...r, matchType: "has-name" };
            }
          }
          if (!mt) {
            return { ...r, matchType: "has-name" };
          }
          return r;
        });
      }
    } catch (e) {
    }
    if (!Array.isArray(this.settings.wordEntries) || this.settings.wordEntries.length === 0) {
      const obj = this.settings.wordColors || {};
      const arr = [];
      for (const k of Object.keys(obj)) {
        const c = obj[k];
        arr.push({ pattern: String(k), color: this.isValidHexColor(String(c)) ? String(c) : "", isRegex: false, flags: "", groupedPatterns: null, styleType: "text" });
      }
      this.settings.wordEntries = arr;
    } else {
      this.settings.wordEntries = this.settings.wordEntries.map((e) => {
        if (!e) return null;
        if (typeof e === "string") return { pattern: e, color: "", isRegex: false, flags: "", groupedPatterns: null, styleType: "text" };
        const color = e.color || e.hex || "";
        const textColor = e.textColor;
        const backgroundColor = e.backgroundColor;
        const hasValidColor = this.isValidHexColor(color);
        const hasValidText = textColor === "currentColor" || this.isValidHexColor(textColor);
        const hasValidBg = this.isValidHexColor(backgroundColor);
        let styleType2 = e.styleType;
        if (!styleType2) {
          if (hasValidText && hasValidBg) styleType2 = "both";
          else if (hasValidBg) styleType2 = "highlight";
          else styleType2 = "text";
        }
        const finalColor = styleType2 === "both" || styleType2 === "highlight" ? "" : hasValidColor ? color : "";
        const finalText = hasValidText ? textColor : styleType2 === "highlight" ? "currentColor" : null;
        const finalBg = hasValidBg ? backgroundColor : null;
        const mapped = {
          pattern: e.pattern || e.word || "",
          color: finalColor,
          textColor: finalText,
          backgroundColor: finalBg,
          styleType: styleType2,
          isRegex: !!e.isRegex,
          flags: e.flags || "",
          groupedPatterns: e.groupedPatterns || null,
          matchType: typeof e.matchType === "string" && (/* @__PURE__ */ new Set(["exact", "contains", "startswith", "endswith"])).has(e.matchType.toLowerCase()) ? e.matchType.toLowerCase() : this.settings.partialMatch ? "contains" : "exact",
          presetLabel: e.presetLabel || void 0,
          // PRESERVE targetElement (Critical for reading mode formatting)
          targetElement: e.targetElement || (e.presetLabel && /bold\s*italic/i.test(e.presetLabel) ? "strong-em" : e.presetLabel && /bold/i.test(e.presetLabel) ? "strong" : e.presetLabel && /italic/i.test(e.presetLabel) ? "em" : e.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1" ? "strong" : e.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1" ? "em" : e.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1" ? "strong-em" : void 0),
          // PRESERVE custom styling properties from original entry
          backgroundOpacity: e.backgroundOpacity,
          highlightBorderRadius: e.highlightBorderRadius,
          highlightHorizontalPadding: e.highlightHorizontalPadding,
          highlightVerticalPadding: e.highlightVerticalPadding,
          enableBorderThickness: e.enableBorderThickness,
          borderStyle: e.borderStyle,
          borderLineStyle: e.borderLineStyle,
          borderOpacity: e.borderOpacity,
          borderThickness: e.borderThickness,
          uid: e.uid
          // Also preserve UID
        };
        try {
          if (Array.isArray(e.inclusionRules)) {
            mapped.inclusionRules = e.inclusionRules.map((r) => ({
              path: String(r && r.path || ""),
              isRegex: !!(r && r.isRegex),
              flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
            })).filter((r) => r.path.length > 0);
          } else {
            mapped.inclusionRules = [];
          }
          if (Array.isArray(e.exclusionRules)) {
            mapped.exclusionRules = e.exclusionRules.map((r) => ({
              path: String(r && r.path || ""),
              isRegex: !!(r && r.isRegex),
              flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
            })).filter((r) => r.path.length > 0);
          } else {
            mapped.exclusionRules = [];
          }
        } catch (_) {
          mapped.inclusionRules = Array.isArray(mapped.inclusionRules) ? mapped.inclusionRules : [];
          mapped.exclusionRules = Array.isArray(mapped.exclusionRules) ? mapped.exclusionRules : [];
        }
        return mapped;
      }).filter((x) => x && String(x.pattern).trim() !== "");
    }
    try {
      const tbg = Array.isArray(this.settings.textBgColoringEntries) ? this.settings.textBgColoringEntries : [];
      if (tbg.length > 0) {
        debugLog("[MIGRATE_TBG]", `Starting migration of ${tbg.length} TBG entries into wordEntries. wordEntries before: ${this.settings.wordEntries.length}`);
        for (const e of tbg) {
          if (!e) continue;
          const patterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "").trim()];
          const textColor = e.textColor || "currentColor";
          const backgroundColor = e.backgroundColor;
          const isRegex = !!e.isRegex;
          const flags = e.flags || "";
          if (!patterns[0]) continue;
          let merged = false;
          for (let i = 0; i < this.settings.wordEntries.length; i++) {
            const we = this.settings.wordEntries[i];
            if (!we) continue;
            const wePatterns = Array.isArray(we.groupedPatterns) && we.groupedPatterns.length > 0 ? we.groupedPatterns : [String(we.pattern || "").trim()];
            const match = wePatterns.some((p) => String(p).trim() === String(patterns[0]).trim());
            if (match) {
              we.textColor = textColor;
              we.backgroundColor = backgroundColor;
              we.color = "";
              we.styleType = textColor && textColor !== "currentColor" ? backgroundColor ? "both" : "text" : backgroundColor ? "highlight" : we.styleType || "text";
              we.isRegex = isRegex;
              we.flags = flags;
              we.groupedPatterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : we.groupedPatterns || null;
              if (typeof e.backgroundOpacity === "number") we.backgroundOpacity = e.backgroundOpacity;
              if (typeof e.highlightBorderRadius === "number") we.highlightBorderRadius = e.highlightBorderRadius;
              if (typeof e.highlightHorizontalPadding === "number") we.highlightHorizontalPadding = e.highlightHorizontalPadding;
              if (typeof e.highlightVerticalPadding === "number") we.highlightVerticalPadding = e.highlightVerticalPadding;
              if (typeof e.enableBorderThickness === "boolean") we.enableBorderThickness = e.enableBorderThickness;
              if (typeof e.borderStyle === "string") we.borderStyle = e.borderStyle;
              if (typeof e.borderLineStyle === "string") we.borderLineStyle = e.borderLineStyle;
              if (typeof e.borderOpacity === "number") we.borderOpacity = e.borderOpacity;
              if (typeof e.borderThickness === "number") we.borderThickness = e.borderThickness;
              try {
                if (Array.isArray(e.inclusionRules)) {
                  we.inclusionRules = e.inclusionRules.map((r) => ({
                    path: String(r && r.path || ""),
                    isRegex: !!(r && r.isRegex),
                    flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
                  })).filter((r) => r.path.length > 0);
                } else if (!Array.isArray(we.inclusionRules)) {
                  we.inclusionRules = [];
                }
                if (Array.isArray(e.exclusionRules)) {
                  we.exclusionRules = e.exclusionRules.map((r) => ({
                    path: String(r && r.path || ""),
                    isRegex: !!(r && r.isRegex),
                    flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
                  })).filter((r) => r.path.length > 0);
                } else if (!Array.isArray(we.exclusionRules)) {
                  we.exclusionRules = [];
                }
              } catch (_) {
                if (!Array.isArray(we.inclusionRules)) we.inclusionRules = [];
                if (!Array.isArray(we.exclusionRules)) we.exclusionRules = [];
              }
              merged = true;
              break;
            }
          }
          if (!merged) {
            const styleType2 = textColor && textColor !== "currentColor" ? backgroundColor ? "both" : "text" : backgroundColor ? "highlight" : "text";
            const newEntry = {
              pattern: patterns[0],
              color: styleType2 === "text" ? textColor || "" : "",
              isRegex,
              flags,
              groupedPatterns: Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : null,
              textColor: styleType2 !== "text" ? textColor : null,
              backgroundColor,
              styleType: styleType2,
              matchType: this.settings.partialMatch ? "contains" : "exact"
            };
            if (typeof e.backgroundOpacity === "number") newEntry.backgroundOpacity = e.backgroundOpacity;
            if (typeof e.highlightBorderRadius === "number") newEntry.highlightBorderRadius = e.highlightBorderRadius;
            if (typeof e.highlightHorizontalPadding === "number") newEntry.highlightHorizontalPadding = e.highlightHorizontalPadding;
            if (typeof e.highlightVerticalPadding === "number") newEntry.highlightVerticalPadding = e.highlightVerticalPadding;
            if (typeof e.enableBorderThickness === "boolean") newEntry.enableBorderThickness = e.enableBorderThickness;
            if (typeof e.borderStyle === "string") newEntry.borderStyle = e.borderStyle;
            if (typeof e.borderLineStyle === "string") newEntry.borderLineStyle = e.borderLineStyle;
            if (typeof e.borderOpacity === "number") newEntry.borderOpacity = e.borderOpacity;
            if (typeof e.borderThickness === "number") newEntry.borderThickness = e.borderThickness;
            try {
              if (Array.isArray(e.inclusionRules)) {
                newEntry.inclusionRules = e.inclusionRules.map((r) => ({
                  path: String(r && r.path || ""),
                  isRegex: !!(r && r.isRegex),
                  flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
                })).filter((r) => r.path.length > 0);
              } else {
                newEntry.inclusionRules = [];
              }
              if (Array.isArray(e.exclusionRules)) {
                newEntry.exclusionRules = e.exclusionRules.map((r) => ({
                  path: String(r && r.path || ""),
                  isRegex: !!(r && r.isRegex),
                  flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
                })).filter((r) => r.path.length > 0);
              } else {
                newEntry.exclusionRules = [];
              }
            } catch (_) {
              newEntry.inclusionRules = Array.isArray(newEntry.inclusionRules) ? newEntry.inclusionRules : [];
              newEntry.exclusionRules = Array.isArray(newEntry.exclusionRules) ? newEntry.exclusionRules : [];
            }
            this.settings.wordEntries.push(newEntry);
          }
        }
        this.settings.textBgColoringEntries = [];
        debugLog("[MIGRATE_TBG]", `Migration complete. wordEntries after: ${this.settings.wordEntries.length}`);
      }
    } catch (e) {
    }
    try {
      const weBeforeCompile = (this.settings.wordEntries || []).filter((e) => e && (typeof e.backgroundOpacity === "number" || typeof e.highlightBorderRadius === "number"));
      if (weBeforeCompile.length > 0) {
        debugLog("[BEFORE_COMPILE_WE]", `Found ${weBeforeCompile.length} entries with custom: ${weBeforeCompile.slice(0, 3).map((e) => `${e.pattern}(op=${e.backgroundOpacity}, rad=${e.highlightBorderRadius})`).join(", ")}`);
      }
    } catch (e) {
    }
    if (Array.isArray(this.settings.wordEntries) && this.settings.wordEntries.some((e) => e && e.isRegex)) {
      this.settings.enableRegexSupport = true;
    }
    if (Array.isArray(this.settings.blacklistEntries) && this.settings.blacklistEntries.some((e) => e && e.isRegex)) {
      this.settings.enableRegexSupport = true;
    }
    this.compileWordEntries();
    this.compileTextBgColoringEntries();
    this.compileBlacklistEntries();
    this._wordPatternsCompilationDirty = true;
    this._textBgPatternsCompilationDirty = true;
    this._blacklistCompilationDirty = true;
    this.compileBlacklistEntries();
    try {
      this.startMemoryMonitor();
    } catch (e) {
    }
  }
  async fetchLatestRelease() {
    const url = "https://api.github.com/repos/Kazi-Aidah/always-color-text/releases/latest";
    try {
      if (typeof requestUrl === "function") {
        const res = await requestUrl({ url, headers: { "Accept": "application/vnd.github.v3+json", "User-Agent": "Obsidian-Always-Color-Text" } });
        const data = res.json || (res.text ? JSON.parse(res.text) : null);
        return data;
      }
    } catch (e) {
    }
    try {
      const r = await fetch(url, { headers: { "Accept": "application/vnd.github.v3+json", "User-Agent": "Obsidian-Always-Color-Text" } });
      if (!r.ok) throw new Error("Network error");
      return await r.json();
    } catch (e) {
      return null;
    }
  }
  async fetchAllReleases() {
    const allReleases = [];
    let page = 1;
    let hasMorePages = true;
    while (hasMorePages) {
      const url = `https://api.github.com/repos/Kazi-Aidah/always-color-text/releases?page=${page}&per_page=100`;
      try {
        let data = null;
        if (typeof requestUrl === "function") {
          try {
            const res = await requestUrl({ url, headers: { "Accept": "application/vnd.github.v3+json", "User-Agent": "Obsidian-Always-Color-Text" } });
            data = res.json || (res.text ? JSON.parse(res.text) : null);
          } catch (e) {
          }
        }
        if (!data) {
          try {
            const r = await fetch(url, { headers: { "Accept": "application/vnd.github.v3+json", "User-Agent": "Obsidian-Always-Color-Text" } });
            if (!r.ok) throw new Error("Network error");
            data = await r.json();
          } catch (e) {
            hasMorePages = false;
            break;
          }
        }
        if (!Array.isArray(data) || data.length === 0) {
          hasMorePages = false;
        } else {
          allReleases.push(...data);
          if (data.length < 100) {
            hasMorePages = false;
          } else {
            page++;
          }
        }
      } catch (e) {
        hasMorePages = false;
      }
    }
    return allReleases;
  }
  // --- Save settings and refresh plugin state ---
  applyFormattingStyles() {
    try {
      const styleId = "act-formatting-styles";
      let styleEl = document.getElementById(styleId);
      const we = this.settings.wordEntries || [];
      const weAll2 = (this.settings.wordEntryGroups || []).reduce((acc, g) => acc.concat(g.entries || []), []).concat(we);
      const hasBoldItalic = we.some((e) => e.targetElement === "strong-em") || weAll2.some((e) => e.targetElement === "strong-em");
      const targets = [
        {
          type: "strong",
          selector: hasBoldItalic ? ".cm-strong:not(.cm-em), .markdown-rendered strong:not(:has(em)), .cm-s-obsidian span.cm-strong:not(.cm-em)" : ".cm-strong, .markdown-rendered strong, .cm-s-obsidian span.cm-strong"
        },
        {
          type: "em",
          selector: hasBoldItalic ? ".cm-em:not(.cm-strong), .markdown-rendered em:not(:has(strong)), .cm-s-obsidian span.cm-em:not(.cm-strong)" : ".cm-em, .markdown-rendered em, .cm-s-obsidian span.cm-em"
        },
        {
          type: "strong-em",
          selector: ".cm-strong.cm-em, .cm-strong .cm-em, .cm-em .cm-strong, .markdown-rendered strong em, .markdown-rendered em strong, .cm-s-obsidian span.cm-strong.cm-em"
        }
      ];
      let css = "";
      targets.forEach((t) => {
        const reversedWe = [...we].reverse();
        const reversedWeAll = [...weAll2].reverse();
        const entry = reversedWe.find((e) => e && e.targetElement === t.type) || reversedWeAll.find((e) => e && e.targetElement === t.type);
        if (entry) {
          const textColor = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color || null;
          const bgColor = entry.backgroundColor || null;
          css += `${t.selector} {`;
          if (textColor || bgColor) {
            if (textColor) css += ` color: ${textColor} !important;`;
            if (bgColor) {
              const opacityRaw = typeof entry.backgroundOpacity === "number" ? entry.backgroundOpacity : this.settings.backgroundOpacity ?? 25;
              const opacity = opacityRaw <= 1 && opacityRaw > 0 ? opacityRaw * 100 : opacityRaw;
              const bgRgba = this.hexToRgba(bgColor, opacity);
              css += ` background-color: ${bgRgba} !important;`;
            }
          }
          {
            const hPad = typeof entry.highlightHorizontalPadding === "number" ? entry.highlightHorizontalPadding : this.settings.highlightHorizontalPadding ?? 4;
            const vPad = typeof entry.highlightVerticalPadding === "number" ? entry.highlightVerticalPadding : this.settings.highlightVerticalPadding ?? 0;
            const radius = typeof entry.highlightBorderRadius === "number" ? entry.highlightBorderRadius : this.settings.highlightBorderRadius ?? 8;
            const borderCSS = this.generateBorderStyle(textColor, bgColor, entry);
            css += ` padding-left: ${hPad}px !important; padding-right: ${hPad}px !important;`;
            css += ` padding-top: ${vPad}px !important; padding-bottom: ${vPad}px !important;`;
            css += ` border-radius: ${radius}px !important;`;
            if (borderCSS) css += borderCSS;
            if (this.settings.enableBoxDecorationBreak !== false) {
              css += ` box-decoration-break: clone; -webkit-box-decoration-break: clone;`;
            }
          }
          css += ` } 
`;
        }
      });
      if (css) {
        if (!styleEl) {
          styleEl = document.createElement("style");
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
        styleEl.textContent = css;
      } else {
        if (styleEl) styleEl.remove();
      }
    } catch (e) {
      console.error("ACT: Error applying formatting styles", e);
    }
  }
  async saveSettings() {
    try {
      this.sanitizeSettings();
    } catch (e) {
    }
    const data = Object.assign({}, this.settings);
    const globalStyles = {};
    GLOBAL_STYLE_KEYS.forEach((key) => {
      if (data[key] !== void 0) {
        globalStyles[key] = data[key];
        delete data[key];
      }
    });
    data.globalStyles = globalStyles;
    if (Array.isArray(data.wordEntries)) {
      data.wordEntries = data.wordEntries.map((e) => this.compressEntry(e));
    }
    if (Array.isArray(data.wordEntryGroups)) {
      data.wordEntryGroups = data.wordEntryGroups.map((g) => {
        const ng = Object.assign({}, g);
        if (Array.isArray(ng.entries)) {
          ng.entries = ng.entries.map((e) => this.compressEntry(e));
        }
        return ng;
      });
    }
    if (Array.isArray(data.quickStyles)) {
      data.quickStyles = data.quickStyles.map((e) => this.compressEntry(e));
    }
    if (Array.isArray(data.quickColors)) {
      data.quickColors = data.quickColors.map((e) => this.compressEntry(e));
    }
    await this.saveData(data);
    this.compileWordEntries();
    this.compileTextBgColoringEntries();
    this.compileBlacklistEntries();
    try {
      this._pathRulesCache = /* @__PURE__ */ new Map();
    } catch (e) {
      this._pathRulesCache = /* @__PURE__ */ new Map();
    }
    this.disablePluginFeatures();
    if (this.settings.enabled) {
      this.enablePluginFeatures();
    }
    this.updateStatusBar();
    try {
      this.forceRefreshAllEditors();
    } catch (e) {
    }
    try {
      this.forceRefreshAllReadingViews();
    } catch (e) {
    }
  }
  async exportSettingsToVault() {
    const payload = this.buildExportPayload();
    const d = /* @__PURE__ */ new Date();
    const pad = (n) => String(n).padStart(2, "0");
    let vaultName = "vault";
    try {
      const n = this.app?.vault?.getName?.();
      vaultName = String(n || "vault").trim();
    } catch (e) {
    }
    const safeVault = vaultName.replace(/[^a-z0-9-_]+/gi, "_");
    const fname = `always-color-text-export-${safeVault}-${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.json`;
    const path = `.obsidian/plugins/always-color-text/${fname}`;
    await this.app.vault.adapter.write(path, JSON.stringify(payload, null, 2));
    return path;
  }
  async importSettingsFromJson(text) {
    let obj = null;
    try {
      obj = JSON.parse(String(text || ""));
    } catch (e) {
      throw new Error("invalid json");
    }
    const incoming = obj && obj.settings ? obj.settings : obj;
    if (!incoming || typeof incoming !== "object") throw new Error("invalid payload");
    const merged = Object.assign({}, this.settings, incoming);
    this.settings = merged;
    try {
      this.sanitizeSettings();
    } catch (e) {
    }
    await this.saveSettings();
    this.reconfigureEditorExtensions();
    this.forceRefreshAllEditors();
    this.forceRefreshAllReadingViews();
  }
  buildExportPayload() {
    return {
      plugin: "always-color-text",
      version: this.manifest && this.manifest.version || "",
      settings: this.settings
      // Note: Each entry in settings.wordEntries includes per-entry highlight style settings:
      // - styleType: 'text' | 'highlight' | 'both'
      // - backgroundOpacity, highlightBorderRadius, highlightHorizontalPadding, etc. (individual entry customizations)
    };
  }
  async exportSettingsToPickedLocation() {
    const payload = this.buildExportPayload();
    const json = JSON.stringify(payload, null, 2);
    const d = /* @__PURE__ */ new Date();
    const pad = (n) => String(n).padStart(2, "0");
    let vaultName = "vault";
    try {
      const n = this.app?.vault?.getName?.();
      vaultName = String(n || "vault").trim();
    } catch (e) {
    }
    const safeVault = vaultName.replace(/[^a-z0-9-_]+/gi, "_");
    const fname = `always-color-text-export-${safeVault}-${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.json`;
    try {
      const { Platform } = require("obsidian");
      const isMobile = !!(Platform && (Platform.isMobileApp || Platform.isMobile));
      if (isMobile) {
        try {
          if (typeof navigator !== "undefined") {
            const file = new File([json], fname, { type: "application/json" });
            const canShare = !!(navigator.canShare && navigator.canShare({ files: [file] }));
            if (canShare && navigator.share) {
              await navigator.share({ files: [file], title: fname, text: this.plugin.t("share_export_title", "Always Color Text export") });
              return fname;
            }
          }
        } catch (e) {
        }
        return await this.exportSettingsToVault();
      }
      if (typeof window === "undefined") {
        return await this.exportSettingsToVault();
      }
    } catch (e) {
    }
    if (typeof window !== "undefined" && window.showSaveFilePicker) {
      try {
        const handle = await window.showSaveFilePicker({ suggestedName: fname, types: [{ description: "JSON", accept: { "application/json": [".json"] } }] });
        const writable = await handle.createWritable();
        await writable.write(json);
        await writable.close();
        return fname;
      } catch (e) {
        return await this.exportSettingsToVault();
      }
    } else {
      try {
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          try {
            document.body.removeChild(a);
          } catch (e) {
          }
          try {
            URL.revokeObjectURL(url);
          } catch (e) {
          }
        }, 0);
        return fname;
      } catch (e) {
        return await this.exportSettingsToVault();
      }
    }
  }
  sanitizeSettings() {
    try {
      const s = this.settings || {};
      if (!Array.isArray(s.wordEntries)) s.wordEntries = [];
      if (!Array.isArray(s.blacklistEntries)) s.blacklistEntries = [];
      if (!Array.isArray(s.pathRules)) s.pathRules = [];
      s.wordEntries = s.wordEntries.map((e) => {
        const x = Object.assign({}, e || {});
        x.pattern = String(x.pattern || "");
        if (Array.isArray(x.groupedPatterns)) {
          x.groupedPatterns = x.groupedPatterns.map((p) => String(p || "")).filter((p) => (p || "").length > 0);
          if (x.groupedPatterns.length === 0) x.groupedPatterns = null;
        } else {
          x.groupedPatterns = null;
        }
        x.color = this.isValidHexColor(x.color) ? x.color : "";
        x.textColor = x.textColor && x.textColor !== "currentColor" && this.isValidHexColor(x.textColor) ? x.textColor : x.textColor === "currentColor" ? "currentColor" : null;
        x.backgroundColor = this.isValidHexColor(x.backgroundColor) ? x.backgroundColor : null;
        x.flags = String(x.flags || "").replace(/[^gimsuy]/g, "");
        x.isRegex = !!x.isRegex;
        x.styleType = x.styleType || (x.backgroundColor ? x.textColor && x.textColor !== "currentColor" ? "both" : "highlight" : x.color ? "text" : "text");
        const rawMt = String(x.matchType || "").trim();
        const mtLower = rawMt.toLowerCase();
        const normalized = mtLower === "startswith" || rawMt === "startsWith" || mtLower === "starts with" ? "startswith" : mtLower === "endswith" || rawMt === "endsWith" || mtLower === "ends with" ? "endswith" : mtLower === "exact" ? "exact" : mtLower === "contains" ? "contains" : this.settings.partialMatch ? "contains" : "exact";
        x.matchType = normalized;
        x._savedTextColor = x._savedTextColor && this.isValidHexColor(x._savedTextColor) ? x._savedTextColor : this.isValidHexColor(x.color) ? x.color : null;
        x._savedBackgroundColor = x._savedBackgroundColor && this.isValidHexColor(x._savedBackgroundColor) ? x._savedBackgroundColor : this.isValidHexColor(x.backgroundColor) ? x.backgroundColor : null;
        if (Array.isArray(e.inclusionRules)) {
          x.inclusionRules = e.inclusionRules.map((r) => ({
            path: String(r && r.path || ""),
            isRegex: !!(r && r.isRegex),
            flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
          })).filter((r) => r.path.length > 0);
        } else {
          x.inclusionRules = [];
        }
        if (!Array.isArray(x.enableFolders)) x.enableFolders = [];
        if (!Array.isArray(x.disableFolders)) x.disableFolders = [];
        if (!Array.isArray(x.enableTags)) x.enableTags = [];
        if (!Array.isArray(x.disableTags)) x.disableTags = [];
        if (Array.isArray(e.exclusionRules)) {
          x.exclusionRules = e.exclusionRules.map((r) => ({
            path: String(r && r.path || ""),
            isRegex: !!(r && r.isRegex),
            flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
          })).filter((r) => r.path.length > 0);
        } else {
          x.exclusionRules = [];
        }
        x.backgroundOpacity = typeof e.backgroundOpacity === "number" ? e.backgroundOpacity : void 0;
        x.highlightBorderRadius = typeof e.highlightBorderRadius === "number" ? e.highlightBorderRadius : void 0;
        x.highlightHorizontalPadding = typeof e.highlightHorizontalPadding === "number" ? e.highlightHorizontalPadding : void 0;
        x.highlightVerticalPadding = typeof e.highlightVerticalPadding === "number" ? e.highlightVerticalPadding : void 0;
        x.enableBorderThickness = typeof e.enableBorderThickness === "boolean" ? e.enableBorderThickness : void 0;
        x.borderStyle = typeof e.borderStyle === "string" ? e.borderStyle : void 0;
        x.borderLineStyle = typeof e.borderLineStyle === "string" ? e.borderLineStyle : void 0;
        x.borderOpacity = typeof e.borderOpacity === "number" ? e.borderOpacity : void 0;
        x.borderThickness = typeof e.borderThickness === "number" ? e.borderThickness : void 0;
        x.affectMarkElements = typeof e.affectMarkElements === "boolean" ? e.affectMarkElements : void 0;
        return x;
      });
      if (!Array.isArray(s.wordEntryGroups)) s.wordEntryGroups = [];
      s.wordEntryGroups = s.wordEntryGroups.map((g) => {
        const group = Object.assign({}, g || {});
        if (!Array.isArray(group.entries)) group.entries = [];
        if (!Array.isArray(group.enableFolders)) group.enableFolders = [];
        if (!Array.isArray(group.disableFolders)) group.disableFolders = [];
        if (!Array.isArray(group.enableTags)) group.enableTags = [];
        if (!Array.isArray(group.disableTags)) group.disableTags = [];
        group.entries = group.entries.map((e) => Object.assign({}, e || {}));
        return group;
      });
      s.blacklistEntries = s.blacklistEntries.map((e) => {
        const x = Object.assign({}, e || {});
        x.pattern = String(x.pattern || "");
        if (Array.isArray(x.groupedPatterns)) {
          x.groupedPatterns = x.groupedPatterns.map((p) => String(p || "")).filter((p) => (p || "").length > 0);
          if (x.groupedPatterns.length === 0) x.groupedPatterns = null;
        } else {
          x.groupedPatterns = null;
        }
        x.flags = String(x.flags || "").replace(/[^gimsuy]/g, "");
        x.isRegex = !!x.isRegex;
        return x;
      });
      if (Array.isArray(s.textBgColoringEntries)) {
        s.textBgColoringEntries = s.textBgColoringEntries.map((e) => {
          const x = Object.assign({}, e || {});
          x.pattern = String(x.pattern || "");
          if (Array.isArray(x.groupedPatterns)) {
            x.groupedPatterns = x.groupedPatterns.map((p) => String(p || "")).filter((p) => (p || "").length > 0);
            if (x.groupedPatterns.length === 0) x.groupedPatterns = null;
          } else {
            x.groupedPatterns = null;
          }
          x.textColor = x.textColor && x.textColor !== "currentColor" && this.isValidHexColor(x.textColor) ? x.textColor : x.textColor === "currentColor" ? "currentColor" : null;
          x.backgroundColor = this.isValidHexColor(x.backgroundColor) ? x.backgroundColor : null;
          x.flags = String(x.flags || "").replace(/[^gimsuy]/g, "");
          x.isRegex = !!x.isRegex;
          x.styleType = x.styleType || (x.backgroundColor ? x.textColor && x.textColor !== "currentColor" ? "both" : "highlight" : "text");
          if (Array.isArray(e.inclusionRules)) {
            x.inclusionRules = e.inclusionRules.map((r) => ({
              path: String(r && r.path || ""),
              isRegex: !!(r && r.isRegex),
              flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
            })).filter((r) => r.path.length > 0);
          } else {
            x.inclusionRules = [];
          }
          if (Array.isArray(e.exclusionRules)) {
            x.exclusionRules = e.exclusionRules.map((r) => ({
              path: String(r && r.path || ""),
              isRegex: !!(r && r.isRegex),
              flags: String(r && r.flags || "").replace(/[^gimsuy]/g, "")
            })).filter((r) => r.path.length > 0);
          } else {
            x.exclusionRules = [];
          }
          x.backgroundOpacity = typeof e.backgroundOpacity === "number" ? e.backgroundOpacity : void 0;
          x.highlightBorderRadius = typeof e.highlightBorderRadius === "number" ? e.highlightBorderRadius : void 0;
          x.highlightHorizontalPadding = typeof e.highlightHorizontalPadding === "number" ? e.highlightHorizontalPadding : void 0;
          x.highlightVerticalPadding = typeof e.highlightVerticalPadding === "number" ? e.highlightVerticalPadding : void 0;
          x.enableBorderThickness = typeof e.enableBorderThickness === "boolean" ? e.enableBorderThickness : void 0;
          x.borderStyle = typeof e.borderStyle === "string" ? e.borderStyle : void 0;
          x.borderLineStyle = typeof e.borderLineStyle === "string" ? e.borderLineStyle : void 0;
          x.borderOpacity = typeof e.borderOpacity === "number" ? e.borderOpacity : void 0;
          x.borderThickness = typeof e.borderThickness === "number" ? e.borderThickness : void 0;
          return x;
        });
      }
      s.pathRules = s.pathRules.map((r) => {
        const x = Object.assign({}, r || {});
        x.path = String(x.path || "");
        x.mode = x.mode === "exclude" ? "exclude" : "include";
        x.matchType = x.matchType === "regex" ? "regex" : x.matchType === "exact" ? "exact" : x.matchType === "has-name" ? "has-name" : "has-name";
        x.isFolder = !!x.isFolder;
        return x;
      });
      s.enableQuickColorOnce = !!s.enableQuickColorOnce;
      s.enableQuickHighlightOnce = !!s.enableQuickHighlightOnce;
      s.quickHighlightStyleEnable = !!s.quickHighlightStyleEnable;
      s.quickHighlightUseGlobalStyle = !!s.quickHighlightUseGlobalStyle;
      s.quickHighlightOpacity = Math.max(0, Math.min(100, Number(s.quickHighlightOpacity ?? 25)));
      s.quickHighlightBorderRadius = Math.max(0, parseInt(s.quickHighlightBorderRadius ?? 8) || 0);
      s.quickHighlightHorizontalPadding = Math.max(0, parseInt(s.quickHighlightHorizontalPadding ?? 4) || 0);
      s.quickHighlightVerticalPadding = Math.max(0, parseInt(s.quickHighlightVerticalPadding ?? 0) || 0);
      s.quickHighlightEnableBorder = !!s.quickHighlightEnableBorder;
      s.quickHighlightBorderStyle = String(s.quickHighlightBorderStyle || "full");
      s.quickHighlightBorderOpacity = Math.max(0, Math.min(100, Number(s.quickHighlightBorderOpacity ?? 100)));
      s.quickHighlightBorderThickness = Math.max(0, Math.min(5, Number(s.quickHighlightBorderThickness ?? 1)));
      s.hideHighlights = !!s.hideHighlights;
      s.hideTextColors = !!s.hideTextColors;
      if (s.hideHighlights && s.hideTextColors) {
        s.hideHighlights = false;
        s.hideTextColors = false;
      }
      const allowedSort = /* @__PURE__ */ new Set(["last-added", "a-z", "reverse-a-z", "style-order", "color"]);
      if (!allowedSort.has(s.wordsSortMode)) s.wordsSortMode = "last-added";
      const allowedBl = /* @__PURE__ */ new Set(["last-added", "a-z", "reverse-a-z"]);
      if (!allowedBl.has(s.blacklistSortMode)) s.blacklistSortMode = "last-added";
      const allowedPath = /* @__PURE__ */ new Set(["last-added", "a-z", "reverse-a-z", "mode", "type"]);
      if (!allowedPath.has(s.pathSortMode)) s.pathSortMode = "last-added";
      s.language = String(s.language || "en");
      s.highlightVerticalPadding = Math.max(0, parseInt(s.highlightVerticalPadding ?? 0) || 0);
      s.entriesSearchLimit = Math.max(0, parseInt(s.entriesSearchLimit ?? 0) || 0);
      s.blacklistSearchLimit = Math.max(0, parseInt(s.blacklistSearchLimit ?? 0) || 0);
      s.pathSearchLimit = Math.max(0, parseInt(s.pathSearchLimit ?? 0) || 0);
      this.settings = s;
    } catch (e) {
    }
  }
  // --- Save a persistent color for a word ---
  async saveEntry(word, color) {
    const pattern = String(word);
    const col = String(color);
    debugLog("SAVE", "saveEntry", { pattern, color: col });
    const idx = this.settings.wordEntries.findIndex((e) => e && e.pattern === pattern && !e.isRegex);
    if (idx !== -1) {
      this.settings.wordEntries[idx].color = col;
      this.settings.wordEntries[idx].styleType = "text";
      this.settings.wordEntries[idx].textColor = null;
      this.settings.wordEntries[idx].backgroundColor = null;
    } else {
      this.settings.wordEntries.push({
        pattern,
        color: col,
        isRegex: false,
        flags: "",
        styleType: "text",
        textColor: null,
        backgroundColor: null,
        matchType: this.settings.partialMatch ? "contains" : "exact"
      });
    }
    await this.saveSettings();
    this.reconfigureEditorExtensions();
  }
  // Add a new entry (word or regex)
  async addNewEntry(pattern, color, isRegex, flags = "", name = "") {
    try {
      const patternStr = String(pattern || "").trim();
      if (!patternStr) {
        debugWarn("ADD_ENTRY", "Pattern is empty");
        return;
      }
      if (patternStr.length > 1e4) {
        debugWarn("ADD_ENTRY", "Pattern exceeds max length (10KB)");
        return;
      }
      if (isRegex) {
        const flagsStr = String(flags || "").replace(/[^gimsuy]/g, "");
        try {
          new RegExp(patternStr, flagsStr);
        } catch (regexErr) {
          debugWarn("ADD_ENTRY", "Invalid regex pattern", regexErr);
          return;
        }
      }
      const uid = (() => {
        try {
          return Date.now().toString(36) + Math.random().toString(36).slice(2);
        } catch (e) {
          return Date.now();
        }
      })();
      const entry = {
        uid,
        pattern: patternStr,
        textColor: String(color || "#000000"),
        isRegex: !!isRegex,
        flags: String(flags || "").replace(/[^gimsuy]/g, ""),
        styleType: "text",
        backgroundColor: null,
        matchType: !isRegex ? this.settings.partialMatch ? "contains" : "exact" : "regex",
        presetLabel: name ? String(name) : void 0,
        persistAtEnd: true,
        groupedPatterns: null,
        inclusionRules: [],
        exclusionRules: []
      };
      this.settings.wordEntries.push(entry);
      await this.saveSettings();
      this.compileWordEntries();
      this.compileTextBgColoringEntries();
      try {
        this.reconfigureEditorExtensions();
      } catch (_) {
      }
      try {
        this.settingTab && this.settingTab._newEntriesSet && this.settingTab._newEntriesSet.add(uid);
      } catch (_) {
      }
    } catch (e) {
      debugError("ADD_ENTRY", "addNewEntry failed", e);
    }
  }
  // --- MIGRATION: Convert global advancedRules to per-entry rules ---
  migrateAdvancedRulesToPerEntry() {
    try {
      const advRules = Array.isArray(this.settings.advancedRules) ? this.settings.advancedRules : [];
      if (advRules.length === 0) return;
      const wordEntries = Array.isArray(this.settings.wordEntries) ? this.settings.wordEntries : [];
      const caseInsensitive = !this.settings.caseSensitive;
      advRules.forEach((rule) => {
        if (!rule || !rule.text) return;
        const ruleText = String(rule.text || "").trim();
        const ruleMode = rule.mode === "exclude" ? "exclude" : "include";
        const rulePath = String(rule.path || "").trim();
        const ruleIsRegex = !!rule.isRegex;
        const ruleFlags = String(rule.flags || "").replace(/[^gimsuy]/g, "");
        const matchingEntry = wordEntries.find((entry) => {
          if (!entry || !entry.pattern) return false;
          const entryPattern = String(entry.pattern || "").trim();
          if (caseInsensitive) {
            return ruleText.toLowerCase() === entryPattern.toLowerCase();
          } else {
            return ruleText === entryPattern;
          }
        });
        if (matchingEntry) {
          if (!Array.isArray(matchingEntry.inclusionRules)) matchingEntry.inclusionRules = [];
          if (!Array.isArray(matchingEntry.exclusionRules)) matchingEntry.exclusionRules = [];
          const newRule = {
            path: rulePath,
            isRegex: ruleIsRegex,
            flags: ruleFlags
          };
          if (ruleMode === "include") {
            if (!matchingEntry.inclusionRules.some((r) => r.path === rulePath && r.isRegex === ruleIsRegex)) {
              matchingEntry.inclusionRules.push(newRule);
            }
          } else {
            if (!matchingEntry.exclusionRules.some((r) => r.path === rulePath && r.isRegex === ruleIsRegex)) {
              matchingEntry.exclusionRules.push(newRule);
            }
          }
        }
      });
      this.settings.advancedRules = [];
      wordEntries.forEach((entry) => {
        if (!Array.isArray(entry.inclusionRules)) entry.inclusionRules = [];
        if (!Array.isArray(entry.exclusionRules)) entry.exclusionRules = [];
      });
      debugLog("MIGRATION", `Migrated ${advRules.length} global rules to per-entry rules`);
    } catch (e) {
      debugError("MIGRATION", "Error migrating advancedRules", e);
    }
  }
  // --- FORCE REFRESH all open Markdown editors ---
  forceRefreshAllEditors() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof MarkdownView && leaf.view.editor?.cm) {
        leaf.view.editor.cm.dispatch({
          effects: forceRebuildEffect.of(null)
        });
      }
    });
    try {
      if (Array.isArray(this.settings.blacklistWords) && this.settings.blacklistWords.length > 0) {
        const existing = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
        const existingPatterns = new Set(existing.map((e) => e && e.pattern));
        const migrated = this.settings.blacklistWords.filter((w) => typeof w === "string" && String(w).length > 0).map((w) => ({ pattern: String(w), isRegex: false, flags: "", groupedPatterns: null }));
        migrated.forEach((m) => {
          if (m && !existingPatterns.has(m.pattern)) existing.push(m);
        });
        this.settings.blacklistEntries = existing;
      } else if (!Array.isArray(this.settings.blacklistEntries)) {
        this.settings.blacklistEntries = [];
      }
    } catch (e) {
    }
  }
  // Clear all highlight spans from the entire document (used when disabling plugin)
  clearAllHighlights() {
    try {
      const highlights = document.querySelectorAll(".always-color-text-highlight");
      for (const hl of highlights) {
        try {
          const textNode = document.createTextNode(hl.textContent);
          hl.replaceWith(textNode);
        } catch (_) {
        }
      }
      debugLog("CLEAR_ALL", `Cleared ${highlights.length} highlights`);
    } catch (e) {
      debugError("CLEAR_ALL", "Failed to clear highlights", e);
    }
  }
  // --- FORCE REFRESH all reading views (reading mode panes) ---
  forceRefreshAllReadingViews() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof MarkdownView && leaf.view.getMode && leaf.view.getMode() === "preview") {
        if (typeof leaf.view.previewMode?.rerender === "function") {
          leaf.view.previewMode.rerender(true);
        } else if (typeof leaf.view.previewMode?.render === "function") {
          leaf.view.previewMode.render();
        } else if (typeof leaf.view?.rerender === "function") {
          leaf.view.rerender();
        }
        try {
          if (this.settings.enabled) {
            const root = leaf.view.previewMode && leaf.view.previewMode.containerEl || leaf.view.contentEl || leaf.view.containerEl;
            const path = leaf.view.file && leaf.view.file.path ? leaf.view.file.path : null;
            if (root && path) {
              try {
                this.processActiveFileOnly(root, { sourcePath: path });
              } catch (_) {
              }
            }
          }
        } catch (_) {
        }
      }
    });
  }
  // --- Reconfigure CodeMirror extensions for all editors ---
  reconfigureEditorExtensions() {
    if (this.extension) {
      this.app.workspace.unregisterEditorExtension(this.extension);
      this.app.workspace.registerEditorExtension(this.extension);
    }
    this.forceRefreshAllEditors();
  }
  // --- Trigger active document rerender ---
  triggerActiveDocumentRerender() {
    if (this._lastRerender && Date.now() - this._lastRerender < 100) {
      return;
    }
    this._lastRerender = Date.now();
    const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (activeView) {
      this.refreshEditor(activeView, true);
      setTimeout(() => {
        this.forceRefreshAllEditors();
        this.forceRefreshAllReadingViews();
      }, 50);
      return;
    }
    this.forceRefreshAllEditors();
    this.forceRefreshAllReadingViews();
    if (activeView) {
      this.refreshEditor(activeView, true);
      if (activeView.getMode && activeView.getMode() === "preview") {
        try {
          if (activeView.previewMode && typeof activeView.previewMode.rerender === "function") {
            activeView.previewMode.rerender(true);
          }
        } catch (e) {
          setTimeout(() => {
            try {
              const root = activeView.previewMode && activeView.previewMode.containerEl || activeView.contentEl || activeView.containerEl;
              if (root && activeView.file && activeView.file.path) {
                this.processActiveFileOnly(root, { sourcePath: activeView.file.path });
              }
            } catch (err) {
              this.forceRefreshAllReadingViews();
            }
          }, 100);
        }
      }
    }
  }
  // --- Update Status Bar Text ---
  updateStatusBar() {
    if (this.statusBar) {
      this.statusBar.setText(`COL: ${this.settings.enabled ? "ON" : "OFF"}`);
    }
  }
  // --- Refresh only the Active Editor!!! ---
  refreshActiveEditor(force = false) {
    if (this._refreshTimeout) clearTimeout(this._refreshTimeout);
    this._refreshSeq = (this._refreshSeq || 0) + 1;
    const token = this._refreshSeq;
    const callback = () => {
      if (token !== this._refreshSeq) return;
      if (!this.app || !this.app.workspace) return;
      const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (activeView) {
        this.refreshEditor(activeView, force);
      }
    };
    this._refreshTimeout = setTimeout(callback, 100);
  }
  // --- Refresh a Specific Editor ---
  refreshEditor(view, force = false) {
    if (view?.editor?.cm) {
      if (this._editorRefreshTimeout) clearTimeout(this._editorRefreshTimeout);
      this._editorRefreshSeq = (this._editorRefreshSeq || 0) + 1;
      const token = this._editorRefreshSeq;
      const callback = () => {
        if (token !== this._editorRefreshSeq) return;
        if (!view?.editor?.cm) return;
        try {
          const cm = view.editor.cm;
          cm.dispatch({ changes: [] });
        } catch (e) {
        }
      };
      this._editorRefreshTimeout = setTimeout(callback, 100);
    }
  }
  // --- Escape Regex Special Characters ---
  escapeRegex(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  // NEW HELPER: Check if a match is a whole word (word boundaries on both sides)
  isWholeWordMatch(text, matchStart, matchEnd) {
    const leftChar = matchStart > 0 ? text[matchStart - 1] : "";
    const rightChar = matchEnd < text.length ? text[matchEnd] : "";
    const isWordChar = (ch) => /[A-Za-z0-9]/.test(ch) || ch === "-" || ch === "'";
    const leftOk = matchStart === 0 || !isWordChar(leftChar);
    const rightOk = matchEnd === text.length || !isWordChar(rightChar);
    return leftOk && rightOk;
  }
  isSentenceLikePattern(p) {
    try {
      const s = String(p || "");
      if (/^[A-Za-z0-9'\-]+(?:\s+[A-Za-z0-9'\-]+)+$/.test(s)) return false;
      return /[\s,\.;:!\?"'\(\)\[\]\{\}<>@#]/.test(s);
    } catch (e) {
      return false;
    }
  }
  isLatinWordPattern(p) {
    try {
      const s = String(p || "");
      return /^[A-Za-z0-9'\-]+$/.test(s);
    } catch (e) {
      return false;
    }
  }
  _isWordStart(text, idx) {
    const leftChar = idx > 0 ? text[idx - 1] : "";
    const currChar = idx < text.length ? text[idx] : "";
    const isWordChar = (ch) => /[A-Za-z0-9]/.test(ch) || ch === "-" || ch === "'";
    return (idx === 0 || !isWordChar(leftChar)) && isWordChar(currChar);
  }
  _isWordEnd(text, idx) {
    const rightChar = idx < text.length ? text[idx] : "";
    const leftChar = idx > 0 ? text[idx - 1] : "";
    const isWordChar = (ch) => /[A-Za-z0-9]/.test(ch) || ch === "-" || ch === "'";
    return (idx === text.length || !isWordChar(rightChar)) && isWordChar(leftChar);
  }
  _isWordChar(ch) {
    return /[A-Za-z0-9]/.test(ch) || ch === "-" || ch === "'";
  }
  findWordStart(text, position) {
    let start = position;
    while (start > 0 && this._isWordChar(text[start - 1])) {
      start--;
    }
    return start;
  }
  findWordEnd(text, position) {
    let end = position;
    while (end < text.length && this._isWordChar(text[end])) {
      end++;
    }
    return end;
  }
  _extractWordAtPosition(text, start, end) {
    let ws = start;
    let we = end;
    while (ws > 0 && this._isWordChar(text[ws - 1])) ws--;
    while (we < text.length && this._isWordChar(text[we])) we++;
    return text.substring(ws, we);
  }
  _isPatternAtWordStart(text, start, end, pattern) {
    const word = this._extractWordAtPosition(text, start, end);
    if (typeof pattern !== "string") pattern = String(pattern || "");
    if (!pattern) return false;
    const a = this.settings.caseSensitive ? word : word.toLowerCase();
    const b = this.settings.caseSensitive ? pattern : pattern.toLowerCase();
    return a.startsWith(b);
  }
  _isPatternAtWordEnd(text, start, end, pattern) {
    const word = this._extractWordAtPosition(text, start, end);
    if (typeof pattern !== "string") pattern = String(pattern || "");
    if (!pattern) return false;
    const a = this.settings.caseSensitive ? word : word.toLowerCase();
    const b = this.settings.caseSensitive ? pattern : pattern.toLowerCase();
    return a.endsWith(b);
  }
  // Helper: Extract full word at given position
  extractFullWordAtPosition(text, start, end) {
    let wordStart = start;
    let wordEnd = end;
    while (wordStart > 0 && this._isWordChar(text[wordStart - 1])) {
      wordStart--;
    }
    while (wordEnd < text.length && this._isWordChar(text[wordEnd])) {
      wordEnd++;
    }
    return text.substring(wordStart, wordEnd);
  }
  matchSatisfiesType(text, start, end, entry) {
    try {
      const matchType = String(entry?.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
      const pattern = entry?.pattern || "";
      if (this.isSentenceLikePattern(pattern)) {
        return true;
      }
      const fullWord = this.extractFullWordAtPosition(text, start, end);
      switch (matchType) {
        case "exact":
          const exactMatch = this.settings.caseSensitive ? fullWord === pattern : fullWord.toLowerCase() === pattern.toLowerCase();
          return exactMatch;
        case "contains":
          const containsMatch = this.settings.caseSensitive ? fullWord.includes(pattern) : fullWord.toLowerCase().includes(pattern.toLowerCase());
          return containsMatch;
        case "startswith":
          try {
            const flags = this.settings.caseSensitive ? "" : "i";
            const re = new RegExp(`^${this.helpers.escapeRegex ? this.helpers.escapeRegex(pattern) : pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&")}[A-Za-z]*$`, flags);
            return re.test(fullWord);
          } catch (_) {
            const startsWithMatch = this.settings.caseSensitive ? fullWord.startsWith(pattern) : fullWord.toLowerCase().startsWith(pattern.toLowerCase());
            return startsWithMatch;
          }
        case "endswith":
          try {
            const flags = this.settings.caseSensitive ? "" : "i";
            const re = new RegExp(`^[A-Za-z]*${this.helpers.escapeRegex ? this.helpers.escapeRegex(pattern) : pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&")}$`, flags);
            return re.test(fullWord);
          } catch (_) {
            const endsWithMatch = this.settings.caseSensitive ? fullWord.endsWith(pattern) : fullWord.toLowerCase().endsWith(pattern.toLowerCase());
            return endsWithMatch;
          }
        default:
          return true;
      }
    } catch (_) {
      return true;
    }
  }
  safeRegexTest(regex, text, timeout = 50) {
    if (this.containsNonRomanCharacters(text)) {
      try {
        return Promise.resolve(regex.test(text));
      } catch (e) {
        return Promise.resolve(false);
      }
    }
    return new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        resolve(false);
      }, timeout);
      try {
        const result = regex.test(text);
        clearTimeout(timeoutId);
        resolve(result);
      } catch (e) {
        clearTimeout(timeoutId);
        resolve(false);
      }
    });
  }
  // --- Safe Regex Matching Loop with Protection ---
  safeMatchLoop(regex, text) {
    if (this._wordPatternsCompilationDirty) try {
      this.compileWordPatterns();
    } catch (e) {
    }
    if (this._textBgPatternsCompilationDirty) try {
      this.compileTextBgPatterns();
    } catch (e) {
    }
    const matches = [];
    try {
      if (regex) regex.lastIndex = 0;
    } catch (e) {
    }
    let lastIndex = 0;
    let safetyCounter = 0;
    const maxIterations = Math.min(EDITOR_PERFORMANCE_CONSTANTS.MAX_MATCHES_PER_PATTERN, 100);
    try {
      while (safetyCounter < maxIterations) {
        const match = regex.exec(text);
        if (!match) break;
        matches.push(match);
        if (regex.lastIndex === lastIndex) break;
        lastIndex = regex.lastIndex;
        safetyCounter++;
        if (matches.length >= EDITOR_PERFORMANCE_CONSTANTS.MAX_MATCHES_PER_PATTERN) break;
      }
    } catch (e) {
      debugWarn("MATCH", "safeMatchLoop error", e);
    }
    return matches;
  }
  // Create a lightweight fastTest function to reject texts that cannot contain the pattern
  createFastTester(pattern, isRegex, caseSensitive) {
    try {
      if (!pattern) return (text) => {
        const bloom2 = this._bloomFilter;
        if (bloom2 && !bloom2.mightContain(text)) return false;
        return true;
      };
      const isPresetPattern = pattern && (pattern.includes("am") || pattern.includes("@[a-zA-Z"));
      const bloom = this._bloomFilter;
      const withBloom = isPresetPattern ? (fn) => fn : (fn) => (text) => {
        if (bloom && !bloom.mightContain(text)) return false;
        return fn(text);
      };
      if (this.containsNonRomanCharacters(pattern)) {
        if (caseSensitive) {
          return withBloom((text) => typeof text === "string" && text.includes(pattern));
        } else {
          const lowerPattern = pattern.toLowerCase();
          return withBloom((text) => typeof text === "string" && text.toLowerCase().includes(lowerPattern));
        }
      }
      if (!isRegex) {
        if (caseSensitive) {
          return withBloom((text) => typeof text === "string" && text.includes(pattern));
        } else {
          const lowerPattern = pattern.toLowerCase();
          return withBloom((text) => typeof text === "string" && text.toLowerCase().includes(lowerPattern));
        }
      }
      try {
        if (pattern.includes("$") || pattern.includes("\u20AC") || pattern.includes("\xA3")) {
          return withBloom((text) => typeof text === "string" && (text.includes("$") || text.includes("\u20AC") || text.includes("\xA3")));
        }
        if (pattern.includes(":")) {
          return withBloom((text) => typeof text === "string" && text.includes(":"));
        }
        if (pattern.includes("@")) {
          return withBloom((text) => typeof text === "string" && text.includes("@"));
        }
        if (pattern.includes("-")) {
          return withBloom((text) => typeof text === "string" && text.includes("-"));
        }
        const literalMatch = pattern.match(/[A-Za-z]{3,}/);
        if (literalMatch) {
          const literal = literalMatch[0];
          if (caseSensitive) {
            return withBloom((text) => typeof text === "string" && text.includes(literal));
          } else {
            const lowerLiteral = literal.toLowerCase();
            return withBloom((text) => typeof text === "string" && text.toLowerCase().includes(lowerLiteral));
          }
        }
      } catch (e) {
      }
    } catch (e) {
    }
    if (isRegex) {
      return (text) => true;
    }
    return (text) => {
      const bloom = this._bloomFilter;
      if (bloom && !bloom.mightContain(text)) return false;
      return true;
    };
  }
  // --- Lightweight mode decision for very large documents ---
  shouldUseLightweightMode(textLength, textContent = "") {
    try {
      if (this.settings && this.settings.extremeLightweightMode) {
        return true;
      }
      const isLargeDoc = Number(textLength) > 5e4;
      const isNonRomanHeavy = this.getNonRomanCharacterRatio(textContent) > 0.3;
      return isLargeDoc || isNonRomanHeavy;
    } catch (e) {
      return false;
    }
  }
  // NEW METHOD: Check if we should skip complex processing
  isPerformanceOverloaded() {
    try {
      if (typeof performance !== "undefined" && performance.memory) {
        const usedMB = performance.memory.usedJSHeapSize / (1024 * 1024);
        if (usedMB > 1e3) {
          debugWarn("[ACT] High memory usage, skipping complex pattern processing");
          return true;
        }
      }
      const totalEntries = this.getSortedWordEntries().length;
      if (totalEntries > 100) {
        debugLog("ACT", "Many patterns defined, using conservative processing");
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  // --- Get Sorted Word Entries (Longest words first!!!) ---
  getSortedWordEntries() {
    if (!this._cachedSortedEntries || this._cacheDirty) {
      const textEntries = Array.isArray(this._compiledWordEntries) ? this._compiledWordEntries : [];
      const bgEntries = Array.isArray(this._compiledTextBgEntries) ? this._compiledTextBgEntries : [];
      const entries = textEntries.concat(bgEntries);
      const numWords = entries.length;
      if (numWords > 500) {
        debugWarn("GET_SORTED", `You have ${numWords} colored words/patterns! That's a lot and may impact performance.`);
      }
      let filtered = entries.filter((e) => {
        if (!e || !e.pattern) return false;
        const bw = Array.isArray(this.settings.blacklistWords) ? this.settings.blacklistWords : [];
        if (this.settings.caseSensitive) {
          if (bw.includes(e.pattern)) return false;
        } else {
          const lower = e.pattern.toLowerCase();
          if (bw.map((w) => String(w).toLowerCase()).includes(lower)) return false;
        }
        const blEntries = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
        for (const be of blEntries) {
          if (!be || be.isRegex) continue;
          const patterns = Array.isArray(be.groupedPatterns) && be.groupedPatterns.length > 0 ? be.groupedPatterns : [be.pattern];
          for (const p of patterns) {
            if (!p) continue;
            if (this.settings.caseSensitive) {
              if (p === e.pattern) return false;
            } else {
              if (String(p).toLowerCase() === e.pattern.toLowerCase()) return false;
            }
          }
        }
        return true;
      });
      if (this.settings.hideHighlights || this.settings.hideTextColors) {
        filtered = filtered.map((orig) => {
          const e = Object.assign({}, orig);
          if (this.settings.hideHighlights) {
            if (e.styleType === "highlight") return null;
            if (e.styleType === "both" && !e.isTextBg) {
              e.styleType = "text";
              e.backgroundColor = null;
              e.textColor = e.textColor || e.color || null;
            }
            if (e.backgroundColor && !e.styleType && !e.isTextBg) {
              e.backgroundColor = null;
              e.styleType = "text";
              e.textColor = e.textColor || e.color || null;
            }
          }
          if (this.settings.hideTextColors) {
            if (e.styleType === "text") return null;
            if (e.styleType === "both") {
              e.styleType = "highlight";
            }
            if (!e.styleType && e.color && !e.backgroundColor) {
              return null;
            }
          }
          return e;
        }).filter(Boolean);
      }
      filtered.sort((a, b) => {
        const sa = typeof a.specificity === "number" ? a.specificity : String(a.pattern || "").replace(/\*/g, "").length;
        const sb = typeof b.specificity === "number" ? b.specificity : String(b.pattern || "").replace(/\*/g, "").length;
        const specDiff = sb - sa;
        if (specDiff !== 0) return specDiff;
        return String(b.pattern || "").length - String(a.pattern || "").length;
      });
      this._cachedSortedEntries = filtered;
      this._cacheDirty = false;
    }
    return this._cachedSortedEntries;
  }
  // --- Helper: Convert hex to rgba with opacity ---
  // Helper: Validate hex color format to prevent CSS injection
  isValidHexColor(hex) {
    if (hex === "inherit" || hex === "currentColor") return true;
    if (typeof hex !== "string") return false;
    if (hex.includes(";") || hex.toLowerCase().includes("!important") || /\s/.test(hex)) return false;
    const hexRegex = /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/;
    return hexRegex.test(hex);
  }
  // Helper: Check if a color is "dark" (low luminance)
  isDarkColor(color) {
    if (!color) return false;
    try {
      let r, g, b;
      if (color.startsWith("#")) {
        let hex = color.substring(1);
        if (hex.length === 3) hex = hex.split("").map((x) => x + x).join("");
        if (hex.length !== 6) return false;
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
      } else if (color.startsWith("rgb")) {
        const parts = color.match(/\d+/g);
        if (!parts || parts.length < 3) return false;
        r = parseInt(parts[0]);
        g = parseInt(parts[1]);
        b = parseInt(parts[2]);
      } else {
        return false;
      }
      const luma = 0.299 * r + 0.587 * g + 0.114 * b;
      return luma < 60;
    } catch (e) {
      return false;
    }
  }
  hexToRgba(hex, opacityPercent) {
    if (!this.isValidHexColor(hex)) {
      return `rgba(0,0,0,1)`;
    }
    let c = hex.replace("#", "");
    if (c.length === 3) c = c.split("").map((x) => x + x).join("");
    const num = parseInt(c, 16);
    const r = num >> 16 & 255;
    const g = num >> 8 & 255;
    const b = num & 255;
    let o = Math.max(0, Math.min(100, Number(opacityPercent)));
    o = o / 100;
    return `rgba(${r},${g},${b},${o})`;
  }
  hexToHexWithAlpha(hex, opacityPercent) {
    try {
      const h = String(hex || "").trim();
      if (!/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(h)) return h;
      const pct = Math.max(0, Math.min(100, Number(opacityPercent)));
      const alpha = Math.round(pct / 100 * 255).toString(16).padStart(2, "0");
      if (h.length === 4) {
        const r = h[1];
        const g = h[2];
        const b = h[3];
        const full = `#${r}${r}${g}${g}${b}${b}`;
        return `${full}${alpha}`;
      }
      return `${h}${alpha}`;
    } catch (_) {
      return hex;
    }
  }
  // Helper: Apply border style to a span element based on settings or entry overrides
  applyBorderStyleToElement(element, textColor, backgroundColor, entry = null) {
    const enable = entry && typeof entry.enableBorderThickness !== "undefined" ? !!entry.enableBorderThickness : !!this.settings.enableBorderThickness;
    if (this.settings.hideHighlights === true || !enable) {
      element.style.border = "";
      element.style.borderTop = "";
      element.style.borderRight = "";
      element.style.borderBottom = "";
      element.style.borderLeft = "";
      return;
    }
    const borderThickness = entry && typeof entry.borderThickness === "number" ? entry.borderThickness : this.settings.borderThickness ?? 1;
    const borderOpacity = entry && typeof entry.borderOpacity === "number" ? entry.borderOpacity : this.settings.borderOpacity ?? 100;
    let sourceColor = null;
    if (textColor && textColor !== "currentColor" && this.isValidHexColor(textColor)) {
      sourceColor = textColor;
    } else if (backgroundColor && this.isValidHexColor(backgroundColor)) {
      sourceColor = backgroundColor;
    } else {
      sourceColor = "#000000";
    }
    const borderColorRgba = this.hexToRgba(sourceColor, borderOpacity);
    const borderStyleType = entry && typeof entry.borderStyle === "string" ? entry.borderStyle : this.settings.borderStyle ?? "full";
    const lineStyle = entry && typeof entry.borderLineStyle === "string" ? entry.borderLineStyle : this.settings.borderLineStyle ?? "solid";
    const borderCSS = `${borderThickness}px ${lineStyle} ${borderColorRgba}`;
    switch (borderStyleType) {
      case "bottom":
        element.style.borderBottom = borderCSS;
        break;
      case "top":
        element.style.borderTop = borderCSS;
        break;
      case "left":
        element.style.borderLeft = borderCSS;
        break;
      case "right":
        element.style.borderRight = borderCSS;
        break;
      case "top-bottom":
        element.style.borderTop = borderCSS;
        element.style.borderBottom = borderCSS;
        break;
      case "left-right":
        element.style.borderLeft = borderCSS;
        element.style.borderRight = borderCSS;
        break;
      case "top-right":
        element.style.borderTop = borderCSS;
        element.style.borderRight = borderCSS;
        break;
      case "top-left":
        element.style.borderTop = borderCSS;
        element.style.borderLeft = borderCSS;
        break;
      case "bottom-right":
        element.style.borderBottom = borderCSS;
        element.style.borderRight = borderCSS;
        break;
      case "bottom-left":
        element.style.borderBottom = borderCSS;
        element.style.borderLeft = borderCSS;
        break;
      case "full":
      default:
        element.style.border = borderCSS;
        break;
    }
  }
  // Helper: Generate border CSS string based on settings (border always uses text color)
  generateBorderStyle(textColor, backgroundColor) {
    const entry = arguments.length > 2 ? arguments[2] : null;
    const enable = entry && typeof entry.enableBorderThickness !== "undefined" ? !!entry.enableBorderThickness : !!this.settings.enableBorderThickness;
    if (this.settings.hideHighlights === true || !enable) {
      return "";
    }
    const borderThickness = entry && typeof entry.borderThickness === "number" ? entry.borderThickness : this.settings.borderThickness ?? 1;
    const borderOpacity = entry && typeof entry.borderOpacity === "number" ? entry.borderOpacity : this.settings.borderOpacity ?? 100;
    let borderColor;
    if (textColor && textColor !== "currentColor" && this.isValidHexColor(textColor)) {
      borderColor = this.hexToRgba(textColor, borderOpacity);
    } else if (backgroundColor && this.isValidHexColor(backgroundColor)) {
      borderColor = this.hexToRgba(backgroundColor, borderOpacity);
    } else {
      borderColor = "rgba(0,0,0,1)";
    }
    const borderStyleType = entry && typeof entry.borderStyle === "string" ? entry.borderStyle : this.settings.borderStyle ?? "full";
    const lineStyle = entry && typeof entry.borderLineStyle === "string" ? entry.borderLineStyle : this.settings.borderLineStyle ?? "solid";
    const borderCSS = `${borderThickness}px ${lineStyle} ${borderColor} !important;`;
    switch (borderStyleType) {
      case "bottom":
        return ` border-bottom: ${borderCSS}`;
      case "top":
        return ` border-top: ${borderCSS}`;
      case "left":
        return ` border-left: ${borderCSS}`;
      case "right":
        return ` border-right: ${borderCSS}`;
      case "top-bottom":
        return ` border-top: ${borderCSS} border-bottom: ${borderCSS}`;
      case "left-right":
        return ` border-left: ${borderCSS} border-right: ${borderCSS}`;
      case "top-left-right":
        return ` border-top: ${borderCSS} border-left: ${borderCSS} border-right: ${borderCSS}`;
      case "bottom-left-right":
        return ` border-bottom: ${borderCSS} border-left: ${borderCSS} border-right: ${borderCSS}`;
      case "top-right":
        return ` border-top: ${borderCSS} border-right: ${borderCSS}`;
      case "top-left":
        return ` border-top: ${borderCSS} border-left: ${borderCSS}`;
      case "bottom-right":
        return ` border-bottom: ${borderCSS} border-right: ${borderCSS}`;
      case "bottom-left":
        return ` border-bottom: ${borderCSS} border-left: ${borderCSS}`;
      case "full":
      default:
        return ` border: ${borderCSS}`;
    }
  }
  getHighlightParams(entry) {
    const result = {
      opacity: entry && typeof entry.backgroundOpacity === "number" ? entry.backgroundOpacity : this.settings.backgroundOpacity ?? 25,
      radius: entry && typeof entry.highlightBorderRadius === "number" ? entry.highlightBorderRadius : this.settings.highlightBorderRadius ?? 8,
      hPad: entry && typeof entry.highlightHorizontalPadding === "number" ? entry.highlightHorizontalPadding : this.settings.highlightHorizontalPadding ?? 4,
      vPad: entry && typeof entry.highlightVerticalPadding === "number" ? entry.highlightVerticalPadding : this.settings.highlightVerticalPadding ?? 0,
      enableBorder: entry && typeof entry.enableBorderThickness !== "undefined" ? !!entry.enableBorderThickness : !!this.settings.enableBorderThickness,
      borderStyle: entry && typeof entry.borderStyle === "string" ? entry.borderStyle : this.settings.borderStyle ?? "full",
      borderLineStyle: entry && typeof entry.borderLineStyle === "string" ? entry.borderLineStyle : this.settings.borderLineStyle ?? "solid",
      borderOpacity: entry && typeof entry.borderOpacity === "number" ? entry.borderOpacity : this.settings.borderOpacity ?? 100,
      borderThickness: entry && typeof entry.borderThickness === "number" ? entry.borderThickness : this.settings.borderThickness ?? 1
    };
    return result;
  }
  // Helper: Generate tooltip text explaining why text is colored
  getColoringReasonTooltip(match) {
    try {
      if (!match || !match.entry) return "";
      const entry = match.entry;
      const pattern = entry.pattern || "";
      const matchType = (entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
      if (matchType === "exact") {
        return `matches exactly "${pattern}"`;
      } else if (matchType === "contains") {
        return `contains "${pattern}"`;
      } else if (matchType === "startswith" || matchType === "starts with") {
        return `starts with "${pattern}"`;
      } else if (matchType === "endswith" || matchType === "ends with") {
        return `ends with "${pattern}"`;
      }
      return `matches "${pattern}"`;
    } catch (e) {
      return "";
    }
  }
  generateOnceBorderStyle(backgroundColor) {
    try {
      if (this.settings.hideHighlights === true) return "";
      if (!this.settings.quickHighlightEnableBorder) return "";
      const thickness = this.settings.quickHighlightBorderThickness ?? 1;
      const opacity = this.settings.quickHighlightBorderOpacity ?? 100;
      const borderColor = this.hexToRgba(backgroundColor, opacity);
      const type = this.settings.quickHighlightBorderStyle ?? "full";
      const lineStyle = this.settings.quickHighlightBorderLineStyle ?? "solid";
      const css = `${thickness}px ${lineStyle} ${borderColor}`;
      switch (type) {
        case "bottom":
          return ` border-bottom: ${css};`;
        case "top":
          return ` border-top: ${css};`;
        case "left":
          return ` border-left: ${css};`;
        case "right":
          return ` border-right: ${css};`;
        case "top-bottom":
          return ` border-top: ${css}; border-bottom: ${css};`;
        case "left-right":
          return ` border-left: ${css}; border-right: ${css};`;
        case "top-right":
          return ` border-top: ${css}; border-right: ${css};`;
        case "top-left":
          return ` border-top: ${css}; border-left: ${css};`;
        case "bottom-right":
          return ` border-bottom: ${css}; border-right: ${css};`;
        case "bottom-left":
          return ` border-bottom: ${css}; border-left: ${css};`;
        case "full":
        default:
          return ` border: ${css};`;
      }
    } catch (_) {
      return "";
    }
  }
  generateGlobalBorderStyle(backgroundColor) {
    try {
      if (this.settings.hideHighlights === true) return "";
      if (!this.settings.enableBorderThickness) return "";
      const thickness = this.settings.borderThickness ?? 1;
      const opacity = this.settings.borderOpacity ?? 100;
      const borderColor = this.hexToRgba(backgroundColor, opacity);
      const type = this.settings.borderStyle ?? "full";
      const lineStyle = this.settings.borderLineStyle ?? "solid";
      const css = `${thickness}px ${lineStyle} ${borderColor}`;
      switch (type) {
        case "bottom":
          return ` border-bottom: ${css};`;
        case "top":
          return ` border-top: ${css};`;
        case "left":
          return ` border-left: ${css};`;
        case "right":
          return ` border-right: ${css};`;
        case "top-bottom":
          return ` border-top: ${css}; border-bottom: ${css};`;
        case "left-right":
          return ` border-left: ${css}; border-right: ${css};`;
        case "top-right":
          return ` border-top: ${css}; border-right: ${css};`;
        case "top-left":
          return ` border-top: ${css}; border-left: ${css};`;
        case "bottom-right":
          return ` border-bottom: ${css}; border-right: ${css};`;
        case "bottom-left":
          return ` border-bottom: ${css}; border-left: ${css};`;
        case "full":
        default:
          return ` border: ${css};`;
      }
    } catch (_) {
      return "";
    }
  }
  async _applyQuickColorACT(selectedText, textColor, backgroundColor, view, styleEntry = null) {
    if (this.isWordBlacklisted(selectedText, view?.file?.path)) {
      new Notice(this.t("notice_blacklisted_cannot_color", `"${selectedText}" is blacklisted and cannot be colored.`, { word: selectedText }));
      return;
    }
    if (!Array.isArray(this.settings.wordEntries)) this.settings.wordEntries = [];
    const matchType = this.settings.partialMatch ? "contains" : "exact";
    const styleType2 = textColor && backgroundColor ? "both" : backgroundColor ? "highlight" : "text";
    const targetGroupUid = styleEntry && styleEntry.groupUid ? styleEntry.groupUid : null;
    const groupsList = Array.isArray(this.settings.wordEntryGroups) ? this.settings.wordEntryGroups : [];
    const targetGroup = targetGroupUid ? groupsList.find((g) => g && g.uid === targetGroupUid) : null;
    const matchesEntry = (a, b) => {
      if (!a || !b) return false;
      if (a.uid && b.uid) return String(a.uid) === String(b.uid);
      return String(a.pattern || "") === String(b.pattern || "") && !!a.isRegex === !!b.isRegex;
    };
    const applyStyleToEntry = (entry) => {
      entry.styleType = styleType2;
      if (textColor) {
        entry.color = "";
        entry.textColor = textColor;
        entry._savedTextColor = textColor;
      }
      if (backgroundColor) {
        entry.backgroundColor = backgroundColor;
        entry._savedBackgroundColor = backgroundColor;
        entry.textColor = entry.textColor || "currentColor";
      }
      if (!entry.isRegex) entry.matchType = matchType;
      if (styleEntry) {
        if (styleEntry.groupUid) entry.groupUid = styleEntry.groupUid;
        if (styleEntry.matchType) entry.matchType = styleEntry.matchType;
        if (typeof styleEntry.backgroundOpacity === "number") entry.backgroundOpacity = styleEntry.backgroundOpacity;
        if (typeof styleEntry.highlightBorderRadius === "number") entry.highlightBorderRadius = styleEntry.highlightBorderRadius;
        if (typeof styleEntry.highlightHorizontalPadding === "number") entry.highlightHorizontalPadding = styleEntry.highlightHorizontalPadding;
        if (typeof styleEntry.highlightVerticalPadding === "number") entry.highlightVerticalPadding = styleEntry.highlightVerticalPadding;
        if (typeof styleEntry.enableBorderThickness !== "undefined") entry.enableBorderThickness = styleEntry.enableBorderThickness;
        if (styleEntry.borderStyle) entry.borderStyle = styleEntry.borderStyle;
        if (styleEntry.borderLineStyle) entry.borderLineStyle = styleEntry.borderLineStyle;
        if (typeof styleEntry.borderOpacity === "number") entry.borderOpacity = styleEntry.borderOpacity;
        if (typeof styleEntry.borderThickness === "number") entry.borderThickness = styleEntry.borderThickness;
      }
    };
    const removeFromAllGroups = (entry) => {
      for (const g of groupsList) {
        if (!g || !Array.isArray(g.entries) || g.entries.length === 0) continue;
        for (let i = g.entries.length - 1; i >= 0; i--) {
          if (matchesEntry(g.entries[i], entry)) g.entries.splice(i, 1);
        }
      }
    };
    const removeFromWordEntries = (entry) => {
      if (!Array.isArray(this.settings.wordEntries) || this.settings.wordEntries.length === 0) return;
      for (let i = this.settings.wordEntries.length - 1; i >= 0; i--) {
        if (matchesEntry(this.settings.wordEntries[i], entry)) this.settings.wordEntries.splice(i, 1);
      }
    };
    const findInGroups = () => {
      for (const g of groupsList) {
        if (!g || !Array.isArray(g.entries)) continue;
        const idx2 = g.entries.findIndex((e) => e && e.pattern === selectedText && !e.isRegex);
        if (idx2 !== -1) return { group: g, idx: idx2, entry: g.entries[idx2] };
      }
      return null;
    };
    const idx = this.settings.wordEntries.findIndex((e) => e && e.pattern === selectedText && !e.isRegex);
    let existing = null;
    let existingSource = null;
    if (idx !== -1) {
      existing = this.settings.wordEntries[idx];
      existingSource = { type: "wordEntries", idx };
    } else {
      const gFound = findInGroups();
      if (gFound && gFound.entry) {
        existing = gFound.entry;
        existingSource = { type: "group", group: gFound.group, idx: gFound.idx };
      }
    }
    if (existing) {
      applyStyleToEntry(existing);
      if (targetGroup) {
        removeFromWordEntries(existing);
        removeFromAllGroups(existing);
        if (!Array.isArray(targetGroup.entries)) targetGroup.entries = [];
        targetGroup.entries.push(existing);
      } else {
        removeFromAllGroups(existing);
        if (!existingSource || existingSource.type !== "wordEntries") {
          removeFromWordEntries(existing);
          this.settings.wordEntries.push(existing);
        }
      }
    } else {
      const newEntry = { pattern: selectedText, isRegex: false, flags: "", matchType, styleType: styleType2 };
      if (styleType2 === "text") {
        newEntry.color = textColor;
        newEntry._savedTextColor = textColor;
      } else if (styleType2 === "highlight") {
        newEntry.color = "";
        newEntry.textColor = "currentColor";
        newEntry.backgroundColor = backgroundColor;
        newEntry._savedBackgroundColor = backgroundColor;
      } else {
        newEntry.color = "";
        newEntry.textColor = textColor;
        newEntry.backgroundColor = backgroundColor;
        newEntry._savedTextColor = textColor;
        newEntry._savedBackgroundColor = backgroundColor;
      }
      if (styleEntry) {
        if (styleEntry.groupUid) newEntry.groupUid = styleEntry.groupUid;
        if (styleEntry.matchType) newEntry.matchType = styleEntry.matchType;
        if (typeof styleEntry.backgroundOpacity === "number") newEntry.backgroundOpacity = styleEntry.backgroundOpacity;
        if (typeof styleEntry.highlightBorderRadius === "number") newEntry.highlightBorderRadius = styleEntry.highlightBorderRadius;
        if (typeof styleEntry.highlightHorizontalPadding === "number") newEntry.highlightHorizontalPadding = styleEntry.highlightHorizontalPadding;
        if (typeof styleEntry.highlightVerticalPadding === "number") newEntry.highlightVerticalPadding = styleEntry.highlightVerticalPadding;
        if (typeof styleEntry.enableBorderThickness !== "undefined") newEntry.enableBorderThickness = styleEntry.enableBorderThickness;
        if (styleEntry.borderStyle) newEntry.borderStyle = styleEntry.borderStyle;
        if (styleEntry.borderLineStyle) newEntry.borderLineStyle = styleEntry.borderLineStyle;
        if (typeof styleEntry.borderOpacity === "number") newEntry.borderOpacity = styleEntry.borderOpacity;
        if (typeof styleEntry.borderThickness === "number") newEntry.borderThickness = styleEntry.borderThickness;
      }
      if (targetGroup) {
        if (!Array.isArray(targetGroup.entries)) targetGroup.entries = [];
        targetGroup.entries.push(newEntry);
      } else {
        this.settings.wordEntries.push(newEntry);
      }
    }
    await this.saveSettings();
    this.compileWordEntries();
    this.compileTextBgColoringEntries();
    this.reconfigureEditorExtensions();
    this.refreshEditor(view, true);
  }
  async _applyQuickStyleToSelection(style, selectedPair, selectedText, editor, view, forceInline = false) {
    const styleType2 = style && style.styleType ? style.styleType : "both";
    const tc = selectedPair && selectedPair.textColor ? selectedPair.textColor : style.textColor || style.color || null;
    const bc = selectedPair && selectedPair.backgroundColor ? selectedPair.backgroundColor : style.backgroundColor || null;
    if (this.settings.quickColorsApplyMode === "act" && !forceInline) {
      await this._applyQuickColorACT(selectedText, styleType2 === "text" ? tc : styleType2 === "both" ? tc : null, styleType2 === "highlight" ? bc : styleType2 === "both" ? bc : null, view, style);
      return;
    }
    const params = this.getHighlightParams(style);
    const borderCss = this.generateBorderStyle(tc, bc, style);
    if (styleType2 === "text") {
      const html2 = `<span style="color: ${tc || ""}">${selectedText}</span>`;
      editor.replaceSelection(html2);
      return;
    }
    if (styleType2 === "highlight") {
      const bg2 = bc ? this.hexToHexWithAlpha(bc, params.opacity ?? 25) : null;
      const styleStr2 = `${bg2 ? `background-color: ${bg2}; ` : ""}border-radius: ${params.radius ?? 8}px; padding: ${params.vPad ?? 0}px ${params.hPad ?? 4}px;${borderCss} box-decoration-break: clone; -webkit-box-decoration-break: clone;`;
      const html2 = `<span class="always-color-text-highlight" style="${styleStr2}">${selectedText}</span>`;
      editor.replaceSelection(html2);
      return;
    }
    const bg = bc ? this.hexToHexWithAlpha(bc, params.opacity ?? 25) : null;
    let styleStr = "";
    if (tc) styleStr += `color: ${tc}; `;
    if (bg) styleStr += `background-color: ${bg}; `;
    styleStr += `border-radius: ${params.radius ?? 8}px; padding: ${params.vPad ?? 0}px ${params.hPad ?? 4}px;${borderCss} box-decoration-break: clone; -webkit-box-decoration-break: clone;`;
    const html = `<span style="${styleStr}">${selectedText}</span>`;
    editor.replaceSelection(html);
  }
  // Helper: Extract color and background from selected HTML text in editor
  extractSelectedTextStyles(selectedText) {
    try {
      if (!selectedText || typeof selectedText !== "string") {
        return { textColor: null, backgroundColor: null };
      }
      const spanMatch = selectedText.match(/<span\s+(?:class="[^"]*"\s+)?style="([^"]*)"/i);
      if (!spanMatch || !spanMatch[1]) {
        return { textColor: null, backgroundColor: null };
      }
      const styleString = spanMatch[1];
      let textColor = null;
      let backgroundColor = null;
      const colorMatch = styleString.match(/color\s*:\s*(#[0-9A-Fa-f]{3,6}|rgb\([^)]*\)|rgba\([^)]*\)|[a-z]+)/i);
      if (colorMatch && colorMatch[1]) {
        const colorValue = colorMatch[1].trim();
        if (/^#[0-9A-Fa-f]{3,6}$/.test(colorValue)) {
          textColor = colorValue;
        }
      }
      const bgMatch = styleString.match(/background-color\s*:\s*(#[0-9A-Fa-f]{3,6}|rgb\([^)]*\)|rgba\([^)]*\)|[a-z]+)/i);
      if (bgMatch && bgMatch[1]) {
        const bgValue = bgMatch[1].trim();
        if (/^#[0-9A-Fa-f]{3,6}$/.test(bgValue)) {
          backgroundColor = bgValue;
        }
      }
      return { textColor, backgroundColor };
    } catch (e) {
      debugError("EXTRACT_STYLES", e);
      return { textColor: null, backgroundColor: null };
    }
  }
  // Helper: Check frontmatter for disabling coloring (`always-color-text: false` disables)
  isFrontmatterColoringDisabled(source) {
    if (!source) return false;
    const { TFile } = require("obsidian");
    let file = null;
    if (typeof source === "string") {
      file = this.app.vault.getAbstractFileByPath(source);
    } else if (source instanceof TFile) {
      file = source;
    } else if (source.path) {
      file = source;
    }
    if (!file) return false;
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.frontmatter) return false;
    if (Object.prototype.hasOwnProperty.call(cache.frontmatter, "always-color-text")) {
      return cache.frontmatter["always-color-text"] === false;
    }
    return false;
  }
  // --- Helper: RegExp Folder Pattern ---
  normalizePath(p) {
    return String(p || "").replace(/\\/g, "/");
  }
  _folderPatternToRegExp(p) {
    const raw = this.normalizePath(p).replace(/\/$/, "");
    const esc = raw.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
    const re = "^" + esc.replace(/\*/g, ".*") + "(?:/.*)?$";
    try {
      return new RegExp(re);
    } catch (e) {
      return null;
    }
  }
  _pathPatternToRegExp(p) {
    const raw = this.normalizePath(p);
    const esc = raw.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
    const re = "^" + esc.replace(/\*/g, ".*") + "$";
    try {
      return new RegExp(re);
    } catch (e) {
      return null;
    }
  }
  _basename(p) {
    const fp = this.normalizePath(p);
    const idx = fp.lastIndexOf("/");
    return idx === -1 ? fp : fp.slice(idx + 1);
  }
  _parentFolders(p) {
    const fp = this.normalizePath(p);
    const parts = fp.split("/");
    parts.pop();
    const res = [];
    let acc = "";
    for (const part of parts) {
      acc = acc ? acc + "/" + part : part;
      res.push(acc);
    }
    return res;
  }
  detectRuleTarget(path, matchType) {
    const s = String(path || "");
    const hasSlash = s.includes("/");
    const endsWithSlash = /\/$/.test(s);
    const hasStarSlash = s.includes("*/");
    const hasExt = /\.[a-zA-Z0-9]+$/.test(s);
    const hasStarDotStar = s.includes("*.*");
    if (matchType === "exact") {
      if (endsWithSlash || hasStarSlash) return "folder";
      if (hasExt || hasStarDotStar) return "file";
      return hasSlash ? "folder" : "file";
    }
    if (matchType === "regex") {
      return "both";
    }
    if (matchType === "has-name") {
      return "both";
    }
    return "both";
  }
  detectRuleKind(path) {
    const s = String(path || "").trim();
    if (!s) return { kind: "vault" };
    if (s.startsWith("#")) return { kind: "tag", tag: s.slice(1) };
    const isParenRegex = s.startsWith("(") && s.endsWith(")");
    if (isParenRegex) return { kind: "regex", pattern: s.slice(1, -1) };
    if (/\/$/.test(s)) return { kind: "exact-folder", path: s.replace(/\/$/, "") };
    if (s.includes("/")) return { kind: "exact-file", path: s };
    return { kind: "name", name: s };
  }
  _matchesByName(filePath, name) {
    const fp = this.normalizePath(filePath);
    const nm = String(name || "").trim();
    if (!nm) return { fileMatch: true, folderMatch: true };
    const base = this._basename(fp);
    const stem = base.replace(/\.[^/.]+$/, "");
    const fileMatch = base === nm || stem === nm;
    let folderMatch = false;
    const parents = this._parentFolders(fp);
    for (const folder of parents) {
      if (this._basename(folder) === nm) {
        folderMatch = true;
        break;
      }
    }
    return { fileMatch, folderMatch };
  }
  _matchFolder(pattern, filePath) {
    const fp = this.normalizePath(filePath);
    const re = this._folderPatternToRegExp(pattern);
    return !!(re && re.test(fp));
  }
  _matchFile(rulePath, filePath) {
    const a = this.normalizePath(rulePath);
    const b = this.normalizePath(filePath);
    return a === b;
  }
  evaluatePathRules(filePath) {
    const rules = Array.isArray(this.settings.pathRules) ? this.settings.pathRules : [];
    if (!filePath || rules.length === 0) return { included: false, excluded: false, hasIncludes: false };
    try {
      if (this._pathRulesCache && this._pathRulesCache.has(filePath)) {
        return this._pathRulesCache.get(filePath);
      }
    } catch (_) {
    }
    const fp = this.normalizePath(filePath);
    let fileInclude = false;
    let fileExclude = false;
    let folderInclude = false;
    let folderExclude = false;
    let hasIncludes = false;
    const parents = this._parentFolders(fp);
    for (const r of rules) {
      if (!r) continue;
      const mode = r.mode === "exclude" ? "exclude" : "include";
      const pathStr = String(r.path || "").trim();
      const pathEmpty = pathStr.length === 0;
      if (mode === "include") hasIncludes = true;
      if (pathEmpty) {
        if (mode === "include") {
          folderInclude = true;
          fileInclude = true;
        } else {
          folderExclude = true;
          fileExclude = true;
        }
        continue;
      }
      const dk = this.detectRuleKind(pathStr);
      if (dk.kind === "name") {
        const { fileMatch, folderMatch } = this._matchesByName(fp, dk.name);
        if (fileMatch) {
          if (mode === "include") fileInclude = true;
          else fileExclude = true;
        }
        if (folderMatch) {
          if (mode === "include") folderInclude = true;
          else folderExclude = true;
        }
        continue;
      }
      if (dk.kind === "tag") {
        const tags = this.getFileTags(fp).map((t) => t.replace(/^#/, ""));
        const hasTag = tags.includes(String(dk.tag || "").replace(/^#/, ""));
        if (hasTag) {
          if (mode === "include") fileInclude = true;
          else fileExclude = true;
        }
        continue;
      }
      if (dk.kind === "exact-folder") {
        for (const p of parents) {
          if (this.normalizePath(p) === this.normalizePath(dk.path)) {
            if (mode === "include") folderInclude = true;
            else folderExclude = true;
            break;
          }
        }
        continue;
      }
      if (dk.kind === "exact-file") {
        if (this._matchFile(dk.path, fp)) {
          if (mode === "include") fileInclude = true;
          else fileExclude = true;
        }
        continue;
      }
      if (dk.kind === "regex") {
        let re = null;
        try {
          re = new RegExp(dk.pattern);
        } catch (e) {
          re = null;
        }
        if (re) {
          if (re.test(fp)) {
            if (mode === "include") fileInclude = true;
            else fileExclude = true;
          }
          for (const p of parents) {
            if (re.test(p)) {
              if (mode === "include") folderInclude = true;
              else folderExclude = true;
              break;
            }
          }
        }
        continue;
      }
    }
    let included = false;
    let excluded = false;
    if (fileInclude) {
      included = true;
      excluded = false;
    } else if (fileExclude) {
      included = false;
      excluded = true;
    } else if (folderInclude) {
      included = true;
      excluded = false;
    } else if (folderExclude) {
      included = false;
      excluded = true;
    }
    const hasFileRule = fileInclude || fileExclude;
    const result = { included, excluded, hasIncludes, hasFileRule };
    try {
      this._pathRulesCache && this._pathRulesCache.set(filePath, result);
    } catch (_) {
    }
    return result;
  }
  // Advanced Rules: filter word entries based on file/folder path rules
  // CLEAR RULE ENGINE: Apply your four rules in strict order
  // Rule 1: Folder excluded?  No files in folder get colored
  // Rule 2: File explicitly included in excluded folder?  File gets colored
  // Rule 3: Text "only colors in" this file/folder?  Color only here
  // Rule 4: Text "does not color in" this file/folder?  Don't color here
  shouldColorText(filePath, textPattern, entry = null) {
    try {
      if (!filePath || !textPattern) return true;
      const fp = this.normalizePath(filePath);
      if (entry) {
        const enableFolders = Array.isArray(entry.groupEnableFolders) ? entry.groupEnableFolders : [];
        const disableFolders = Array.isArray(entry.groupDisableFolders) ? entry.groupDisableFolders : [];
        const hasEnableFolders = enableFolders.length > 0;
        const hasDisableFolders = disableFolders.length > 0;
        let folderDecision = 0;
        if (hasEnableFolders || hasDisableFolders) {
          const parents = this._parentFolders(fp).map((p) => this.normalizePath(p));
          const normRule = (p) => {
            const n = this.normalizePath(String(p || "").trim());
            if (n === "/") return "/";
            return n.replace(/\/$/, "");
          };
          let enableMatch = false;
          let disableMatch = false;
          let bestEnableDepth = -1;
          let bestDisableDepth = -1;
          for (const f of enableFolders) {
            const fNorm = normRule(f);
            if (!fNorm) continue;
            if (fNorm === "/" || fNorm === "") {
              enableMatch = true;
              if (bestEnableDepth < 0) bestEnableDepth = 0;
              continue;
            }
            const matchParent = parents.find((p) => p === fNorm);
            if (matchParent) {
              enableMatch = true;
              const depth = matchParent.split("/").length;
              if (depth > bestEnableDepth) bestEnableDepth = depth;
            }
          }
          for (const f of disableFolders) {
            const fNorm = normRule(f);
            if (!fNorm) continue;
            if (fNorm === "/" || fNorm === "") {
              disableMatch = true;
              if (bestDisableDepth < 0) bestDisableDepth = 0;
              continue;
            }
            const matchParent = parents.find((p) => p === fNorm);
            if (matchParent) {
              disableMatch = true;
              const depth = matchParent.split("/").length;
              if (depth > bestDisableDepth) bestDisableDepth = depth;
            }
          }
          if (!enableMatch && !disableMatch) {
            if (hasEnableFolders) folderDecision = -1;
          } else if (enableMatch && disableMatch) {
            if (bestDisableDepth > bestEnableDepth) folderDecision = -1;
            else folderDecision = 1;
          } else if (!enableMatch && disableMatch) {
            folderDecision = -1;
          } else if (enableMatch && !disableMatch) {
            folderDecision = 1;
          }
        }
        const hasEnableTags = Array.isArray(entry.groupEnableTags) && entry.groupEnableTags.length > 0;
        const hasDisableTags = Array.isArray(entry.groupDisableTags) && entry.groupDisableTags.length > 0;
        let tagDecision = 0;
        if (hasEnableTags || hasDisableTags) {
          const fileTags = this.getFileTags(filePath);
          const normTag = (t) => String(t || "").replace(/^#/, "").trim();
          const enableTags = hasEnableTags ? entry.groupEnableTags.map(normTag).filter(Boolean) : [];
          const disableTags = hasDisableTags ? entry.groupDisableTags.map(normTag).filter(Boolean) : [];
          const enableMatchTag = enableTags.length > 0 && fileTags.some((t) => enableTags.includes(normTag(t)));
          const disableMatchTag = disableTags.length > 0 && fileTags.some((t) => disableTags.includes(normTag(t)));
          if (enableTags.length > 0 && !enableMatchTag) {
            tagDecision = -1;
          }
          if (disableMatchTag) tagDecision = -1;
          if (enableMatchTag) tagDecision = 1;
        }
        if (folderDecision === 1 || tagDecision === 1) {
        } else if (folderDecision === -1 || tagDecision === -1) {
          return false;
        }
      }
      const pathRules = Array.isArray(this.settings.pathRules) ? this.settings.pathRules : [];
      const advRules = Array.isArray(this.settings.advancedRules) ? this.settings.advancedRules : [];
      const caseInsensitive = !this.settings.caseSensitive;
      if (String(textPattern).includes("belmo")) {
        debugLog("RULE_CHECK_BELMO", `Checking pattern "${textPattern}" in file "${filePath}"`);
        debugLog("RULE_CHECK_BELMO", `advRules count: ${advRules.length}`);
        advRules.forEach((r, i) => {
          debugLog("RULE_CHECK_BELMO", `Rule ${i}: text="${r.text}" mode="${r.mode}" path="${r.path}"`);
        });
      }
      const textMatches = (rule, pattern) => {
        const ruleText = String(rule.text || "").trim();
        if (!ruleText) return false;
        const patternStr = String(pattern).trim();
        if (rule.isRegex) {
          if (caseInsensitive) {
            return ruleText.toLowerCase() === patternStr.toLowerCase();
          } else {
            return ruleText === patternStr;
          }
        }
        if (caseInsensitive) {
          return ruleText.toLowerCase() === patternStr.toLowerCase();
        } else {
          return ruleText === patternStr;
        }
      };
      const pathMatches = (rule) => {
        const pathStr = String(rule.path || "").trim();
        if (pathStr.length === 0) return true;
        const dk = this.detectRuleKind(pathStr);
        if (dk.kind === "tag") {
          const tags = this.getFileTags(filePath).map((t) => t.replace(/^#/, ""));
          if (tags.includes(String(dk.tag || "").replace(/^#/, ""))) return "file";
          return null;
        }
        if (dk.kind === "name") {
          const { fileMatch, folderMatch } = this._matchesByName(fp, dk.name);
          return fileMatch || folderMatch;
        }
        if (dk.kind === "exact-file") return this._matchFile(dk.path, fp);
        if (dk.kind === "exact-folder") {
          const parents = this._parentFolders(fp);
          for (const p of parents) {
            if (this.normalizePath(p) === this.normalizePath(dk.path)) return true;
          }
          return false;
        }
        if (dk.kind === "regex") {
          try {
            const re = new RegExp(dk.pattern);
            if (re.test(fp)) return true;
            const parents = this._parentFolders(fp);
            for (const p of parents) {
              if (re.test(p)) return true;
            }
          } catch (e) {
            return false;
          }
        }
        return false;
      };
      const pathEval = this.evaluatePathRules(filePath);
      if (pathEval.excluded) {
        debugLog("RULE_ENGINE", `Skipping: path excluded for ${filePath}`);
        return false;
      }
      const matchType = (rule) => {
        const pathStr = String(rule.path || "").trim();
        if (pathStr.length === 0) return "vault";
        const dk = this.detectRuleKind(pathStr);
        if (dk.kind === "tag") {
          const tags = this.getFileTags(filePath).map((t) => t.replace(/^#/, ""));
          if (tags.includes(String(dk.tag || "").replace(/^#/, ""))) return "file";
          return null;
        }
        if (dk.kind === "name") {
          const { fileMatch, folderMatch } = this._matchesByName(fp, dk.name);
          if (fileMatch) return "file";
          if (folderMatch) return "folder";
          return null;
        }
        if (dk.kind === "exact-file") return this._matchFile(dk.path, fp) ? "file" : null;
        if (dk.kind === "exact-folder") {
          const parents = this._parentFolders(fp);
          for (const p of parents) {
            if (this.normalizePath(p) === this.normalizePath(dk.path)) return "folder";
          }
          return null;
        }
        if (dk.kind === "regex") {
          try {
            const re = new RegExp(dk.pattern);
            if (re.test(fp)) return "file";
            const parents = this._parentFolders(fp);
            for (const p of parents) {
              if (re.test(p)) return "folder";
            }
          } catch (e) {
            return null;
          }
        }
        return null;
      };
      const perEntryInclude = entry && Array.isArray(entry.inclusionRules) ? entry.inclusionRules : [];
      const perEntryExclude = entry && Array.isArray(entry.exclusionRules) ? entry.exclusionRules : [];
      const globalInclude = advRules.filter((r) => r && r.mode === "include" && textMatches(r, textPattern)).map((r) => ({ path: r.path, isRegex: r.isRegex, flags: r.flags }));
      const globalExclude = advRules.filter((r) => r && r.mode === "exclude" && textMatches(r, textPattern)).map((r) => ({ path: r.path, isRegex: r.isRegex, flags: r.flags }));
      const includeRules = [...perEntryInclude, ...globalInclude];
      const excludeRules = [...perEntryExclude, ...globalExclude];
      const includeMatches = includeRules.map((r) => matchType(r)).filter((t) => t);
      const hasIncludeRules = includeRules.length > 0;
      const includeMatched = includeMatches.length > 0;
      const hasFileInclude = includeMatches.includes("file");
      if (hasIncludeRules && !includeMatched) {
        debugLog("RULE_ENGINE", `Skipping: text "${textPattern}" only colors elsewhere`);
        return false;
      }
      const excludeMatches = excludeRules.map((r) => matchType(r)).filter((t) => t);
      const hasFileExclude = excludeMatches.includes("file");
      const hasFolderOrVaultExclude = excludeMatches.includes("folder") || excludeMatches.includes("vault");
      if (hasFileExclude) {
        debugLog("RULE_ENGINE", `Skipping: text "${textPattern}" does not color in this file`);
        return false;
      }
      if (hasFolderOrVaultExclude && !hasFileInclude) {
        debugLog("RULE_ENGINE", `Skipping: text "${textPattern}" does not color here due to folder/vault rule`);
        return false;
      }
      return true;
    } catch (e) {
      debugError("RULE_ENGINE", "Error in shouldColorText", e);
      return true;
    }
  }
  // Filter entries based on the four rules using shouldColorText
  filterEntriesByAdvancedRules(filePath, entries) {
    try {
      if (!filePath || !Array.isArray(entries) || entries.length === 0) return entries;
      const filtered = entries.filter((entry) => {
        if (!entry || !entry.pattern) return true;
        return this.shouldColorText(filePath, entry.pattern, entry);
      });
      return filtered;
    } catch (e) {
      return entries;
    }
  }
  hasGlobalExclude() {
    try {
      const rules = Array.isArray(this.settings.pathRules) ? this.settings.pathRules : [];
      return rules.some((r) => r && r.mode === "exclude" && String(r.path || "").trim().length === 0);
    } catch (e) {
      return false;
    }
  }
  getFileTags(filePath) {
    try {
      const af = this.app.vault.getAbstractFileByPath(filePath);
      if (!af) return [];
      const cache = this.app.metadataCache.getFileCache(af);
      if (!cache) return [];
      const tags = /* @__PURE__ */ new Set();
      const normalize = (t) => String(t || "").replace(/^#/, "").trim();
      const raw = cache.frontmatter?.tags;
      if (Array.isArray(raw)) {
        raw.forEach((t) => tags.add(normalize(t)));
      } else if (typeof raw === "string") {
        raw.split(",").forEach((t) => tags.add(normalize(t)));
      }
      if (Array.isArray(cache.tags)) {
        cache.tags.forEach((t) => tags.add(normalize(t.tag)));
      }
      return Array.from(tags).filter(Boolean);
    } catch (e) {
      return [];
    }
  }
  // Return the most specific folder rule that matches filePath, or null
  getBestFolderEntry(filePath) {
    try {
      const rules = Array.isArray(this.settings.pathRules) ? this.settings.pathRules : [];
      if (!filePath || rules.length === 0) return null;
      const fp = this.normalizePath(filePath);
      const parents = this._parentFolders(fp);
      let best = null;
      for (const r of rules) {
        if (!r) continue;
        const mode = r.mode === "exclude" ? "exclude" : "include";
        const pathStr = String(r.path || "").trim();
        const dk = this.detectRuleKind(pathStr);
        if (pathStr.length === 0) {
          const candidate = { path: "", mode };
          best = candidate;
          continue;
        }
        if (dk.kind === "name") {
          for (const p of parents) {
            if (this._basename(p) === dk.name) {
              if (!best || p.length > best.path.length) best = { path: p, mode };
              break;
            }
          }
          continue;
        }
        if (dk.kind === "exact-folder") {
          for (const p of parents) {
            if (this.normalizePath(p) === this.normalizePath(dk.path)) {
              if (!best || p.length > best.path.length) best = { path: p, mode };
              break;
            }
          }
          continue;
        }
        if (dk.kind === "regex") {
          let re = null;
          try {
            re = new RegExp(dk.pattern);
          } catch (e) {
            re = null;
          }
          if (re) {
            for (const p of parents) {
              if (re.test(p)) {
                if (!best || p.length > best.path.length) best = { path: p, mode };
                break;
              }
            }
          }
          continue;
        }
      }
      return best;
    } catch (e) {
      return null;
    }
  }
  // Check for known problematic patterns that should be blocked
  isKnownProblematicPattern(pattern) {
    if (!pattern || typeof pattern !== "string") return false;
    const p = pattern.trim();
    const hardBlocked = [
      '"[^" ]*"',
      "'[^' ]*'",
      "(.*)*",
      "(.+)+",
      "(a*)*",
      "^(.|\\n)*?$",
      "\\b\\w{1,15}\\b\\s+\\b\\w{1,15}\\b\\s+\\b\\w{1,15}\\b"
    ];
    const normalize = (s) => String(s || "").replace(/\s/g, "");
    if (hardBlocked.some((h) => normalize(h) === normalize(p))) return true;
    if (/\(\?[=!<]/.test(p)) return true;
    if (p.includes("*.*") || p.includes("+.+")) return true;
    const dangerousPatterns = [
      '"[^"]*"',
      "'[^']*'",
      '"(?:[^"\\]|\\\\.)*"',
      "'(?:[^'\\\\]|\\\\.)*'",
      "\\b\\d{4}-(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)-\\d{1,2}\\b",
      "(\\w+)*\\s+",
      "([a-z]+)*\\d+",
      "(a*)*b",
      "(a+)*b",
      "(\\w+)\\1+",
      "(\\w+)(\\1){3,}",
      "(?:\\w+|\\d+)*\\s+",
      "(?:[a-z]*|[0-9]*)*",
      "^(a|a?)+$",
      "^(a|aa)+$",
      "^(.*a){10}.*$",
      "\\((?:[^()\\]|\\([^()]*\\))*\\)",
      "\\{[^{}]*(?:\\{[^{}]*\\}[^{}]*)*\\}"
    ];
    return dangerousPatterns.some((d) => normalize(d) === normalize(p));
  }
  // Compile word entries into runtime structures (regexes, testRegex, validity)
  compileWordEntries() {
    try {
      try {
        this._compiledWordEntries = [];
        this._cachedSortedEntries = null;
        this._cacheDirty = true;
      } catch (e) {
      }
      try {
        this._regexCache && this._regexCache.clear();
      } catch (_) {
      }
      try {
        this._bloomFilter && this._bloomFilter.reset();
      } catch (_) {
      }
      if (!Array.isArray(this.settings.wordEntries)) return;
      let allEntries = [...this.settings.wordEntries || []];
      if (Array.isArray(this.settings.wordEntryGroups)) {
        this.settings.wordEntryGroups.forEach((group) => {
          if (group && group.active && Array.isArray(group.entries)) {
            const groupCase = typeof group.caseSensitiveOverride === "boolean" ? group.caseSensitiveOverride : void 0;
            const groupMatch = typeof group.matchTypeOverride === "string" && group.matchTypeOverride ? group.matchTypeOverride : void 0;
            const mapped = group.entries.map((e) => {
              const copy = Object.assign({}, e);
              if (groupMatch) copy.matchType = groupMatch;
              if (groupCase !== void 0) copy._caseSensitiveOverride = groupCase;
              if (group.styleType) copy.styleType = group.styleType;
              if (group.textColor) copy.textColor = group.textColor;
              if (group.color) copy.color = group.color;
              if (group.backgroundColor) copy.backgroundColor = group.backgroundColor;
              if (typeof group.backgroundOpacity !== "undefined") copy.backgroundOpacity = group.backgroundOpacity;
              if (typeof group.highlightBorderRadius !== "undefined") copy.highlightBorderRadius = group.highlightBorderRadius;
              if (typeof group.highlightHorizontalPadding !== "undefined") copy.highlightHorizontalPadding = group.highlightHorizontalPadding;
              if (typeof group.highlightVerticalPadding !== "undefined") copy.highlightVerticalPadding = group.highlightVerticalPadding;
              if (typeof group.enableBorderThickness !== "undefined") copy.enableBorderThickness = group.enableBorderThickness;
              if (group.borderStyle) copy.borderStyle = group.borderStyle;
              if (group.borderLineStyle) copy.borderLineStyle = group.borderLineStyle;
              if (typeof group.borderOpacity !== "undefined") copy.borderOpacity = group.borderOpacity;
              if (typeof group.borderThickness !== "undefined") copy.borderThickness = group.borderThickness;
              copy._groupUid = group.uid || null;
              copy.groupEnableFolders = Array.isArray(group.enableFolders) ? group.enableFolders.slice() : [];
              copy.groupDisableFolders = Array.isArray(group.disableFolders) ? group.disableFolders.slice() : [];
              copy.groupEnableTags = Array.isArray(group.enableTags) ? group.enableTags.slice() : [];
              copy.groupDisableTags = Array.isArray(group.disableTags) ? group.disableTags.slice() : [];
              return copy;
            });
            allEntries = allEntries.concat(mapped);
          }
        });
      }
      for (const e of allEntries) {
        if (!e) continue;
        if (e && e.backgroundColor) {
          continue;
        }
        const patterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "").trim()];
        const color = e.color;
        if (!this.isValidHexColor(color) && !this.isValidHexColor(e.textColor)) {
          continue;
        }
        const isRegex = !!e.isRegex;
        for (let pattern of patterns) {
          pattern = String(pattern).trim();
          if (!pattern) continue;
          pattern = this.sanitizePattern(pattern, isRegex);
          if (!this.settings.disableRegexSafety && this.isKnownProblematicPattern(pattern)) {
            debugWarn("COMPILE", `Blocked dangerous pattern: ${pattern.substring(0, 50)}`);
            const compiled2 = { pattern, color, isRegex, flags: "", regex: null, testRegex: null, invalid: true, specificity: 0 };
            this._compiledWordEntries.push(compiled2);
            try {
              new Notice(this.t("notice_pattern_blocked", "Pattern blocked for Memory Safety: " + pattern.substring(0, 30) + "..."));
            } catch (e2) {
            }
            continue;
          }
          const rawFlags = String(e.flags || "").replace(/[^gimsuy]/g, "");
          let flags = rawFlags || "";
          if (!flags.includes("g")) flags += "g";
          const effectiveCaseSensitive = typeof e._caseSensitiveOverride === "boolean" ? e._caseSensitiveOverride : typeof e.caseSensitive === "boolean" ? e.caseSensitive : this.settings.caseSensitive;
          if (!effectiveCaseSensitive && !flags.includes("i")) flags += "i";
          const compiled = {
            pattern,
            color,
            textColor: e.textColor || e.color || color,
            backgroundColor: e.backgroundColor || null,
            styleType: e.styleType || "text",
            matchType: e.matchType || (this.settings.partialMatch ? "contains" : "exact"),
            isRegex,
            flags,
            regex: null,
            testRegex: null,
            invalid: false,
            specificity: pattern.replace(/\*/g, "").length,
            presetLabel: e.presetLabel || void 0,
            // Preserve presetLabel from original entry
            entryRef: e,
            // Keep reference to original entry for highlight styling parameters
            caseSensitive: effectiveCaseSensitive,
            targetElement: e.targetElement || (e.presetLabel && /bold\s*italic/i.test(e.presetLabel) ? "strong-em" : e.presetLabel && /bold/i.test(e.presetLabel) ? "strong" : e.presetLabel && /italic/i.test(e.presetLabel) ? "em" : e.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1" ? "strong" : e.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1" ? "em" : e.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1" ? "strong-em" : void 0),
            // Copy per-entry include/exclude rules so filtering still works after reload
            inclusionRules: Array.isArray(e.inclusionRules) ? e.inclusionRules.slice() : [],
            exclusionRules: Array.isArray(e.exclusionRules) ? e.exclusionRules.slice() : [],
            groupUid: e._groupUid || null,
            groupEnableFolders: Array.isArray(e.groupEnableFolders) ? e.groupEnableFolders.slice() : [],
            groupDisableFolders: Array.isArray(e.groupDisableFolders) ? e.groupDisableFolders.slice() : [],
            groupEnableTags: Array.isArray(e.groupEnableTags) ? e.groupEnableTags.slice() : [],
            groupDisableTags: Array.isArray(e.groupDisableTags) ? e.groupDisableTags.slice() : [],
            // Copy custom styling properties directly to compiled entry as well
            backgroundOpacity: e.backgroundOpacity,
            highlightBorderRadius: e.highlightBorderRadius,
            highlightHorizontalPadding: e.highlightHorizontalPadding,
            highlightVerticalPadding: e.highlightVerticalPadding,
            enableBorderThickness: e.enableBorderThickness,
            borderStyle: e.borderStyle,
            borderLineStyle: e.borderLineStyle,
            borderOpacity: e.borderOpacity,
            borderThickness: e.borderThickness,
            // instrumentation counters
            execs: 0,
            avoidedExecs: 0,
            matchesFound: 0,
            blocksProcessed: 0,
            _hotLogged: false
          };
          if (!pattern) {
            compiled.invalid = true;
            this._compiledWordEntries.push(compiled);
            continue;
          }
          try {
            if (this.settings.enableRegexSupport && isRegex) {
              if (!this.validateAndSanitizeRegex(pattern)) {
                compiled.invalid = true;
                try {
                  new Notice(this.t("notice_pattern_too_complex", "Pattern too complex: " + pattern.substring(0, 60) + "..."));
                } catch (e2) {
                }
                this._compiledWordEntries.push(compiled);
                continue;
              }
              compiled.regex = this._regexCache.getOrCreate(pattern, flags);
              const testFlags = flags.replace(/g/g, "");
              compiled.testRegex = this._regexCache.getOrCreate(pattern, testFlags);
            } else {
              const esc = this.escapeRegex(pattern);
              const matchTypeLower = String(compiled.matchType || "exact").toLowerCase();
              const isSentence = this.isSentenceLikePattern(pattern);
              let finalPattern = esc;
              if (!isSentence && matchTypeLower === "startswith") {
                finalPattern = "\\b" + esc;
              } else if (!isSentence && matchTypeLower === "endswith") {
                finalPattern = esc + "\\b";
              } else if (!isSentence && matchTypeLower === "exact" && String(pattern).length === 1) {
                finalPattern = "\\b" + esc + "\\b";
              }
              const literalFlags = effectiveCaseSensitive ? "g" : "gi";
              compiled.regex = this._regexCache.getOrCreate(finalPattern, literalFlags);
              compiled.testRegex = effectiveCaseSensitive ? this._regexCache.getOrCreate(finalPattern, "") : this._regexCache.getOrCreate(finalPattern, "i");
            }
          } catch (err) {
            compiled.invalid = true;
          }
          try {
            this._bloomFilter && this._bloomFilter.addPattern(pattern, isRegex);
          } catch (_) {
          }
          try {
            compiled.fastTest = this.createFastTester(pattern, compiled.isRegex, effectiveCaseSensitive);
          } catch (e2) {
            compiled.fastTest = (text) => true;
          }
          this._compiledWordEntries.push(compiled);
          if (compiled.pattern === "hello" && typeof compiled.backgroundOpacity === "number") {
            debugLog("[COMPILED_ENTRY_CHECK]", `Compiled entry 'hello': opacity=${compiled.backgroundOpacity}, radius=${compiled.highlightBorderRadius}, entryRef.opacity=${compiled.entryRef?.backgroundOpacity}`);
          }
        }
      }
      this._compiledWordEntries.sort((a, b) => b.specificity - a.specificity || b.pattern.length - a.pattern.length);
      try {
        this._cacheDirty = true;
        this._cachedSortedEntries = null;
      } catch (e) {
      }
      try {
        const all = (Array.isArray(this._compiledWordEntries) ? this._compiledWordEntries : []).concat(Array.isArray(this._compiledTextBgEntries) ? this._compiledTextBgEntries : []);
        this._settingsIndex && this._settingsIndex.rebuild(all);
      } catch (_) {
      }
    } catch (err) {
      debugError("COMPILE", "compileWordEntries failed", err);
      try {
        this._compiledWordEntries = [];
        this._cachedSortedEntries = null;
        this._cacheDirty = true;
      } catch (e) {
      }
    }
  }
  // Compile text + background coloring entries
  compileTextBgColoringEntries() {
    try {
      try {
        this._compiledTextBgEntries = [];
      } catch (e) {
      }
      let source = [...Array.isArray(this.settings.wordEntries) ? this.settings.wordEntries : []];
      if (Array.isArray(this.settings.wordEntryGroups)) {
        this.settings.wordEntryGroups.forEach((group) => {
          if (group && group.active && Array.isArray(group.entries)) {
            const groupCase = typeof group.caseSensitiveOverride === "boolean" ? group.caseSensitiveOverride : void 0;
            const groupMatch = typeof group.matchTypeOverride === "string" && group.matchTypeOverride ? group.matchTypeOverride : void 0;
            const mapped = group.entries.map((e) => {
              const copy = Object.assign({}, e);
              if (groupMatch) copy.matchType = groupMatch;
              if (groupCase !== void 0) copy._caseSensitiveOverride = groupCase;
              if (group.styleType) copy.styleType = group.styleType;
              if (group.textColor) copy.textColor = group.textColor;
              if (group.color) copy.color = group.color;
              if (group.backgroundColor) copy.backgroundColor = group.backgroundColor;
              if (typeof group.backgroundOpacity !== "undefined") copy.backgroundOpacity = group.backgroundOpacity;
              if (typeof group.highlightBorderRadius !== "undefined") copy.highlightBorderRadius = group.highlightBorderRadius;
              if (typeof group.highlightHorizontalPadding !== "undefined") copy.highlightHorizontalPadding = group.highlightHorizontalPadding;
              if (typeof group.highlightVerticalPadding !== "undefined") copy.highlightVerticalPadding = group.highlightVerticalPadding;
              if (typeof group.enableBorderThickness !== "undefined") copy.enableBorderThickness = group.enableBorderThickness;
              if (group.borderStyle) copy.borderStyle = group.borderStyle;
              if (group.borderLineStyle) copy.borderLineStyle = group.borderLineStyle;
              if (typeof group.borderOpacity !== "undefined") copy.borderOpacity = group.borderOpacity;
              if (typeof group.borderThickness !== "undefined") copy.borderThickness = group.borderThickness;
              copy._groupUid = group.uid || null;
              copy.groupEnableFolders = Array.isArray(group.enableFolders) ? group.enableFolders.slice() : [];
              copy.groupDisableFolders = Array.isArray(group.disableFolders) ? group.disableFolders.slice() : [];
              copy.groupEnableTags = Array.isArray(group.enableTags) ? group.enableTags.slice() : [];
              copy.groupDisableTags = Array.isArray(group.disableTags) ? group.disableTags.slice() : [];
              return copy;
            });
            source = source.concat(mapped);
          }
        });
      }
      debugLog("[TBG_COMPILE_START]", `Starting with ${source.length} source entries from wordEntries`);
      for (const e of source) {
        if (!e || !e.backgroundColor) continue;
        if (e.presetLabel) {
          const label = String(e.presetLabel).toLowerCase();
          if (label.includes("bold") || label.includes("italic")) continue;
        }
        if (e.pattern === "hello") {
          debugLog("[TBG_SOURCE_ENTRY]", `Source entry 'hello': opacity=${e.backgroundOpacity}, radius=${e.highlightBorderRadius}, bg=${e.backgroundColor}`);
        }
        const patterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "").trim()];
        const textColor = e.textColor || "currentColor";
        const backgroundColor = e.backgroundColor;
        const isRegex = !!e.isRegex;
        const textOk = textColor === "currentColor" || this.isValidHexColor(textColor);
        const bgOk = this.isValidHexColor(backgroundColor);
        if (!textOk || !bgOk) {
          continue;
        }
        for (let pattern of patterns) {
          pattern = String(pattern).trim();
          if (!pattern) continue;
          pattern = this.sanitizePattern(pattern, isRegex);
          if (!this.settings.disableRegexSafety && this.isKnownProblematicPattern(pattern)) {
            debugWarn("COMPILE_TEXTBG", `Blocked dangerous pattern: ${pattern.substring(0, 50)}`);
            const compiled2 = {
              pattern,
              textColor,
              backgroundColor,
              matchType: e.matchType || (this.settings.partialMatch ? "contains" : "exact"),
              isRegex,
              flags: "",
              regex: null,
              testRegex: null,
              invalid: true,
              specificity: 0,
              isTextBg: true,
              entryRef: e
            };
            this._compiledTextBgEntries.push(compiled2);
            try {
              new Notice(this.t("notice_pattern_blocked", "Pattern blocked for Memory Safety: " + pattern.substring(0, 30) + "..."));
            } catch (e2) {
            }
            continue;
          }
          const rawFlags = String(e.flags || "").replace(/[^gimsuy]/g, "");
          let flags = rawFlags || "";
          if (!flags.includes("g")) flags += "g";
          const effectiveCaseSensitive = typeof e._caseSensitiveOverride === "boolean" ? e._caseSensitiveOverride : typeof e.caseSensitive === "boolean" ? e.caseSensitive : this.settings.caseSensitive;
          if (!effectiveCaseSensitive && !flags.includes("i")) flags += "i";
          const compiled = {
            pattern,
            textColor,
            backgroundColor,
            styleType: e.styleType || "both",
            matchType: e.matchType || (this.settings.partialMatch ? "contains" : "exact"),
            isRegex,
            flags,
            regex: null,
            testRegex: null,
            invalid: false,
            specificity: pattern.replace(/\*/g, "").length,
            isTextBg: true,
            // Mark as text+bg entry
            presetLabel: e.presetLabel || void 0,
            // Preserve presetLabel from original entry
            entryRef: e,
            // Keep reference to original entry for highlight styling parameters
            caseSensitive: effectiveCaseSensitive,
            // Copy per-entry include/exclude rules so filtering still works after reload
            inclusionRules: Array.isArray(e.inclusionRules) ? e.inclusionRules.slice() : [],
            exclusionRules: Array.isArray(e.exclusionRules) ? e.exclusionRules.slice() : [],
            groupUid: e._groupUid || null,
            groupEnableFolders: Array.isArray(e.groupEnableFolders) ? e.groupEnableFolders.slice() : [],
            groupDisableFolders: Array.isArray(e.groupDisableFolders) ? e.groupDisableFolders.slice() : [],
            groupEnableTags: Array.isArray(e.groupEnableTags) ? e.groupEnableTags.slice() : [],
            groupDisableTags: Array.isArray(e.groupDisableTags) ? e.groupDisableTags.slice() : [],
            // Copy custom styling properties directly to compiled entry as well
            backgroundOpacity: e.backgroundOpacity,
            highlightBorderRadius: e.highlightBorderRadius,
            highlightHorizontalPadding: e.highlightHorizontalPadding,
            highlightVerticalPadding: e.highlightVerticalPadding,
            enableBorderThickness: e.enableBorderThickness,
            borderStyle: e.borderStyle,
            borderLineStyle: e.borderLineStyle,
            borderOpacity: e.borderOpacity,
            borderThickness: e.borderThickness
          };
          try {
            if (this.settings.enableRegexSupport && isRegex) {
              if (!this.validateAndSanitizeRegex(pattern)) {
                compiled.invalid = true;
                try {
                  new Notice(this.t("notice_pattern_too_complex", "Pattern too complex: " + pattern.substring(0, 60) + "..."));
                } catch (e2) {
                }
                this._compiledTextBgEntries.push(compiled);
                continue;
              }
              compiled.regex = this._regexCache.getOrCreate(pattern, flags);
              const testFlags = flags.replace(/g/g, "");
              compiled.testRegex = this._regexCache.getOrCreate(pattern, testFlags);
            } else {
              const esc = this.escapeRegex(pattern);
              const matchTypeLower = String(compiled.matchType || "exact").toLowerCase();
              const isSentence = this.isSentenceLikePattern(pattern);
              let finalPattern = esc;
              if (!isSentence && matchTypeLower === "startswith") {
                finalPattern = "\\b" + esc;
              } else if (!isSentence && matchTypeLower === "endswith") {
                finalPattern = esc + "\\b";
              } else if (!isSentence && matchTypeLower === "exact" && String(pattern).length === 1) {
                finalPattern = "\\b" + esc + "\\b";
              }
              const literalFlags = effectiveCaseSensitive ? "g" : "gi";
              compiled.regex = this._regexCache.getOrCreate(finalPattern, literalFlags);
              compiled.testRegex = effectiveCaseSensitive ? this._regexCache.getOrCreate(finalPattern, "") : this._regexCache.getOrCreate(finalPattern, "i");
            }
            try {
              compiled.fastTest = this.createFastTester(pattern, isRegex, effectiveCaseSensitive);
            } catch (e2) {
              compiled.fastTest = (text) => true;
            }
            try {
              this._bloomFilter && this._bloomFilter.addPattern(pattern, isRegex);
            } catch (_) {
            }
            this._compiledTextBgEntries.push(compiled);
            if (compiled.pattern === "hello" && typeof compiled.backgroundOpacity === "number") {
              debugLog("[COMPILED_TBG_ENTRY_CHECK]", `Compiled TBG entry 'hello': opacity=${compiled.backgroundOpacity}, radius=${compiled.highlightBorderRadius}, entryRef.opacity=${compiled.entryRef?.backgroundOpacity}`);
            }
          } catch (err) {
            compiled.invalid = true;
            compiled.regex = null;
            compiled.testRegex = null;
            debugError("COMPILE_TEXTBG", `Failed to compile pattern: ${pattern}`, err);
            this._compiledTextBgEntries.push(compiled);
          }
        }
      }
      this._compiledTextBgEntries.sort((a, b) => b.specificity - a.specificity);
    } catch (err) {
      debugError("COMPILE_TEXTBG", "compileTextBgColoringEntries failed", err);
      try {
        this._compiledTextBgEntries = [];
      } catch (e) {
      }
    }
    try {
      const all = (Array.isArray(this._compiledWordEntries) ? this._compiledWordEntries : []).concat(Array.isArray(this._compiledTextBgEntries) ? this._compiledTextBgEntries : []);
      this._settingsIndex && this._settingsIndex.rebuild(all);
    } catch (_) {
    }
    try {
      this.compileWordPatterns();
    } catch (e) {
      debugError("COMPILE", "Failed to compile word patterns", e);
    }
    try {
      this.compileTextBgPatterns();
    } catch (e) {
      debugError("COMPILE", "Failed to compile text+bg patterns", e);
    }
  }
  // OPTIMIZATION: Pre-compile word pattern regexes for extreme performance
  // This builds lookup table for quick pattern matching without recreating RegExp
  compileWordPatterns() {
    try {
      this._compiledWordPatterns = {};
      const entries = Array.isArray(this._compiledWordEntries) ? this._compiledWordEntries : [];
      for (const entry of entries) {
        if (!entry || entry.invalid || !entry.regex) continue;
        const key = `${entry.pattern}::${entry.flags || ""}`;
        this._compiledWordPatterns[key] = {
          regex: entry.regex,
          pattern: entry.pattern,
          flags: entry.flags,
          entry
        };
      }
      this._wordPatternsCompilationDirty = false;
      debugLog("COMPILE_WORD_PATTERNS", `Compiled ${Object.keys(this._compiledWordPatterns).length} word patterns`);
    } catch (e) {
      debugError("COMPILE_WORD_PATTERNS", "Failed to compile word patterns", e);
    }
  }
  // OPTIMIZATION: Pre-compile text+bg pattern regexes for extreme performance
  compileTextBgPatterns() {
    try {
      this._compiledTextBgPatterns = {};
      const entries = Array.isArray(this._compiledTextBgEntries) ? this._compiledTextBgEntries : [];
      for (const entry of entries) {
        if (!entry || entry.invalid || !entry.regex) continue;
        const key = `${entry.pattern}::${entry.flags || ""}`;
        this._compiledTextBgPatterns[key] = {
          regex: entry.regex,
          pattern: entry.pattern,
          flags: entry.flags,
          entry
        };
      }
      this._textBgPatternsCompilationDirty = false;
      debugLog("COMPILE_TEXTBG_PATTERNS", `Compiled ${Object.keys(this._compiledTextBgPatterns).length} text+bg patterns`);
    } catch (e) {
      debugError("COMPILE_TEXTBG_PATTERNS", "Failed to compile text+bg patterns", e);
    }
  }
  // OPTIMIZATION: Pre-compile blacklist regexes for performance
  // This avoids creating new RegExp objects on every blacklist check
  compileBlacklistEntries() {
    try {
      this._compiledBlacklistWords = [];
      this._compiledBlacklistEntries = [];
      this._compiledBlacklistGroups = {};
      const blacklistWords = Array.isArray(this.settings.blacklistWords) ? this.settings.blacklistWords : [];
      for (const word of blacklistWords) {
        if (!word) continue;
        try {
          const flags = this.settings.caseSensitive ? "" : "i";
          const pattern = `\\b${this.escapeRegex(String(word))}\\b`;
          const regex = this._regexCache.getOrCreate(pattern, flags);
          if (regex) {
            this._compiledBlacklistWords.push({ word, regex, flags });
          }
        } catch (e) {
        }
      }
      const blacklistEntries = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
      for (const entry of blacklistEntries) {
        if (!entry) continue;
        try {
          const compiled = { entry, patterns: [] };
          if (entry.isRegex && this.settings.enableRegexSupport) {
            const flags = entry.flags || (this.settings.caseSensitive ? "" : "i");
            const regex = this._regexCache.getOrCreate(entry.pattern, flags);
            if (regex) {
              compiled.patterns.push({ regex, flags, isRegex: true });
            }
          } else {
            const patterns = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns : [entry.pattern];
            for (const p of patterns) {
              if (!p) continue;
              const flags = this.settings.caseSensitive ? "" : "i";
              const pattern = `\\b${this.escapeRegex(String(p))}\\b`;
              const regex = this._regexCache.getOrCreate(pattern, flags);
              if (regex) {
                compiled.patterns.push({ regex, flags, isRegex: false, pattern: String(p) });
              }
            }
          }
          if (compiled.patterns.length > 0) {
            this._compiledBlacklistEntries.push(compiled);
          }
        } catch (e) {
        }
      }
      const blacklistGroups = Array.isArray(this.settings.blacklistEntryGroups) ? this.settings.blacklistEntryGroups : [];
      for (const group of blacklistGroups) {
        if (!group || !group.uid) continue;
        try {
          const compiled = {
            group,
            entries: [],
            isCaseSensitive: group.caseSensitiveOverride !== null ? group.caseSensitiveOverride : this.settings.caseSensitive,
            matchType: group.matchTypeOverride || "contains"
          };
          const groupEntries = Array.isArray(group.entries) ? group.entries : [];
          for (const entry of groupEntries) {
            if (!entry) continue;
            const entryCompiled = { entry, patterns: [] };
            if (entry.isRegex && this.settings.enableRegexSupport) {
              const flags = entry.flags || (compiled.isCaseSensitive ? "" : "i");
              const regex = this._regexCache.getOrCreate(entry.pattern, flags);
              if (regex) {
                entryCompiled.patterns.push({ regex, flags, isRegex: true });
              }
            } else {
              const patterns = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns : [entry.pattern];
              for (const p of patterns) {
                if (!p) continue;
                const pattern = `\\b${this.escapeRegex(String(p))}\\b`;
                const regex = this._regexCache.getOrCreate(pattern, compiled.isCaseSensitive ? "" : "i");
                if (regex) {
                  entryCompiled.patterns.push({ regex, pattern: String(p), isRegex: false });
                }
              }
            }
            if (entryCompiled.patterns.length > 0) {
              entryCompiled.matchType = compiled.matchType;
              compiled.entries.push(entryCompiled);
            }
          }
          if (compiled.entries.length > 0) {
            this._compiledBlacklistGroups[group.uid] = compiled;
          }
        } catch (e) {
        }
      }
      this._blacklistCompilationDirty = false;
      debugLog("BLACKLIST_COMPILE", `Compiled ${this._compiledBlacklistWords.length} words, ${this._compiledBlacklistEntries.length} entries, ${Object.keys(this._compiledBlacklistGroups).length} groups`);
    } catch (e) {
      debugError("BLACKLIST_COMPILE", "Failed to compile blacklist", e);
    }
  }
  // NEW METHOD: Apply highlights to specific HTML elements (for logic-based coloring)
  applyElementHighlights(el, entries, folderEntry = null) {
    if (!el || !entries || entries.length === 0) return;
    for (const entry of entries) {
      if (!entry || !entry.targetElement) continue;
      let selector = entry.targetElement;
      if (selector === "strong-em") selector = "strong > em, em > strong";
      let elements;
      try {
        elements = el.querySelectorAll(selector);
      } catch (e) {
        continue;
      }
      if (elements.length === 0) continue;
      const textColor = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color || null;
      const backgroundColor = entry.backgroundColor || null;
      const finalTextColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : textColor;
      const hideText = this.settings.hideTextColors === true;
      const hideBg = this.settings.hideHighlights === true;
      for (const element of elements) {
        if (!hideText && finalTextColor) {
          element.style.setProperty("color", finalTextColor, "important");
          element.style.setProperty("--highlight-color", finalTextColor);
        }
        if (!hideBg && backgroundColor) {
          const params = this.getHighlightParams(entry);
          const bgRgba = this.hexToRgba(backgroundColor, params.opacity);
          element.style.setProperty("background-color", bgRgba, "important");
          element.style.setProperty("border-radius", params.radius + "px", "important");
          element.style.setProperty("padding-left", params.hPad + "px", "important");
          element.style.setProperty("padding-right", params.hPad + "px", "important");
          const vPad = params.vPad;
          if (vPad >= 0) {
            element.style.setProperty("padding-top", vPad + "px", "important");
            element.style.setProperty("padding-bottom", vPad + "px", "important");
          } else {
            element.style.setProperty("padding-top", "0px", "important");
            element.style.setProperty("padding-bottom", "0px", "important");
            element.style.setProperty("margin-top", vPad + "px", "important");
            element.style.setProperty("margin-bottom", vPad + "px", "important");
          }
          if (this.settings.enableBoxDecorationBreak ?? true) {
            element.style.boxDecorationBreak = "clone";
            element.style.WebkitBoxDecorationBreak = "clone";
          }
        }
      }
    }
  }
  // Apply Highlights in Reading View (Markdown Post Processor) - optional folderEntry may override match colors
  applyHighlights(el, folderEntry = null, options = {}) {
    const entries = options && Array.isArray(options.entries) ? options.entries : this.getSortedWordEntries();
    if (entries.length === 0) return;
    if (!el.isConnected) return;
    const elementEntries = entries.filter((e) => e && e.targetElement);
    const regexEntries = entries.filter((e) => e && !e.targetElement);
    if (elementEntries.length > 0) {
      this.applyElementHighlights(el, elementEntries, folderEntry);
    }
    if (regexEntries.length > 0) {
      this._wrapMatchesRecursive(el, regexEntries, folderEntry, options || {});
    }
  }
  // NEW METHOD: Apply highlights for simple patterns (ultra-fast version)
  applySimpleHighlights(textNode, matches, text, filePath = null) {
    if (!matches || matches.length === 0) return;
    try {
      if (textNode.parentElement?.closest(".always-color-text-highlight")) return;
    } catch (_) {
    }
    const decodedText = this.decodeHtmlEntities(text);
    try {
      const filtered = [];
      for (const m of matches) {
        if (this.isContextBlacklisted(decodedText, m.start, m.end, filePath)) continue;
        filtered.push(m);
      }
      matches = filtered;
      if (matches.length === 0) return;
    } catch (_) {
    }
    matches.sort((a, b) => a.start - b.start);
    const nonOverlapping = [];
    for (const m of matches) {
      let overlaps = false;
      const overlappingIndices = [];
      for (let i = 0; i < nonOverlapping.length; i++) {
        const existing = nonOverlapping[i];
        if (m.start < existing.end && m.end > existing.start) {
          overlaps = true;
          overlappingIndices.push(i);
        }
      }
      if (!overlaps) {
        nonOverlapping.push(m);
      } else {
        const mLength = m.end - m.start;
        const allShorter = overlappingIndices.every((i) => {
          const existing = nonOverlapping[i];
          return existing.end - existing.start < mLength;
        });
        if (allShorter) {
          for (let i = overlappingIndices.length - 1; i >= 0; i--) {
            nonOverlapping.splice(overlappingIndices[i], 1);
          }
          nonOverlapping.push(m);
        }
      }
    }
    const frag = document.createDocumentFragment();
    let pos = 0;
    try {
      const txtCount = nonOverlapping.filter((m) => !m.isTextBg && (m.styleType || "text") === "text").length;
      debugLog("READING_MATCHES", `total=${nonOverlapping.length}, text=${txtCount}, hideTextColors=${this.settings.hideTextColors === true}`);
    } catch (_) {
    }
    for (const m of nonOverlapping) {
      if (m.start > pos) {
        frag.appendChild(document.createTextNode(decodedText.slice(pos, m.start)));
      }
      const span = document.createElement("span");
      const entryForClass = m.entryRef || m.entry;
      const classNames = ["always-color-text-highlight"];
      if (entryForClass && entryForClass.affectMarkElements) {
        classNames.push("always-color-text-highlight-marks");
      }
      span.className = classNames.join(" ");
      span.textContent = decodedText.slice(m.start, m.end);
      if (this.settings.showColoringReasonOnHover && m.entry) {
        const tooltip = this.getColoringReasonTooltip(m);
        debugLog("TOOLTIP_DEBUG", `Setting tooltip for "${span.textContent}": "${tooltip}", entry=${m.entry?.pattern}`);
        span.title = tooltip;
        debugLog("TOOLTIP_DEBUG", `span.title is now: "${span.title}"`);
      } else {
        debugLog("TOOLTIP_DEBUG", `NOT setting tooltip. showColoringReasonOnHover=${this.settings.showColoringReasonOnHover}, m.entry=${m.entry ? "yes" : "no"}`);
      }
      const entry = m.entryRef || m.entry;
      let styleType2 = entry && entry.affectMarkElements ? "highlight" : entry && entry.styleType ? entry.styleType : "text";
      if (entry && entry.pattern) {
        debugLog("[READING_ENTRY_STYLE]", `Pattern: ${entry.pattern}, styleType: ${styleType2}, textColor: ${entry.textColor}, bgColor: ${entry.backgroundColor}, hasCustomBgOpacity: ${entry.backgroundOpacity !== void 0}`);
        const hasOpacity = typeof entry.backgroundOpacity === "number";
        const hasRadius = typeof entry.highlightBorderRadius === "number";
        const hasPadding = typeof entry.highlightHorizontalPadding === "number";
        if (hasOpacity || hasRadius || hasPadding) {
          debugLog("[ENTRY_CUSTOM_CHECK]", `Pattern: ${entry.pattern} has custom props: opacity=${hasOpacity}, radius=${hasRadius}, padding=${hasPadding}`);
        }
      }
      const folderDefault = m.folderEntry && m.folderEntry.defaultColor ? m.folderEntry.defaultColor : null;
      const entryTextColor = entry && entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : null;
      const resolvedTextColor = folderDefault || entryTextColor || (entry ? entry.color : null);
      const hideText = this.settings.hideTextColors === true;
      const hideBg = this.settings.hideHighlights === true;
      if (styleType2 === "text") {
        if (hideText) {
          frag.appendChild(document.createTextNode(decodedText.slice(m.start, m.end)));
          pos = m.end;
          continue;
        }
        if (resolvedTextColor) {
          try {
            span.style.setProperty("color", resolvedTextColor, "important");
          } catch (_) {
            span.style.color = resolvedTextColor;
          }
          try {
            span.style.setProperty("--highlight-color", resolvedTextColor);
          } catch (e) {
          }
        }
        try {
          debugLog("READING_TEXT", `applied color=${resolvedTextColor || "none"}`);
        } catch (_) {
        }
      } else if (styleType2 === "highlight") {
        if (hideBg) {
          frag.appendChild(document.createTextNode(decodedText.slice(m.start, m.end)));
          pos = m.end;
          continue;
        }
        const params = this.getHighlightParams(entry);
        const bgBase = entry && entry.backgroundColor ? entry.backgroundColor : entry && entry.color ? entry.color : resolvedTextColor;
        const bgRgba = this.hexToRgba(bgBase, params.opacity);
        try {
          span.style.setProperty("background-color", bgRgba, "important");
        } catch (_) {
          span.style.backgroundColor = bgRgba;
        }
        try {
          const vpad = params.vPad;
          span.style.setProperty("padding-left", params.hPad + "px", "important");
          span.style.setProperty("padding-right", params.hPad + "px", "important");
          span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
          span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
          if (vpad < 0) {
            span.style.setProperty("margin-top", vpad + "px", "important");
            span.style.setProperty("margin-bottom", vpad + "px", "important");
          }
        } catch (_) {
          const vpad = params.vPad;
          span.style.paddingLeft = span.style.paddingRight = params.hPad + "px";
          span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
          if (vpad < 0) {
            span.style.marginTop = vpad + "px";
            span.style.marginBottom = vpad + "px";
          }
        }
        const br = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
        try {
          span.style.setProperty("border-radius", br, "important");
        } catch (_) {
          span.style.borderRadius = br;
        }
        if (this.settings.enableBoxDecorationBreak ?? true) {
          span.style.boxDecorationBreak = "clone";
          span.style.WebkitBoxDecorationBreak = "clone";
        }
        try {
          const borderCss = this.generateBorderStyle(null, bgBase, entry);
          if (borderCss) {
            span.style.cssText += borderCss;
          }
        } catch (_) {
        }
      } else if (styleType2 === "both") {
        const textColor = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : null;
        const bgColor = entry && entry.backgroundColor ? entry.backgroundColor : entry && entry.color ? entry.color : resolvedTextColor;
        if (!hideText && textColor) {
          try {
            span.style.setProperty("color", textColor, "important");
          } catch (_) {
            span.style.color = textColor;
          }
          try {
            span.style.setProperty("--highlight-color", textColor);
          } catch (e) {
          }
        }
        if (!hideBg) {
          const params = this.getHighlightParams(entry);
          const bgRgba = this.hexToRgba(bgColor, params.opacity);
          try {
            span.style.setProperty("background-color", bgRgba, "important");
          } catch (_) {
            span.style.backgroundColor = bgRgba;
          }
          try {
            const vpad = params.vPad;
            span.style.setProperty("padding-left", params.hPad + "px", "important");
            span.style.setProperty("padding-right", params.hPad + "px", "important");
            span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
            span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
            if (vpad < 0) {
              span.style.setProperty("margin-top", vpad + "px", "important");
              span.style.setProperty("margin-bottom", vpad + "px", "important");
            }
          } catch (_) {
            const vpad = params.vPad;
            span.style.paddingLeft = span.style.paddingRight = params.hPad + "px";
            span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
            if (vpad < 0) {
              span.style.marginTop = vpad + "px";
              span.style.marginBottom = vpad + "px";
            }
          }
          const br2 = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
          try {
            span.style.setProperty("border-radius", br2, "important");
          } catch (_) {
            span.style.borderRadius = br2;
          }
          if (this.settings.enableBoxDecorationBreak ?? true) {
            span.style.boxDecorationBreak = "clone";
            span.style.WebkitBoxDecorationBreak = "clone";
          }
        } else {
          try {
            span.style.setProperty("background-color", "transparent", "important");
          } catch (_) {
            span.style.backgroundColor = "transparent";
          }
          span.style.paddingLeft = span.style.paddingRight = "0px";
          span.style.border = "";
          span.style.borderRadius = "";
        }
        try {
          const borderCss = this.generateBorderStyle(hideText ? null : textColor, hideBg ? null : bgColor, entry);
          if (borderCss) {
            span.style.cssText += borderCss;
          }
        } catch (_) {
        }
      }
      frag.appendChild(span);
      pos = m.end;
    }
    if (pos < decodedText.length) {
      frag.appendChild(document.createTextNode(decodedText.slice(pos)));
    }
    debugLog("HIGHLIGHT_APPLY", `Created ${nonOverlapping.length} spans, replacing text node`);
    const parentNode = textNode.parentNode;
    const isConnected = textNode.isConnected;
    debugLog("HIGHLIGHT_APPLY", `TextNode connected: ${isConnected}, parent: ${parentNode?.nodeName || "none"}`);
    textNode.replaceWith(frag);
    const highlightsNow = parentNode?.querySelectorAll?.(".always-color-text-highlight")?.length || 0;
    debugLog("HIGHLIGHT_APPLY", `After replacement: ${highlightsNow} highlights in parent`);
  }
  setupReadingModeObserver(el, sourcePath) {
    try {
      if (!el || !sourcePath) return;
      if (!this._readingModeIntervals) this._readingModeIntervals = /* @__PURE__ */ new Map();
      if (this._readingModeIntervals.has(el)) {
        clearInterval(this._readingModeIntervals.get(el));
      }
    } catch (e) {
      debugError("READING_OBS", "Failed to set up observer", e);
    }
  }
  // Cleanup reading mode observers and disconnect viewport observers
  cleanupObserversForElement(el) {
    try {
      if (this._readingModeIntervals && this._readingModeIntervals instanceof Map) {
        const intervals = this._readingModeIntervals.get(el);
        if (Array.isArray(intervals)) {
          for (const intervalId of intervals) {
            try {
              clearInterval(intervalId);
            } catch (e) {
            }
          }
        }
        this._readingModeIntervals.delete(el);
      }
    } catch (e) {
    }
    if (!el) return;
    try {
      if (this._readingModeIntervals && this._readingModeIntervals.has(el)) {
        const interval = this._readingModeIntervals.get(el);
        if (interval) clearInterval(interval);
        this._readingModeIntervals.delete(el);
      }
    } catch (e) {
    }
    try {
      if (this._viewportObservers && this._viewportObservers.has(el)) {
        const observer = this._viewportObservers.get(el);
        if (observer && typeof observer.disconnect === "function") {
          observer.disconnect();
        }
        this._viewportObservers.delete(el);
      }
    } catch (e) {
    }
  }
  // Process only the active file: immediate visible blocks then deferred idle processing
  processActiveFileOnly(el, ctx) {
    if (!el || !ctx || !ctx.sourcePath) return;
    if (!this.settings.enabled) return;
    try {
      this.removeDisabledNeutralizerStyles();
    } catch (_) {
    }
    if (typeof ctx.sourcePath !== "string") {
      debugWarn("ACT", `Invalid sourcePath type: ${typeof ctx.sourcePath}`);
      return;
    }
    const startTime = performance.now();
    debugLog("ACT", "Processing active file", ctx.sourcePath.slice(-30));
    if (this.settings.forceFullRenderInReading) {
      try {
        debugWarn("ACT", "forceFullRenderInReading enabled - forcing full processing");
        try {
          debugLog("ACT_FLAGS", `hideTextColors=${this.settings.hideTextColors === true}, hideHighlights=${this.settings.hideHighlights === true}`);
        } catch (_) {
        }
        const pr0 = this.evaluatePathRules(ctx.sourcePath);
        const allowedEntriesForce = this.filterEntriesByAdvancedRules(ctx.sourcePath, this.getSortedWordEntries());
        if ((pr0.excluded || this.hasGlobalExclude() && pr0.hasIncludes && !pr0.included) && allowedEntriesForce.length === 0) return;
        if (this.settings.disabledFiles.includes(ctx.sourcePath)) return;
        if (this.isFrontmatterColoringDisabled(ctx.sourcePath)) return;
        const folderEntry2 = this.getBestFolderEntry(ctx.sourcePath);
        this.processInChunks(el, allowedEntriesForce, folderEntry2, {
          skipFirstN: 0,
          batchSize: 30,
          clearExisting: true,
          forceProcess: true,
          maxMatches: Infinity
        });
      } catch (e) {
        debugError("ACT", "forceFullRenderInReading failed", e);
      }
      return;
    }
    try {
      if (this.performanceMonitor && this.performanceMonitor.isOverloaded && this.performanceMonitor.isOverloaded()) {
        try {
          const now = Date.now();
          if (!this._lastPerfWarning || now - this._lastPerfWarning > 1e3) {
            debugLog("ACT", "Skipping: perf overload");
            this._lastPerfWarning = now;
          }
        } catch (e) {
          debugError("ACT", "perf gate error", e);
        }
        return;
      }
    } catch (e) {
      debugError("ACT", "perf gate error", e);
    }
    const pr = this.evaluatePathRules(ctx.sourcePath);
    if (this.settings.disabledFiles.includes(ctx.sourcePath)) return;
    if (this.isFrontmatterColoringDisabled(ctx.sourcePath)) return;
    const folderEntry = this.getBestFolderEntry(ctx.sourcePath);
    const allEntries = this.getSortedWordEntries();
    const allowedEntries = this.filterEntriesByAdvancedRules(ctx.sourcePath, allEntries);
    for (const entry of allowedEntries) {
      if (!entry.targetElement && entry.isRegex) {
        if (entry.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1") entry.targetElement = "strong";
        else if (entry.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1") entry.targetElement = "em";
        else if (entry.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1") entry.targetElement = "strong-em";
      }
    }
    try {
      if (el && el.querySelectorAll) {
        const strongs = el.querySelectorAll("strong");
        for (let i = 0; i < strongs.length; i++) {
          const strong = strongs[i];
          const ems = strong.getElementsByTagName("em");
          if (ems.length > 0) {
            let allEmText = "";
            for (let j = 0; j < ems.length; j++) allEmText += ems[j].textContent;
            if (strong.textContent.trim() === allEmText.trim()) {
              strong.classList.add("act-transparent-strong");
            }
          }
        }
      }
    } catch (e) {
    }
    const isExcludedByPathRules = pr.excluded || this.hasGlobalExclude() && pr.hasIncludes && !pr.included;
    if (isExcludedByPathRules && allowedEntries.length === 0) {
      debugLog("ACT", "Skipping: excluded by path rules with no advanced rule exceptions");
      return;
    }
    if (this.settings.disableReadingModeColoring) {
      try {
        const prev = this._viewportObservers && this._viewportObservers.get && this._viewportObservers.get(el);
        if (prev && typeof prev.disconnect === "function") {
          try {
            prev.disconnect();
          } catch (e) {
          }
          try {
            this._viewportObservers.delete(el);
          } catch (e) {
          }
        }
      } catch (e) {
      }
      return;
    }
    try {
      if (this.shouldUseLightweightMode && this.shouldUseLightweightMode(el.textContent ? el.textContent.length : 0)) {
        debugLog("ACT", "Large doc detected -> using viewport-based rendering");
        try {
          this.setupViewportObserver(el, folderEntry || null, { clearExisting: true, entries: allowedEntries });
          this._processBasesViews();
          try {
            const pseudoView = { dom: el, file: { path: ctx.sourcePath } };
            this._processLivePreviewCallouts(pseudoView);
            this._processLivePreviewTables(pseudoView);
          } catch (err) {
            debugError("ACT", "lightweight mode element processing failed", err);
          }
        } catch (e) {
          debugError("ACT", "setupViewportObserver failed", e);
          this.applyHighlights(el, folderEntry || null, { immediateBlocks, clearExisting: true, entries: allowedEntries, filePath: ctx.sourcePath });
        }
        return;
      }
    } catch (e) {
    }
    const processNow = () => this.applyHighlights(el, folderEntry || null, { immediateBlocks, clearExisting: true, entries: allowedEntries, filePath: ctx.sourcePath });
    const t0 = performance.now();
    processNow();
    debugLog("ACT", `immediate pass: ${(performance.now() - t0).toFixed(1)}ms`);
    try {
      try {
        this._domRefs.set(el, Object.assign(this._domRefs.get(el) || {}, { deferredScheduled: true, deferredDone: false }));
      } catch (e) {
      }
      const runDeferred = (label) => {
        try {
          const meta = this._domRefs.get(el) || {};
          if (meta.deferredDone) return;
          meta.deferredDone = true;
          try {
            this._domRefs.set(el, meta);
          } catch (e) {
          }
          const t1 = performance.now();
          debugLog("DEFERRED", `Start: ${label}, skipFirstN=${immediateBlocks}`);
          try {
            this.processInChunks(el, allowedEntries, folderEntry || null, { skipFirstN: immediateBlocks, batchSize: 30, clearExisting: true, forceProcess: true, filePath: ctx.sourcePath }).then(() => debugLog("DEFERRED", `Completed: ${label} in ${(performance.now() - t1).toFixed(1)}ms`)).catch((e) => debugError("DEFERRED", "processInChunks error", e));
          } catch (e) {
            debugError("DEFERRED", "fallback applyHighlights due to error", e);
            this.applyHighlights(el, folderEntry || null, { skipFirstN: immediateBlocks, clearExisting: true, entries: allowedEntries, filePath: ctx.sourcePath });
          }
        } catch (e) {
          debugError("ACT", "deferred pass error", e);
        }
      };
      if (isReadingRoot) {
        try {
          runDeferred("reading-immediate");
        } catch (e) {
          debugError("DEFERRED", "reading immediate failed", e);
        }
      } else if (typeof window !== "undefined" && typeof window.requestIdleCallback === "function") {
        try {
          window.requestIdleCallback(() => runDeferred("idleCallback"), { timeout: 2e3 });
        } catch (e) {
          setTimeout(() => runDeferred("setTimeout-after-idle-error"), 1200);
        }
      } else {
        setTimeout(() => runDeferred("setTimeout-fallback"), 1200);
      }
      if (!isReadingRoot) {
        setTimeout(() => runDeferred("safety-timeout"), 3e3);
      }
    } catch (e) {
      setTimeout(() => {
        try {
          const t3 = performance.now();
          this.applyHighlights(el, folderEntry || null, { skipFirstN: immediateBlocks, clearExisting: false, entries: allowedEntries, filePath: ctx.sourcePath });
          debugLog("ACT", `deferred (fallback-final) in ${(performance.now() - t3).toFixed(1)}ms`);
        } catch (err) {
          debugError("ACT", "fallback-final error", err);
        }
      }, 1500);
    }
    debugLog("ACT", `scheduled total: ${(performance.now() - startTime).toFixed(1)}ms`);
  }
  // Progressive optimized processing for very large documents
  processLargeDocument(el, ctx, folderEntry) {
    try {
      debugLog("LARGE", "Processing large document with optimized mode");
      const entries = this.filterEntriesByAdvancedRules(ctx.sourcePath, this.getSortedWordEntries());
      this.applyHighlights(el, folderEntry, {
        immediateBlocks: 50,
        skipFirstN: 0,
        clearExisting: true,
        entries,
        filePath: ctx.sourcePath
      });
      setTimeout(() => {
        try {
          this.processInChunks(el, entries, folderEntry, {
            batchSize: 30,
            clearExisting: false,
            forceProcess: true
            // Force full render even in lightweight mode as per user request
          });
          this._processBasesViews();
          try {
            const pseudoView = { dom: el, file: { path: ctx.sourcePath } };
            this._processLivePreviewCallouts(pseudoView, true);
            this._processLivePreviewTables(pseudoView, true);
          } catch (_) {
          }
        } catch (e) {
          debugError("LARGE", "deferred processing failed", e);
        }
      }, 1e3);
    } catch (e) {
      debugError("LARGE", "processLargeDocument failed", e);
    }
  }
  // NEW METHOD: Optimized processing for non-Roman text
  processNonRomanOptimized(element, entries, folderEntry = null, options = {}) {
    const nonRomanEntries = entries.filter(
      (entry) => entry && !entry.invalid && this.containsNonRomanCharacters(entry.pattern)
    );
    if (nonRomanEntries.length === 0) return;
    const blockTags = ["P", "LI", "DIV", "SPAN", "TD", "TH", "BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6"];
    const queue = [];
    for (const node of element.childNodes) {
      if (node.nodeType === Node.ELEMENT_NODE && blockTags.includes(node.nodeName)) {
        queue.push(node);
      }
    }
    for (const block of queue) {
      this.processNonRomanBlock(block, nonRomanEntries, folderEntry, options);
    }
  }
  // NEW METHOD: Process single block with non-Roman text
  processNonRomanBlock(block, entries, folderEntry, opts = {}) {
    try {
      if (block && (block.classList?.contains("act-skip-coloring") || block.closest?.(".act-skip-coloring"))) return;
    } catch (_) {
    }
    const clearExisting = opts.clearExisting !== false;
    if (clearExisting) {
      const highlights = block.querySelectorAll("span.always-color-text-highlight");
      for (const ex of highlights) {
        const tn = document.createTextNode(ex.textContent);
        ex.replaceWith(tn);
      }
    }
    for (const node of block.childNodes) {
      if (node.nodeType !== Node.TEXT_NODE) continue;
      let text = node.textContent;
      if (!text || text.length > 5e3) continue;
      text = this.decodeHtmlEntities(text);
      let matches = [];
      for (const entry of entries) {
        if (!entry || entry.invalid) continue;
        let pattern = entry.pattern;
        pattern = this.decodeHtmlEntities(pattern);
        const styleType2 = entry.styleType || "text";
        const textColor = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color || null;
        const resolvedTextColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : textColor;
        const backgroundColor = entry.backgroundColor || null;
        let pos = 0;
        while ((pos = text.indexOf(pattern, pos)) !== -1) {
          if (this.isContextBlacklisted(text, pos, pos + pattern.length, opts.filePath)) {
            pos += pattern.length;
            continue;
          }
          matches.push({
            start: pos,
            end: pos + pattern.length,
            styleType: styleType2,
            textColor: resolvedTextColor || null,
            backgroundColor: backgroundColor || null
          });
          pos += pattern.length;
          if (matches.length > 100) break;
        }
        if (matches.length > 100) break;
      }
      if (matches.length > 0) {
        matches.sort((a, b) => a.start - b.start);
        const frag = document.createDocumentFragment();
        let pos = 0;
        for (const m of matches) {
          if (m.start > pos) {
            frag.appendChild(document.createTextNode(text.slice(pos, m.start)));
          }
          const span = document.createElement("span");
          span.className = "always-color-text-highlight";
          span.textContent = text.slice(m.start, m.end);
          const hideText = this.settings.hideTextColors === true;
          const hideBg = this.settings.hideHighlights === true;
          if (m.styleType === "text") {
            if (!hideText && m.textColor) {
              try {
                span.style.setProperty("color", m.textColor, "important");
              } catch (_) {
                span.style.color = m.textColor;
              }
              try {
                span.style.setProperty("--highlight-color", m.textColor);
              } catch (e) {
              }
            }
          } else if (m.styleType === "highlight") {
            if (!hideBg) {
              const bg = m.backgroundColor || m.textColor;
              if (bg) {
                try {
                  span.style.setProperty("background-color", this.hexToRgba(bg, this.settings.backgroundOpacity ?? 0.3), "important");
                } catch (_) {
                  span.style.backgroundColor = this.hexToRgba(bg, this.settings.backgroundOpacity ?? 0.3);
                }
                try {
                  span.style.setProperty("padding-left", (this.settings.highlightHorizontalPadding ?? 4) + "px", "important");
                  span.style.setProperty("padding-right", (this.settings.highlightHorizontalPadding ?? 4) + "px", "important");
                  span.style.setProperty("padding-top", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
                  span.style.setProperty("padding-bottom", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
                } catch (_) {
                  span.style.paddingLeft = span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
                  span.style.paddingTop = span.style.paddingBottom = (this.settings.highlightVerticalPadding ?? 0) + "px";
                }
                const br = (this.settings.highlightBorderRadius ?? 8) + "px";
                try {
                  span.style.setProperty("border-radius", br, "important");
                } catch (_) {
                  span.style.borderRadius = br;
                }
                if (this.settings.enableBoxDecorationBreak ?? true) {
                  span.style.boxDecorationBreak = "clone";
                  span.style.WebkitBoxDecorationBreak = "clone";
                }
                this.applyBorderStyleToElement(span, null, bg);
              }
            } else {
              try {
                span.style.setProperty("background-color", "transparent", "important");
              } catch (_) {
                span.style.backgroundColor = "transparent";
              }
              span.style.paddingLeft = span.style.paddingRight = "0px";
              span.style.border = "";
              span.style.borderRadius = "";
            }
          } else {
            const tc = m.textColor;
            const bg = m.backgroundColor || m.textColor;
            if (!hideText && tc) {
              try {
                span.style.setProperty("color", tc, "important");
              } catch (_) {
                span.style.color = tc;
              }
              try {
                span.style.setProperty("--highlight-color", tc);
              } catch (e) {
              }
            }
            if (!hideBg && bg) {
              try {
                span.style.setProperty("background-color", this.hexToRgba(bg, this.settings.backgroundOpacity ?? 0.3), "important");
              } catch (_) {
                span.style.backgroundColor = this.hexToRgba(bg, this.settings.backgroundOpacity ?? 0.3);
              }
              try {
                span.style.setProperty("padding-left", (this.settings.highlightHorizontalPadding ?? 4) + "px", "important");
                span.style.setProperty("padding-right", (this.settings.highlightHorizontalPadding ?? 4) + "px", "important");
                span.style.setProperty("padding-top", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
                span.style.setProperty("padding-bottom", (this.settings.highlightVerticalPadding ?? 0) + "px", "important");
              } catch (_) {
                span.style.paddingLeft = span.style.paddingRight = (this.settings.highlightHorizontalPadding ?? 4) + "px";
                span.style.paddingTop = span.style.paddingBottom = (this.settings.highlightVerticalPadding ?? 0) + "px";
              }
              const br2 = (this.settings.highlightBorderRadius ?? 8) + "px";
              try {
                span.style.setProperty("border-radius", br2, "important");
              } catch (_) {
                span.style.borderRadius = br2;
              }
              if (this.settings.enableBoxDecorationBreak ?? true) {
                span.style.boxDecorationBreak = "clone";
                span.style.WebkitBoxDecorationBreak = "clone";
              }
              this.applyBorderStyleToElement(span, hideText ? null : tc, hideBg ? null : bg);
            } else if (hideBg) {
              try {
                span.style.setProperty("background-color", "transparent", "important");
              } catch (_) {
                span.style.backgroundColor = "transparent";
              }
              span.style.paddingLeft = span.style.paddingRight = "0px";
              span.style.border = "";
              span.style.borderRadius = "";
            }
          }
          frag.appendChild(span);
          pos = m.end;
        }
        if (pos < text.length) {
          frag.appendChild(document.createTextNode(text.slice(pos)));
        }
        node.replaceWith(frag);
      }
    }
  }
  // CRITICAL PERFORMANCE FIX: Check if element is inside a collapsed header section
  // This prevents processing hidden text that contributes to lag
  isElementInCollapsedSection(element) {
    try {
      const style = window.getComputedStyle(element);
      if (style.display === "none") return true;
      if (style.visibility === "hidden") return true;
    } catch (_) {
    }
    let current = element.parentElement;
    while (current && current !== document.body) {
      try {
        if (current.classList.contains("is-collapsed")) {
          return true;
        }
        const style = window.getComputedStyle(current);
        if (style.display === "none" || style.visibility === "hidden") {
          return true;
        }
      } catch (_) {
      }
      current = current.parentElement;
    }
    return false;
  }
  _wrapMatchesRecursive(element, entries, folderEntry = null, options = {}) {
    debugLog("WRAP", `Starting with ${entries.length} entries`);
    try {
      const textContent = element.textContent || "";
      const nonRomanCharCount = this.countNonRomanCharacters(textContent);
      const totalChars = textContent.length;
      if (nonRomanCharCount > 100 && nonRomanCharCount / totalChars > 0.3) {
        debugLog("ACT", "Using optimized non-Roman text processing");
        return this.processNonRomanOptimized(element, entries, folderEntry, options);
      }
    } catch (e) {
    }
    try {
      this.processMarkdownFormattingInReading(element, folderEntry, entries, options.filePath);
    } catch (e) {
    }
    const simpleEntries = entries.filter(
      (entry) => entry && !entry.invalid && this.isSimplePattern(entry.pattern)
    );
    const complexEntries = entries.filter(
      (entry) => entry && !entry.invalid && !this.isSimplePattern(entry.pattern)
    );
    debugLog("WRAP", `Pattern split: ${simpleEntries.length} simple, ${complexEntries.length} complex`);
    const allEntriesToProcess = simpleEntries.concat(complexEntries);
    if (complexEntries.length > 0 && !this.isPerformanceOverloaded()) {
      debugLog("ACT", `Processing ${allEntriesToProcess.length} total patterns (${simpleEntries.length} simple + ${complexEntries.length} complex)`);
    } else if (complexEntries.length > 0) {
      debugLog("ACT", "Skipping complex pattern processing due to performance constraints");
    }
    const immediateLimit = Number(options.immediateBlocks) || 0;
    const skipFirstN = Number(options.skipFirstN) || 0;
    const clearExisting = options.clearExisting !== false;
    const blockTags = ["P", "LI", "DIV", "SPAN", "TD", "TH", "BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6", "CODE", "PRE", "A"];
    try {
      if (this.settings.forceFullRenderInReading) {
        try {
          debugWarn("DOM", "forceFullRenderInReading active - skipping DOM size checks");
        } catch (e) {
        }
      } else {
        try {
          if (this.performanceMonitor && this.performanceMonitor.isOverloaded && this.performanceMonitor.isOverloaded()) {
            try {
              const now = Date.now();
              if (!this._lastPerfWarning || now - this._lastPerfWarning > 1e3) {
                debugLog("DOM", "Perf overload detected -> using chunked processing");
                this._lastPerfWarning = now;
              }
            } catch (e) {
            }
            try {
              this.processInChunks(element, entries, folderEntry, options);
            } catch (e) {
              debugError("DOM", "Chunking on overload failed", e);
            }
            return;
          }
        } catch (e) {
        }
        const MAX_DOM_NODES = 1e4;
        const MAX_BLOCK_NODES = 2e3;
        let nodeCount = 0;
        const tw = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, null, false);
        while (tw.nextNode()) {
          nodeCount++;
          if (nodeCount > MAX_DOM_NODES) break;
        }
        if (nodeCount > MAX_DOM_NODES) {
          debugLog("DOM", `DOM too large (${nodeCount} nodes) -> using chunked processing`);
          try {
            this.processInChunks(element, entries, folderEntry, options);
          } catch (e) {
            debugError("DOM", "Chunking failed", e);
          }
          return;
        }
        const blockSet2 = new Set(blockTags);
        let blockCount = 0;
        const tw2 = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode(node) {
            return blockSet2.has(node.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        }, false);
        while (tw2.nextNode()) {
          blockCount++;
          if (blockCount > MAX_BLOCK_NODES) break;
        }
        if (blockCount > MAX_BLOCK_NODES) {
          debugLog("DOM", `Chunking large block count: ${blockCount}`);
          try {
            this.processInChunks(element, entries, folderEntry, options);
          } catch (e) {
            debugError("DOM", "Chunking failed", e);
          }
          return;
        }
      }
    } catch (e) {
      debugError("DOM", "TreeWalker error", e);
    }
    const queue = [];
    const blockSet = new Set(blockTags);
    if (element.nodeType === Node.ELEMENT_NODE && blockTags.includes(element.nodeName)) {
      queue.unshift(element);
    }
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
      acceptNode(n) {
        if (["CODE", "PRE"].includes(n.nodeName)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (blockSet.has(n.nodeName)) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    }, false);
    let currentNode;
    while (currentNode = walker.nextNode()) {
      queue.push(currentNode);
    }
    try {
      debugLog("COLOR", `Processing ${queue.length} blocks, skipping first ${skipFirstN}`);
    } catch (e) {
    }
    let visited = 0;
    let collapsedSkipped = 0;
    for (let qIndex = 0; qIndex < queue.length; qIndex++) {
      const block = queue[qIndex];
      if (qIndex < skipFirstN) {
        try {
          if (qIndex % 50 === 0) debugLog("COLOR", `Skipping block ${qIndex}`);
        } catch (e) {
        }
        visited++;
        continue;
      }
      if (this.isElementInCollapsedSection(block)) {
        collapsedSkipped++;
        if (collapsedSkipped % 50 === 1) {
          try {
            debugLog("COLLAPSE_SKIP", `Skipping block in collapsed section (${collapsedSkipped} total skipped)`);
          } catch (e) {
          }
        }
        continue;
      }
      const effectiveStyle = "text";
      try {
        if (qIndex % 100 === 0) debugLog("COLOR", `Processing block ${qIndex}`);
      } catch (e) {
      }
      this._errorRecovery.wrap("PROCESS_BLOCK", () => this._processBlock(block, allEntriesToProcess, folderEntry, { clearExisting, effectiveStyle, immediateLimit, qIndex, skipFirstN, element, forceProcess: options && options.forceProcess || this.settings.forceFullRenderInReading, maxMatches: options && options.maxMatches || (this.settings.forceFullRenderInReading ? Infinity : void 0), filePath: options.filePath }), () => null);
    }
    if (collapsedSkipped > 0) {
      try {
        debugLog("COLLAPSE_SKIP", `Total collapsed blocks skipped: ${collapsedSkipped}`);
      } catch (e) {
      }
    }
    queue.length = 0;
  }
  // Extracted helper: process a single block element (previously inlined inside _wrapMatchesRecursive)
  _processBlock(block, entries, folderEntry, opts = {}) {
    if (block.matches && block.matches(".inline_spoilers-spoiler")) return;
    try {
      try {
        this._domRefs.set(block, { processedAt: Date.now(), matchCount: 0 });
      } catch (e) {
      }
    } catch (e) {
    }
    const clearExisting = opts.clearExisting !== false;
    let effectiveStyle;
    if (typeof opts.effectiveStyle === "string" && opts.effectiveStyle.length > 0) {
      effectiveStyle = opts.effectiveStyle;
    } else if (folderEntry && folderEntry.defaultStyle) {
      effectiveStyle = folderEntry.defaultStyle;
    } else {
      effectiveStyle = "text";
    }
    const immediateLimit = opts.immediateLimit || 0;
    try {
      this._perfCounters.totalBlocksProcessed = (this._perfCounters.totalBlocksProcessed || 0) + 1;
    } catch (e) {
    }
    try {
      if (clearExisting) {
        const highlights = [];
        const walker2 = document.createTreeWalker(block, NodeFilter.SHOW_ELEMENT, {
          acceptNode(node) {
            return node.classList && node.classList.contains("always-color-text-highlight") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        }, false);
        let highlightNode;
        while (highlightNode = walker2.nextNode()) {
          highlights.push(highlightNode);
        }
        for (const ex of highlights) {
          const tn = document.createTextNode(ex.textContent);
          ex.replaceWith(tn);
        }
        highlights.length = 0;
      }
    } catch (e) {
    }
    try {
      this.processMarkdownFormattingInReading(block, folderEntry, entries, opts.filePath);
    } catch (e) {
      try {
        debugError("MARKDOWN_FORMAT", "per-block processing error", e);
      } catch (_) {
      }
    }
    const textNodes = [];
    const walker = document.createTreeWalker(
      block,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode(node) {
          if (node.parentElement?.closest("code, pre")) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.parentElement?.closest("mark")) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.parentElement?.closest(".inline_spoilers-spoiler")) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.parentElement?.closest(".always-color-text-highlight")) {
            return NodeFilter.FILTER_REJECT;
          }
          try {
            if (node.parentElement?.closest(".act-skip-coloring")) {
              return NodeFilter.FILTER_REJECT;
            }
          } catch (_) {
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      },
      false
    );
    let currentNode;
    while (currentNode = walker.nextNode()) {
      textNodes.push(currentNode);
    }
    const literalMatches = [];
    try {
      let literalEntries = (entries || []).filter((e) => e && !e.invalid && !e.isRegex && typeof e.pattern === "string" && !e.isTextBg);
      if (literalEntries.length > 0) {
        try {
          this._literalEntriesToProcess = literalEntries;
        } catch (e) {
        }
      }
    } catch (e) {
      debugLog("LITERAL_PATH", `Error setting up literal entries: ${e.message}`);
    }
    if ((entries || []).filter((e) => e && !e.invalid && e.isRegex).length > 0) {
      textNodes.length = 0;
      let refreshWalker2 = document.createTreeWalker(
        block,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode(node) {
            if (node.parentElement?.closest("code, pre")) {
              return NodeFilter.FILTER_REJECT;
            }
            if (node.parentElement?.closest("mark")) {
              return NodeFilter.FILTER_REJECT;
            }
            if (node.parentElement?.closest(".always-color-text-highlight")) {
              return NodeFilter.FILTER_REJECT;
            }
            if (node.parentElement?.closest(".inline_spoilers-spoiler")) {
              return NodeFilter.FILTER_REJECT;
            }
            try {
              if (node.parentElement?.closest(".act-skip-coloring")) {
                return NodeFilter.FILTER_REJECT;
              }
            } catch (_) {
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        },
        false
      );
      let currentRefreshNode;
      while (currentRefreshNode = refreshWalker2.nextNode()) {
        textNodes.push(currentRefreshNode);
      }
    }
    try {
      const regexEntries = (entries || []).filter((e) => e && !e.invalid && e.isRegex);
      for (const entry of regexEntries) {
        if (!entry.regex) {
          this._patternMatcher && this._patternMatcher.compilePattern(entry);
        }
      }
    } catch (e) {
      debugLog("REGEX_COMPILE", `Error compiling regex entries: ${e.message}`);
    }
    textNodes.length = 0;
    let refreshWalker = document.createTreeWalker(
      block,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode(node) {
          if (node.parentElement?.closest("code, pre")) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.parentElement?.closest("mark")) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.parentElement?.closest(".always-color-text-highlight")) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.parentElement?.closest(".inline_spoilers-spoiler")) {
            return NodeFilter.FILTER_REJECT;
          }
          try {
            if (node.parentElement?.closest(".act-skip-coloring")) {
              return NodeFilter.FILTER_REJECT;
            }
          } catch (_) {
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      },
      false
    );
    let refreshNode;
    while (refreshNode = refreshWalker.nextNode()) {
      textNodes.push(refreshNode);
    }
    for (const node of textNodes) {
      let text = node.textContent;
      const headingEl = node.parentElement?.closest("h1, h2, h3, h4, h5, h6");
      if (headingEl) {
        const we = entries;
        const tagName = (headingEl.tagName || "").toUpperCase();
        let level = 0;
        if (tagName.startsWith("H")) {
          const parsed = parseInt(tagName.substring(1), 10);
          if (!isNaN(parsed)) level = parsed;
        }
        const headingEntry = level > 0 ? getEntryForHeadingLevel(we, level) : null;
        if (headingEntry) {
          if (headingEntry.styleType === "highlight" || headingEntry.styleType === "both") {
            if (!headingEl.querySelector(".act-heading-wrapper")) {
              const wrapper = document.createElement("span");
              wrapper.className = "always-color-text-highlight act-heading-wrapper";
              try {
                wrapper.style.display = "inline-block";
              } catch (e) {
              }
              if (headingEntry.styleType === "both") {
                wrapper.style.color = headingEntry.textColor;
                try {
                  wrapper.style.setProperty("--highlight-color", headingEntry.textColor);
                } catch (e) {
                }
                wrapper.style.background = "";
                {
                  const params = this.getHighlightParams(headingEntry);
                  wrapper.style.backgroundColor = this.hexToRgba(headingEntry.backgroundColor, params.opacity);
                  const vpad = params.vPad;
                  wrapper.style.paddingLeft = wrapper.style.paddingRight = params.hPad + "px";
                  wrapper.style.paddingTop = wrapper.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
                  if (vpad < 0) {
                    wrapper.style.marginTop = vpad + "px";
                    wrapper.style.marginBottom = vpad + "px";
                  }
                  const br = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
                  wrapper.style.borderRadius = br;
                }
                if (this.settings.enableBoxDecorationBreak ?? true) {
                  wrapper.style.boxDecorationBreak = "clone";
                  wrapper.style.WebkitBoxDecorationBreak = "clone";
                }
                this.applyBorderStyleToElement(wrapper, headingEntry.textColor, headingEntry.backgroundColor, headingEntry);
              } else {
                wrapper.style.background = "";
                {
                  const params = this.getHighlightParams(headingEntry);
                  wrapper.style.backgroundColor = this.hexToRgba(headingEntry.backgroundColor, params.opacity);
                  const vpad = params.vPad;
                  wrapper.style.paddingLeft = wrapper.style.paddingRight = params.hPad + "px";
                  wrapper.style.paddingTop = wrapper.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
                  if (vpad < 0) {
                    wrapper.style.marginTop = vpad + "px";
                    wrapper.style.marginBottom = vpad + "px";
                  }
                  const br = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
                  wrapper.style.borderRadius = br;
                }
                if (this.settings.enableBoxDecorationBreak ?? true) {
                  wrapper.style.boxDecorationBreak = "clone";
                  wrapper.style.WebkitBoxDecorationBreak = "clone";
                }
                this.applyBorderStyleToElement(wrapper, null, headingEntry.backgroundColor, headingEntry);
              }
              const children = Array.from(headingEl.childNodes);
              children.forEach((ch) => wrapper.appendChild(ch));
              headingEl.appendChild(wrapper);
              try {
                const info = this._domRefs.get(block);
                if (info) info.matchCount = 1;
              } catch (e) {
              }
            }
            continue;
          } else {
            const c = headingEntry.color || headingEntry.textColor;
            if (c) {
              headingEl.style.color = c;
              try {
                headingEl.style.setProperty("--highlight-color", c);
              } catch (e) {
              }
              try {
                const info = this._domRefs.get(block);
                if (info) info.matchCount = 1;
              } catch (e) {
              }
              continue;
            }
          }
        }
      }
      const originalText = text;
      text = this.decodeHtmlEntities(text);
      if (originalText !== text && (text.includes("\u2713") || originalText.includes("&#10003;"))) {
        debugLog("PROCESSBLOCK", "Decoded checkmark:", {
          from: originalText.substring(0, 30),
          to: text.substring(0, 30)
        });
      }
      const isBlacklisted = (textToCheck) => {
        try {
          return this.isWordBlacklisted(textToCheck, opts.filePath);
        } catch (e) {
          return false;
        }
      };
      const isForced = opts && opts.forceProcess || this.settings.forceFullRenderInReading;
      const maxMatches = typeof opts.maxMatches === "number" ? opts.maxMatches : isForced ? Infinity : this.settings && this.settings.extremeLightweightMode ? 200 : 500;
      let matches = [];
      try {
        const spoilerRegex = /\|\|.*?\|\|/g;
        let sMatch;
        while ((sMatch = spoilerRegex.exec(text)) !== null) {
          matches.push({
            start: sMatch.index,
            end: sMatch.index + sMatch[0].length,
            skip: true,
            // Dummy props for sorting/merging compatibility
            color: void 0,
            styleType: "text"
          });
        }
      } catch (e) {
      }
      let textBgEntries = entries.filter((e) => e && e.isTextBg === true);
      const TEXT_BG_CHUNK_SIZE = 10;
      try {
        debugLog("TEXTBG_ENTRIES", `count=${textBgEntries.length}`);
      } catch (_) {
      }
      try {
        debugLog("PROCESSBLOCK_TEXT", `text="${text}", length=${text.length}, containsColon=${text.includes(":")}, containsPM=${text.toLowerCase().includes("pm")}`);
      } catch (_) {
      }
      if (textBgEntries.length > TEXT_BG_CHUNK_SIZE) {
        for (let i = 0; i < textBgEntries.length && matches.length < maxMatches; i += TEXT_BG_CHUNK_SIZE) {
          const chunk = textBgEntries.slice(i, i + TEXT_BG_CHUNK_SIZE);
          for (const entry of chunk) {
            if (!entry || entry.invalid) continue;
            try {
              if (entry.fastTest && typeof entry.fastTest === "function") {
                if (!entry.fastTest(text)) continue;
              }
            } catch (e) {
            }
            const regex = entry.regex;
            if (!regex) continue;
            const _matches = this.safeMatchLoop(regex, text);
            for (const match of _matches) {
              const matchedText = match[0];
              const matchStart = match.index;
              const matchEnd = match.index + matchedText.length;
              if (!this.matchSatisfiesType(text, matchStart, matchEnd, entry)) continue;
              let fullWordStart = matchStart;
              let fullWordEnd = matchEnd;
              if (!this.isSentenceLikePattern(entry.pattern)) {
                while (fullWordStart > 0 && (/[A-Za-z0-9]/.test(text[fullWordStart - 1]) || text[fullWordStart - 1] === "-" || text[fullWordStart - 1] === "'")) {
                  fullWordStart--;
                }
                while (fullWordEnd < text.length && (/[A-Za-z0-9]/.test(text[fullWordEnd]) || text[fullWordEnd] === "-" || text[fullWordEnd] === "'")) {
                  fullWordEnd++;
                }
              }
              const fullWord = this.isSentenceLikePattern(entry.pattern) ? matchedText : text.substring(fullWordStart, fullWordEnd);
              if (isBlacklisted(fullWord)) continue;
              const mtLower = String(entry && entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
              let colorStart = matchStart;
              let colorEnd = matchEnd;
              if (!this.isSentenceLikePattern(entry.pattern) && (mtLower === "contains" || mtLower === "startswith" || mtLower === "endswith")) {
                colorStart = fullWordStart;
                colorEnd = fullWordEnd;
              }
              matches.push({
                start: colorStart,
                end: colorEnd,
                textColor: entry.textColor,
                backgroundColor: entry.backgroundColor,
                isTextBg: true,
                entryLabel: entry.presetLabel || entry.pattern.substring(0, 20),
                entryRef: entry
              });
              try {
                debugLog("TEXTBG_MATCH_ADDED", `entry="${entry.presetLabel || entry.pattern.substring(0, 20)}", text="${text.substring(colorStart, colorEnd)}", position=${colorStart}-${colorEnd}`);
              } catch (_) {
              }
              if (matches.length > maxMatches) break;
            }
            if (matches.length > maxMatches) break;
          }
        }
      } else {
        for (const entry of textBgEntries) {
          if (!entry || entry.invalid) continue;
          try {
            if (entry.fastTest && typeof entry.fastTest === "function") {
              if (!entry.fastTest(text)) continue;
            }
          } catch (e) {
          }
          const regex = entry.regex;
          if (!regex) continue;
          const _matches = this.safeMatchLoop(regex, text);
          for (const match of _matches) {
            const matchedText = match[0];
            const matchStart = match.index;
            const matchEnd = match.index + matchedText.length;
            if (!this.matchSatisfiesType(text, matchStart, matchEnd, entry)) continue;
            let fullWordStart = matchStart;
            let fullWordEnd = matchEnd;
            if (!this.isSentenceLikePattern(entry.pattern)) {
              while (fullWordStart > 0 && (/[A-Za-z0-9]/.test(text[fullWordStart - 1]) || text[fullWordStart - 1] === "-" || text[fullWordStart - 1] === "'")) {
                fullWordStart--;
              }
              while (fullWordEnd < text.length && (/[A-Za-z0-9]/.test(text[fullWordEnd]) || text[fullWordEnd] === "-" || text[fullWordEnd] === "'")) {
                fullWordEnd++;
              }
            }
            const fullWord = this.isSentenceLikePattern(entry.pattern) ? matchedText : text.substring(fullWordStart, fullWordEnd);
            if (isBlacklisted(fullWord)) continue;
            const mtLower = String(entry && entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
            let colorStart = matchStart;
            let colorEnd = matchEnd;
            if (!this.isSentenceLikePattern(entry.pattern) && (mtLower === "contains" || mtLower === "startswith" || mtLower === "endswith")) {
              colorStart = fullWordStart;
              colorEnd = fullWordEnd;
            }
            matches.push({
              start: colorStart,
              end: colorEnd,
              textColor: entry.textColor,
              backgroundColor: entry.backgroundColor,
              isTextBg: true,
              entryLabel: entry.presetLabel || entry.pattern.substring(0, 20),
              entryRef: entry
            });
            try {
              debugLog("TEXTBG_MATCH_ADDED", `entry="${entry.presetLabel || entry.pattern.substring(0, 20)}", text="${text.substring(colorStart, colorEnd)}", position=${colorStart}-${colorEnd}`);
            } catch (_) {
            }
            if (matches.length > maxMatches) break;
          }
          if (matches.length > maxMatches) break;
        }
      }
      try {
        const tbCount = matches.filter((m) => m && m.isTextBg).length;
        debugLog("TEXTBG_MATCHES", `count=${tbCount}`);
      } catch (_) {
      }
      {
        let textOnlyEntries = entries.filter((e) => !e || !e.isTextBg);
        textOnlyEntries = textOnlyEntries.filter((e) => {
          if (!e || e.isTextBg || !(!e.styleType || e.styleType === "text")) return true;
          const actualMatchType = String(e.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
          const isSentence = this.isSentenceLikePattern(e.pattern);
          const isLatin = this.isLatinWordPattern(e.pattern);
          return !(["contains", "startswith", "endswith"].includes(actualMatchType) && !isSentence && isLatin);
        });
        try {
          const tbCount = entries.filter((e) => e && e.isTextBg).length;
          const toCount = textOnlyEntries.length;
          debugLog("PATTERN_MATCH_FILTER", `Total entries=${entries.length}, TextBg=${tbCount}, TextOnly=${toCount}, partialMatch=${this.settings.partialMatch}`);
        } catch (_) {
        }
        const candidates = textOnlyEntries;
        try {
          debugLog("REGEX_MATCH_INPUT", `text="${text.substring(0, 100)}${text.length > 100 ? "..." : ""}", length=${text.length}, candidatesCount=${candidates.length}`);
        } catch (_) {
        }
        const pm = this._patternMatcher ? this._patternMatcher.match(text, candidates, folderEntry) : [];
        try {
          debugLog("REGEX_MATCH_RESULT", `found=${pm.length} matches from PatternMatcher`);
        } catch (_) {
        }
        for (const m of pm) {
          const overlappingTextBgIndices = [];
          for (let i = 0; i < matches.length; i++) {
            const tbMatch = matches[i];
            if (!tbMatch || !tbMatch.isTextBg) continue;
            if (m.start < tbMatch.end && m.end > tbMatch.start) {
              overlappingTextBgIndices.push(i);
            }
          }
          if (overlappingTextBgIndices.length > 0) {
            const mLength = m.end - m.start;
            const allShorter = overlappingTextBgIndices.every((i) => {
              const s = matches[i];
              return s.end - s.start < mLength;
            });
            if (!allShorter) {
              continue;
            }
            for (let i = overlappingTextBgIndices.length - 1; i >= 0; i--) {
              matches.splice(overlappingTextBgIndices[i], 1);
            }
          }
          matches.push(m);
          if (matches.length > maxMatches) break;
        }
      }
      if (matches.length > 1) {
        debugLog("OVERLAP", `Before resolution: ${matches.length} matches found`);
        matches.sort((a, b) => {
          const lenA = a.end - a.start;
          const lenB = b.end - b.start;
          if (lenA !== lenB) return lenB - lenA;
          if (a.start !== b.start) return a.start - b.start;
          const aHasText = a.isTextBg ? !!(a.textColor && a.textColor !== "currentColor") : !!a.color;
          const bHasText = b.isTextBg ? !!(b.textColor && b.textColor !== "currentColor") : !!b.color;
          if (aHasText && !bHasText) return -1;
          if (!aHasText && bHasText) return 1;
          if (a.isTextBg && !b.isTextBg) return -1;
          if (!a.isTextBg && b.isTextBg) return 1;
          return 0;
        });
        let nonOverlapping2 = [];
        for (const m of matches) {
          let overlapsWithSelected = false;
          for (const selected of nonOverlapping2) {
            if (m.start < selected.end && m.end > selected.start) {
              overlapsWithSelected = true;
              break;
            }
          }
          if (!overlapsWithSelected) {
            nonOverlapping2.push(m);
          }
        }
        matches = nonOverlapping2;
      }
      if (textBgEntries.some((e) => ["contains", "startswith", "endswith"].includes(String(e.matchType || "").toLowerCase()))) {
        const wordRegex = /[A-Za-z0-9'\-]+/g;
        let match;
        while (match = wordRegex.exec(text)) {
          const w = match[0];
          const start = match.index;
          const end = start + w.length;
          if (isBlacklisted(w)) continue;
          for (const entry of textBgEntries.filter((e) => ["contains", "startswith", "endswith"].includes(String(e.matchType || "").toLowerCase()))) {
            if (!entry || entry.invalid) continue;
            if (/^[^a-zA-Z0-9]+$/.test(entry.pattern)) continue;
            if (isBlacklisted(entry.pattern)) continue;
            const mt = String(entry.matchType || "").toLowerCase();
            const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
            const word = cs ? w : w.toLowerCase();
            const pat = cs ? String(entry.pattern || "") : String(entry.pattern || "").toLowerCase();
            const ok = mt === "contains" ? word.includes(pat) : mt === "startswith" ? word.startsWith(pat) : mt === "endswith" ? word.endsWith(pat) : false;
            if (ok) {
              let overlapsWithExisting = false;
              for (const existingMatch of matches) {
                if (start < existingMatch.end && end > existingMatch.start) {
                  overlapsWithExisting = true;
                  break;
                }
              }
              if (!overlapsWithExisting) {
                matches.push({
                  start,
                  end,
                  textColor: entry.textColor,
                  backgroundColor: entry.backgroundColor,
                  isTextBg: true,
                  styleType: "both",
                  entryRef: entry
                });
              } else {
                matches = matches.filter((m) => !(m.start >= start && m.end <= end && m.end - m.start < end - start));
                matches.push({
                  start,
                  end,
                  textColor: entry.textColor,
                  backgroundColor: entry.backgroundColor,
                  isTextBg: true,
                  styleType: "both",
                  entryRef: entry
                });
              }
              break;
            }
          }
          try {
            if (typeof wordRegex.lastIndex === "number" && wordRegex.lastIndex === match.index) wordRegex.lastIndex++;
          } catch (e) {
          }
        }
      }
      {
        const textOnlyEntries = entries.filter((e) => e && !e.invalid && (!e.styleType || e.styleType === "text") && !e.isTextBg && ["contains", "startswith", "endswith"].includes(String(e.matchType || "").toLowerCase()));
        if (textOnlyEntries.length > 0) {
          const wordRegex = /[A-Za-z0-9'\-]+/g;
          let match;
          while (match = wordRegex.exec(text)) {
            const w = match[0];
            const start = match.index;
            const end = start + w.length;
            if (isBlacklisted(w)) continue;
            for (const entry of textOnlyEntries) {
              if (!entry || entry.invalid) continue;
              if (/^[^a-zA-Z0-9]+$/.test(entry.pattern)) continue;
              if (isBlacklisted(entry.pattern)) continue;
              const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
              const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
              const word = cs ? w : w.toLowerCase();
              const pat = cs ? String(entry.pattern || "") : String(entry.pattern || "").toLowerCase();
              const ok = mt === "contains" ? word.includes(pat) : mt === "startswith" ? word.startsWith(pat) : mt === "endswith" ? word.endsWith(pat) : false;
              if (ok) {
                const matchStart = start;
                const matchEnd = end;
                let overlapsWithExisting = false;
                for (const existingMatch of matches) {
                  if (matchStart < existingMatch.end && matchEnd > existingMatch.start) {
                    overlapsWithExisting = true;
                    break;
                  }
                }
                if (!overlapsWithExisting) {
                  const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
                  matches.push({ start: matchStart, end: matchEnd, color: useColor, styleType: "text", word: w, entry, folderEntry });
                } else {
                  matches = matches.filter((m) => !(m.start >= matchStart && m.end <= matchEnd && m.end - m.start < matchEnd - matchStart));
                  const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
                  matches.push({ start: matchStart, end: matchEnd, color: useColor, styleType: "text", word: w, entry, folderEntry });
                }
                break;
              }
            }
            try {
              if (typeof wordRegex.lastIndex === "number" && wordRegex.lastIndex === match.index) wordRegex.lastIndex++;
            } catch (e) {
            }
          }
        }
      }
      try {
        const literalEntries = this._literalEntriesToProcess || [];
        for (const entry of literalEntries) {
          const rawPatt = String(entry.pattern || "");
          const patt = this.decodeHtmlEntities(rawPatt);
          if (!patt) continue;
          const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
          const textSearch = cs ? text : text.toLowerCase();
          const pattSearch = cs ? patt : patt.toLowerCase();
          let pos = 0;
          while ((pos = textSearch.indexOf(pattSearch, pos)) !== -1) {
            const start = pos;
            const end = pos + pattSearch.length;
            pos += pattSearch.length;
            if (!this.matchSatisfiesType(text, start, end, entry)) continue;
            const mtLower = String(entry && entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
            let expandedStart = start;
            let expandedEnd = end;
            if (!this.isSentenceLikePattern(entry.pattern) && (mtLower === "contains" || mtLower === "startswith" || mtLower === "endswith")) {
              while (expandedStart > 0 && (/[A-Za-z0-9]/.test(text[expandedStart - 1]) || text[expandedStart - 1] === "-" || text[expandedStart - 1] === "'")) {
                expandedStart--;
              }
              while (expandedEnd < text.length && (/[A-Za-z0-9]/.test(text[expandedEnd]) || text[expandedEnd] === "-" || text[expandedEnd] === "'")) {
                expandedEnd++;
              }
            }
            const fullWord = this.isSentenceLikePattern(entry.pattern) ? text.substring(start, end) : text.substring(expandedStart, expandedEnd);
            if (isBlacklisted(fullWord)) continue;
            const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
            matches.push({
              start: expandedStart,
              end: expandedEnd,
              color: useColor,
              styleType: entry.styleType || "text",
              word: entry.pattern,
              entry,
              folderEntry
            });
          }
        }
      } catch (e) {
        debugLog("LITERAL_MATCH_ADDITION", `Error adding literal matches: ${e.message}`);
      }
      for (const entry of entries) {
        if (!entry || entry.invalid) continue;
        if (/^[^a-zA-Z0-9]+$/.test(entry.pattern)) {
          const regex = entry.regex;
          if (!regex) continue;
          const _matches = this.safeMatchLoop(regex, text);
          for (const match of _matches) {
            if (entry.isTextBg && entry.backgroundColor) {
              matches.push({
                start: match.index,
                end: match.index + match[0].length,
                textColor: entry.textColor,
                backgroundColor: entry.backgroundColor,
                isTextBg: true,
                styleType: "both",
                word: match[0],
                entryRef: entry,
                // Copy custom styling properties
                backgroundOpacity: entry.backgroundOpacity,
                highlightBorderRadius: entry.highlightBorderRadius,
                highlightHorizontalPadding: entry.highlightHorizontalPadding,
                highlightVerticalPadding: entry.highlightVerticalPadding,
                enableBorderThickness: entry.enableBorderThickness,
                borderStyle: entry.borderStyle,
                borderLineStyle: entry.borderLineStyle,
                borderOpacity: entry.borderOpacity,
                borderThickness: entry.borderThickness
              });
            } else {
              const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
              matches.push({
                start: match.index,
                end: match.index + match[0].length,
                color: useColor,
                word: match[0],
                highlightHorizontalPadding: this.settings.highlightHorizontalPadding ?? 4,
                highlightBorderRadius: this.settings.highlightBorderRadius ?? 8
              });
            }
          }
        }
      }
      if (this.settings.symbolWordColoring) {
        const symbolEntries = entries.filter((entry) => entry && !entry.invalid && /^[^a-zA-Z0-9]+$/.test(entry.pattern));
        if (symbolEntries.length > 0) {
          const wordRegex = /\b\w+[^\s]*\b/g;
          let match;
          while (match = wordRegex.exec(text)) {
            const w = match[0];
            const start = match.index;
            const end = start + w.length;
            if (isBlacklisted(w)) continue;
            for (const symEntry of symbolEntries) {
              const testRe = symEntry.testRegex || (this.settings.caseSensitive ? new RegExp(this.escapeRegex(symEntry.pattern)) : new RegExp(this.escapeRegex(symEntry.pattern), "i"));
              if (testRe.test(w)) {
                if (symEntry.isTextBg && symEntry.backgroundColor) {
                  matches.push({
                    start,
                    end,
                    textColor: symEntry.textColor,
                    backgroundColor: symEntry.backgroundColor,
                    isTextBg: true,
                    styleType: "both",
                    word: w,
                    entryRef: symEntry,
                    // Copy custom styling properties
                    backgroundOpacity: symEntry.backgroundOpacity,
                    highlightBorderRadius: symEntry.highlightBorderRadius,
                    highlightHorizontalPadding: symEntry.highlightHorizontalPadding,
                    highlightVerticalPadding: symEntry.highlightVerticalPadding,
                    enableBorderThickness: symEntry.enableBorderThickness,
                    borderStyle: symEntry.borderStyle,
                    borderLineStyle: symEntry.borderLineStyle,
                    borderOpacity: symEntry.borderOpacity,
                    borderThickness: symEntry.borderThickness
                  });
                } else {
                  const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : symEntry.textColor && symEntry.textColor !== "currentColor" ? symEntry.textColor : symEntry.color;
                  matches.push({ start, end, color: useColor, word: w });
                }
                break;
              }
            }
            try {
              if (typeof wordRegex.lastIndex === "number" && wordRegex.lastIndex === match.index) wordRegex.lastIndex++;
            } catch (e) {
            }
          }
        }
      }
      if (matches.length > 1) {
        matches.sort((a, b) => {
          const lenA = a.end - a.start;
          const lenB = b.end - b.start;
          if (lenA !== lenB) return lenB - lenA;
          if (a.start !== b.start) return a.start - b.start;
          const aHasText = a.isTextBg ? !!(a.textColor && a.textColor !== "currentColor") : !!a.color;
          const bHasText = b.isTextBg ? !!(b.textColor && b.textColor !== "currentColor") : !!b.color;
          if (aHasText && !bHasText) return -1;
          if (!aHasText && bHasText) return 1;
          if (a.isTextBg && !b.isTextBg) return -1;
          if (!a.isTextBg && b.isTextBg) return 1;
          return 0;
        });
        let nonOverlapping2 = [];
        for (const m of matches) {
          let overlapsWithSelected = false;
          for (const selected of nonOverlapping2) {
            if (m.start < selected.end && m.end > selected.start) {
              overlapsWithSelected = true;
              break;
            }
          }
          if (!overlapsWithSelected) {
            nonOverlapping2.push(m);
          }
        }
        matches = nonOverlapping2;
      }
      matches.sort((a, b) => a.start - b.start);
      let nonOverlapping = matches;
      const seenRanges = /* @__PURE__ */ new Set();
      const beforeDedup = nonOverlapping.length;
      nonOverlapping = nonOverlapping.filter((m) => {
        const key = `${m.start}-${m.end}`;
        if (seenRanges.has(key)) {
          debugLog("DEDUP_MATCH", `Removing duplicate match: '${m.word || "unknown"}' at ${m.start}-${m.end}`);
          return false;
        }
        seenRanges.add(key);
        return true;
      });
      if (beforeDedup !== nonOverlapping.length) {
        debugLog("DEDUP_SUMMARY", `Removed ${beforeDedup - nonOverlapping.length} duplicates`);
      }
      let lastEnd = 0;
      try {
        debugLog("READING_BLOCK", `matches=${nonOverlapping.length}, hideTextColors=${this.settings.hideTextColors === true}, hideHighlights=${this.settings.hideHighlights === true}`);
      } catch (_) {
      }
      if (nonOverlapping.length) {
        const frag = document.createDocumentFragment();
        let pos = 0;
        let i = 0;
        while (i < nonOverlapping.length) {
          let m = nonOverlapping[i];
          let j = i + 1;
          while (j < nonOverlapping.length && nonOverlapping[j].start === nonOverlapping[j - 1].end && !m.isTextBg && !nonOverlapping[j].isTextBg && (nonOverlapping[j].color === m.color || nonOverlapping[j].textColor === m.textColor && nonOverlapping[j].backgroundColor === m.backgroundColor || nonOverlapping[j].styleType === m.styleType)) {
            m = { start: m.start, end: nonOverlapping[j].end, color: m.color, styleType: m.styleType, textColor: m.textColor, backgroundColor: m.backgroundColor, skip: m.skip };
            j++;
          }
          if (m.start > pos) frag.appendChild(document.createTextNode(text.slice(pos, m.start)));
          if (m.skip) {
            frag.appendChild(document.createTextNode(text.slice(m.start, m.end)));
            pos = m.end;
            i = j;
            continue;
          }
          if (effectiveStyle === "none") {
            frag.appendChild(document.createTextNode(text.slice(m.start, m.end)));
          } else {
            const entry = m.entryRef || m.entry;
            const presetLabel = entry?.presetLabel || "";
            const isBoldItalicPreset = /bold|italic/i.test(presetLabel);
            let skipWrapper = false;
            if (isBoldItalicPreset) {
              const parent = node.parentElement;
              if (parent && (parent.closest(".cm-strong, .cm-em, .markdown-rendered strong, .markdown-rendered em") || parent.matches && parent.matches(".cm-strong, .cm-em, .markdown-rendered strong, .markdown-rendered em"))) {
                skipWrapper = true;
              }
            }
            if (skipWrapper) {
              frag.appendChild(document.createTextNode(text.slice(m.start, m.end)));
              pos = m.end;
              i = j;
              continue;
            }
            const span = document.createElement("span");
            span.className = "always-color-text-highlight";
            span.textContent = text.slice(m.start, m.end);
            const styleType2 = m.isTextBg ? "both" : m.styleType || "text";
            const hideText = this.settings.hideTextColors === true;
            const hideBg = this.settings.hideHighlights === true;
            let shouldAppendSpan = true;
            if (styleType2 === "text") {
              if (hideText) {
                frag.appendChild(document.createTextNode(text.slice(m.start, m.end)));
                shouldAppendSpan = false;
              } else {
                const textColor = m.color || (m.textColor && m.textColor !== "currentColor" ? m.textColor : null);
                if (textColor) {
                  try {
                    span.style.setProperty("color", textColor, "important");
                  } catch (_) {
                    span.style.color = textColor;
                  }
                  try {
                    span.style.setProperty("--highlight-color", textColor);
                  } catch (e) {
                  }
                }
                try {
                  debugLog("READING_TEXT_FULL", `applied color=${textColor || "none"}, hideTextColors=${this.settings.hideTextColors === true}, hideHighlights=${this.settings.hideHighlights === true}`);
                } catch (_) {
                }
              }
            } else if (styleType2 === "highlight") {
              if (hideBg) {
                frag.appendChild(document.createTextNode(text.slice(m.start, m.end)));
                shouldAppendSpan = false;
              } else {
                const bgColor = m.backgroundColor || m.color || (m.textColor && m.textColor !== "currentColor" ? m.textColor : null) || (folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : null);
                span.style.background = "";
                try {
                  span.style.setProperty("display", "inline-block", "important");
                } catch (_) {
                  span.style.display = "inline-block";
                }
                {
                  const entryRef = m.entryRef || m.entry || null;
                  const params = this.getHighlightParams(entryRef);
                  try {
                    span.style.setProperty("background-color", this.hexToRgba(bgColor, params.opacity ?? 25), "important");
                  } catch (_) {
                    span.style.backgroundColor = this.hexToRgba(bgColor, params.opacity ?? 25);
                  }
                  try {
                    const vpad = params.vPad;
                    span.style.setProperty("padding-left", params.hPad + "px", "important");
                    span.style.setProperty("padding-right", params.hPad + "px", "important");
                    span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
                    span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
                    if (vpad < 0) {
                      span.style.setProperty("margin-top", vpad + "px", "important");
                      span.style.setProperty("margin-bottom", vpad + "px", "important");
                    }
                  } catch (_) {
                    const vpad = params.vPad;
                    span.style.paddingLeft = span.style.paddingRight = params.hPad + "px";
                    span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
                    if (vpad < 0) {
                      span.style.marginTop = vpad + "px";
                      span.style.marginBottom = vpad + "px";
                    }
                  }
                  const br = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
                  try {
                    span.style.setProperty("border-radius", br, "important");
                  } catch (_) {
                    span.style.borderRadius = br;
                  }
                  const borderCss = this.generateBorderStyle(null, bgColor, entryRef);
                  if (borderCss) {
                    span.style.cssText += borderCss;
                  }
                }
                if (this.settings.enableBoxDecorationBreak ?? true) {
                  span.style.boxDecorationBreak = "clone";
                  span.style.WebkitBoxDecorationBreak = "clone";
                }
                try {
                  debugLog("READING_HIGHLIGHT", `applied bg=${bgColor || "none"}`);
                } catch (_) {
                }
              }
            } else if (styleType2 === "both") {
              const textColor = m.textColor && m.textColor !== "currentColor" ? m.textColor : m.color || null;
              const bgColor = m.backgroundColor || m.color || (folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : null);
              if (!hideText && textColor) {
                try {
                  span.style.setProperty("color", textColor, "important");
                } catch (_) {
                  span.style.color = textColor;
                }
                try {
                  span.style.setProperty("--highlight-color", textColor);
                } catch (e) {
                }
              } else if (hideText && !hideBg && !textColor && bgColor) {
              }
              if (!hideBg) {
                span.style.background = "";
                {
                  const entryRef = m.entryRef || m.entry || null;
                  const params = this.getHighlightParams(entryRef);
                  try {
                    span.style.setProperty("background-color", this.hexToRgba(bgColor, params.opacity ?? 25), "important");
                  } catch (_) {
                    span.style.backgroundColor = this.hexToRgba(bgColor, params.opacity ?? 25);
                  }
                  try {
                    const vpad = params.vPad;
                    span.style.setProperty("padding-left", params.hPad + "px", "important");
                    span.style.setProperty("padding-right", params.hPad + "px", "important");
                    span.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px", "important");
                    span.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px", "important");
                    if (vpad < 0) {
                      span.style.setProperty("margin-top", vpad + "px", "important");
                      span.style.setProperty("margin-bottom", vpad + "px", "important");
                    }
                  } catch (_) {
                    const vpad = params.vPad;
                    span.style.paddingLeft = span.style.paddingRight = params.hPad + "px";
                    span.style.paddingTop = span.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
                    if (vpad < 0) {
                      span.style.marginTop = vpad + "px";
                      span.style.marginBottom = vpad + "px";
                    }
                  }
                  const br2 = (params.hPad > 0 && params.radius === 0 ? 0 : params.radius) + "px";
                  try {
                    span.style.setProperty("border-radius", br2, "important");
                  } catch (_) {
                    span.style.borderRadius = br2;
                  }
                  const borderCss = this.generateBorderStyle(hideText ? null : textColor, hideBg ? null : bgColor, entryRef);
                  if (borderCss) {
                    span.style.cssText += borderCss;
                  }
                }
                if (this.settings.enableBoxDecorationBreak ?? true) {
                  span.style.boxDecorationBreak = "clone";
                  span.style.WebkitBoxDecorationBreak = "clone";
                }
                try {
                  debugLog("READING_BOTH", `applied text=${textColor || "none"}, bg=${bgColor || "none"}`);
                } catch (_) {
                }
              }
              if (hideText && hideBg) {
                frag.appendChild(document.createTextNode(text.slice(m.start, m.end)));
                shouldAppendSpan = false;
              }
              {
                const entryRef = m.entryRef || m.entry || null;
                this.applyBorderStyleToElement(span, hideText ? null : textColor, hideBg ? null : bgColor, entryRef);
              }
            }
            if (shouldAppendSpan) {
              frag.appendChild(span);
            }
          }
          pos = m.end;
          i = j;
        }
        if (pos < text.length) frag.appendChild(document.createTextNode(text.slice(pos)));
        node.replaceWith(frag);
        try {
          const info = this._domRefs.get(block);
          if (info) info.matchCount = effectiveStyle === "none" ? 0 : nonOverlapping.length;
        } catch (e) {
        }
      }
    }
  }
  // Async chunked processing to prevent UI freezes on large documents
  async processInChunks(element, entries, folderEntry = null, options = {}) {
    const selector = "p, li, div, span, td, th, blockquote, h1, h2, h3, h4, h5, h6";
    const batch = Number(options.batchSize) || 20;
    const blocks = [];
    const tags = new Set(selector.split(",").map((s) => s.trim().toUpperCase()));
    if (options.includeSelf && element && tags.has(element.nodeName)) {
      blocks.push(element);
    }
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        return tags.has(node.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    }, false);
    let currentNode;
    while (currentNode = walker.nextNode()) {
      blocks.push(currentNode);
    }
    const startIndex = Number(options.skipFirstN) || 0;
    const forceProcess = !!options.forceProcess;
    debugLog("CHUNK", `start: ${blocks.length} blocks, batch=${batch}, startIndex=${startIndex}, forceProcess=${forceProcess}`);
    for (let i = startIndex; i < blocks.length; i++) {
      if (!forceProcess && this.performanceMonitor && this.performanceMonitor.isOverloaded && this.performanceMonitor.isOverloaded()) {
        debugWarn("CHUNK", `paused at block ${i} due to perf overload`);
        const resumeOpts = Object.assign({}, options, { skipFirstN: i });
        setTimeout(() => {
          try {
            this.processInChunks(element, entries, folderEntry, resumeOpts);
          } catch (e) {
            debugError("CHUNK", "retry failed", e);
          }
        }, 300);
        blocks.length = 0;
        return;
      }
      try {
        this._errorRecovery.wrap("PROCESS_BLOCK", () => this._processBlock(blocks[i], entries, folderEntry, {
          clearExisting: options.clearExisting !== false,
          effectiveStyle: "text",
          forceProcess: forceProcess || this.settings.forceFullRenderInReading,
          maxMatches: options && typeof options.maxMatches !== "undefined" ? options.maxMatches : forceProcess || this.settings.forceFullRenderInReading ? Infinity : void 0,
          filePath: options.filePath
        }), () => null);
      } catch (e) {
        debugError("CHUNK", "block error", e);
      }
      const yieldInterval = forceProcess ? 50 : batch;
      if (i % yieldInterval === 0 && i > 0) {
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }
    debugLog("CHUNK", `done: ${blocks.length} blocks processed`);
    blocks.length = 0;
  }
  _processLivePreviewCallouts(view, force = false) {
    try {
      if (this.settings.disableLivePreviewColoring) return;
      const now = Date.now();
      if (!force && this._lpLastRun && now - this._lpLastRun < EDITOR_PERFORMANCE_CONSTANTS.CALLOUT_THROTTLE_MS) return;
      this._lpLastRun = now;
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      const isLP = root.closest && root.closest(".is-live-preview") || root.closest && root.closest(".canvas-node") || root.closest && root.closest(".markdown-embed") || force;
      if (!isLP) return;
      if (!force && this._isTyping && now - this._lastTypingTime < EDITOR_PERFORMANCE_CONSTANTS.TYPING_GRACE_PERIOD_MS) return;
      if (this._lpCalloutRaf) return;
      this._lpCalloutRaf = requestAnimationFrame(() => {
        this._lpCalloutRaf = null;
        this._processLivePreviewCalloutsInternal(view, force);
      });
      return;
    } catch (e) {
      try {
        debugError("LP_CALLOUT", "Failed coloring live preview callouts", e);
      } catch (_) {
      }
    }
  }
  _processLivePreviewCalloutsInternal(view, force = false) {
    try {
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      const isLP = root.closest && root.closest(".is-live-preview") || root.closest && root.closest(".canvas-node") || root.closest && root.closest(".markdown-embed") || force;
      if (!isLP) return;
      const viewport = {
        top: window.scrollY || 0,
        bottom: (window.scrollY || 0) + (window.innerHeight || 0),
        left: 0,
        right: window.innerWidth || 0
      };
      const callouts = root.querySelectorAll(".cm-callout, .callout");
      if (!callouts || callouts.length === 0) return;
      const fileForView = view.file || this.app.workspace.getActiveFile();
      const filePath = fileForView ? fileForView.path : null;
      const docDisabled = !!(filePath && this.settings.disabledFiles && this.settings.disabledFiles.includes(filePath));
      const fmDisabled = !!(filePath && this.isFrontmatterColoringDisabled && this.isFrontmatterColoringDisabled(filePath));
      if (!this.settings.enabled || docDisabled || fmDisabled) {
        for (const co of callouts) {
          try {
            const highlights = co.querySelectorAll(".always-color-text-highlight");
            for (const hl of highlights) {
              const textNode = document.createTextNode(hl.textContent);
              hl.replaceWith(textNode);
            }
          } catch (_) {
          }
        }
        return;
      }
      const allEntries = this.getSortedWordEntries();
      const entries = filePath ? this.filterEntriesByAdvancedRules(filePath, allEntries) : allEntries;
      const folderEntry = filePath ? this.getBestFolderEntry(filePath) : null;
      if (!this._lpCalloutCache) this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
      for (const co of callouts) {
        try {
          const hasContent = co.textContent && co.textContent.trim().length > 0;
          if (!hasContent) continue;
          const sig = [
            co.textContent ? co.textContent.length : 0,
            co.childElementCount || 0,
            this.settings.enabled ? 1 : 0,
            this.settings.hideTextColors ? 1 : 0,
            this.settings.hideHighlights ? 1 : 0,
            docDisabled ? 1 : 0,
            fmDisabled ? 1 : 0
          ].join(":");
          const prev = this._lpCalloutCache.get(co);
          if (prev === sig) continue;
          this._lpCalloutCache.set(co, sig);
          this.processInChunks(co, entries, folderEntry, {
            clearExisting: true,
            batchSize: 10,
            forceProcess: true,
            maxMatches: Infinity
          });
        } catch (_) {
        }
      }
    } catch (e) {
      try {
        debugError("LP_CALLOUT", "Failed coloring live preview callouts", e);
      } catch (_) {
      }
    }
  }
  _processLivePreviewTables(view, force = false) {
    try {
      if (this.settings.disableLivePreviewColoring) return;
      const now = Date.now();
      if (!force && this._lpTablesLastRun && now - this._lpTablesLastRun < EDITOR_PERFORMANCE_CONSTANTS.TABLE_THROTTLE_MS) return;
      this._lpTablesLastRun = now;
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      const isLP = root.closest && root.closest(".is-live-preview") || root.closest && root.closest(".canvas-node") || root.closest && root.closest(".markdown-embed") || force;
      if (!isLP) return;
      if (!force && this._isTyping && now - this._lastTypingTime < EDITOR_PERFORMANCE_CONSTANTS.TYPING_GRACE_PERIOD_MS) return;
      if (this._lpTableRaf) cancelAnimationFrame(this._lpTableRaf);
      this._lpTableRaf = requestAnimationFrame(() => {
        this._lpTableRaf = null;
        this._processLivePreviewTablesInternal(view, force);
      });
      return;
    } catch (e) {
      try {
        debugError("LP_TABLES", "Failed coloring live preview tables", e);
      } catch (_) {
      }
    }
  }
  _processLivePreviewTablesInternal(view, force = false) {
    try {
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      const isLP = root.closest && root.closest(".is-live-preview") || root.closest && root.closest(".canvas-node") || root.closest && root.closest(".markdown-embed") || force;
      if (!isLP) return;
      const cells = root.querySelectorAll(".cm-content table td, .cm-content table th");
      if (!cells || cells.length === 0) return;
      const fileForView = view.file || this.app.workspace.getActiveFile();
      const filePath = fileForView ? fileForView.path : null;
      const docDisabled = !!(filePath && this.settings.disabledFiles && this.settings.disabledFiles.includes(filePath));
      const fmDisabled = !!(filePath && this.isFrontmatterColoringDisabled && this.isFrontmatterColoringDisabled(filePath));
      if (!this.settings.enabled || docDisabled || fmDisabled) {
        for (const cell of cells) {
          try {
            const highlights = cell.querySelectorAll(".always-color-text-highlight");
            for (const hl of highlights) {
              const textNode = document.createTextNode(hl.textContent);
              hl.replaceWith(textNode);
            }
          } catch (_) {
          }
        }
        return;
      }
      const allEntries = this.getSortedWordEntries();
      const entries = filePath ? this.filterEntriesByAdvancedRules(filePath, allEntries) : allEntries;
      const folderEntry = filePath ? this.getBestFolderEntry(filePath) : null;
      if (!this._lpTableCache) this._lpTableCache = /* @__PURE__ */ new WeakMap();
      const isVisible = (el) => {
        try {
          const rect = el.getBoundingClientRect();
          return rect.bottom >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight);
        } catch (_) {
          return true;
        }
      };
      let caretAnchor = null, caretFocus = null;
      try {
        const sel = window.getSelection && window.getSelection();
        if (sel && sel.rangeCount > 0) {
          caretAnchor = sel.anchorNode || null;
          caretFocus = sel.focusNode || null;
        }
      } catch (_) {
      }
      let processedCount = 0;
      const maxProcessPerFrame = 100;
      for (const cell of cells) {
        try {
          if (processedCount >= maxProcessPerFrame) {
            requestAnimationFrame(() => {
              try {
                this._processLivePreviewTablesInternal(view);
              } catch (_) {
              }
            });
            break;
          }
          const hasContent = cell.textContent && cell.textContent.trim().length > 0;
          if (!hasContent) continue;
          if (!isVisible(cell)) continue;
          try {
            if (caretAnchor && cell.contains(caretAnchor) || caretFocus && cell.contains(caretFocus)) {
              continue;
            }
          } catch (_) {
          }
          const sig = [
            cell.textContent ? cell.textContent.length : 0,
            cell.childElementCount || 0,
            this.settings.enabled ? 1 : 0,
            this.settings.hideTextColors ? 1 : 0,
            this.settings.hideHighlights ? 1 : 0,
            docDisabled ? 1 : 0,
            fmDisabled ? 1 : 0
          ].join(":");
          const prev = this._lpTableCache.get(cell);
          if (prev === sig) continue;
          this._lpTableCache.set(cell, sig);
          try {
            if (typeof this.processInChunks === "function") {
              this.processInChunks(cell, entries, folderEntry, {
                clearExisting: true,
                batchSize: 10,
                forceProcess: true,
                maxMatches: Infinity,
                filePath
              });
            } else {
              this.applyHighlights(cell, folderEntry, {
                clearExisting: true,
                entries,
                filePath
              });
            }
          } catch (e) {
            try {
              this.applyHighlights(cell, folderEntry, {
                clearExisting: true,
                entries,
                filePath
              });
            } catch (_) {
            }
          }
          processedCount++;
        } catch (_) {
        }
      }
    } catch (e) {
      try {
        debugError("LP_TABLES", "Failed coloring live preview tables", e);
      } catch (_) {
      }
    }
  }
  refreshAllLivePreviewTables() {
    try {
      this._lpTableCache = /* @__PURE__ */ new WeakMap();
      try {
        this._lpTablesLastRun = 0;
      } catch (_) {
      }
      this.app.workspace.iterateAllLeaves((leaf) => {
        try {
          if (!(leaf.view instanceof MarkdownView)) return;
          if (leaf.view.getMode && leaf.view.getMode() !== "source") return;
          const view = leaf.view && (leaf.view.editor?.cm?.view || leaf.view.editor?.view || leaf.view.view || null);
          if (view) {
            const root = view && view.dom ? view.dom : null;
            if (root) {
              try {
                const cells = root.querySelectorAll(".cm-content table td, .cm-content table th");
                for (const cell of cells) {
                  const highlights = cell.querySelectorAll(".always-color-text-highlight");
                  for (const hl of highlights) {
                    const textNode = document.createTextNode(hl.textContent);
                    hl.replaceWith(textNode);
                  }
                }
              } catch (e) {
              }
            }
            if (this.settings.enabled && !this.settings.disableLivePreviewColoring) {
              this._processLivePreviewTables(view);
              try {
                this._attachLivePreviewTableObserver(view);
              } catch (_) {
              }
              setTimeout(() => {
                try {
                  this._processLivePreviewTables(view);
                } catch (_) {
                }
              }, 250);
            }
          }
        } catch (_) {
        }
      });
    } catch (_) {
    }
  }
  forceReprocessLivePreviewTables() {
    const runPass = (delay) => {
      setTimeout(() => {
        try {
          this._lpTablesLastRun = 0;
        } catch (_) {
        }
        try {
          this._lpTableCache = /* @__PURE__ */ new WeakMap();
        } catch (_) {
        }
        try {
          this.app.workspace.iterateAllLeaves((leaf) => {
            try {
              if (!(leaf.view instanceof MarkdownView)) return;
              if (leaf.view.getMode && leaf.view.getMode() !== "source") return;
              const view = leaf.view && (leaf.view.editor?.cm?.view || leaf.view.editor?.view || leaf.view.view || null);
              if (view) {
                try {
                  this._attachLivePreviewTableObserver(view);
                } catch (_) {
                }
                try {
                  this.refreshEditor(leaf.view, true);
                } catch (_) {
                }
                try {
                  this._processLivePreviewTables(view);
                } catch (_) {
                }
              }
            } catch (_) {
            }
          });
        } catch (_) {
        }
      }, delay);
    };
    runPass(0);
    runPass(60);
    runPass(260);
    runPass(800);
  }
  _attachLivePreviewTableObserver(view) {
    try {
      if (this.settings.disableLivePreviewColoring) return;
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      if (!this._lpTableObservers) this._lpTableObservers = /* @__PURE__ */ new Map();
      const existing = this._lpTableObservers.get(root);
      if (existing) return;
      let debounceTimer = null;
      const DEBOUNCE_MS = 300;
      const observer = new MutationObserver((mutations) => {
        if (debounceTimer) clearTimeout(debounceTimer);
        let hasRelevantChange = false;
        for (const m of mutations) {
          try {
            if (m.type === "childList") {
              for (const node of m.addedNodes || []) {
                if (node && node.nodeType === 1) {
                  const el = node;
                  if (el.classList && el.classList.contains("cm-content") || el.querySelector && el.querySelector(".cm-content table")) {
                    hasRelevantChange = true;
                    break;
                  }
                }
              }
            } else if (m.type === "characterData") {
              const target = m.target;
              if (target && (target.closest && target.closest(".cm-content table"))) {
                hasRelevantChange = true;
              }
            }
            if (hasRelevantChange) break;
          } catch (_) {
          }
        }
        if (hasRelevantChange) {
          debounceTimer = setTimeout(() => {
            try {
              this._processLivePreviewTables(view);
            } catch (_) {
            }
          }, DEBOUNCE_MS);
        }
      });
      observer.observe(root, { childList: true, subtree: true });
      try {
        this._lpTableObservers.set(root, observer);
      } catch (_) {
      }
    } catch (_) {
    }
  }
  _detachLivePreviewTableObserver(view) {
    try {
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      const existing = this._lpTableObservers && this._lpTableObservers.get ? this._lpTableObservers.get(root) : null;
      if (existing && existing.disconnect) {
        try {
          existing.disconnect();
        } catch (_) {
        }
        try {
          this._lpTableObservers.delete(root);
        } catch (_) {
        }
      }
    } catch (_) {
    }
  }
  refreshAllLivePreviewCallouts() {
    try {
      this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
      try {
        this._lpLastRun = 0;
      } catch (_) {
      }
      try {
        this._lpTableCache = /* @__PURE__ */ new WeakMap();
      } catch (_) {
      }
      try {
        this._lpTablesLastRun = 0;
      } catch (_) {
      }
      try {
        this._basesCache = /* @__PURE__ */ new WeakMap();
      } catch (_) {
      }
      try {
        this._basesLastRun = 0;
      } catch (_) {
      }
      this.app.workspace.iterateAllLeaves((leaf) => {
        try {
          if (!(leaf.view instanceof MarkdownView)) return;
          if (leaf.view.getMode && leaf.view.getMode() !== "source") return;
          const view = leaf.view && (leaf.view.editor?.cm?.view || leaf.view.editor?.view || leaf.view.view || null);
          if (view) {
            const root = view && view.dom ? view.dom : null;
            if (root) {
              try {
                const callouts = root.querySelectorAll(".cm-callout, .callout");
                for (const co of callouts) {
                  const highlights = co.querySelectorAll(".always-color-text-highlight");
                  for (const hl of highlights) {
                    const textNode = document.createTextNode(hl.textContent);
                    hl.replaceWith(textNode);
                  }
                }
                const cells = root.querySelectorAll(".cm-content table td, .cm-content table th");
                for (const cell of cells) {
                  const highlights = cell.querySelectorAll(".always-color-text-highlight");
                  for (const hl of highlights) {
                    const textNode = document.createTextNode(hl.textContent);
                    hl.replaceWith(textNode);
                  }
                }
              } catch (e) {
              }
            }
            if (this.settings.enabled && !this.settings.disableLivePreviewColoring) {
              this._processLivePreviewCallouts(view);
              this._processLivePreviewTables(view);
              this._processBasesViews();
              try {
                this._attachLivePreviewCalloutObserver(view);
              } catch (_) {
              }
              try {
                this._attachLivePreviewTableObserver(view);
              } catch (_) {
              }
              setTimeout(() => {
                try {
                  this._processLivePreviewCallouts(view);
                } catch (_) {
                }
              }, 250);
              setTimeout(() => {
                try {
                  this._processLivePreviewTables(view);
                } catch (_) {
                }
              }, 250);
              setTimeout(() => {
                try {
                  this._processBasesViews();
                } catch (_) {
                }
              }, 250);
            }
          }
        } catch (_) {
        }
      });
    } catch (_) {
    }
  }
  forceReprocessLivePreviewCallouts() {
    const runPass = (delay) => {
      setTimeout(() => {
        try {
          this._lpLastRun = 0;
        } catch (_) {
        }
        try {
          this._lpCalloutCache = /* @__PURE__ */ new WeakMap();
        } catch (_) {
        }
        try {
          this._lpTablesLastRun = 0;
        } catch (_) {
        }
        try {
          this._lpTableCache = /* @__PURE__ */ new WeakMap();
        } catch (_) {
        }
        try {
          this._basesLastRun = 0;
        } catch (_) {
        }
        try {
          this._basesCache = /* @__PURE__ */ new WeakMap();
        } catch (_) {
        }
        try {
          this.app.workspace.iterateAllLeaves((leaf) => {
            try {
              if (!(leaf.view instanceof MarkdownView)) return;
              if (leaf.view.getMode && leaf.view.getMode() !== "source") return;
              const view = leaf.view && (leaf.view.editor?.cm?.view || leaf.view.editor?.view || leaf.view.view || null);
              if (view) {
                try {
                  this._attachLivePreviewCalloutObserver(view);
                } catch (_) {
                }
                try {
                  this.refreshEditor(leaf.view, true);
                } catch (_) {
                }
                try {
                  this._processLivePreviewCallouts(view);
                } catch (_) {
                }
                try {
                  this._attachLivePreviewTableObserver(view);
                } catch (_) {
                }
                try {
                  this._processLivePreviewTables(view);
                } catch (_) {
                }
                try {
                  this._processBasesViews();
                } catch (_) {
                }
              }
            } catch (_) {
            }
          });
        } catch (_) {
        }
      }, delay);
    };
    runPass(0);
    runPass(60);
    runPass(260);
    runPass(800);
  }
  _processBasesViews() {
    try {
      const now = Date.now();
      if (this._basesLastRun && now - this._basesLastRun < 200) return;
      this._basesLastRun = now;
      const roots = Array.from(document.querySelectorAll(".bases-view"));
      if (!roots || roots.length === 0) return;
      const fileForView = this.app.workspace.getActiveFile();
      const filePath = fileForView ? fileForView.path : null;
      const docDisabled = !!(filePath && this.settings.disabledFiles && this.settings.disabledFiles.includes(filePath));
      const fmDisabled = !!(filePath && this.isFrontmatterColoringDisabled && this.isFrontmatterColoringDisabled(filePath));
      const allEntries = this.getSortedWordEntries();
      const entries = filePath ? this.filterEntriesByAdvancedRules(filePath, allEntries) : allEntries;
      const folderEntry = filePath ? this.getBestFolderEntry(filePath) : null;
      if (!this._basesCache) this._basesCache = /* @__PURE__ */ new WeakMap();
      for (const root of roots) {
        const targets = root.querySelectorAll(".bases-table-cell, .metadata-input-longtext, .multi-select-pill-content, .multi-select-input");
        if (!targets || targets.length === 0) continue;
        if (!this.settings.enabled || docDisabled || fmDisabled) {
          for (const el of targets) {
            try {
              const highlights = el.querySelectorAll(".always-color-text-highlight");
              for (const hl of highlights) {
                const textNode = document.createTextNode(hl.textContent);
                hl.replaceWith(textNode);
              }
            } catch (_) {
            }
          }
          continue;
        }
        for (const el of targets) {
          try {
            const hasContent = el.textContent && el.textContent.trim().length > 0;
            if (!hasContent) continue;
            const sig = [
              el.textContent ? el.textContent.length : 0,
              el.childElementCount || 0,
              this.settings.enabled ? 1 : 0,
              this.settings.hideTextColors ? 1 : 0,
              this.settings.hideHighlights ? 1 : 0,
              docDisabled ? 1 : 0,
              fmDisabled ? 1 : 0
            ].join(":");
            const prev = this._basesCache.get(el);
            if (prev === sig) continue;
            this._basesCache.set(el, sig);
            this.processInChunks(el, entries, folderEntry, {
              clearExisting: true,
              batchSize: 10,
              forceProcess: true,
              maxMatches: Infinity,
              includeSelf: true
            });
          } catch (_) {
          }
        }
      }
      try {
        this._attachBasesObserver();
      } catch (_) {
      }
    } catch (e) {
    }
  }
  _attachBasesObserver() {
    try {
      if (!this._basesObservers) this._basesObservers = /* @__PURE__ */ new Map();
      const key = document.body || document;
      if (this._basesObservers.get(key)) return;
      const observer = new MutationObserver((mutations) => {
        for (const m of mutations) {
          try {
            if (m.type === "childList" || m.type === "characterData" || m.type === "attributes") {
              const added = Array.from(m.addedNodes || []);
              if (added.some((n) => n.nodeType === 1 && (n.classList?.contains("bases-view") || n.querySelector?.(".bases-view")))) {
                this._processBasesViews();
                return;
              }
              const t = m.target;
              if (t && t.closest && t.closest(".bases-view")) {
                this._processBasesViews();
                return;
              }
            }
          } catch (_) {
          }
        }
      });
      observer.observe(document.body || document, { childList: true, subtree: true, characterData: true, attributes: true });
      this._basesObservers.set(key, observer);
    } catch (_) {
    }
  }
  refreshAllBasesViews() {
    try {
      this._basesCache = /* @__PURE__ */ new WeakMap();
      try {
        this._basesLastRun = 0;
      } catch (_) {
      }
      const roots = Array.from(document.querySelectorAll(".bases-view"));
      for (const root of roots) {
        try {
          const targets = root.querySelectorAll(".bases-table-cell, .metadata-input-longtext, .multi-select-pill-content, .multi-select-input");
          for (const el of targets) {
            const highlights = el.querySelectorAll(".always-color-text-highlight");
            for (const hl of highlights) {
              const textNode = document.createTextNode(hl.textContent);
              hl.replaceWith(textNode);
            }
          }
        } catch (_) {
        }
      }
      if (this.settings.enabled) {
        this._processBasesViews();
        setTimeout(() => {
          try {
            this._processBasesViews();
          } catch (_) {
          }
        }, 250);
      }
    } catch (_) {
    }
  }
  forceReprocessBasesViews() {
    const runPass = (delay) => {
      setTimeout(() => {
        try {
          this._basesLastRun = 0;
        } catch (_) {
        }
        try {
          this._basesCache = /* @__PURE__ */ new WeakMap();
        } catch (_) {
        }
        try {
          this._processBasesViews();
        } catch (_) {
        }
      }, delay);
    };
    runPass(0);
    runPass(60);
    runPass(260);
    runPass(800);
  }
  _attachLivePreviewCalloutObserver(view) {
    try {
      if (this.settings.disableLivePreviewColoring) return;
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      if (!this._lpObservers) this._lpObservers = /* @__PURE__ */ new Map();
      const existing = this._lpObservers.get(root);
      if (existing) return;
      let debounceTimer = null;
      const DEBOUNCE_MS = 300;
      const observer = new MutationObserver((mutations) => {
        if (debounceTimer) clearTimeout(debounceTimer);
        let hasRelevantChange = false;
        for (const m of mutations) {
          try {
            if (m.type === "childList") {
              for (const node of m.addedNodes || []) {
                if (node && node.nodeType === 1) {
                  const el = node;
                  if (el.classList && (el.classList.contains("cm-callout") || el.classList.contains("callout")) || el.querySelector && el.querySelector(".cm-callout, .callout")) {
                    hasRelevantChange = true;
                    break;
                  }
                }
              }
            } else if (m.type === "characterData") {
              const target = m.target;
              if (target && (target.closest && target.closest(".cm-callout, .callout"))) {
                hasRelevantChange = true;
              }
            }
            if (hasRelevantChange) break;
          } catch (_) {
          }
        }
        if (hasRelevantChange) {
          debounceTimer = setTimeout(() => {
            try {
              this._processLivePreviewCallouts(view);
            } catch (_) {
            }
          }, DEBOUNCE_MS);
        }
      });
      observer.observe(root, { childList: true, subtree: true });
      try {
        this._lpObservers.set(root, observer);
      } catch (_) {
      }
    } catch (_) {
    }
  }
  _detachLivePreviewCalloutObserver(view) {
    try {
      const root = view && view.dom ? view.dom : null;
      if (!root) return;
      const existing = this._lpObservers && this._lpObservers.get ? this._lpObservers.get(root) : null;
      if (existing && existing.disconnect) {
        try {
          existing.disconnect();
        } catch (_) {
        }
        try {
          this._lpObservers.delete(root);
        } catch (_) {
        }
      }
    } catch (_) {
    }
  }
  // Setup IntersectionObserver to process only blocks as they enter the viewport
  setupViewportObserver(rootEl, folderEntry = null, options = {}) {
    try {
      if (!rootEl || !rootEl.isConnected) return;
      if (!this._viewportObservers) {
        this._viewportObservers = /* @__PURE__ */ new Map();
      }
      try {
        const prev = this._viewportObservers.get(rootEl);
        if (prev && typeof prev.disconnect === "function") prev.disconnect();
      } catch (e) {
        debugError("VIEWPORT", "Error disconnecting old observer", e);
      }
      const selectorTags = /* @__PURE__ */ new Set(["P", "LI", "DIV", "SPAN", "TD", "TH", "BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6"]);
      const blocks = [];
      try {
        const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_ELEMENT, null, false);
        let node;
        while (node = walker.nextNode()) {
          if (!node || !node.nodeName) continue;
          if (["CODE", "PRE"].includes(node.nodeName)) continue;
          try {
            if (node.closest(".act-skip-coloring") || node.classList.contains("act-skip-coloring")) continue;
          } catch (_) {
          }
          if (selectorTags.has(node.nodeName)) blocks.push(node);
        }
      } catch (e) {
        try {
          const nodeList = rootEl.querySelectorAll("p:not(.act-skip-coloring), li:not(.act-skip-coloring), div:not(.act-skip-coloring), span:not(.act-skip-coloring), td:not(.act-skip-coloring), th:not(.act-skip-coloring), blockquote:not(.act-skip-coloring), h1:not(.act-skip-coloring), h2:not(.act-skip-coloring), h3:not(.act-skip-coloring), h4:not(.act-skip-coloring), h5:not(.act-skip-coloring), h6:not(.act-skip-coloring)");
          for (const n of nodeList) blocks.push(n);
        } catch (err) {
          debugError("VIEWPORT", "querySelectorAll fallback failed", err);
        }
      }
      if (blocks.length === 0) return;
      const processed = /* @__PURE__ */ new WeakSet();
      const observerOptions = {
        root: rootEl,
        rootMargin: options.rootMargin || "300px 0px 300px 0px",
        threshold: options.threshold || 0.01
      };
      const pq = new PriorityQueue();
      let processing = false;
      const processNext = () => {
        if (processing) return;
        processing = true;
        const run = () => {
          const blk = pq.pop();
          if (!blk) {
            processing = false;
            return;
          }
          try {
            const es = options && Array.isArray(options.entries) ? options.entries : this.getSortedWordEntries();
            this._errorRecovery.wrap("PROCESS_BLOCK", () => this._processBlock(blk, es, folderEntry, { clearExisting: options.clearExisting !== false, effectiveStyle: "text", forceProcess: options.forceProcess || this.settings.forceFullRenderInReading, maxMatches: options.maxMatches || (this.settings.forceFullRenderInReading ? Infinity : void 0), filePath: options.filePath }), () => null);
          } catch (e) {
            debugError("VIEWPORT", "_processBlock failed", e);
          }
          if (pq.size() > 0) {
            setTimeout(run, 0);
          } else {
            processing = false;
          }
        };
        setTimeout(run, 0);
      };
      const io = new IntersectionObserver((entries) => {
        for (const ent of entries) {
          try {
            const block = ent.target;
            if (ent.isIntersecting) {
              try {
                if (block.closest(".act-skip-coloring") || block.classList.contains("act-skip-coloring")) {
                  io.unobserve(block);
                  continue;
                }
              } catch (_) {
              }
              if (processed.has(block)) {
                try {
                  io.unobserve(block);
                } catch (e) {
                }
                continue;
              }
              processed.add(block);
              try {
                io.unobserve(block);
              } catch (e) {
              }
              const r = ent.intersectionRatio || 0;
              const rect = block.getBoundingClientRect();
              const dist = Math.abs(rect.top - 0) + Math.abs(rect.bottom - window.innerHeight);
              const pr = r * 1e3 - dist;
              pq.push(block, pr);
            }
          } catch (e) {
            debugError("VIEWPORT", "observer entry error", e);
          }
        }
        processNext();
      }, observerOptions);
      for (const b of blocks) {
        try {
          io.observe(b);
        } catch (e) {
          debugError("VIEWPORT", "Error observing block", e);
        }
      }
      try {
        if (!this._viewportObservers) this._viewportObservers = /* @__PURE__ */ new Map();
        this._viewportObservers.set(rootEl, io);
      } catch (e) {
        debugError("VIEWPORT", "Error storing observer", e);
      }
      try {
        const firstN = Number(options.immediateBlocks) || 10;
        let count = 0;
        for (const b of blocks) {
          if (count >= firstN) break;
          const rect = b.getBoundingClientRect();
          if (rect.top < window.innerHeight + 400 && rect.bottom > -400) {
            if (!processed.has(b)) {
              processed.add(b);
              try {
                io.unobserve(b);
              } catch (e) {
              }
              try {
                if (b.closest(".act-skip-coloring") || b.classList.contains("act-skip-coloring")) {
                  continue;
                }
              } catch (_) {
              }
              pq.push(b, 1e3);
            }
            count++;
          }
        }
        processNext();
      } catch (e) {
        debugError("VIEWPORT", "Error prefetching visible blocks", e);
      }
      debugLog("VIEWPORT", `observer set: ${blocks.length} blocks, immediate=${options.immediateBlocks || 10}`);
      const debounce2 = (fn, ms) => {
        let t;
        return (...args) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...args), ms);
        };
      };
      const onChange = debounce2(() => {
        processNext();
      }, 100);
      const scrollH = this._eventManager.add(window, "scroll", onChange, { passive: true, debounceMs: 100, useRaf: true, viewType: "reading", priority: 1 });
      const resizeH = this._eventManager.add(window, "resize", onChange, { debounceMs: 100, useRaf: true, viewType: "reading", priority: 1 });
      const memCheck = () => {
        try {
          if (performance && performance.memory) {
            const usedMB = performance.memory.usedJSHeapSize / (1024 * 1024);
            if (usedMB > 1e3) {
              for (const b of blocks) {
                const rect = b.getBoundingClientRect();
                if (rect.bottom < -200 || rect.top > window.innerHeight + 200) {
                  const highlights = b.querySelectorAll("span.always-color-text-highlight");
                  for (const ex of highlights) {
                    const tn = document.createTextNode(ex.textContent);
                    ex.replaceWith(tn);
                  }
                }
              }
            }
          }
        } catch (_) {
        }
      };
      const memCheckInterval = setInterval(memCheck, 2e3);
      try {
        if (!this._readingModeIntervals) this._readingModeIntervals = /* @__PURE__ */ new Map();
        if (!this._readingModeIntervals.has(rootEl)) this._readingModeIntervals.set(rootEl, []);
        this._readingModeIntervals.get(rootEl).push(memCheckInterval);
      } catch (_) {
      }
    } catch (e) {
      debugError("VIEWPORT", "setup failed", e);
    }
  }
  // NEW METHOD: Optimized decorations for non-Roman text
  buildNonRomanOptimizedDeco(view, builder, from, to, text) {
    const plugin = this;
    const activeFile = this.app.workspace.getActiveFile();
    if (!this.settings.enabled) return builder.finish();
    if (activeFile) {
      const prnr = this.evaluatePathRules(activeFile.path);
      if (prnr.excluded || this.hasGlobalExclude() && prnr.hasIncludes && !prnr.included) return builder.finish();
    }
    if (activeFile && this.settings.disabledFiles.includes(activeFile.path)) return builder.finish();
    if (activeFile && this.isFrontmatterColoringDisabled(activeFile.path)) return builder.finish();
    const folderEntry = activeFile ? this.getBestFolderEntry(activeFile.path) : null;
    const entries = this.getSortedWordEntries();
    const nonRomanEntries = entries.filter(
      (entry) => entry && !entry.invalid && this.containsNonRomanCharacters(entry.pattern)
    );
    if (nonRomanEntries.length === 0) return builder.finish();
    let matches = [];
    for (const entry of nonRomanEntries) {
      const pattern = entry.pattern;
      let pos = 0;
      while ((pos = text.indexOf(pattern, pos)) !== -1) {
        matches.push({
          start: from + pos,
          end: from + pos + pattern.length,
          color: entry.color
        });
        pos += pattern.length;
        if (matches.length > 200) break;
      }
      if (matches.length > 200) break;
    }
    const effectiveStyle = "text";
    if (effectiveStyle === "none") return builder.finish();
    for (const m of matches) {
      let style;
      if (effectiveStyle === "text") {
        style = `color: ${m.color} !important; --highlight-color: ${m.color};`;
      } else {
        const hPad = typeof m.highlightHorizontalPadding === "number" ? m.highlightHorizontalPadding : this.settings.highlightHorizontalPadding ?? 4;
        const vPad = typeof m.highlightVerticalPadding === "number" ? m.highlightVerticalPadding : this.settings.highlightVerticalPadding ?? 0;
        const radius = typeof m.highlightBorderRadius === "number" ? m.highlightBorderRadius : this.settings.highlightBorderRadius ?? 8;
        const opacity = typeof m.backgroundOpacity === "number" ? m.backgroundOpacity : this.settings.backgroundOpacity ?? 25;
        const vPadCss = vPad >= 0 ? `padding-top: ${vPad}px !important; padding-bottom: ${vPad}px !important;` : `padding-top: 0px !important; padding-bottom: 0px !important; margin-top: ${vPad}px !important; margin-bottom: ${vPad}px !important;`;
        const br = hPad > 0 && radius === 0 ? 0 : radius;
        const boxDecoBreak = this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : "";
        style = `background: none; background-color: ${this.hexToRgba(m.color, opacity)} !important; border-radius: ${br}px !important; padding-left: ${hPad}px !important; padding-right: ${hPad}px !important; ${vPadCss}${boxDecoBreak}`;
      }
      const isDark = m.color && this.isDarkColor(m.color);
      const deco = Decoration.mark({
        attributes: {
          style,
          class: isDark ? "always-color-text-highlight act-dark-color" : "always-color-text-highlight",
          title: this.settings.showColoringReasonOnHover && m.color ? `matches "${m.entry?.pattern || ""}"` : ""
        }
      });
      builder.add(m.start, m.end, deco);
    }
    return builder.finish();
  }
  // --- Build CodeMirror Editor Extension (Editing View) ---
  buildEditorExtension() {
    const plugin = this;
    return ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = this.buildDeco(view);
        this.lastFilePath = view.file ? view.file.path : null;
        this._typingDebounceTimer = null;
        this.wasInTable = false;
        try {
          const sel = window.getSelection();
          if (sel && sel.rangeCount > 0) {
            const node = sel.anchorNode;
            if (node && (node.nodeType === 1 ? node : node.parentElement)?.closest(".cm-content table")) {
              this.wasInTable = true;
            }
          }
        } catch (_) {
        }
        try {
          if (plugin.settings.enabled && !plugin.settings.disableLivePreviewColoring) plugin._processLivePreviewCallouts(view);
        } catch (_) {
        }
        try {
          if (plugin.settings.enabled && !plugin.settings.disableLivePreviewColoring) plugin._processLivePreviewTables(view);
        } catch (_) {
        }
        try {
          if (plugin.settings.enabled && !plugin.settings.disableLivePreviewColoring) plugin._attachLivePreviewCalloutObserver(view);
        } catch (_) {
        }
        try {
          if (plugin.settings.enabled && !plugin.settings.disableLivePreviewColoring) plugin._attachLivePreviewTableObserver(view);
        } catch (_) {
        }
      }
      update(update) {
        if (update.selectionSet) {
          let isInTable = false;
          try {
            const sel = window.getSelection();
            if (sel && sel.rangeCount > 0) {
              const node = sel.anchorNode;
              if (node && (node.nodeType === 1 ? node : node.parentElement)?.closest(".cm-content table")) {
                isInTable = true;
              }
            }
          } catch (_) {
          }
          if (this.wasInTable && !isInTable) {
            try {
              plugin._processLivePreviewTables(this.view, true);
            } catch (_) {
            }
          }
          this.wasInTable = isInTable;
        }
        const currentFilePath = plugin.app.workspace.getActiveFile()?.path;
        const fileChanged = this.lastFilePath !== currentFilePath;
        this.lastFilePath = currentFilePath;
        const forceRebuild = update.transactions.some((tr) => tr.effects.some((e) => e.is(forceRebuildEffect)));
        if (update.docChanged) {
          plugin._isTyping = true;
          plugin._lastTypingTime = Date.now();
          clearTimeout(plugin._typingFlagTimer);
          plugin._typingFlagTimer = setTimeout(() => {
            plugin._isTyping = false;
          }, EDITOR_PERFORMANCE_CONSTANTS.TYPING_GRACE_PERIOD_MS);
        }
        if (update.docChanged || update.viewportChanged || fileChanged || forceRebuild) {
          if (plugin.settings.enableSmartUpdates && update.docChanged && !forceRebuild && !fileChanged && !update.viewportChanged) {
            try {
              this.decorations = this.decorations.map(update.changes);
              const dirtyRanges = [];
              let totalDirtyLength = 0;
              const viewport = update.view.viewport;
              update.changes.iterChanges((fromA, toA, fromB, toB) => {
                const startLine = update.view.state.doc.lineAt(fromB);
                const endLine = update.view.state.doc.lineAt(toB);
                if (endLine.to < viewport.from || startLine.from > viewport.to) return;
                const range = { from: startLine.from, to: endLine.to };
                dirtyRanges.push(range);
                totalDirtyLength += range.to - range.from;
              });
              if (totalDirtyLength > 5e3) {
                this.decorations = this.buildDeco(update.view);
              } else if (dirtyRanges.length > 0) {
                const { entries, folderEntry } = this.getApplicableEntries(update.view);
                if (entries && entries.length > 0) {
                  for (const range of dirtyRanges) {
                    this.decorations = this.decorations.update({
                      filter: (from, to) => to < range.from || from > range.to
                    });
                    const builder = new RangeSetBuilder();
                    const text = update.view.state.doc.sliceString(range.from, range.to);
                    const chunkDecos = plugin.buildDecoChunked(update.view, builder, range.from, range.to, text, entries, folderEntry, currentFilePath);
                    const newRanges = [];
                    chunkDecos.between(range.from, range.to, (f, t, v) => {
                      newRanges.push({ from: f, to: t, value: v });
                    });
                    this.decorations = this.decorations.update({
                      add: newRanges
                    });
                  }
                }
              }
            } catch (e) {
              this.decorations = this.buildDeco(update.view);
            }
          } else {
            this.decorations = this.buildDeco(update.view);
          }
          clearTimeout(this._typingDebounceTimer);
          const debounceMs = plugin.settings.extremeLightweightMode ? 1e3 : EDITOR_PERFORMANCE_CONSTANTS.TYPING_DEBOUNCE_MS;
          this._typingDebounceTimer = setTimeout(() => {
            try {
              if (plugin.settings.enabled && !plugin.settings.disableLivePreviewColoring) plugin._processLivePreviewCallouts(this.view);
            } catch (_) {
            }
            try {
              if (plugin.settings.enabled && !plugin.settings.disableLivePreviewColoring) plugin._processLivePreviewTables(this.view);
            } catch (_) {
            }
          }, debounceMs);
        }
      }
      destroy() {
        try {
          clearTimeout(this._typingDebounceTimer);
        } catch (_) {
        }
        try {
          plugin._detachLivePreviewCalloutObserver(this.view);
        } catch (_) {
        }
        try {
          plugin._detachLivePreviewTableObserver(this.view);
        } catch (_) {
        }
      }
      getApplicableEntries(view) {
        if (!plugin.settings.enabled) return { entries: [], folderEntry: null };
        let entries = plugin.getSortedWordEntries();
        const fileForView = view.file || plugin.app.workspace.getActiveFile();
        if (fileForView) {
          const prb = plugin.evaluatePathRules(fileForView.path);
          if (plugin.settings.disabledFiles.includes(fileForView.path)) return { entries: [], folderEntry: null };
          if (plugin.isFrontmatterColoringDisabled(fileForView.path)) return { entries: [], folderEntry: null };
          let previewEntries = entries;
          if (fileForView && fileForView.path) previewEntries = plugin.filterEntriesByAdvancedRules(fileForView.path, entries);
          if ((prb.excluded || plugin.hasGlobalExclude() && prb.hasIncludes && !prb.included) && previewEntries.length === 0) return { entries: [], folderEntry: null };
          entries = previewEntries;
        }
        for (const entry of entries) {
          if (!entry.targetElement && entry.isRegex) {
            const pattern = entry.pattern;
            const label = (entry.presetLabel || "").toLowerCase();
            if (pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1" || label === "bold" || label.includes("bold (")) entry.targetElement = "strong";
            else if (pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1" || label === "italic" || label.includes("italic (")) entry.targetElement = "em";
            else if (pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1" || label === "bold italic" || label.includes("bold italic")) entry.targetElement = "strong-em";
          }
        }
        const folderEntry = fileForView ? plugin.getBestFolderEntry(fileForView.path) : null;
        return { entries, folderEntry };
      }
      buildDeco(view) {
        const builder = new RangeSetBuilder();
        const root = view && view.dom ? view.dom : null;
        const isLivePreview = root && root.closest && root.closest(".is-live-preview");
        if (plugin.settings.disableLivePreviewColoring && isLivePreview) return builder.finish();
        const { entries, folderEntry } = this.getApplicableEntries(view);
        if (entries.length === 0) return builder.finish();
        const { from, to } = view.viewport;
        const docLength = view.state.doc.length;
        const extendedTo = Math.min(to + EDITOR_PERFORMANCE_CONSTANTS.VIEWPORT_EXTENSION, docLength);
        const text = view.state.doc.sliceString(from, extendedTo);
        const fileForView = view.file || plugin.app.workspace.getActiveFile();
        return plugin.buildDecoChunked(view, builder, from, extendedTo, text, entries, folderEntry, fileForView ? fileForView.path : null, syntaxTree);
      }
    }, {
      decorations: (v) => v.decorations
    });
  }
  // NEW METHOD: Extract full word containing a match
  extractFullWord(text, matchStart, matchEnd) {
    let fullWordStart = matchStart;
    let fullWordEnd = matchEnd;
    while (fullWordStart > 0 && /\w/.test(text[fullWordStart - 1]) && text[fullWordStart - 1] !== "_" && text[fullWordStart - 1] !== "*") {
      fullWordStart--;
    }
    while (fullWordEnd < text.length && /\w/.test(text[fullWordEnd]) && text[fullWordEnd] !== "_" && text[fullWordEnd] !== "*") {
      fullWordEnd++;
    }
    return text.substring(fullWordStart, fullWordEnd);
  }
  // NEW METHOD: Extract content from list item element, stripping markdown prefixes
  extractListItemContent(liElement) {
    try {
      if (!liElement) return "";
      const text = this.decodeHtmlEntities(String(liElement.textContent || ""));
      if (!text) return "";
      let content = text.replace(REGEX_CONSTANTS.CHECKBOX_PREFIX, "");
      if (content === text) {
        content = text.replace(REGEX_CONSTANTS.TASK_MARKER_PREFIX, "");
      }
      if (content === text) {
        content = text.replace(REGEX_CONSTANTS.BULLET_PREFIX, "");
      }
      if (content === text) {
        content = text.replace(REGEX_CONSTANTS.NUMBERED_PREFIX, "");
      }
      return content;
    } catch (e) {
      return "";
    }
  }
  // NEW METHOD: Check if word is blacklisted
  isGroupEnabledForFile(group, filePath) {
    if (!group || !filePath) return true;
    const enableFolders = Array.isArray(group.enableFolders) ? group.enableFolders : [];
    const disableFolders = Array.isArray(group.disableFolders) ? group.disableFolders : [];
    const hasEnableFolders = enableFolders.length > 0;
    const hasDisableFolders = disableFolders.length > 0;
    let folderDecision = 0;
    if (hasEnableFolders || hasDisableFolders) {
      const fp = this.normalizePath(filePath);
      const parents = this._parentFolders(fp).map((p) => this.normalizePath(p));
      const normRule = (p) => {
        const n = this.normalizePath(String(p || "").trim());
        if (n === "/") return "/";
        return n.replace(/\/$/, "");
      };
      let enableMatch = false;
      let disableMatch = false;
      let bestEnableDepth = -1;
      let bestDisableDepth = -1;
      for (const f of enableFolders) {
        const fNorm = normRule(f);
        if (!fNorm) continue;
        if (fNorm === "/" || fNorm === "") {
          enableMatch = true;
          if (bestEnableDepth < 0) bestEnableDepth = 0;
          continue;
        }
        const matchParent = parents.find((p) => p === fNorm);
        if (matchParent) {
          enableMatch = true;
          const depth = matchParent.split("/").length;
          if (depth > bestEnableDepth) bestEnableDepth = depth;
        }
      }
      for (const f of disableFolders) {
        const fNorm = normRule(f);
        if (!fNorm) continue;
        if (fNorm === "/" || fNorm === "") {
          disableMatch = true;
          if (bestDisableDepth < 0) bestDisableDepth = 0;
          continue;
        }
        const matchParent = parents.find((p) => p === fNorm);
        if (matchParent) {
          disableMatch = true;
          const depth = matchParent.split("/").length;
          if (depth > bestDisableDepth) bestDisableDepth = depth;
        }
      }
      if (!enableMatch && !disableMatch) {
        if (hasEnableFolders) folderDecision = -1;
      } else if (enableMatch && disableMatch) {
        if (bestDisableDepth > bestEnableDepth) folderDecision = -1;
        else folderDecision = 1;
      } else if (!enableMatch && disableMatch) {
        folderDecision = -1;
      } else if (enableMatch && !disableMatch) {
        folderDecision = 1;
      }
    }
    const enableTags = Array.isArray(group.enableTags) ? group.enableTags : [];
    const disableTags = Array.isArray(group.disableTags) ? group.disableTags : [];
    const hasEnableTags = enableTags.length > 0;
    const hasDisableTags = disableTags.length > 0;
    let tagDecision = 0;
    if (hasEnableTags || hasDisableTags) {
      const fileTags = this.getFileTags(filePath);
      const normTag = (t) => String(t || "").replace(/^#/, "").trim();
      const enableTagsNorm = hasEnableTags ? enableTags.map(normTag).filter(Boolean) : [];
      const disableTagsNorm = hasDisableTags ? disableTags.map(normTag).filter(Boolean) : [];
      const enableMatchTag = enableTagsNorm.length > 0 && fileTags.some((t) => enableTagsNorm.includes(normTag(t)));
      const disableMatchTag = disableTagsNorm.length > 0 && fileTags.some((t) => disableTagsNorm.includes(normTag(t)));
      if (enableTagsNorm.length > 0 && !enableMatchTag) {
        tagDecision = -1;
      }
      if (disableMatchTag) tagDecision = -1;
      if (enableMatchTag) tagDecision = 1;
    }
    if (folderDecision === 1 || tagDecision === 1) return true;
    if (folderDecision === -1 || tagDecision === -1) return false;
    return true;
  }
  isWordBlacklisted(word, filePath = null) {
    try {
      if (this._blacklistCompilationDirty) this.compileBlacklistEntries();
      const w = String(word || "");
      for (const compiled of this._compiledBlacklistWords) {
        compiled.regex.lastIndex = 0;
        if (compiled.regex.test(w)) return true;
      }
      for (const compiled of this._compiledBlacklistEntries) {
        for (const pattern of compiled.patterns) {
          pattern.regex.lastIndex = 0;
          if (pattern.regex.test(w)) return true;
        }
      }
      for (const compiled of Object.values(this._compiledBlacklistGroups)) {
        if (!compiled.group.active) continue;
        if (filePath && !this.isGroupEnabledForFile(compiled.group, filePath)) continue;
        for (const entryCompiled of compiled.entries) {
          for (const pattern of entryCompiled.patterns) {
            pattern.regex.lastIndex = 0;
            if (pattern.regex.test(w)) return true;
          }
        }
      }
    } catch (e) {
    }
    return false;
  }
  containsBlacklistedWord(text, filePath = null) {
    try {
      if (this._blacklistCompilationDirty) this.compileBlacklistEntries();
      const t = String(text || "");
      for (const compiled of this._compiledBlacklistWords) {
        compiled.regex.lastIndex = 0;
        if (compiled.regex.test(t)) return true;
      }
      for (const compiled of this._compiledBlacklistEntries) {
        for (const pattern of compiled.patterns) {
          pattern.regex.lastIndex = 0;
          if (pattern.regex.test(t)) return true;
        }
      }
      for (const compiled of Object.values(this._compiledBlacklistGroups)) {
        if (!compiled.group.active) continue;
        if (filePath && !this.isGroupEnabledForFile(compiled.group, filePath)) continue;
        for (const entryCompiled of compiled.entries) {
          for (const pattern of entryCompiled.patterns) {
            pattern.regex.lastIndex = 0;
            if (pattern.regex.test(t)) return true;
          }
        }
      }
    } catch (e) {
    }
    return false;
  }
  // NEW METHOD: Check if a full line is blacklisted by regex pattern (for markdown formatting)
  isLineBlacklistedByRegex(line, filePath = null) {
    try {
      if (this._blacklistCompilationDirty) this.compileBlacklistEntries();
      const l = String(line);
      for (const compiled of this._compiledBlacklistEntries) {
        for (const pattern of compiled.patterns) {
          if (!pattern.isRegex) continue;
          pattern.regex.lastIndex = 0;
          if (pattern.regex.test(l)) return true;
        }
      }
      for (const compiled of Object.values(this._compiledBlacklistGroups)) {
        if (!compiled.group.active) continue;
        if (filePath && !this.isGroupEnabledForFile(compiled.group, filePath)) continue;
        for (const entryCompiled of compiled.entries) {
          for (const pattern of entryCompiled.patterns) {
            if (!pattern.isRegex) continue;
            pattern.regex.lastIndex = 0;
            if (pattern.regex.test(l)) return true;
          }
        }
      }
    } catch (e) {
    }
    return false;
  }
  // NEW METHOD: Get all text ranges that are within blacklisted list items
  getBlacklistedListItemRanges(text, baseOffset = 0, filePath = null) {
    const ranges = [];
    try {
      let pos = 0;
      while (pos <= text.length) {
        const lineStart = pos;
        const nextNL = text.indexOf("\n", pos);
        const lineEnd = nextNL === -1 ? text.length : nextNL;
        const line = text.substring(lineStart, lineEnd);
        if (this.isLineBlacklistedByRegex(line, filePath)) {
          ranges.push({
            start: baseOffset + lineStart,
            end: baseOffset + lineEnd
          });
        }
        if (nextNL === -1) break;
        pos = nextNL + 1;
      }
    } catch (e) {
    }
    return ranges;
  }
  // NEW METHOD: Check if a match position falls within blacklisted ranges
  isMatchInBlacklistedRange(matchStart, matchEnd, blacklistedRanges) {
    try {
      for (const range of blacklistedRanges) {
        if (range.start >= matchEnd) return false;
        if (matchStart < range.end && matchEnd > range.start) {
          return true;
        }
      }
    } catch (e) {
    }
    return false;
  }
  // NEW METHOD: Context-aware blacklist check with prefix-aware tokens
  isContextBlacklisted(text, matchStart, matchEnd, filePath = null) {
    try {
      const fullWord = this.extractFullWord(text, matchStart, matchEnd);
      if (this.isWordBlacklisted(fullWord, filePath)) return true;
      if (matchStart > 0) {
        const prev = text[matchStart - 1];
        if (prev && /[@#]/.test(prev)) {
          const token = prev + fullWord;
          if (this.isWordBlacklisted(token, filePath)) return true;
        }
      }
      let ls = matchStart;
      while (ls > 0 && text[ls - 1] !== "\n") ls--;
      let le = matchEnd;
      while (le < text.length && text[le] !== "\n") le++;
      const line = text.substring(ls, le);
      const mTaskChecked = /^\s*[\-\*]\s+\[[xX]\]\s+(.*)$/.exec(line);
      const mTaskUnchecked = /^\s*[\-\*]\s+\[\s\]\s+(.*)$/.exec(line);
      const mNumbered = /^\s*\d+\.\s+(.*)$/.exec(line);
      const mBullet = /^\s*[\-\*]\s+(.*)$/.exec(line);
      const content = mTaskChecked && mTaskChecked[1] || mTaskUnchecked && mTaskUnchecked[1] || mNumbered && mNumbered[1] || mBullet && mBullet[1] || null;
      if (content && this.containsBlacklistedWord(content, filePath)) return true;
    } catch (e) {
    }
    return false;
  }
  // Helper: Check if a position is within a codeblock
  isPositionInCodeblock(pos, text, from) {
    try {
      const codeblockPattern = /```[\s\S]*?```/g;
      let match;
      while ((match = codeblockPattern.exec(text)) !== null) {
        const cbStart = from + match.index;
        const cbEnd = from + match.index + match[0].length;
        if (pos >= cbStart && pos <= cbEnd) return true;
      }
    } catch (e) {
    }
    return false;
  }
  // NEW METHOD: Standard editor processing for small/medium pattern/text sizes
  buildDecoStandard(view, builder, from, to, text, entries, folderEntry, filePath = null) {
    const entries_copy = entries || this.getSortedWordEntries();
    const allTimeEntries = entries_copy.filter((e) => e && e.presetLabel && (e.presetLabel.includes("Times") || e.pattern.includes("am")));
    debugLog("TIMEPM_ENTRY", `Total entries=${entries_copy.length}, Time entries found=${allTimeEntries.length}`);
    if (allTimeEntries.length > 0) {
      allTimeEntries.forEach((e, i) => {
        debugLog("TIMEPM_ENTRY", `[${i}] pattern=${e.pattern.substring(0, 50)}, regex=${e.regex ? "yes" : "no"}, invalid=${e.invalid}, presetLabel=${e.presetLabel}`);
      });
    }
    const timeEntry = entries_copy.find((e) => e && e.presetLabel && e.presetLabel.includes("Times"));
    if (timeEntry) {
      debugLog("TIMEPM_ENTRY", `Found timepm entry, regex=${timeEntry.regex ? "yes" : "no"}, invalid=${timeEntry.invalid}`);
    } else {
      debugLog("TIMEPM_ENTRY", "No timepm entry found in entries");
    }
    let matches = [];
    let headingRanges = [];
    let hasHeadingBlacklist = false;
    let codeblockRanges = [];
    try {
      const codeblockPattern = /```[\s\S]*?```/g;
      let cbMatch;
      while ((cbMatch = codeblockPattern.exec(text)) !== null) {
        const codeblockStart = from + cbMatch.index;
        const codeblockEnd = from + cbMatch.index + cbMatch[0].length;
        codeblockRanges.push({ start: codeblockStart, end: codeblockEnd });
      }
      const we = entries;
      const blEntries = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
      const codeblockEntry = we.find((e) => e && e.presetLabel === "Codeblocks");
      const hasCodeblockBlacklist = !!blEntries.find((e) => e && e.presetLabel === "Codeblocks" && !!e.isRegex);
      if (hasCodeblockBlacklist) {
        for (const cbRange of codeblockRanges) {
          matches.push({ start: cbRange.start, end: cbRange.end, skip: true });
        }
      } else if (codeblockEntry) {
        for (const cbMatch2 of text.matchAll(/```[\s\S]*?```/g)) {
          const start = from + cbMatch2.index;
          const end = from + cbMatch2.index + cbMatch2[0].length;
          if (codeblockEntry.backgroundColor) {
            const tc = codeblockEntry.textColor || "currentColor";
            const bc = codeblockEntry.backgroundColor;
            matches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true });
          } else {
            const c = codeblockEntry.color || codeblockEntry.textColor;
            if (c) matches.push({ start, end, color: c });
          }
        }
      }
    } catch (e) {
    }
    try {
      headingRanges = [];
      let posScan = 0;
      while (posScan <= text.length) {
        const lineStartScan = posScan;
        const nextNLScan = text.indexOf("\n", posScan);
        const lineEndScan = nextNLScan === -1 ? text.length : nextNLScan;
        let iScan = lineStartScan;
        while (iScan < lineEndScan && /\s/.test(text[iScan])) iScan++;
        let hScan = 0;
        while (iScan < lineEndScan && text[iScan] === "#" && hScan < 6) {
          hScan++;
          iScan++;
        }
        if (hScan > 0 && iScan < lineEndScan && text[iScan] === " ") {
          headingRanges.push({ start: from + lineStartScan, end: from + lineEndScan });
        }
        if (nextNLScan === -1) break;
        posScan = nextNLScan + 1;
      }
      const we = entries;
      let pos = 0;
      while (pos <= text.length) {
        const lineStart = pos;
        const nextNL = text.indexOf("\n", pos);
        const lineEnd = nextNL === -1 ? text.length : nextNL;
        let i = lineStart;
        while (i < lineEnd && /\s/.test(text[i])) i++;
        let hashes = 0;
        while (i < lineEnd && text[i] === "#" && hashes < 6) {
          hashes++;
          i++;
        }
        if (hashes > 0 && i < lineEnd && text[i] === " ") {
          while (i < lineEnd && text[i] === " ") i++;
          const start = from + i;
          const end = from + lineEnd;
          const entryToUse = hashes > 0 ? getEntryForHeadingLevel(we, hashes) : null;
          if (entryToUse) {
            if (entryToUse.backgroundColor) {
              const tc = entryToUse.textColor || "currentColor";
              const bc = entryToUse.backgroundColor;
              matches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true });
            } else {
              const c = entryToUse.color || entryToUse.textColor;
              if (c) matches.push({ start, end, color: c });
            }
          }
        }
        if (nextNL === -1) break;
        pos = nextNL + 1;
      }
    } catch (e) {
    }
    try {
      const we = entries;
      const blEntries = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
      const taskCheckedEntry = we.find((e) => e && e.presetLabel === "Task List (Checked)");
      const taskUncheckedEntry = we.find((e) => e && e.presetLabel === "Task List (Unchecked)");
      const numberedEntry = we.find((e) => e && e.presetLabel === "Numbered Lists");
      const bulletEntry = we.find((e) => e && e.presetLabel === "Bullet Points");
      const taskCheckedBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Task List (Checked)" && !!e.isRegex);
      const taskUncheckedBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Task List (Unchecked)" && !!e.isRegex);
      const numberedBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Numbered Lists" && !!e.isRegex);
      const bulletBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Bullet Points" && !!e.isRegex);
      const taskCheckedAllowed = !filePath || this.shouldColorText(filePath, taskCheckedEntry ? taskCheckedEntry.pattern : null);
      const taskUncheckedAllowed = !filePath || this.shouldColorText(filePath, taskUncheckedEntry ? taskUncheckedEntry.pattern : null);
      const numberedAllowed = !filePath || this.shouldColorText(filePath, numberedEntry ? numberedEntry.pattern : null);
      const bulletAllowed = !filePath || this.shouldColorText(filePath, bulletEntry ? bulletEntry.pattern : null);
      let pos = 0;
      while (pos <= text.length) {
        const lineStart = pos;
        const nextNL = text.indexOf("\n", pos);
        const lineEnd = nextNL === -1 ? text.length : nextNL;
        const line = text.substring(lineStart, lineEnd);
        let matched = false;
        if (!matched && !taskCheckedBlacklisted && taskCheckedEntry && taskCheckedAllowed) {
          const pattern = REGEX_CONSTANTS.TASK_CHECKED;
          const mdMatch = pattern.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length + mdMatch[4].length + mdMatch[5].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[6] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (taskCheckedEntry.backgroundColor) {
                const tc = taskCheckedEntry.textColor || "currentColor";
                const bc = taskCheckedEntry.backgroundColor;
                matches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true });
              } else {
                const c = taskCheckedEntry.color || taskCheckedEntry.textColor;
                if (c) matches.push({ start, end, color: c });
              }
              matched = true;
            }
          }
        }
        if (!matched && !taskUncheckedBlacklisted && taskUncheckedEntry && taskUncheckedAllowed) {
          const pattern = /^(\s*)([\-\*])(\s+)(\[\s\])(\s+)(.*)$/;
          const mdMatch = pattern.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length + mdMatch[4].length + mdMatch[5].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[6] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (taskUncheckedEntry.backgroundColor) {
                const tc = taskUncheckedEntry.textColor || "currentColor";
                const bc = taskUncheckedEntry.backgroundColor;
                matches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true });
              } else {
                const c = taskUncheckedEntry.color || taskUncheckedEntry.textColor;
                if (c) matches.push({ start, end, color: c });
              }
              matched = true;
            }
          }
        }
        if (!matched && !numberedBlacklisted && numberedEntry && numberedAllowed) {
          const pattern = REGEX_CONSTANTS.NUMBERED_LIST;
          const mdMatch = pattern.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[4] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (numberedEntry.backgroundColor) {
                const tc = numberedEntry.textColor || "currentColor";
                const bc = numberedEntry.backgroundColor;
                matches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true });
              } else {
                const c = numberedEntry.color || numberedEntry.textColor;
                if (c) matches.push({ start, end, color: c });
              }
              matched = true;
            }
          }
        }
        if (!matched && !bulletBlacklisted && bulletEntry && bulletAllowed) {
          const mdMatch = REGEX_CONSTANTS.BULLET_POINT.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[4] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (bulletEntry.backgroundColor) {
                const tc = bulletEntry.textColor || "currentColor";
                const bc = bulletEntry.backgroundColor;
                matches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true });
              } else {
                const c = bulletEntry.color || bulletEntry.textColor;
                if (c) matches.push({ start, end, color: c });
              }
              matched = true;
            }
          }
        }
        if (nextNL === -1) break;
        pos = nextNL + 1;
      }
    } catch (e) {
    }
    const blacklistedListRanges = this.getBlacklistedListItemRanges(text, from, filePath);
    let textBgEntries = Array.isArray(this._compiledTextBgEntries) ? this._compiledTextBgEntries : [];
    if (filePath) {
      textBgEntries = textBgEntries.filter((entry) => {
        if (!entry || !entry.pattern) return true;
        return this.shouldColorText(filePath, entry.pattern, entry);
      });
    }
    for (const entry of textBgEntries) {
      if (!entry || entry.invalid) continue;
      try {
        if (entry.fastTest && typeof entry.fastTest === "function" && !entry.fastTest(text)) continue;
      } catch (e) {
      }
      const regex = entry.regex;
      if (!regex) continue;
      const _matches = this.safeMatchLoop(regex, text);
      for (const match of _matches) {
        const matchedText = match[0];
        const matchStart = match.index;
        const matchEnd = match.index + matchedText.length;
        if (!this.matchSatisfiesType(text, matchStart, matchEnd, entry)) continue;
        if (this.isContextBlacklisted(text, matchStart, matchEnd, filePath)) continue;
        const absStart = from + matchStart;
        const absEnd = from + matchEnd;
        if (this.isMatchInBlacklistedRange(absStart, absEnd, blacklistedListRanges)) continue;
        if (hasHeadingBlacklist && headingRanges && headingRanges.length > 0) {
          let inHeading = false;
          for (const hr of headingRanges) {
            if (absStart < hr.end && absEnd > hr.start) {
              inHeading = true;
              break;
            }
          }
          if (inHeading) continue;
        }
        const fullWordStart = this.extractFullWord(text, matchStart, matchEnd);
        let colorStart = matchStart;
        let colorEnd = matchEnd;
        {
          const mt = String(entry.matchType || "").toLowerCase();
          if ((mt === "contains" || mt === "startswith" || mt === "endswith") && !this.isSentenceLikePattern(entry.pattern)) {
            colorStart = matchStart;
            colorEnd = matchEnd;
            while (colorStart > 0 && (/[A-Za-z0-9]/.test(text[colorStart - 1]) || text[colorStart - 1] === "-" || text[colorStart - 1] === "'")) {
              colorStart--;
            }
            while (colorEnd < text.length && (/[A-Za-z0-9]/.test(text[colorEnd]) || text[colorEnd] === "-" || text[colorEnd] === "'")) {
              colorEnd++;
            }
            const fullWord = text.substring(colorStart, colorEnd);
            const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
            const patRaw = String(entry.pattern || "");
            const pat = cs ? patRaw : patRaw.toLowerCase();
            const word = cs ? fullWord : fullWord.toLowerCase();
            let satisfies = false;
            if (mt === "contains") {
              satisfies = word.includes(pat);
            } else if (mt === "startswith") {
              satisfies = word.startsWith(pat);
            } else if (mt === "endswith") {
              satisfies = word.endsWith(pat);
            }
            if (!satisfies) {
              colorStart = matchStart;
              colorEnd = matchEnd;
            }
          }
        }
        matches.push({
          start: from + colorStart,
          end: from + colorEnd,
          textColor: entry.textColor,
          backgroundColor: entry.backgroundColor,
          isTextBg: true,
          entryRef: entry
        });
        if (matches.length > 3e3) break;
      }
      if (matches.length > 3e3) break;
    }
    for (const entry of entries_copy) {
      if (!entry || entry.invalid) continue;
      const isTextOnly = !entry.isTextBg && (!entry.styleType || entry.styleType === "text");
      const hasExplicitMatchType = entry.matchType && String(entry.matchType).toLowerCase() !== "exact";
      const shouldSkipToPartialSection = isTextOnly && !hasExplicitMatchType && this.settings.partialMatch && !this.isSentenceLikePattern(entry.pattern) && this.isLatinWordPattern(entry.pattern);
      if (shouldSkipToPartialSection) {
        debugLog("MAIN_LOOP_SKIP_PARTIAL", `pattern="${entry.pattern}" matchType="${entry.matchType}" (undefined means using setting default) isTextOnly=${isTextOnly}`);
        continue;
      }
      const actualMatchType = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
      debugLog("MAIN_LOOP_PROCESS", `pattern="${entry.pattern}" isTextOnly=${isTextOnly} matchType="${entry.matchType}" actualMatchType="${actualMatchType}"`);
      const isSentenceLike = this.isSentenceLikePattern(entry.pattern);
      let startswithRegex = null;
      let endswithRegex = null;
      if (isSentenceLike && (actualMatchType === "startswith" || actualMatchType === "endswith")) {
        try {
          const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
          const patRaw = String(entry.pattern || "");
          const flags = cs ? "" : "i";
          const esc = this.helpers.escapeRegex ? this.helpers.escapeRegex(patRaw) : patRaw.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          if (actualMatchType === "startswith") {
            startswithRegex = new RegExp(`^${esc}[A-Za-z]*$`, flags);
          } else if (actualMatchType === "endswith") {
            endswithRegex = new RegExp(`^[A-Za-z]*${esc}$`, flags);
          }
        } catch (_) {
        }
      }
      try {
        if (entry.fastTest && typeof entry.fastTest === "function") {
          const fastTestResult = entry.fastTest(text);
          if (entry.pattern && entry.pattern.includes("am") || entry.presetLabel && entry.presetLabel.includes("Times")) {
            debugLog("FASTTEST_CHECK", `Pattern: ${entry.presetLabel || entry.pattern.substring(0, 40)}, fastTest result=${fastTestResult}, text length=${text.length}, text="${text.substring(0, 50)}"`);
          }
          if (!fastTestResult) continue;
        }
      } catch (e) {
      }
      const regex = entry.regex;
      if (!regex) continue;
      if (entry.pattern && entry.pattern.includes("am") || entry.presetLabel && entry.presetLabel.includes("Times")) {
        debugLog("REGEX_ENTRY", `Processing ${entry.presetLabel || entry.pattern}, fastTest=${entry.fastTest ? "yes" : "no"}`);
      }
      let iterCount = 0;
      const _matches2 = this.safeMatchLoop(regex, text);
      if (entry.pattern && entry.pattern.includes("am") || entry.presetLabel && entry.presetLabel.includes("Times")) {
        debugLog("REGEX_FOUND", `${entry.presetLabel || entry.pattern}: found ${_matches2.length} matches`);
      }
      for (const match of _matches2) {
        iterCount++;
        const matchedText = match[0];
        const matchStart = from + match.index;
        const matchEnd = from + match.index + matchedText.length;
        if (this.isMatchInBlacklistedRange(matchStart, matchEnd, blacklistedListRanges)) {
          try {
            if (typeof regex.lastIndex === "number" && regex.lastIndex === match.index) regex.lastIndex++;
          } catch (e) {
          }
          continue;
        }
        const overlappingTextBgIndices = [];
        for (let i = 0; i < matches.length; i++) {
          const tbMatch = matches[i];
          if (!tbMatch || !tbMatch.isTextBg) continue;
          if (matchStart < tbMatch.end && matchEnd > tbMatch.start) {
            overlappingTextBgIndices.push(i);
          }
        }
        if (overlappingTextBgIndices.length > 0) {
          const mLength = matchEnd - matchStart;
          const isPresetPattern = entry.presetLabel && (entry.presetLabel.includes("Times") || entry.presetLabel.includes("username"));
          if (!isPresetPattern) {
            const allShorter = overlappingTextBgIndices.every((i) => matches[i].end - matches[i].start < mLength);
            if (entry.presetLabel && entry.presetLabel.includes("Times")) {
              debugLog("OVERLAP_CHECK", `Time match '${matchedText}' length=${mLength}, overlaps=${overlappingTextBgIndices.length}, allShorter=${allShorter}, isPreset=${isPresetPattern}`);
            }
            if (!allShorter) {
              try {
                if (typeof regex.lastIndex === "number" && regex.lastIndex === match.index) regex.lastIndex++;
              } catch (e) {
              }
              continue;
            }
          } else {
            if (entry.presetLabel && entry.presetLabel.includes("Times")) {
              debugLog("OVERLAP_CHECK", `Time match '${matchedText}' length=${mLength}, overlaps=${overlappingTextBgIndices.length}, isPreset=${isPresetPattern} - REMOVING overlaps`);
            }
          }
          for (let i = overlappingTextBgIndices.length - 1; i >= 0; i--) {
            matches.splice(overlappingTextBgIndices[i], 1);
          }
        }
        if (hasHeadingBlacklist && headingRanges && headingRanges.length > 0) {
          let inHeading = false;
          for (const hr of headingRanges) {
            if (matchStart < hr.end && matchEnd > hr.start) {
              inHeading = true;
              break;
            }
          }
          if (inHeading) continue;
        }
        {
          const mt2 = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
          if (!this.isSentenceLikePattern(entry.pattern) && mt2 === "exact" && !this.isWholeWordMatch(text, match.index, match.index + matchedText.length)) {
            continue;
          }
        }
        if (this.isContextBlacklisted(text, match.index, match.index + matchedText.length, filePath)) continue;
        const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
        let colorStart = match.index;
        let colorEnd = match.index + matchedText.length;
        if ((mt === "contains" || mt === "startswith" || mt === "endswith") && !this.isSentenceLikePattern(entry.pattern)) {
          while (colorStart > 0 && (/[A-Za-z0-9]/.test(text[colorStart - 1]) || text[colorStart - 1] === "-" || text[colorStart - 1] === "'")) colorStart--;
          while (colorEnd < text.length && (/[A-Za-z0-9]/.test(text[colorEnd]) || text[colorEnd] === "-" || text[colorEnd] === "'")) colorEnd++;
        }
        if ((mt === "contains" || mt === "startswith" || mt === "endswith") && !this.isSentenceLikePattern(entry.pattern)) {
          const fullWord = text.substring(colorStart, colorEnd);
          const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
          const patRaw = String(entry.pattern || "");
          const pat = cs ? patRaw : patRaw.toLowerCase();
          const word = cs ? fullWord : fullWord.toLowerCase();
          let ok = false;
          if (mt === "contains") {
            ok = word.includes(pat);
          } else if (mt === "startswith") {
            ok = word.startsWith(pat);
          } else if (mt === "endswith") {
            ok = word.endsWith(pat);
          }
          if (!ok) {
            try {
              if (typeof regex.lastIndex === "number" && regex.lastIndex === match.index) regex.lastIndex++;
            } catch (e) {
            }
            continue;
          }
        } else if (mt === "contains" || mt === "startswith" || mt === "endswith") {
          if (entry.isRegex) {
            matches.push({
              start: from + colorStart,
              end: from + colorEnd,
              color: entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color,
              styleType: entry.styleType,
              textColor: entry.textColor,
              backgroundColor: entry.backgroundColor,
              entryRef: entry
            });
            continue;
          }
          const fullWord = text.substring(colorStart, colorEnd);
          const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
          const patRaw = String(entry.pattern || "");
          const pat = cs ? patRaw : patRaw.toLowerCase();
          const word = cs ? fullWord : fullWord.toLowerCase();
          let ok = false;
          if (mt === "contains") {
            ok = word.includes(pat);
          } else if (mt === "startswith") {
            try {
              const flags = cs ? "" : "i";
              const esc = this.helpers.escapeRegex ? this.helpers.escapeRegex(patRaw) : patRaw.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              const re = new RegExp(`^${esc}[A-Za-z]*$`, flags);
              ok = re.test(fullWord);
            } catch (_) {
              ok = word.startsWith(pat);
            }
          } else if (mt === "endswith") {
            try {
              const flags = cs ? "" : "i";
              const esc = this.helpers.escapeRegex ? this.helpers.escapeRegex(patRaw) : patRaw.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              const re = new RegExp(`^[A-Za-z0-9'\\-]*${esc}$`, flags);
              ok = re.test(fullWord);
            } catch (_) {
              ok = word.endsWith(pat);
            }
          } else if (mt === "exact") {
            ok = word === pat;
          }
          if (!ok) {
            try {
              if (typeof regex.lastIndex === "number" && regex.lastIndex === match.index) regex.lastIndex++;
            } catch (e) {
            }
            continue;
          }
        }
        matches.push({
          start: from + colorStart,
          end: from + colorEnd,
          color: entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color,
          styleType: entry.styleType,
          textColor: entry.textColor,
          backgroundColor: entry.backgroundColor,
          entryRef: entry
        });
        if (matches.length > 3e3) break;
      }
      if (iterCount > 0) {
        try {
          entry.execs = (entry.execs || 0) + iterCount;
        } catch (e) {
        }
        try {
          this._perfCounters.totalRegexExecs = (this._perfCounters.totalRegexExecs || 0) + iterCount;
        } catch (e) {
        }
      }
      if (matches.length > 3e3) break;
    }
    const checkPartialMatch = (e) => {
      if (!e || e.invalid || !(!e.styleType || e.styleType === "text") || e.isTextBg) return false;
      if (e.matchType && String(e.matchType).toLowerCase() !== "contains" && String(e.matchType).toLowerCase() !== "exact") {
        return false;
      }
      try {
        if (this.isSentenceLikePattern(e.pattern)) return false;
        if (!this.isLatinWordPattern(e.pattern)) return false;
      } catch (_) {
      }
      const actualMatchType = String(e.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
      return actualMatchType === "contains";
    };
    debugLog("PARTIAL_MATCH_SECTION_ENTRY", `entries_copy.length=${entries_copy.length}, some matches partial=${entries_copy.some(checkPartialMatch)}, matches.length=${matches.length}`);
    if (entries_copy.some(checkPartialMatch) && matches.length < 3e3) {
      const textOnlyEntries = entries_copy.filter(checkPartialMatch);
      debugLog("PARTIAL_MATCH_RUNNING", `textOnlyEntries.length=${textOnlyEntries.length}, text="${text.substring(0, 100)}", partialMatch setting=${this.settings.partialMatch}`);
      textOnlyEntries.forEach((e, idx) => debugLog("PARTIAL_ENTRY_DETAIL", `[${idx}] pattern="${e.pattern}" matchType="${e.matchType}" styleType="${e.styleType}"`));
      if (textOnlyEntries.length > 0) {
        const wordRegex = /[A-Za-z0-9'\-]+/g;
        let match;
        let wordMatchCount = 0;
        while (match = wordRegex.exec(text)) {
          wordMatchCount++;
          const w = match[0];
          const wStart = match.index;
          const wEnd = wStart + w.length;
          if (this.isWordBlacklisted(w, filePath)) continue;
          const absWStart = from + wStart;
          const absWEnd = from + wEnd;
          if (this.isMatchInBlacklistedRange(absWStart, absWEnd, blacklistedListRanges)) continue;
          if (hasHeadingBlacklist && headingRanges && headingRanges.length > 0) {
            let inHeading = false;
            for (const hr of headingRanges) {
              if (absWStart < hr.end && absWEnd > hr.start) {
                inHeading = true;
                break;
              }
            }
            if (inHeading) continue;
          }
          for (const entry of textOnlyEntries) {
            if (!entry || entry.invalid) continue;
            if (/^[^a-zA-Z0-9]+$/.test(entry.pattern)) continue;
            if (this.isWordBlacklisted(entry.pattern, filePath)) continue;
            const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
            const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
            const word = cs ? w : w.toLowerCase();
            const pat = cs ? String(entry.pattern || "") : String(entry.pattern || "").toLowerCase();
            let ok = false;
            if (mt === "contains") {
              ok = word.includes(pat);
            }
            if (w === "should" || w === "colored") debugLog("PARTIAL_WORD_CHECK", `w="${w}" entry.pattern="${entry.pattern}" mt="${mt}" word="${word}" pat="${pat}" ok=${ok}`);
            if (ok) {
              let expandedWStart = wStart;
              let expandedWEnd = wEnd;
              if (!this.settings.extremeLightweightMode && !this.isSentenceLikePattern(entry.pattern)) {
                while (expandedWStart > 0 && (/[A-Za-z0-9]/.test(text[expandedWStart - 1]) || text[expandedWStart - 1] === "-" || text[expandedWStart - 1] === "'")) {
                  expandedWStart--;
                }
                while (expandedWEnd < text.length && (/[A-Za-z0-9]/.test(text[expandedWEnd]) || text[expandedWEnd] === "-" || text[expandedWEnd] === "'")) {
                  expandedWEnd++;
                }
              }
              debugLog("PARTIAL_EXPANSION", `pattern="${entry.pattern}" word="${w}" wStart=${wStart} wEnd=${wEnd} expanded=${expandedWStart}-${expandedWEnd} (${text.substring(expandedWStart, expandedWEnd)})`);
              let overlapsWithExisting = false;
              for (const existingMatch of matches) {
                const existStart = existingMatch.start - from;
                const existEnd = existingMatch.end - from;
                if (expandedWStart < existEnd && expandedWEnd > existStart) {
                  overlapsWithExisting = true;
                  break;
                }
              }
              if (!overlapsWithExisting) {
                const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
                debugLog("PARTIAL_MATCH_ADDED", `pattern="${entry.pattern}" word="${w}" final_range=${from + expandedWStart}-${from + expandedWEnd}`);
                matches.push({ start: from + expandedWStart, end: from + expandedWEnd, color: useColor, styleType: "text", entryRef: entry });
                if (matches.length > 3e3) break;
              } else {
                matches = matches.filter((m) => !(m.start >= from + expandedWStart && m.end <= from + expandedWEnd && m.end - m.start < expandedWEnd - expandedWStart));
                const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
                matches.push({ start: from + expandedWStart, end: from + expandedWEnd, color: useColor, styleType: "text", entryRef: entry });
                if (matches.length > 3e3) break;
              }
              break;
            }
          }
          if (matches.length > 3e3) break;
          try {
            if (typeof wordRegex.lastIndex === "number" && wordRegex.lastIndex === match.index) wordRegex.lastIndex++;
          } catch (e) {
          }
        }
      }
    }
    if (folderEntry && folderEntry.defaultColor) {
      matches = matches.map((m) => m.isTextBg ? m : Object.assign({}, m, { color: folderEntry.defaultColor }));
    }
    if (matches.some((m) => m.isTextBg)) {
      const fullTextBg = matches.filter((m) => m.isTextBg && m.textColor && m.textColor !== "currentColor");
      if (fullTextBg.length > 0) {
        matches = matches.filter((m) => {
          if (!(m.isTextBg && (!m.textColor || m.textColor === "currentColor"))) return true;
          return !fullTextBg.some((f) => m.start < f.end && m.end > f.start);
        });
      }
    }
    if (matches.length > 1) {
      const all = matches.slice().sort((a, b) => {
        if (a.start !== b.start) return a.start - b.start;
        const lenA = a.end - a.start;
        const lenB = b.end - b.start;
        if (lenA !== lenB) return lenB - lenA;
        const ar = a.entryRef && !!a.entryRef.isRegex;
        const br = b.entryRef && !!b.entryRef.isRegex;
        if (ar !== br) return ar ? 1 : -1;
        if (a.isTextBg && !b.isTextBg) return -1;
        if (!a.isTextBg && b.isTextBg) return 1;
        return 0;
      });
      const selected = [];
      for (const m of all) {
        let overlaps = false;
        const overlappingIndices = [];
        for (let i = 0; i < selected.length; i++) {
          const s = selected[i];
          if (m.start < s.end && m.end > s.start) {
            overlaps = true;
            overlappingIndices.push(i);
          }
        }
        if (!overlaps) {
          selected.push(m);
        } else {
          const mLength = m.end - m.start;
          const allShorter = overlappingIndices.every((i) => {
            const s = selected[i];
            return s.end - s.start < mLength;
          });
          if (allShorter) {
            for (let i = overlappingIndices.length - 1; i >= 0; i--) {
              selected.splice(overlappingIndices[i], 1);
            }
            selected.push(m);
          }
        }
      }
      matches = selected;
    }
    matches = matches.slice(0, 3e3);
    matches.sort((a, b) => {
      if (a.start !== b.start) return a.start - b.start;
      return a.end - b.end;
    });
    try {
      const viewportText = text.substring(0, 100);
      if (viewportText.includes(":")) {
        const timeMatches = matches.filter((m) => {
          const matchText = text.substring(m.start - from, m.end - from);
          return matchText && (matchText.includes("pm") || matchText.includes("am"));
        });
        if (timeMatches.length > 0) {
          debugLog("MATCHES_TIME", `Found ${timeMatches.length} time matches in ${matches.length} total matches`);
        }
      }
      if (viewportText.includes("@")) {
        const userMatches = matches.filter((m) => {
          const matchText = text.substring(m.start - from, m.end - from);
          return matchText && matchText.startsWith("@");
        });
        if (userMatches.length > 0) {
          debugLog("MATCHES_USER", `Found ${userMatches.length} username matches in ${matches.length} total matches`);
        }
      }
    } catch (_) {
    }
    const effectiveStyle = "text";
    if (effectiveStyle === "none" && matches.length > 0 && !matches.some((m) => m.isTextBg)) return builder.finish();
    let toApply = matches;
    if (matches.length > 1 && effectiveStyle !== "text") {
      const merged = [];
      for (const m of matches) {
        const last = merged[merged.length - 1];
        if (last && (m.isTextBg && last.isTextBg && m.textColor === last.textColor && m.backgroundColor === last.backgroundColor && m.start <= last.end || !m.isTextBg && !last.isTextBg && effectiveStyle === "background" && m.color === last.color && m.start <= last.end)) {
          if (m.end > last.end) last.end = m.end;
        } else {
          merged.push(Object.assign({}, m));
        }
      }
      toApply = merged;
    }
    for (const m of toApply) {
      if (tree) {
        try {
          const checkPos = Math.min(m.end - 1, Math.max(m.start, Math.floor((m.start + m.end) / 2)));
          const node = tree.resolve(checkPos, 1);
          let curr = node;
          let isInsideFormat = false;
          while (curr) {
            if (curr.name === "Strong" || curr.name === "Emphasis" || curr.name === "StrongEmphasis") {
              isInsideFormat = true;
              break;
            }
            curr = curr.parent;
          }
          if (isInsideFormat) {
            continue;
          }
        } catch (e) {
        }
      }
      let style;
      if (m.isTextBg) {
        const hideText = this.settings.hideTextColors === true;
        const hideBg = this.settings.hideHighlights === true;
        if (hideText && hideBg) continue;
        const params = this.getHighlightParams(m.entryRef);
        const borderStyle = this.generateBorderStyle(hideText ? null : m.textColor, hideBg ? null : m.backgroundColor, m.entryRef);
        const textPart = hideText ? "" : `color: ${m.textColor} !important; --highlight-color: ${m.textColor}; `;
        const vPad = params.vPad;
        const vPadCss = vPad >= 0 ? `padding-top: ${vPad}px !important; padding-bottom: ${vPad}px !important;` : `padding-top: 0px !important; padding-bottom: 0px !important; margin-top: ${vPad}px !important; margin-bottom: ${vPad}px !important;`;
        const bgPart = hideBg ? "" : `background-color: ${this.hexToRgba(m.backgroundColor, params.opacity)} !important; border-radius: ${params.radius}px !important; padding-left: ${params.hPad}px !important; padding-right: ${params.hPad}px !important; ${vPadCss}${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}`;
        style = `${textPart}${bgPart}${borderStyle}`;
      } else {
        let styleType2 = m.entryRef && m.entryRef.affectMarkElements ? "highlight" : m.styleType || "text";
        if (styleType2 === "text") {
          if (this.settings.hideTextColors) continue;
          style = `color: ${m.color} !important; --highlight-color: ${m.color};`;
        } else if (styleType2 === "highlight") {
          if (this.settings.hideHighlights) continue;
          const bgColor = m.backgroundColor || m.color;
          const params = this.getHighlightParams(m.entryRef);
          const borderStyle = this.generateBorderStyle(null, bgColor, m.entryRef);
          const vPadH = params.vPad;
          const vPadCssH = vPadH >= 0 ? `padding-top: ${vPadH}px !important; padding-bottom: ${vPadH}px !important;` : `padding-top: 0px !important; padding-bottom: 0px !important; margin-top: ${vPadH}px !important; margin-bottom: ${vPadH}px !important;`;
          style = `background: none; background-color: ${this.hexToRgba(bgColor, params.opacity)} !important; border-radius: ${params.hPad > 0 && params.radius === 0 ? 0 : params.radius}px !important; padding-left: ${params.hPad}px !important; padding-right: ${params.hPad}px !important; ${vPadCssH}${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}${borderStyle}`;
        } else if (styleType2 === "both") {
          const textColor = m.textColor && m.textColor !== "currentColor" ? m.textColor : m.color || null;
          const bgColor = m.backgroundColor || m.color;
          const hideText = this.settings.hideTextColors === true;
          const hideBg = this.settings.hideHighlights === true;
          if (hideText && hideBg) continue;
          const params = this.getHighlightParams(m.entryRef);
          const borderStyle = this.generateBorderStyle(hideText ? null : textColor, hideBg ? null : bgColor, m.entryRef);
          const textPart = hideText ? "" : textColor ? `color: ${textColor} !important; --highlight-color: ${textColor}; ` : "";
          const vPadB = params.vPad;
          const vPadCssB = vPadB >= 0 ? `padding-top: ${vPadB}px !important; padding-bottom: ${vPadB}px !important;` : `padding-top: 0px !important; padding-bottom: 0px !important; margin-top: ${vPadB}px !important; margin-bottom: ${vPadB}px !important;`;
          const bgPart = hideBg ? "" : `background-color: ${this.hexToRgba(bgColor, params.opacity)} !important; border-radius: ${params.radius}px !important; padding-left: ${params.hPad}px !important; padding-right: ${params.hPad}px !important; ${vPadCssB}${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}`;
          style = `${textPart}${bgPart}${borderStyle}`;
        } else {
          if (this.settings.hideTextColors) continue;
          style = `color: ${m.color} !important; --highlight-color: ${m.color};`;
        }
      }
      const isDark = (m.color || m.textColor || m.backgroundColor) && this.isDarkColor(m.color || m.textColor || m.backgroundColor);
      const baseClass = m.entryRef && m.entryRef.affectMarkElements ? "always-color-text-highlight always-color-text-highlight-marks" : "always-color-text-highlight";
      const deco = Decoration.mark({
        attributes: {
          style,
          class: isDark ? `${baseClass} act-dark-color` : baseClass,
          title: this.settings.showColoringReasonOnHover && m.entry ? this.getColoringReasonTooltip(m) : ""
        }
      });
      builder.add(m.start, m.end, deco);
      try {
        if (m.start >= 0 && m.end > m.start) {
          const matchText = "";
          if (matchText.includes("@") || matchText.includes(":")) {
            debugLog("DECO_APPLY", `Applied deco at ${m.start}-${m.end}, style=${styleType}`);
          }
        }
      } catch (_) {
      }
    }
    return builder.finish();
  }
  // NEW METHOD: Chunked editor processing for large pattern sets or large text
  buildDecoChunked(view, builder, from, to, text, entries, folderEntry, filePath = null, syntaxTreeFn = null) {
    const startTime = performance.now();
    const TIME_BUDGET_MS = 12;
    const tree2 = syntaxTreeFn && view && view.state ? syntaxTreeFn(view.state) : null;
    const CHUNK_SIZE = EDITOR_PERFORMANCE_CONSTANTS.PATTERN_CHUNK_SIZE;
    const TEXT_CHUNK_SIZE = EDITOR_PERFORMANCE_CONSTANTS.TEXT_CHUNK_SIZE;
    const MAX_MATCHES = this.settings.extremeLightweightMode ? EDITOR_PERFORMANCE_CONSTANTS.LIGHTWEIGHT_MAX_TOTAL_MATCHES : EDITOR_PERFORMANCE_CONSTANTS.MAX_TOTAL_MATCHES;
    let allMatches = [];
    try {
      const we = entries;
      const blEntries = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
      const codeblockEntry = we.find((e) => e && e.presetLabel === "Codeblocks");
      const hasCodeblockBlacklist = !!blEntries.find((e) => e && e.presetLabel === "Codeblocks" && !!e.isRegex);
      if (hasCodeblockBlacklist) {
        for (const cbMatch of text.matchAll(/```[\s\S]*?```/g)) {
          const start = from + cbMatch.index;
          const end = from + cbMatch.index + cbMatch[0].length;
          allMatches.push({ start, end, skip: true });
        }
      }
      try {
        for (const spoilerMatch of text.matchAll(/\|\|[\s\S]*?\|\|/g)) {
          const start = from + spoilerMatch.index;
          const end = from + spoilerMatch.index + spoilerMatch[0].length;
          allMatches.push({ start, end, skip: true });
        }
      } catch (e) {
      }
      if (codeblockEntry && !hasCodeblockBlacklist) {
        for (const cbMatch of text.matchAll(/```[\s\S]*?```/g)) {
          const start = from + cbMatch.index;
          const end = from + cbMatch.index + cbMatch[0].length;
          if (codeblockEntry.backgroundColor) {
            const tc = codeblockEntry.textColor || "currentColor";
            const bc = codeblockEntry.backgroundColor;
            allMatches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true, entryRef: codeblockEntry });
          } else {
            const c = codeblockEntry.color || codeblockEntry.textColor;
            if (c) allMatches.push({ start, end, color: c, entryRef: codeblockEntry });
          }
        }
      }
    } catch (e) {
    }
    let headingRanges = [];
    let hasHeadingBlacklist = false;
    try {
      headingRanges = [];
      let posScan = 0;
      while (posScan <= text.length) {
        const lineStartScan = posScan;
        const nextNLScan = text.indexOf("\n", posScan);
        const lineEndScan = nextNLScan === -1 ? text.length : nextNLScan;
        let iScan = lineStartScan;
        while (iScan < lineEndScan && /\s/.test(text[iScan])) iScan++;
        let hScan = 0;
        while (iScan < lineEndScan && text[iScan] === "#" && hScan < 6) {
          hScan++;
          iScan++;
        }
        if (hScan > 0 && iScan < lineEndScan && text[iScan] === " ") {
          headingRanges.push({ start: from + lineStartScan, end: from + lineEndScan });
        }
        if (nextNLScan === -1) break;
        posScan = nextNLScan + 1;
      }
      const we = entries;
      let pos = 0;
      while (pos <= text.length) {
        const lineStart = pos;
        const nextNL = text.indexOf("\n", pos);
        const lineEnd = nextNL === -1 ? text.length : nextNL;
        let i = lineStart;
        while (i < lineEnd && /\s/.test(text[i])) i++;
        let hashes = 0;
        while (i < lineEnd && text[i] === "#" && hashes < 6) {
          hashes++;
          i++;
        }
        if (hashes > 0 && i < lineEnd && text[i] === " ") {
          const start = from + lineStart;
          const end = from + lineEnd;
          const entryToUse = hashes > 0 ? getEntryForHeadingLevel(we, hashes) : null;
          if (entryToUse) {
            if (entryToUse.backgroundColor) {
              const tc = entryToUse.textColor || "currentColor";
              const bc = entryToUse.backgroundColor;
              allMatches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true, entryRef: entryToUse });
            } else {
              const c = entryToUse.color || entryToUse.textColor;
              if (c) allMatches.push({ start, end, color: c, entryRef: entryToUse });
            }
          }
        }
        if (nextNL === -1) break;
        pos = nextNL + 1;
      }
    } catch (e) {
    }
    try {
      const we = entries;
      const blEntries = Array.isArray(this.settings.blacklistEntries) ? this.settings.blacklistEntries : [];
      const taskCheckedEntry = we.find((e) => e && e.presetLabel === "Task List (Checked)");
      const taskUncheckedEntry = we.find((e) => e && e.presetLabel === "Task List (Unchecked)");
      const numberedEntry = we.find((e) => e && e.presetLabel === "Numbered Lists");
      const bulletEntry = we.find((e) => e && e.presetLabel === "Bullet Points");
      const taskCheckedBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Task List (Checked)" && !!e.isRegex);
      const taskUncheckedBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Task List (Unchecked)" && !!e.isRegex);
      const numberedBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Numbered Lists" && !!e.isRegex);
      const bulletBlacklisted = !!blEntries.find((e) => e && e.presetLabel === "Bullet Points" && !!e.isRegex);
      const taskCheckedAllowed = !filePath || this.shouldColorText(filePath, taskCheckedEntry ? taskCheckedEntry.pattern : null);
      const taskUncheckedAllowed = !filePath || this.shouldColorText(filePath, taskUncheckedEntry ? taskUncheckedEntry.pattern : null);
      const numberedAllowed = !filePath || this.shouldColorText(filePath, numberedEntry ? numberedEntry.pattern : null);
      const bulletAllowed = !filePath || this.shouldColorText(filePath, bulletEntry ? bulletEntry.pattern : null);
      let pos = 0;
      while (pos <= text.length) {
        const lineStart = pos;
        const nextNL = text.indexOf("\n", pos);
        const lineEnd = nextNL === -1 ? text.length : nextNL;
        const line = text.substring(lineStart, lineEnd);
        let matched = false;
        if (!matched && !taskCheckedBlacklisted && taskCheckedEntry && taskCheckedAllowed) {
          const pattern = /^(\s*)([\-\*])(\s+)(\[[xX]\])(\s+)(.*)$/;
          const mdMatch = pattern.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length + mdMatch[4].length + mdMatch[5].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[6] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (taskCheckedEntry.backgroundColor) {
                const tc = taskCheckedEntry.textColor || "currentColor";
                const bc = taskCheckedEntry.backgroundColor;
                allMatches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true, entryRef: taskCheckedEntry });
              } else {
                const c = taskCheckedEntry.color || taskCheckedEntry.textColor;
                if (c) allMatches.push({ start, end, color: c, entryRef: taskCheckedEntry });
              }
              matched = true;
            }
          }
        }
        if (!matched && !taskUncheckedBlacklisted && taskUncheckedEntry) {
          const pattern = /^(\s*)([\-\*])(\s+)(\[\s\])(\s+)(.*)$/;
          const mdMatch = pattern.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length + mdMatch[4].length + mdMatch[5].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[6] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (taskUncheckedEntry.backgroundColor) {
                const tc = taskUncheckedEntry.textColor || "currentColor";
                const bc = taskUncheckedEntry.backgroundColor;
                allMatches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true, entryRef: taskUncheckedEntry });
              } else {
                const c = taskUncheckedEntry.color || taskUncheckedEntry.textColor;
                if (c) allMatches.push({ start, end, color: c, entryRef: taskUncheckedEntry });
              }
              matched = true;
            }
          }
        }
        if (!matched && !numberedBlacklisted && numberedEntry && numberedAllowed) {
          const pattern = /^(\s*)(\d+\.)(\s+)(.*)$/;
          const mdMatch = pattern.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[4] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (numberedEntry.backgroundColor) {
                const tc = numberedEntry.textColor || "currentColor";
                const bc = numberedEntry.backgroundColor;
                allMatches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true, entryRef: numberedEntry });
              } else {
                const c = numberedEntry.color || numberedEntry.textColor;
                if (c) allMatches.push({ start, end, color: c, entryRef: numberedEntry });
              }
              matched = true;
            }
          }
        }
        if (!matched && !bulletBlacklisted && bulletEntry && bulletAllowed) {
          const pattern = /^(\s*)([\-\*])(\s+)(.*)$/;
          const mdMatch = pattern.exec(line);
          if (mdMatch) {
            const contentStart = lineStart + mdMatch.index + (mdMatch[1].length + mdMatch[2].length + mdMatch[3].length);
            const contentEnd = lineEnd;
            const contentText = mdMatch[4] || "";
            const lineBlacklisted = this.isLineBlacklistedByRegex(line, filePath);
            if (contentStart < contentEnd && !this.containsBlacklistedWord(contentText, filePath) && !lineBlacklisted) {
              const start = from + contentStart;
              const end = from + contentEnd;
              if (bulletEntry.backgroundColor) {
                const tc = bulletEntry.textColor || "currentColor";
                const bc = bulletEntry.backgroundColor;
                allMatches.push({ start, end, textColor: tc, backgroundColor: bc, isTextBg: true, entryRef: bulletEntry });
              } else {
                const c = bulletEntry.color || bulletEntry.textColor;
                if (c) allMatches.push({ start, end, color: c, entryRef: bulletEntry });
              }
              matched = true;
            }
          }
        }
        if (nextNL === -1) break;
        pos = nextNL + 1;
      }
    } catch (e) {
    }
    const blacklistedListRanges = this.getBlacklistedListItemRanges(text, from, filePath);
    let textBgEntries = Array.isArray(this._compiledTextBgEntries) ? this._compiledTextBgEntries : [];
    if (filePath) {
      textBgEntries = textBgEntries.filter((entry) => {
        if (!entry || !entry.pattern) return true;
        return this.shouldColorText(filePath, entry.pattern, entry);
      });
    }
    if (textBgEntries.length > 0) {
      for (const entry of textBgEntries) {
        if (!entry || entry.invalid) continue;
        if (entry.fastTest && !entry.fastTest(text)) continue;
        const regex = entry.regex;
        if (!regex) continue;
        let match;
        try {
          regex.lastIndex = 0;
        } catch (e) {
        }
        while (match = regex.exec(text)) {
          const matchStart = match.index;
          const matchEnd = match.index + match[0].length;
          if (!this.matchSatisfiesType(text, matchStart, matchEnd, entry)) {
            try {
              if (typeof regex.lastIndex === "number" && regex.lastIndex === match.index) regex.lastIndex++;
            } catch (e) {
            }
            continue;
          }
          if (this.isContextBlacklisted(text, matchStart, matchEnd, filePath)) continue;
          const absStart = from + matchStart;
          const absEnd = from + matchEnd;
          if (this.isMatchInBlacklistedRange(absStart, absEnd, blacklistedListRanges)) {
            try {
              if (typeof regex.lastIndex === "number" && regex.lastIndex === match.index) regex.lastIndex++;
            } catch (e) {
            }
            continue;
          }
          if (hasHeadingBlacklist && headingRanges && headingRanges.length > 0) {
            let inHeading = false;
            for (const hr of headingRanges) {
              if (absStart < hr.end && absEnd > hr.start) {
                inHeading = true;
                break;
              }
            }
            if (inHeading) continue;
          }
          let colorStart = matchStart;
          let colorEnd = matchEnd;
          {
            const mt = String(entry.matchType || "").toLowerCase();
            if ((mt === "contains" || mt === "startswith" || mt === "endswith") && !this.isSentenceLikePattern(entry.pattern)) {
              colorStart = matchStart;
              colorEnd = matchEnd;
              while (colorStart > 0 && (/[A-Za-z0-9]/.test(text[colorStart - 1]) || text[colorStart - 1] === "-" || text[colorStart - 1] === "'")) {
                colorStart--;
              }
              while (colorEnd < text.length && (/[A-Za-z0-9]/.test(text[colorEnd]) || text[colorEnd] === "-" || text[colorEnd] === "'")) {
                colorEnd++;
              }
            }
          }
          allMatches.push({
            start: from + colorStart,
            end: from + colorEnd,
            textColor: entry.textColor,
            backgroundColor: entry.backgroundColor,
            isTextBg: true,
            entryRef: entry
          });
          if (allMatches.length > MAX_MATCHES) break;
        }
        if (allMatches.length > MAX_MATCHES) break;
      }
    }
    const regexEntries = entries.filter((e) => {
      if (e.targetElement) return false;
      if (e.presetLabel) {
        const label = String(e.presetLabel).toLowerCase();
        if (label.includes("bold") || label.includes("italic")) return false;
      }
      if (e.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1") return false;
      if (e.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1") return false;
      if (e.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1") return false;
      return true;
    });
    if (regexEntries.length > CHUNK_SIZE) {
      debugLog("PATTERN_PROCESSING", `Starting pattern processing for ${regexEntries.length} patterns`);
      for (let i = 0; i < regexEntries.length; i += CHUNK_SIZE) {
        const chunk = regexEntries.slice(i, i + CHUNK_SIZE);
        const chunkMatches = this.processPatternChunk(text, from, chunk, folderEntry, allMatches, hasHeadingBlacklist ? headingRanges : [], blacklistedListRanges, filePath);
        allMatches = allMatches.concat(chunkMatches);
        if (allMatches.length > MAX_MATCHES) {
          break;
        }
      }
    } else if (text.length > TEXT_CHUNK_SIZE) {
      debugLog("EDITOR", `Processing long text (${text.length} chars) in chunks (chunk size: ${TEXT_CHUNK_SIZE})`);
      let chunkNum = 0;
      const totalChunks = Math.ceil(text.length / TEXT_CHUNK_SIZE);
      for (let pos = 0; pos < text.length; pos += TEXT_CHUNK_SIZE) {
        chunkNum++;
        const chunkEnd = Math.min(pos + TEXT_CHUNK_SIZE, text.length);
        const chunkText = text.slice(pos, chunkEnd);
        const chunkFrom = from + pos;
        const chunkMatches = this.processTextChunk(chunkText, chunkFrom, regexEntries, folderEntry, allMatches, hasHeadingBlacklist ? headingRanges : [], blacklistedListRanges, filePath);
        allMatches = allMatches.concat(chunkMatches);
        if (allMatches.length > MAX_MATCHES) {
          break;
        }
      }
    } else {
      const chunkMatches = this.processPatternChunk(text, from, regexEntries, folderEntry, allMatches, hasHeadingBlacklist ? headingRanges : [], blacklistedListRanges, filePath);
      allMatches = allMatches.concat(chunkMatches);
    }
    return this.applyDecorationsFromMatches(builder, allMatches, folderEntry, tree2);
  }
  // NEW METHOD: Process a chunk of patterns
  processPatternChunk(text, baseFrom, patternChunk, folderEntry, existingMatches = [], headingRanges = [], blacklistedListRanges = [], filePath = null) {
    const MAX_MATCHES_PER_PATTERN = this.settings.extremeLightweightMode ? EDITOR_PERFORMANCE_CONSTANTS.MAX_MATCHES_PER_PATTERN : EDITOR_PERFORMANCE_CONSTANTS.MAX_MATCHES_PER_PATTERN;
    const matches = [];
    for (const entry of patternChunk) {
      if (!entry || entry.invalid) continue;
      const isPartialEntry = !entry.isRegex && !entry.isTextBg && (!entry.styleType || entry.styleType === "text") && ["contains", "startswith", "endswith"].includes(String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase()) && !this.isSentenceLikePattern(entry.pattern);
      if (isPartialEntry) continue;
      if (entry.fastTest && !entry.fastTest(text)) continue;
      const regex = entry.regex;
      if (!regex) continue;
      let match;
      let matchCount = 0;
      try {
        regex.lastIndex = 0;
      } catch (e) {
      }
      while ((match = regex.exec(text)) && matchCount < MAX_MATCHES_PER_PATTERN) {
        const matchedText = match[0];
        const matchStart = baseFrom + match.index;
        const matchEnd = baseFrom + match.index + matchedText.length;
        if (this.isMatchInBlacklistedRange(matchStart, matchEnd, blacklistedListRanges)) {
          continue;
        }
        const overlappingTextBgIndices = [];
        for (let i = 0; i < existingMatches.length; i++) {
          const existing = existingMatches[i];
          if (!existing || !existing.isTextBg) continue;
          if (matchStart < existing.end && matchEnd > existing.start) {
            overlappingTextBgIndices.push(i);
          }
        }
        if (overlappingTextBgIndices.length > 0) {
          const mLength = matchEnd - matchStart;
          const allShorter = overlappingTextBgIndices.every((i) => existingMatches[i].end - existingMatches[i].start < mLength);
          if (!allShorter) {
            continue;
          }
          for (let i = overlappingTextBgIndices.length - 1; i >= 0; i--) {
            existingMatches.splice(overlappingTextBgIndices[i], 1);
          }
        }
        if (headingRanges && headingRanges.length > 0) {
          let inHeading = false;
          for (const hr of headingRanges) {
            if (matchEnd <= hr.start) continue;
            if (matchStart >= hr.end) continue;
            if (matchStart < hr.end && matchEnd > hr.start) {
              inHeading = true;
              break;
            }
          }
          if (inHeading) continue;
        }
        {
          const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
          if (mt === "exact" && !this.isWholeWordMatch(text, match.index, match.index + matchedText.length)) {
            continue;
          }
        }
        if (this.isContextBlacklisted(text, match.index, match.index + matchedText.length, filePath)) continue;
        matches.push({
          start: matchStart,
          end: matchEnd,
          color: folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color,
          styleType: entry.styleType,
          textColor: entry.textColor,
          backgroundColor: entry.backgroundColor,
          entryRef: entry
        });
        matchCount++;
        if (matches.length > 2e3) break;
      }
      if (matches.length > 2e3) break;
    }
    const partialEntries = patternChunk.filter((e) => e && !e.invalid && !e.isRegex && (!e.styleType || e.styleType === "text") && !e.isTextBg && ["contains", "startswith", "endswith"].includes(String(e.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase()) && !this.isSentenceLikePattern(e.pattern));
    const wordPartialEntries = partialEntries.filter((e) => this.isLatinWordPattern(e.pattern));
    const phrasePartialEntries = partialEntries.filter((e) => !this.isLatinWordPattern(e.pattern));
    if (partialEntries.length > 0 && matches.length < 2e3) {
      for (const entry of wordPartialEntries) {
        const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
        if (mt === "startswith" || mt === "endswith") {
          const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
          if (mt === "startswith" && (!entry._startswithRegex || entry._lastCs !== cs) || mt === "endswith" && (!entry._endswithRegex || entry._lastCs !== cs)) {
            const pat = cs ? String(entry.pattern || "") : String(entry.pattern || "").toLowerCase();
            const flags = cs ? "" : "i";
            const esc = this.escapeRegex(pat);
            try {
              if (mt === "startswith") entry._startswithRegex = new RegExp(`^${esc}[A-Za-z0-9'\\-]*$`, flags);
              else entry._endswithRegex = new RegExp(`^[A-Za-z0-9'\\-]*${esc}$`, flags);
              entry._lastCs = cs;
            } catch (_) {
            }
          }
        }
      }
      const wordRegex = /[A-Za-z0-9'\-]+/g;
      let match;
      while (match = wordRegex.exec(text)) {
        const w = match[0];
        const wStart = match.index;
        const wEnd = wStart + w.length;
        if (this.isMatchInBlacklistedRange(baseFrom + wStart, baseFrom + wEnd, blacklistedListRanges)) continue;
        for (const entry of wordPartialEntries) {
          if (/^[^a-zA-Z0-9]+$/.test(entry.pattern)) continue;
          if (this.isWordBlacklisted(entry.pattern, filePath)) continue;
          const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
          const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
          const word = cs ? w : w.toLowerCase();
          const pat = cs ? String(entry.pattern || "") : String(entry.pattern || "").toLowerCase();
          let ok = false;
          if (mt === "contains") {
            ok = word.includes(pat);
          } else if (mt === "startswith") {
            if (entry._startswithRegex) ok = entry._startswithRegex.test(word);
            else ok = word.startsWith(pat);
          } else if (mt === "endswith") {
            if (entry._endswithRegex) ok = entry._endswithRegex.test(word);
            else ok = word.endsWith(pat);
          }
          if (ok) {
            let expandedWStart = wStart;
            let expandedWEnd = wEnd;
            if (!this.isSentenceLikePattern(entry.pattern)) {
              while (expandedWStart > 0 && (/[A-Za-z0-9]/.test(text[expandedWStart - 1]) || text[expandedWStart - 1] === "-" || text[expandedWStart - 1] === "'")) {
                expandedWStart--;
              }
              while (expandedWEnd < text.length && (/[A-Za-z0-9]/.test(text[expandedWEnd]) || text[expandedWEnd] === "-" || text[expandedWEnd] === "'")) {
                expandedWEnd++;
              }
            }
            let overlapsWithExisting = false;
            for (const existingMatch of matches) {
              if (baseFrom + expandedWStart < existingMatch.end && baseFrom + expandedWEnd > existingMatch.start) {
                overlapsWithExisting = true;
                break;
              }
            }
            for (const textBgMatch of existingMatches) {
              if (textBgMatch.isTextBg && baseFrom + expandedWStart < textBgMatch.end && baseFrom + expandedWEnd > textBgMatch.start) {
                overlapsWithExisting = true;
                break;
              }
            }
            if (!overlapsWithExisting) {
              matches.push({
                start: baseFrom + expandedWStart,
                end: baseFrom + expandedWEnd,
                color: folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color,
                styleType: entry.styleType,
                textColor: entry.textColor,
                backgroundColor: entry.backgroundColor,
                entryRef: entry
              });
              if (matches.length > 2e3) break;
            }
            break;
          }
        }
        if (matches.length > 2e3) break;
        try {
          if (typeof wordRegex.lastIndex === "number" && wordRegex.lastIndex === match.index) wordRegex.lastIndex++;
        } catch (e) {
        }
      }
      if (phrasePartialEntries.length > 0 && matches.length < 2e3) {
        let textLower = null;
        const getTextForCase = (cs) => {
          if (cs) return text;
          if (!textLower) textLower = text.toLowerCase();
          return textLower;
        };
        for (const entry of phrasePartialEntries) {
          if (/^[^a-zA-Z0-9]+$/.test(entry.pattern)) continue;
          if (this.isWordBlacklisted(entry.pattern, filePath)) continue;
          const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
          const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
          const textForSearch = getTextForCase(cs);
          const rawPattern = String(entry.pattern || "");
          const pat = cs ? rawPattern : rawPattern.toLowerCase();
          if (!pat) continue;
          let fromIndex = 0;
          let localMatchCount = 0;
          while (matches.length < 2e3 && localMatchCount < MAX_MATCHES_PER_PATTERN) {
            const idx = textForSearch.indexOf(pat, fromIndex);
            if (idx === -1) break;
            const mStart = idx;
            const mEnd = idx + pat.length;
            let ok = false;
            if (mt === "contains") {
              ok = true;
            } else if (mt === "startswith") {
              const leftChar = mStart > 0 ? text[mStart - 1] : "";
              const isWordChar = (ch) => /[A-Za-z0-9]/.test(ch) || ch === "-" || ch === "'";
              ok = mStart === 0 || !isWordChar(leftChar);
            } else if (mt === "endswith") {
              const rightChar = mEnd < text.length ? text[mEnd] : "";
              const isWordChar = (ch) => /[A-Za-z0-9]/.test(ch) || ch === "-" || ch === "'";
              ok = mEnd === text.length || !isWordChar(rightChar);
            }
            if (ok) {
              const absStart = baseFrom + mStart;
              const absEnd = baseFrom + mEnd;
              if (this.isMatchInBlacklistedRange(absStart, absEnd, blacklistedListRanges)) {
                fromIndex = mStart + 1;
                continue;
              }
              let expandedStart = mStart;
              let expandedEnd = mEnd;
              while (expandedStart > 0 && (/[A-Za-z0-9]/.test(text[expandedStart - 1]) || text[expandedStart - 1] === "-" || text[expandedStart - 1] === "'")) {
                expandedStart--;
              }
              while (expandedEnd < text.length && (/[A-Za-z0-9]/.test(text[expandedEnd]) || text[expandedEnd] === "-" || text[expandedEnd] === "'")) {
                expandedEnd++;
              }
              let overlapsWithExisting = false;
              for (const existingMatch of matches) {
                if (baseFrom + expandedStart < existingMatch.end && baseFrom + expandedEnd > existingMatch.start) {
                  overlapsWithExisting = true;
                  break;
                }
              }
              for (const textBgMatch of existingMatches) {
                if (textBgMatch.isTextBg && baseFrom + expandedStart < textBgMatch.end && baseFrom + expandedEnd > textBgMatch.start) {
                  overlapsWithExisting = true;
                  break;
                }
              }
              if (!overlapsWithExisting) {
                matches.push({
                  start: baseFrom + expandedStart,
                  end: baseFrom + expandedEnd,
                  color: folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color,
                  styleType: entry.styleType,
                  textColor: entry.textColor,
                  backgroundColor: entry.backgroundColor,
                  entryRef: entry
                });
                if (matches.length > 2e3) break;
              }
              localMatchCount++;
            }
            fromIndex = mStart + 1;
          }
          if (matches.length > 2e3) break;
        }
      }
    }
    return matches;
  }
  // NEW METHOD: Process a chunk of text
  processTextChunk(chunkText, chunkFrom, entries, folderEntry, existingMatches = [], headingRanges = [], blacklistedListRanges = [], filePath = null) {
    const matches = [];
    const MAX_MATCHES_PER_PATTERN = this.settings.extremeLightweightMode ? EDITOR_PERFORMANCE_CONSTANTS.MAX_MATCHES_PER_PATTERN : EDITOR_PERFORMANCE_CONSTANTS.MAX_MATCHES_PER_PATTERN;
    for (const entry of entries) {
      if (!entry || entry.invalid) continue;
      const isTextOnly = !entry.isTextBg && (!entry.styleType || entry.styleType === "text");
      const actualMatchType = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
      const isPartialMatch = ["contains", "startswith", "endswith"].includes(actualMatchType);
      if (!entry.isRegex && isTextOnly && isPartialMatch && this.isLatinWordPattern(entry.pattern)) continue;
      if (entry.fastTest && !entry.fastTest(chunkText)) continue;
      const regex = entry.regex;
      if (!regex) continue;
      let match;
      let matchCount = 0;
      try {
        regex.lastIndex = 0;
      } catch (e) {
      }
      while ((match = regex.exec(chunkText)) && matchCount < MAX_MATCHES_PER_PATTERN) {
        const matchedText = match[0];
        const matchStart = chunkFrom + match.index;
        const matchEnd = chunkFrom + match.index + matchedText.length;
        if (this.isMatchInBlacklistedRange(matchStart, matchEnd, blacklistedListRanges)) {
          continue;
        }
        const overlappingTextBgIndices2 = [];
        for (let i = 0; i < existingMatches.length; i++) {
          const existing = existingMatches[i];
          if (!existing || !existing.isTextBg) continue;
          if (matchStart < existing.end && matchEnd > existing.start) {
            overlappingTextBgIndices2.push(i);
          }
        }
        if (overlappingTextBgIndices2.length > 0) {
          const mLength2 = matchEnd - matchStart;
          const allShorter2 = overlappingTextBgIndices2.every((i) => existingMatches[i].end - existingMatches[i].start < mLength2);
          if (!allShorter2) {
            continue;
          }
          for (let i = overlappingTextBgIndices2.length - 1; i >= 0; i--) {
            existingMatches.splice(overlappingTextBgIndices2[i], 1);
          }
        }
        if (headingRanges && headingRanges.length > 0) {
          let inHeading = false;
          for (const hr of headingRanges) {
            if (matchStart < hr.end && matchEnd > hr.start) {
              inHeading = true;
              break;
            }
          }
          if (inHeading) continue;
        }
        {
          const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
          if (!this.isSentenceLikePattern(entry.pattern) && mt === "exact" && !this.isWholeWordMatch(chunkText, match.index, match.index + matchedText.length)) {
            continue;
          }
        }
        if (this.isContextBlacklisted(chunkText, match.index, match.index + matchedText.length, filePath)) continue;
        matches.push({
          start: matchStart,
          end: matchEnd,
          color: folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color,
          styleType: entry.styleType,
          textColor: entry.textColor,
          backgroundColor: entry.backgroundColor,
          entryRef: entry
        });
        matchCount++;
        if (matches.length > 2e3) break;
      }
      if (matches.length > 2e3) break;
    }
    if (matches.length < 2e3) {
      const textOnlyEntries = entries.filter((e) => e && !e.invalid && !e.isRegex && (!e.styleType || e.styleType === "text") && !e.isTextBg && ["contains", "startswith", "endswith"].includes(String(e.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase()) && !this.isSentenceLikePattern(e.pattern) && this.isLatinWordPattern(e.pattern));
      if (textOnlyEntries.length > 0) {
        for (const entry of textOnlyEntries) {
          const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
          if (mt === "startswith" || mt === "endswith") {
            const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
            if (mt === "startswith" && (!entry._startswithRegex || entry._lastCs !== cs) || mt === "endswith" && (!entry._endswithRegex || entry._lastCs !== cs)) {
              const pat = cs ? String(entry.pattern || "") : String(entry.pattern || "").toLowerCase();
              const flags = cs ? "" : "i";
              const esc = this.escapeRegex(pat);
              try {
                if (mt === "startswith") entry._startswithRegex = new RegExp(`^${esc}[A-Za-z0-9'\\-]*$`, flags);
                else entry._endswithRegex = new RegExp(`^[A-Za-z0-9'\\-]*${esc}$`, flags);
                entry._lastCs = cs;
              } catch (_) {
              }
            }
          }
        }
        const wordRegex = /[A-Za-z0-9'\-]+/g;
        let match;
        while (match = wordRegex.exec(chunkText)) {
          const w = match[0];
          const wStart = match.index;
          const wEnd = wStart + w.length;
          if (this.isWordBlacklisted(w, filePath)) continue;
          if (this.isMatchInBlacklistedRange(chunkFrom + wStart, chunkFrom + wEnd, blacklistedListRanges)) continue;
          for (const entry of textOnlyEntries) {
            if (!entry || entry.invalid) continue;
            if (/^[^a-zA-Z0-9]+$/.test(entry.pattern)) continue;
            if (this.isWordBlacklisted(entry.pattern, filePath)) continue;
            const mt = String(entry.matchType || (this.settings.partialMatch ? "contains" : "exact")).toLowerCase();
            const cs = typeof entry._caseSensitiveOverride === "boolean" ? entry._caseSensitiveOverride : typeof entry.caseSensitive === "boolean" ? entry.caseSensitive : this.settings.caseSensitive;
            const word = cs ? w : w.toLowerCase();
            const pat = cs ? String(entry.pattern || "") : String(entry.pattern || "").toLowerCase();
            let ok = false;
            if (mt === "contains") {
              ok = word.includes(pat);
            } else if (mt === "startswith") {
              if (entry._startswithRegex) ok = entry._startswithRegex.test(word);
              else ok = word.startsWith(pat);
            } else if (mt === "endswith") {
              if (entry._endswithRegex) ok = entry._endswithRegex.test(word);
              else ok = word.endsWith(pat);
            }
            if (ok) {
              let expandedWStart = wStart;
              let expandedWEnd = wEnd;
              if (!this.isSentenceLikePattern(entry.pattern)) {
                while (expandedWStart > 0 && (/[A-Za-z0-9]/.test(chunkText[expandedWStart - 1]) || chunkText[expandedWStart - 1] === "-" || chunkText[expandedWStart - 1] === "'")) {
                  expandedWStart--;
                }
                while (expandedWEnd < chunkText.length && (/[A-Za-z0-9]/.test(chunkText[expandedWEnd]) || chunkText[expandedWEnd] === "-" || chunkText[expandedWEnd] === "'")) {
                  expandedWEnd++;
                }
              }
              let overlapsWithExisting = false;
              for (const existingMatch of matches) {
                if (chunkFrom + expandedWStart < existingMatch.end && chunkFrom + expandedWEnd > existingMatch.start) {
                  overlapsWithExisting = true;
                  break;
                }
              }
              for (const textBgMatch of existingMatches) {
                if (textBgMatch.isTextBg && chunkFrom + expandedWStart < textBgMatch.end && chunkFrom + expandedWEnd > textBgMatch.start) {
                  overlapsWithExisting = true;
                  break;
                }
              }
              if (!overlapsWithExisting) {
                const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
                matches.push({
                  start: chunkFrom + expandedWStart,
                  end: chunkFrom + expandedWEnd,
                  color: useColor,
                  styleType: "text",
                  entryRef: entry
                });
                if (matches.length > 2e3) break;
              } else {
                for (let i = matches.length - 1; i >= 0; i--) {
                  const m = matches[i];
                  if (m.start >= chunkFrom + expandedWStart && m.end <= chunkFrom + expandedWEnd && m.end - m.start < expandedWEnd - expandedWStart) {
                    matches.splice(i, 1);
                  }
                }
                const useColor = folderEntry && folderEntry.defaultColor ? folderEntry.defaultColor : entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color;
                matches.push({
                  start: chunkFrom + expandedWStart,
                  end: chunkFrom + expandedWEnd,
                  color: useColor,
                  styleType: "text",
                  entryRef: entry
                });
                if (matches.length > 2e3) break;
              }
              break;
            }
          }
          if (matches.length > 2e3) break;
          try {
            if (typeof wordRegex.lastIndex === "number" && wordRegex.lastIndex === match.index) wordRegex.lastIndex++;
          } catch (e) {
          }
        }
      }
    }
    return matches;
  }
  // NEW METHOD: Apply decorations from collected matches
  applyDecorationsFromMatches(builder, matches, folderEntry) {
    const all = matches.slice().sort((a, b) => {
      if (a.start !== b.start) return a.start - b.start;
      const lenDiff = b.end - b.start - (a.end - a.start);
      if (lenDiff !== 0) return lenDiff;
      const ar = a.entryRef && !!a.entryRef.isRegex;
      const br = b.entryRef && !!b.entryRef.isRegex;
      if (ar !== br) return ar ? 1 : -1;
      return 0;
    });
    const selected = [];
    for (const m of all) {
      let overlaps = false;
      const overlappingIndices = [];
      for (let i = 0; i < selected.length; i++) {
        const s = selected[i];
        if (m.start < s.end && m.end > s.start) {
          overlaps = true;
          overlappingIndices.push(i);
        }
      }
      if (!overlaps) {
        selected.push(Object.assign({}, m));
      } else {
        const mLength = m.end - m.start;
        const allShorter = overlappingIndices.every((i) => {
          const s = selected[i];
          return s.end - s.start < mLength;
        });
        if (allShorter) {
          for (let i = overlappingIndices.length - 1; i >= 0; i--) {
            selected.splice(overlappingIndices[i], 1);
          }
          selected.push(Object.assign({}, m));
        }
      }
    }
    const sortedSel = selected.sort((a, b) => a.start - b.start || a.end - b.end).slice(0, 1e3);
    const limited = (() => {
      const merged = [];
      for (const m of sortedSel) {
        const last = merged[merged.length - 1];
        if (last && m.isTextBg && last.isTextBg && m.textColor === last.textColor && m.backgroundColor === last.backgroundColor && m.start <= last.end) {
          if (m.end > last.end) last.end = m.end;
        } else {
          merged.push(m);
        }
      }
      return merged;
    })();
    const effectiveStyle = "text";
    if (limited.some((m) => m.isTextBg)) {
      const fullTextBg = limited.filter((m) => m.isTextBg);
      const filtered = [];
      for (const m of limited) {
        if (!m.isTextBg) {
          let overlapsTextBg = false;
          for (const f of fullTextBg) {
            if (m.start < f.end && m.end > f.start) {
              const fStyle = f.styleType || (f.entryRef ? f.entryRef.styleType : null);
              if (fStyle !== "highlight") {
                overlapsTextBg = true;
                break;
              }
            }
          }
          if (overlapsTextBg) continue;
        }
        filtered.push(m);
      }
      limited.length = 0;
      for (const m of filtered) limited.push(m);
    }
    for (const m of limited) {
      if (m.skip) continue;
      let style;
      const hideText = this.settings.hideTextColors === true;
      const hideBg = this.settings.hideHighlights === true;
      if (m.isTextBg) {
        const textColor = m.textColor;
        const bgColor = m.backgroundColor;
        if (hideText && hideBg) continue;
        const params = this.getHighlightParams(m.entryRef);
        const borderStyle = this.generateBorderStyle(hideText ? null : textColor, hideBg ? null : bgColor, m.entryRef);
        const textPart = hideText ? "" : `color: ${textColor} !important; `;
        const bgPart = hideBg ? "" : `background-color: ${this.hexToRgba(bgColor, params.opacity)} !important; border-radius: ${params.radius}px !important; padding-left: ${params.hPad}px !important; padding-right: ${params.hPad}px !important; padding-top: ${params.vPad}px !important; padding-bottom: ${params.vPad}px !important;${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}`;
        style = `${textPart}${bgPart}${borderStyle}`;
      } else {
        if (effectiveStyle === "none") continue;
        let styleType2 = m.entryRef && m.entryRef.affectMarkElements ? "highlight" : m.styleType || "text";
        if (styleType2 === "text") {
          if (hideText) continue;
          style = `color: ${m.color} !important; --highlight-color: ${m.color};`;
        } else if (styleType2 === "highlight") {
          const bgColor = m.backgroundColor || m.color;
          if (hideBg) continue;
          const params = this.getHighlightParams(m.entryRef);
          const borderStyle = this.generateBorderStyle(null, bgColor, m.entryRef);
          style = (() => {
            const vPad = params.vPad;
            const vPadCss = vPad >= 0 ? `padding-top: ${vPad}px !important; padding-bottom: ${vPad}px !important;` : `padding-top: 0px !important; padding-bottom: 0px !important; margin-top: ${vPad}px !important; margin-bottom: ${vPad}px !important;`;
            return `background: none; background-color: ${this.hexToRgba(bgColor, params.opacity)} !important; border-radius: ${params.hPad > 0 && params.radius === 0 ? 0 : params.radius}px !important; padding-left: ${params.hPad}px !important; padding-right: ${params.hPad}px !important; ${vPadCss}${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}${borderStyle}`;
          })();
        } else if (styleType2 === "both") {
          const textColor = m.textColor && m.textColor !== "currentColor" ? m.textColor : m.color || null;
          const bgColor = m.backgroundColor || m.color;
          if (hideText && hideBg) continue;
          const params = this.getHighlightParams(m.entryRef);
          const borderStyle = this.generateBorderStyle(hideText ? null : textColor, hideBg ? null : bgColor, m.entryRef);
          const textPart = hideText ? "" : textColor ? `color: ${textColor} !important; --highlight-color: ${textColor}; ` : "";
          const bgPart = (() => {
            if (hideBg) return "";
            const vPad = params.vPad;
            const vPadCss = vPad >= 0 ? `padding-top: ${vPad}px !important; padding-bottom: ${vPad}px !important;` : `padding-top: 0px !important; padding-bottom: 0px !important; margin-top: ${vPad}px !important; margin-bottom: ${vPad}px !important;`;
            return `background-color: ${this.hexToRgba(bgColor, params.opacity)} !important; border-radius: ${params.radius}px !important; padding-left: ${params.hPad}px !important; padding-right: ${params.hPad}px !important; ${vPadCss}${this.settings.enableBoxDecorationBreak ?? true ? " box-decoration-break: clone; -webkit-box-decoration-break: clone;" : ""}`;
          })();
          style = `${textPart}${bgPart}${borderStyle}`;
        } else {
          if (hideText) continue;
          style = `color: ${m.color} !important; --highlight-color: ${m.color};`;
        }
      }
      const isDark = (m.color || m.textColor || m.backgroundColor) && this.isDarkColor(m.color || m.textColor || m.backgroundColor);
      const deco = Decoration.mark({
        attributes: {
          style,
          class: (m.entryRef && m.entryRef.affectMarkElements ? "always-color-text-highlight always-color-text-highlight-marks" : "always-color-text-highlight") + (isDark ? " act-dark-color" : ""),
          title: this.settings.showColoringReasonOnHover && m.entry ? this.getColoringReasonTooltip(m) : ""
        }
      });
      builder.add(m.start, m.end, deco);
    }
    return builder.finish();
  }
  // --- Memory management helpers ---
  async cleanup() {
    try {
      try {
        this._cachedSortedEntries = null;
        this._cacheDirty = true;
      } catch (e) {
      }
      try {
        if (this._regexCache) this._regexCache.clear();
      } catch (e) {
      }
      try {
        this._compiledWordEntries = [];
      } catch (e) {
      }
      try {
        this._lpCalloutCache = null;
      } catch (e) {
      }
      try {
        this._lpTableCache = null;
      } catch (e) {
      }
      try {
        this._canvasDebounceTimers = null;
      } catch (e) {
      }
      try {
        if (this._readingModeIntervals && this._readingModeIntervals instanceof Map) {
          for (const intervals of this._readingModeIntervals.values()) {
            if (Array.isArray(intervals)) {
              for (const intervalId of intervals) {
                try {
                  clearInterval(intervalId);
                } catch (e) {
                }
              }
            }
          }
          this._readingModeIntervals.clear();
        }
      } catch (e) {
      }
      try {
        if (this._refreshTimeout) {
          clearTimeout(this._refreshTimeout);
          this._refreshTimeout = null;
        }
      } catch (e) {
      }
      try {
        if (this._editorRefreshTimeout) {
          clearTimeout(this._editorRefreshTimeout);
          this._editorRefreshTimeout = null;
        }
      } catch (e) {
      }
      try {
        if (this.settings) {
          if (Array.isArray(this.settings.wordEntries)) this.settings.wordEntries.length = 0;
          if (Array.isArray(this.settings.blacklistWords)) this.settings.blacklistWords.length = 0;
          if (Array.isArray(this.settings.disabledFiles)) this.settings.disabledFiles.length = 0;
        }
      } catch (e) {
      }
      try {
        this.stopMemoryMonitor();
      } catch (e) {
      }
      try {
        if (this._viewportObservers && typeof this._viewportObservers.forEach === "function") {
          this._viewportObservers.forEach((obs, key) => {
            try {
              obs.disconnect();
            } catch (e) {
            }
          });
          try {
            this._viewportObservers.clear();
          } catch (e) {
          }
        }
      } catch (e) {
      }
      try {
        if (this._eventManager && typeof this._eventManager.clear === "function") this._eventManager.clear();
      } catch (e) {
      }
      try {
        if (typeof global !== "undefined" && typeof global.gc === "function") global.gc();
      } catch (e) {
      }
    } catch (e) {
      debugError("CLEANUP", "cleanup error", e);
    }
  }
  // --- Helper: Remove highlights created by this plugin from a root element ---
  clearHighlightsInRoot(rootEl) {
    try {
      if (!rootEl || !rootEl.isConnected) return;
      this.cleanupObserversForElement(rootEl);
      const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_ELEMENT, {
        acceptNode(node) {
          return node.classList && node.classList.contains("always-color-text-highlight") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      }, false);
      const toRemove = [];
      let n;
      while (n = walker.nextNode()) {
        toRemove.push(n);
      }
      for (const el of toRemove) {
        try {
          const tn = document.createTextNode(el.textContent);
          el.replaceWith(tn);
        } catch (e) {
        }
      }
    } catch (e) {
      debugError("CLEAR", "clearHighlightsInRoot failed", e);
    }
  }
  startMemoryMonitor() {
  }
  stopMemoryMonitor() {
  }
};
var PresetModal = class extends Modal {
  constructor(app, plugin, onChoose) {
    super(app);
    this.plugin = plugin;
    this.onChoose = onChoose;
    this._listeners = [];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.addClass("act-preset-modal");
    try {
      this.modalEl.style.maxWidth = "1200px !important";
      this.modalEl.style.width = "1200px !important";
    } catch (e) {
    }
    contentEl.style.maxWidth = "1200px !important";
    const presets = [
      { label: this.plugin.t("preset_bold", "Bold"), pattern: "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1", flags: "", examples: ["**bold**"], group: "markdown", isFormatting: true, targetElement: "strong" },
      { label: this.plugin.t("preset_italic", "Italic"), pattern: "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1", flags: "", examples: ["*italic*"], group: "markdown", isFormatting: true, targetElement: "em" },
      { label: this.plugin.t("preset_bold_italic", "Bold Italic"), pattern: "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1", flags: "", examples: ["***bold_italic***"], group: "markdown", isFormatting: true, targetElement: "strong-em" },
      { label: this.plugin.t("preset_all_headings", "All Headings (H1-H6)"), pattern: "^\\s*#{1,6}\\s+.*$", flags: "m", examples: [this.plugin.t("preset_example_heading", "# Heading")] },
      { label: this.plugin.t("preset_headings_h3", "Headings (H3)"), pattern: "^\\s*#{3}\\s+.*$", flags: "m", examples: [this.plugin.t("preset_example_heading_h3", "### Heading")], group: "markdown" },
      { label: this.plugin.t("preset_bullet_points", "Bullet Points"), pattern: "^\\s*[\\-\\*]\\s+.*$", flags: "m", examples: [this.plugin.t("preset_example_bullet", "- Bullet point")], group: "markdown" },
      { label: this.plugin.t("preset_numbered_lists", "Numbered Lists"), pattern: "^\\s*\\d+\\.\\s+.*$", flags: "m", examples: [this.plugin.t("preset_example_numbered", "1. First item")], group: "markdown" },
      { label: this.plugin.t("preset_task_checked", "Task List (Checked)"), pattern: "^\\s*[\\-\\*]\\s+\\[[xX]\\]\\s+.*$", flags: "m", examples: [this.plugin.t("preset_example_task_checked", "- [x] Completed")], group: "markdown" },
      { label: this.plugin.t("preset_task_unchecked", "Task List (Unchecked)"), pattern: "^\\s*[\\-\\*]\\s+\\[\\s\\]\\s+.*$", flags: "m", examples: [this.plugin.t("preset_example_task_unchecked", "- [ ] Todo")], group: "markdown" },
      { label: this.plugin.t("preset_codeblocks", "Codeblocks"), pattern: "```[\\s\\S]*?```", flags: "", examples: [this.plugin.t("preset_example_codeblock", "``` code ```")], group: "markdown" },
      { label: this.plugin.t("preset_dates_yyyy_mm_dd", "Dates (YYYY-MM-DD)"), pattern: "\\b\\d{4}-\\d{2}-\\d{2}\\b", flags: "", examples: [this.plugin.t("preset_example_date_iso", "2009-01-19")] },
      { label: this.plugin.t("preset_dates_yyyy_mmm_dd", "Dates (YYYY-MMM-DD)"), pattern: "\\b\\d{4}-(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\\d{2}\\b", flags: "i", examples: [this.plugin.t("preset_example_date_text", "2025-Jan-19")] },
      { label: this.plugin.t("preset_times_am_pm", "Times (AM/PM)"), pattern: "\\b(?:1[0-2]|0?[1-9]):[0-5][0-9](?:am|pm)\\b", flags: "i", examples: [this.plugin.t("preset_example_time_ampm", "9:05pm")] },
      { label: this.plugin.t("preset_times_24h", "Times (24h)"), pattern: "\\b(?:[01]\\d|2[0-3]):[0-5]\\d\\b", flags: "", examples: [this.plugin.t("preset_example_time_24h", "13:00")] },
      { label: this.plugin.t("preset_relative_dates", "Relative dates"), pattern: "\\b(?:today|tomorrow|yesterday|next week|last week)\\b", flags: "i", examples: [this.plugin.t("preset_example_relative", "today, tomorrow")] },
      { label: this.plugin.t("preset_basic_urls", "Basic URLs"), pattern: "\\bhttps?://\\S+\\b", flags: "", examples: [this.plugin.t("preset_example_url", "https://example.com")], group: "markdown" },
      { label: this.plugin.t("preset_markdown_links", "Markdown links"), pattern: "\\[[^\\]]+\\]\\(https?://[^)]+\\)", flags: "", examples: [this.plugin.t("preset_example_markdown_link", "[Link](https://example.com)")], group: "markdown" },
      { label: this.plugin.t("preset_inline_comments", "Comments (%%\u2026%%)"), pattern: "%%\\s*[\\s\\S]*?\\s*%%", flags: "s", examples: [this.plugin.t("preset_example_comment", "%% comment %%")], group: "markdown" },
      { label: this.plugin.t("preset_highlighted_text", "Highlighted Text (==...)"), pattern: "==[\\s\\S]*?==", flags: "s", examples: [this.plugin.t("preset_example_highlight", "==highlighted text==")], group: "markdown", affectMarkElements: true },
      { label: this.plugin.t("preset_domain_names", "Domain names"), pattern: "\\b[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}\\b", flags: "", examples: [this.plugin.t("preset_example_domain", "example.com")] },
      { label: this.plugin.t("preset_email_addresses", "Email addresses"), pattern: "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b", flags: "", examples: [this.plugin.t("preset_example_email", "name@example.com")] },
      { label: this.plugin.t("preset_at_username", "@username"), pattern: "@[a-zA-Z0-9_]+", flags: "", examples: [this.plugin.t("preset_example_username", "@username")] },
      { label: this.plugin.t("preset_currency", "Currency"), pattern: "\\$\\d+(?:\\.\\d{2})?|\\b[\u20AC\xA3\xA5]\\d+(?:\\.\\d{2})?\\b", flags: "", examples: [this.plugin.t("preset_example_currency", "$29.99")] },
      { label: this.plugin.t("preset_measurements", "Measurements"), pattern: "\\b\\d+(?:\\.\\d+)?(?:kg|cm|m|km|\xB0C|\xB0F|lbs)\\b", flags: "", examples: [this.plugin.t("preset_example_measurement", "25kg")] },
      { label: this.plugin.t("preset_phone_numbers", "Phone numbers"), pattern: "\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b", flags: "", examples: [this.plugin.t("preset_example_phone", "123-456-7890")] },
      { label: this.plugin.t("preset_parentheses", "Parentheses ()"), pattern: "\\(([^)]*)\\)", flags: "g", examples: [this.plugin.t("preset_example_parentheses", "( text )")], group: "brackets" },
      { label: this.plugin.t("preset_square_brackets", "Square Brackets []"), pattern: "\\[([^\\]]*)\\]", flags: "g", examples: [this.plugin.t("preset_example_square_brackets", "[ yes ]")], group: "brackets", disableRegexSafety: true },
      { label: this.plugin.t("preset_curly_braces", "Curly Braces {}"), pattern: "\\{([^}]*)\\}", flags: "g", examples: [this.plugin.t("preset_example_curly_braces", "{ no }")], group: "brackets" },
      { label: this.plugin.t("preset_angle_brackets", "Angle Brackets <>"), pattern: "<([^>]*)>", flags: "g", examples: [this.plugin.t("preset_example_angle_brackets", "< text >")], group: "brackets" },
      { label: this.plugin.t("preset_colons", "Colons :"), pattern: ":([^:]*):", flags: "g", examples: [this.plugin.t("preset_example_colons", ": text :")], group: "brackets" },
      { label: this.plugin.t("preset_double_quotes", 'Double Quotes ""'), pattern: '"[^"]*"', flags: "", examples: [this.plugin.t("preset_example_double_quotes", '"text"')], group: "brackets", disableRegexSafety: true },
      { label: this.plugin.t("preset_single_quotes", "Single Quotes ''"), pattern: "'[^'\\r\\n]*'", flags: "", examples: [this.plugin.t("preset_example_single_quotes", "'text'")], group: "brackets", disableRegexSafety: true },
      { label: this.plugin.t("preset_single_quotes_word_bounded", "Single Quotes '' (word-bounded)"), pattern: "'\\b[^'\\r\\n]*\\b'", flags: "", examples: [this.plugin.t("preset_example_single_quotes_word", "'word'")], group: "brackets", disableRegexSafety: true },
      { label: this.plugin.t("preset_all_texts", "All texts"), pattern: ".+", flags: "", examples: [this.plugin.t("preset_example_all_text", "This will target all texts.")], group: "markdown" }
    ];
    const formattingPresets = presets.filter((p) => p.isFormatting);
    const markdownPresets = presets.filter((p) => (p.group === "markdown" || [
      this.plugin.t("preset_all_headings", "All Headings (H1-H6)")
    ].includes(p.label)) && !p.isFormatting);
    const bracketPresets = presets.filter((p) => p.group === "brackets");
    const otherPresets = presets.filter((p) => !markdownPresets.includes(p) && !bracketPresets.includes(p) && !formattingPresets.includes(p));
    const container = contentEl.createDiv();
    container.style.display = "grid";
    container.style.gridTemplateColumns = "1fr 1fr 1fr";
    container.style.gap = "12px";
    container.style.maxWidth = "100%";
    const mediaRule = `
      @media (max-width: 1024px) { 
        .preset-columns { grid-template-columns: 1fr 1fr !important; gap: 8px !important; } 
      }
      @media (max-width: 600px) { 
        .preset-columns { grid-template-columns: 1fr !important; gap: 8px !important; } 
      }
    `;
    const style = document.createElement("style");
    style.textContent = mediaRule;
    document.head.appendChild(style);
    container.className = "preset-columns";
    const leftCol = container.createDiv();
    const leftTitle = leftCol.createEl("h3", { text: this.plugin.t("preset_group_markdown_formatting", "Markdown Formatting") });
    leftTitle.style.marginTop = "0";
    leftTitle.style.marginBottom = "12px";
    leftTitle.style.fontSize = "14px";
    leftTitle.style.fontWeight = "600";
    leftTitle.style.opacity = "0.8";
    const leftList = leftCol.createDiv();
    if (formattingPresets.length > 0) {
      const row = leftList.createDiv();
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.marginBottom = "8px";
      formattingPresets.forEach((p) => {
        const btn = row.createEl("button", { text: p.label });
        btn.style.fontSize = "12px";
        btn.style.padding = "6px 10px";
        btn.style.flex = "1";
        btn.title = p.examples && p.examples[0] ? p.examples[0] : "";
        const handler = () => {
          try {
            this.onChoose && this.onChoose(p);
          } finally {
            this.close();
          }
        };
        btn.addEventListener("click", handler);
        this._listeners.push({ el: btn, h: handler });
      });
    }
    markdownPresets.forEach((p) => {
      const row = leftList.createDiv();
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.marginBottom = "8px";
      const btn = row.createEl("button", { text: p.label });
      btn.style.fontSize = "12px";
      btn.style.padding = "6px 10px";
      const infoDiv = row.createDiv();
      infoDiv.style.flex = "1";
      infoDiv.style.display = "flex";
      infoDiv.style.flexDirection = "column";
      infoDiv.style.gap = "2px";
      const sample = infoDiv.createEl("span", { text: p.examples && p.examples[0] ? p.examples[0] : "" });
      sample.style.opacity = "0.7";
      sample.style.fontSize = "11px";
      if (p.disableRegexSafety) {
        const badge = infoDiv.createEl("span", { text: this.plugin.t("requires_regex_safety_disabled", "Requires regex safety disabled") });
        badge.style.opacity = "0.6";
        badge.style.fontSize = "10px";
        badge.style.color = "var(--text-warning)";
      }
      const handler = () => {
        try {
          this.onChoose && this.onChoose(p);
        } finally {
          this.close();
        }
      };
      btn.addEventListener("click", handler);
      this._listeners.push({ el: btn, h: handler });
    });
    const rightCol = container.createDiv();
    const rightTitle = rightCol.createEl("h3", { text: this.plugin.t("preset_group_other_patterns", "Other Patterns") });
    rightTitle.style.marginTop = "0";
    rightTitle.style.marginBottom = "12px";
    rightTitle.style.fontSize = "14px";
    rightTitle.style.fontWeight = "600";
    rightTitle.style.opacity = "0.8";
    const rightList = rightCol.createDiv();
    otherPresets.forEach((p) => {
      const row = rightList.createDiv();
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.marginBottom = "8px";
      const btn = row.createEl("button", { text: p.label });
      btn.style.fontSize = "12px";
      btn.style.padding = "6px 10px";
      const infoDiv = row.createDiv();
      infoDiv.style.flex = "1";
      infoDiv.style.display = "flex";
      infoDiv.style.flexDirection = "column";
      infoDiv.style.gap = "2px";
      const sample = infoDiv.createEl("span", { text: p.examples && p.examples[0] ? p.examples[0] : "" });
      sample.style.opacity = "0.7";
      sample.style.fontSize = "11px";
      if (p.disableRegexSafety) {
        const badge = infoDiv.createEl("span", { text: this.plugin.t("requires_regex_safety_disabled", "Requires regex safety disabled") });
        badge.style.opacity = "0.6";
        badge.style.fontSize = "10px";
        badge.style.color = "var(--text-warning)";
      }
      const handler = () => {
        try {
          this.onChoose && this.onChoose(p);
        } finally {
          this.close();
        }
      };
      btn.addEventListener("click", handler);
      this._listeners.push({ el: btn, h: handler });
    });
    const middleCol = container.createDiv();
    const middleTitle = middleCol.createEl("h3", { text: this.plugin.t("preset_group_brackets", "Brackets") });
    middleTitle.style.marginTop = "0";
    middleTitle.style.marginBottom = "12px";
    middleTitle.style.fontSize = "14px";
    middleTitle.style.fontWeight = "600";
    middleTitle.style.opacity = "0.8";
    const middleList = middleCol.createDiv();
    bracketPresets.forEach((p) => {
      const row = middleList.createDiv();
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.marginBottom = "8px";
      const btn = row.createEl("button", { text: p.label });
      btn.style.fontSize = "12px";
      btn.style.padding = "6px 10px";
      const infoDiv = row.createDiv();
      infoDiv.style.flex = "1";
      infoDiv.style.display = "flex";
      infoDiv.style.flexDirection = "column";
      infoDiv.style.gap = "2px";
      const sample = infoDiv.createEl("span", { text: p.examples && p.examples[0] ? p.examples[0] : "" });
      sample.style.opacity = "0.7";
      sample.style.fontSize = "11px";
      if (p.disableRegexSafety) {
        const badge = infoDiv.createEl("span", { text: this.plugin.t("requires_regex_safety_disabled", "Requires regex safety disabled") });
        badge.style.opacity = "0.6";
        badge.style.fontSize = "10px";
        badge.style.color = "var(--text-warning)";
      }
      const handler = () => {
        try {
          this.onChoose && this.onChoose(p);
        } finally {
          this.close();
        }
      };
      btn.addEventListener("click", handler);
      this._listeners.push({ el: btn, h: handler });
    });
  }
  onClose() {
    this._listeners.forEach((x) => {
      try {
        x.el.removeEventListener("click", x.h);
      } catch (e) {
      }
    });
    this._listeners = [];
    this.contentEl.empty();
  }
};
var RealTimeRegexTesterModal = class extends Modal {
  constructor(app, plugin, onAdded, advancedRuleEntry = null, skipWordEntriesPush = false) {
    super(app);
    this.plugin = plugin;
    this.onAdded = onAdded;
    this._advancedRuleEntry = advancedRuleEntry;
    this._skipWordEntriesPush = skipWordEntriesPush;
    this._editingEntry = null;
    this._preFillPattern = "";
    this._preFillFlags = "";
    this._preFillName = "";
    this._preFillStyleType = "both";
    this._preFillTextColor = "#87c760";
    this._preFillBgColor = "#1d5010";
    this._handlers = [];
    this._rafId = null;
    this._debounceId = null;
    this._lastValidHTML = "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      this.modalEl.style.maxWidth = "820px";
      this.modalEl.style.padding = "20px";
    } catch (e) {
    }
    const title = contentEl.createEl("h2", { text: this.plugin.t("regex_tester_header", "Regex Tester") });
    title.style.marginTop = "0";
    title.style.marginBottom = "12px";
    try {
      title.addClass("act-regex-title");
    } catch (e) {
    }
    const controlsRow = contentEl.createDiv();
    controlsRow.style.display = "flex";
    controlsRow.style.gap = "12px";
    const flagsRow = controlsRow.createDiv();
    flagsRow.style.display = "flex";
    flagsRow.style.gap = "6px";
    const flagNames = ["i", "g", "m", "s", "u", "y"];
    const flagButtons = {};
    flagNames.forEach((f) => {
      const b = flagsRow.createEl("button", { text: f });
      b.style.padding = "6px 10px";
      b.style.borderRadius = "var(--radius-m)";
      b.style.border = "1px solid var(--background-modifier-border)";
      b.style.background = "var(--background-modifier-form-field)";
      b.style.cursor = "pointer";
      flagButtons[f] = b;
    });
    const styleSelect = controlsRow.createEl("select");
    ["text", "highlight", "both"].forEach((val) => {
      const opt = styleSelect.createEl("option", { text: this.plugin.t("style_type_" + val, val === "text" ? "color" : val) });
      opt.value = val;
    });
    styleSelect.value = this._preFillStyleType || "both";
    styleSelect.style.border = "1px solid var(--background-modifier-border)";
    styleSelect.style.borderRadius = "var(--radius-m)";
    styleSelect.style.background = "var(--background-modifier-form-field)";
    styleSelect.style.textAlign = "center";
    styleSelect.style.marginTop = "0";
    const textColorInput = controlsRow.createEl("input", { type: "color" });
    textColorInput.value = this._preFillTextColor || "#87c760";
    textColorInput.style.width = "48px";
    const bgColorInput = controlsRow.createEl("input", { type: "color" });
    bgColorInput.value = this._preFillBgColor || "#1d5010";
    bgColorInput.style.width = "48px";
    const onTextPickerContext = (ev) => {
      try {
        ev.preventDefault();
      } catch (e) {
      }
      try {
        const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
          const sel = result || {};
          const tc = sel.textColor && this.plugin.isValidHexColor(sel.textColor) ? sel.textColor : this.plugin.isValidHexColor(color) ? color : null;
          if (tc) {
            textColorInput.value = tc;
            render();
          }
        }, "text", regexInput2.value || "");
        modal._hideHeaderControls = true;
        modal._preFillTextColor = textColorInput.value;
        modal.open();
      } catch (e) {
      }
    };
    const onBgPickerContext = (ev) => {
      try {
        ev.preventDefault();
      } catch (e) {
      }
      try {
        const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
          const sel = result || {};
          const bc = sel.backgroundColor && this.plugin.isValidHexColor(sel.backgroundColor) ? sel.backgroundColor : this.plugin.isValidHexColor(color) ? color : null;
          if (bc) {
            bgColorInput.value = bc;
            render();
          }
        }, "background", regexInput2.value || "");
        modal._hideHeaderControls = true;
        modal._preFillBgColor = bgColorInput.value;
        modal.open();
      } catch (e) {
      }
    };
    try {
      textColorInput.addEventListener("contextmenu", onTextPickerContext);
      bgColorInput.addEventListener("contextmenu", onBgPickerContext);
      this._handlers.push({ el: textColorInput, ev: "contextmenu", fn: onTextPickerContext });
      this._handlers.push({ el: bgColorInput, ev: "contextmenu", fn: onBgPickerContext });
    } catch (e) {
    }
    const updatePickerVisibility = () => {
      const v = styleSelect.value;
      if (v === "text") {
        textColorInput.style.display = "inline-block";
        bgColorInput.style.display = "none";
      } else if (v === "highlight") {
        textColorInput.style.display = "none";
        bgColorInput.style.display = "inline-block";
      } else {
        textColorInput.style.display = "inline-block";
        bgColorInput.style.display = "inline-block";
      }
    };
    const regexInput2 = contentEl.createEl("input", { type: "text" });
    regexInput2.placeholder = this.plugin.t("regex_expression_placeholder", "put your expression here");
    regexInput2.style.marginTop = "10px";
    regexInput2.style.width = "100%";
    regexInput2.style.padding = "10px 14px";
    regexInput2.style.borderRadius = "var(--radius-s)";
    regexInput2.style.border = "1px solid var(--background-modifier-border)";
    regexInput2.style.background = "var(--background-modifier-form-field)";
    regexInput2.style.fontFamily = "var(--font-ui-medium)";
    const subjectWrap = contentEl.createDiv();
    subjectWrap.style.marginTop = "10px";
    subjectWrap.style.border = "1px solid var(--background-modifier-border)";
    subjectWrap.style.borderRadius = "var(--radius-m)";
    subjectWrap.style.overflow = "hidden";
    subjectWrap.style.background = "var(--background-modifier-form-field)";
    const testInput = subjectWrap.createEl("textarea");
    testInput.placeholder = this.plugin.t("regex_subject_placeholder", "type your subject / test string here...");
    testInput.style.width = "100%";
    testInput.style.height = "120px";
    testInput.style.padding = "12px";
    testInput.style.border = "none";
    testInput.style.outline = "none";
    testInput.style.background = "transparent";
    testInput.style.color = "var(--text-normal)";
    testInput.style.fontFamily = "var(--font-ui-medium)";
    testInput.style.resize = "none";
    const previewWrap = contentEl.createDiv();
    previewWrap.style.marginTop = "10px";
    previewWrap.style.border = "1px solid var(--background-modifier-border)";
    previewWrap.style.borderRadius = "var(--radius-m)";
    previewWrap.style.padding = "12px";
    previewWrap.style.background = "var(--background-modifier-form-field)";
    previewWrap.style.whiteSpace = "pre-wrap";
    previewWrap.style.wordWrap = "break-word";
    previewWrap.style.fontFamily = "var(--font-ui-medium)";
    previewWrap.style.fontSize = "var(--font-small)";
    previewWrap.style.lineHeight = "1.5";
    const nameInput = contentEl.createEl("input", { type: "text" });
    nameInput.placeholder = this.plugin.t("regex_name_placeholder", "name your regex");
    nameInput.style.marginTop = "10px";
    nameInput.style.width = "100%";
    nameInput.style.padding = "10px 14px";
    nameInput.style.borderRadius = "var(--radius-m)";
    nameInput.style.border = "1px solid var(--background-modifier-border)";
    nameInput.style.background = "var(--background-modifier-form-field)";
    nameInput.style.boxSizing = "border-box";
    const statusRow = contentEl.createDiv();
    statusRow.style.display = "flex";
    statusRow.style.justifyContent = "space-between";
    statusRow.style.alignItems = "center";
    statusRow.style.gap = "8px";
    statusRow.style.marginTop = "14px";
    const matchFooter = statusRow.createDiv();
    matchFooter.style.opacity = "0.8";
    matchFooter.style.flex = "1";
    const addBtn = statusRow.createEl("button", { text: this._editingEntry ? this.plugin.t("btn_save_regex", "Save Regex") : this.plugin.t("btn_add_regex", "+ Add Regex") });
    addBtn.addClass("mod-cta");
    const infoWrap = contentEl.createDiv();
    infoWrap.style.marginTop = "8px";
    infoWrap.style.fontFamily = "monospace";
    infoWrap.style.fontSize = "var(--font-small)";
    const status = infoWrap.createDiv();
    status.style.opacity = "0.8";
    const sanitizeFlags = (f) => {
      const s = String(f || "").toLowerCase().replace(/[^gimsuy]/g, "");
      let out = "";
      for (const ch of ["g", "i", "m", "s", "u", "y"]) {
        if (s.includes(ch)) out += ch;
      }
      return out;
    };
    const renderPreview = () => {
      const raw = String(testInput.value || "");
      const patRaw = String(regexInput2.value || "").trim();
      const flags = Object.keys(flagButtons).filter((k) => flagButtons[k].dataset.on === "1").join("");
      const f = flags.includes("g") ? flags : flags + "g";
      if (!patRaw) {
        status.textContent = "";
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 " + this.plugin.t("matches", "matches");
        return;
      }
      const pat = this.plugin.sanitizePattern(patRaw, true);
      if (!pat) {
        status.textContent = "";
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 " + this.plugin.t("matches", "matches");
        return;
      }
      if (!this.plugin.settings.disableRegexSafety && !this.plugin.validateAndSanitizeRegex(pat)) {
        status.textContent = "";
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 " + this.plugin.t("matches", "matches");
        return;
      }
      let re;
      try {
        re = new RegExp(pat, f);
      } catch (e) {
        status.textContent = "";
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 matches";
        return;
      }
      let lastIndex = 0;
      let out = "";
      let count = 0;
      const style = styleSelect.value;
      const t = textColorInput.value;
      const b = bgColorInput.value;
      const rgba = this.plugin.hexToRgba(b, this.plugin.settings.backgroundOpacity ?? 25);
      const radius = this.plugin.settings.highlightBorderRadius ?? 8;
      const pad = this.plugin.settings.highlightHorizontalPadding ?? 4;
      const vpad = this.plugin.settings.highlightVerticalPadding ?? 0;
      const borderStyle = style === "text" ? "" : style === "highlight" ? this.plugin.generateBorderStyle(null, b) : this.plugin.generateBorderStyle(t, b);
      const matchStyle = style === "text" ? `color:${t};background:transparent;` : style === "highlight" ? `background-color:${rgba};border-radius:${radius}px;padding:${vpad}px ${pad}px;color:var(--text-normal);${borderStyle}` : `color:${t};background-color:${rgba};border-radius:${radius}px;padding:${vpad}px ${pad}px;${borderStyle}`;
      for (const m of raw.matchAll(re)) {
        const s = m.index ?? 0;
        const e = s + (m[0] ? m[0].length : 0);
        out += escapeHtml(raw.slice(lastIndex, s));
        out += `<mark style="${matchStyle}">${escapeHtml(raw.slice(s, e))}</mark>`;
        lastIndex = e;
        count++;
      }
      out += escapeHtml(raw.slice(lastIndex));
      previewWrap.innerHTML = out.replace(/\n/g, "<br>");
      matchFooter.textContent = `${count} match${count === 1 ? "" : "es"}`;
      status.textContent = "";
    };
    const render = () => {
      if (this._rafId) cancelAnimationFrame(this._rafId);
      this._rafId = requestAnimationFrame(renderPreview);
    };
    const renderDebounced = () => {
      if (this._debounceId) clearTimeout(this._debounceId);
      this._debounceId = setTimeout(() => {
        render();
      }, 100);
    };
    const updateFlagButtonUI = () => {
      const active = Object.keys(flagButtons).filter((k) => flagButtons[k].dataset.on === "1");
      Object.keys(flagButtons).forEach((k) => {
        const on = flagButtons[k].dataset.on === "1";
        if (on) {
          flagButtons[k].addClass("mod-cta");
        } else {
          flagButtons[k].removeClass("mod-cta");
        }
      });
    };
    Object.keys(flagButtons).forEach((k) => {
      const btn = flagButtons[k];
      const flagTooltips = { "i": "ignore case", "g": "global", "m": "multiline", "s": "dotall", "u": "unicode", "y": "sticky" };
      if (flagTooltips[k]) {
        btn.setAttribute("title", flagTooltips[k]);
      }
      const fn = () => {
        btn.dataset.on = btn.dataset.on === "1" ? "0" : "1";
        updateFlagButtonUI();
        render();
      };
      btn.addEventListener("click", fn);
      this._handlers.push({ el: btn, ev: "click", fn });
    });
    updateFlagButtonUI();
    if (this._preFillPattern) {
      regexInput2.value = this._preFillPattern;
    }
    if (this._preFillFlags) {
      const flags = String(this._preFillFlags || "").split("");
      flags.forEach((f) => {
        if (flagButtons[f]) {
          flagButtons[f].dataset.on = "1";
        }
      });
      updateFlagButtonUI();
    }
    if (this._preFillName) {
      nameInput.value = this._preFillName;
    }
    if (this._preFillStyleType) {
      styleSelect.value = this._preFillStyleType;
    }
    if (this._preFillTextColor) {
      textColorInput.value = this._preFillTextColor;
    }
    if (this._preFillBgColor) {
      bgColorInput.value = this._preFillBgColor;
    }
    updatePickerVisibility();
    const onInputImmediate = () => {
      render();
    };
    const onInputDebounced = () => {
      renderDebounced();
    };
    const styleChange = () => {
      updatePickerVisibility();
      render();
    };
    [textColorInput, bgColorInput, styleSelect].forEach((el) => {
      const ev = el === styleSelect ? "change" : "input";
      const fn = el === styleSelect ? styleChange : onInputImmediate;
      el.addEventListener(ev, fn);
      this._handlers.push({ el, ev, fn });
    });
    testInput.addEventListener("input", onInputDebounced);
    this._handlers.push({ el: testInput, ev: "input", fn: onInputDebounced });
    regexInput2.addEventListener("input", onInputDebounced);
    this._handlers.push({ el: regexInput2, ev: "input", fn: onInputDebounced });
    render();
    const addHandler = async () => {
      const patRaw = String(regexInput2.value || "").trim();
      const pat = this.plugin.sanitizePattern(patRaw, true);
      const label = String(nameInput.value || "").trim();
      const flags = Object.keys(flagButtons).filter((k) => flagButtons[k].dataset.on === "1").join("");
      if (!pat) {
        new Notice(this.plugin.t("notice_empty_pattern", "Pattern is empty"));
        return;
      }
      if (!this.plugin.settings.disableRegexSafety && !this.plugin.validateAndSanitizeRegex(pat)) {
        new Notice(this.plugin.t("notice_pattern_too_complex", "Pattern too complex"));
        return;
      }
      try {
        this.plugin.settings.enableRegexSupport = true;
      } catch (e) {
      }
      if (this._advancedRuleEntry) {
        try {
          this._advancedRuleEntry.text = pat;
          this._advancedRuleEntry.flags = flags;
          await this.plugin.saveSettings();
          try {
            this.onAdded && this.onAdded(this._advancedRuleEntry);
          } catch (e) {
          }
          new Notice(this.plugin.t("notice_rule_updated", "Rule updated"));
          this.close();
          return;
        } catch (e) {
          debugError("REGEX_TESTER", "advanced rule update error", e);
        }
      }
      if (this._editingEntry) {
        try {
          const style2 = styleSelect.value;
          const updated = Object.assign({}, this._editingEntry, {
            pattern: pat,
            flags,
            presetLabel: label || void 0,
            styleType: style2,
            isRegex: true
          });
          if (style2 === "text") {
            updated.color = textColorInput.value || "";
            updated.textColor = null;
            updated._savedTextColor = textColorInput.value || this._editingEntry._savedTextColor || updated.color || "";
            updated._savedBackgroundColor = bgColorInput.value || this._editingEntry._savedBackgroundColor || "";
            updated.backgroundColor = null;
          } else if (style2 === "highlight") {
            updated.color = "";
            updated.textColor = "currentColor";
            updated._savedTextColor = textColorInput.value || this._editingEntry._savedTextColor || "";
            updated.backgroundColor = bgColorInput.value || "";
            updated._savedBackgroundColor = bgColorInput.value || this._editingEntry._savedBackgroundColor || "";
          } else {
            updated.color = "";
            updated.textColor = textColorInput.value || "";
            updated.backgroundColor = bgColorInput.value || "";
            updated._savedTextColor = textColorInput.value || this._editingEntry._savedTextColor || "";
            updated._savedBackgroundColor = bgColorInput.value || this._editingEntry._savedBackgroundColor || "";
          }
          let idx = -1;
          if (updated && updated.uid) idx = this.plugin.settings.wordEntries.findIndex((e) => e && e.uid === updated.uid);
          if (idx === -1) idx = this.plugin.settings.wordEntries.indexOf(this._editingEntry);
          if (idx === -1) idx = this.plugin.settings.wordEntries.findIndex((e) => e && e.isRegex && String(e.pattern) === String(this._editingEntry.pattern));
          if (idx !== -1) this.plugin.settings.wordEntries[idx] = updated;
          else this.plugin.settings.wordEntries.push(Object.assign({ matchType: this.plugin.settings.partialMatch ? "contains" : "exact" }, updated));
          this._editingEntry.pattern = updated.pattern;
          this._editingEntry.flags = updated.flags;
          this._editingEntry.presetLabel = updated.presetLabel;
          this._editingEntry.styleType = updated.styleType;
          this._editingEntry.color = updated.color;
          this._editingEntry.textColor = updated.textColor;
          this._editingEntry.backgroundColor = updated.backgroundColor;
          this._editingEntry._savedTextColor = updated._savedTextColor;
          this._editingEntry._savedBackgroundColor = updated._savedBackgroundColor;
          await this.plugin.saveSettings();
          this.plugin.compileWordEntries();
          this.plugin.compileTextBgColoringEntries();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
          this.plugin.forceRefreshAllReadingViews();
          this.plugin.triggerActiveDocumentRerender();
          try {
            this.onAdded && this.onAdded(updated);
          } catch (e) {
          }
          new Notice(this.plugin.t("notice_regex_updated", "Regex updated"));
          try {
            const pm = this._parentModal;
            if (pm) {
              try {
                pm.close();
              } catch (_) {
              }
              setTimeout(() => {
                try {
                  pm.open();
                } catch (_) {
                }
              }, 50);
            }
          } catch (_) {
          }
          this.close();
          return;
        } catch (e) {
          debugError("REGEX_TESTER", "entry update error", e);
        }
      }
      if (!this._skipWordEntriesPush) {
        const uid = (() => {
          try {
            return Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (e) {
            return Date.now();
          }
        })();
        const style2 = styleSelect.value;
        const entry2 = { uid, isRegex: true, pattern: pat, flags, presetLabel: label || void 0, styleType: style2, persistAtEnd: true };
        if (style2 === "text") {
          entry2.color = textColorInput.value || "";
          entry2.textColor = null;
          entry2.backgroundColor = null;
          entry2._savedTextColor = textColorInput.value || "";
          entry2._savedBackgroundColor = bgColorInput.value || "";
        } else if (style2 === "highlight") {
          entry2.color = "";
          entry2.textColor = "currentColor";
          entry2.backgroundColor = bgColorInput.value || "";
          entry2._savedTextColor = textColorInput.value || "";
          entry2._savedBackgroundColor = bgColorInput.value || "";
        } else {
          entry2.color = "";
          entry2.textColor = textColorInput.value || "";
          entry2.backgroundColor = bgColorInput.value || "";
          entry2._savedTextColor = textColorInput.value || "";
          entry2._savedBackgroundColor = bgColorInput.value || "";
        }
        this.plugin.settings.wordEntries.push(Object.assign({ matchType: this.plugin.settings.partialMatch ? "contains" : "exact" }, entry2));
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        this.plugin.compileTextBgColoringEntries();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        this.plugin.forceRefreshAllReadingViews();
        this.plugin.triggerActiveDocumentRerender();
      }
      const style = styleSelect.value;
      const entry = { isRegex: true, pattern: pat, flags, presetLabel: label || void 0, styleType: style };
      if (style === "text") {
        entry.color = textColorInput.value || "";
        entry.textColor = null;
        entry.backgroundColor = null;
        entry._savedTextColor = textColorInput.value || "";
        entry._savedBackgroundColor = bgColorInput.value || "";
      } else if (style === "highlight") {
        entry.color = "";
        entry.textColor = "currentColor";
        entry.backgroundColor = bgColorInput.value || "";
        entry._savedTextColor = textColorInput.value || "";
        entry._savedBackgroundColor = bgColorInput.value || "";
      } else {
        entry.color = "";
        entry.textColor = textColorInput.value || "";
        entry.backgroundColor = bgColorInput.value || "";
        entry._savedTextColor = textColorInput.value || "";
        entry._savedBackgroundColor = bgColorInput.value || "";
      }
      try {
        this.onAdded && this.onAdded(entry);
      } catch (e) {
      }
      new Notice(this.plugin.t("notice_added_regex", "Regex added"));
      try {
        const pm = this._parentModal;
        if (pm) {
          try {
            pm.close();
          } catch (_) {
          }
          setTimeout(() => {
            try {
              pm.open();
            } catch (_) {
            }
          }, 50);
        }
      } catch (_) {
      }
      this.close();
    };
    addBtn.addEventListener("click", addHandler);
    this._handlers.push({ el: addBtn, ev: "click", fn: addHandler });
  }
  onClose() {
    try {
      if (this._rafId) cancelAnimationFrame(this._rafId);
      if (this._debounceId) clearTimeout(this._debounceId);
      if (this._handlers && Array.isArray(this._handlers)) {
        this._handlers.forEach((h) => {
          try {
            if (h.el && h.ev && h.fn && typeof h.el.removeEventListener === "function") {
              h.el.removeEventListener(h.ev, h.fn);
            }
          } catch (e) {
          }
        });
      }
    } catch (e) {
    }
    this._handlers = [];
    try {
      this.contentEl?.empty();
    } catch (e) {
    }
  }
};
var HighlightStylingModal = class extends Modal {
  constructor(app, plugin, entry = null, parentEditEntryModal = null, previewTextOverride = null) {
    super(app);
    this.plugin = plugin;
    this.entry = entry;
    this.parentEditEntryModal = parentEditEntryModal;
    this.previewTextOverride = previewTextOverride;
    this._resetAllApplied = false;
    this._handlers = [];
  }
  onOpen() {
    const { contentEl } = this;
    const clearResetFlag = () => {
      this._resetAllApplied = false;
    };
    contentEl.addEventListener("input", clearResetFlag, true);
    contentEl.addEventListener("change", clearResetFlag, true);
    this._handlers.push({ el: contentEl, ev: "input", fn: clearResetFlag });
    this._handlers.push({ el: contentEl, ev: "change", fn: clearResetFlag });
    contentEl.empty();
    try {
      this.modalEl.addClass("act-highlight-styling-modal");
      this.modalEl.addClass("act-highlight-modal");
      this.modalEl.style.padding = "20px";
    } catch (e) {
    }
    const isGroup = this.entry && Array.isArray(this.entry.entries);
    const headerRow = contentEl.createDiv();
    headerRow.style.display = "flex";
    headerRow.style.alignItems = "center";
    headerRow.style.gap = "8px";
    headerRow.style.marginBottom = "12px";
    headerRow.style.flexWrap = "wrap";
    const headerTitle = isGroup ? this.plugin.t("edit_group_highlight_styling", "Edit Group Highlight Styling") : this.plugin.t("highlight_styling_header", "Edit Highlight Styling");
    const title = headerRow.createEl("h2", { text: headerTitle });
    title.style.margin = "0";
    const spacer = headerRow.createDiv();
    spacer.style.flex = "1";
    if (!isGroup) {
      const groupSelect = headerRow.createEl("select");
      groupSelect.style.minWidth = "120px";
      groupSelect.style.border = "1px solid var(--background-modifier-border)";
      groupSelect.style.borderRadius = "4px";
      groupSelect.style.background = "var(--background-modifier-form-field)";
      groupSelect.style.textAlign = "center";
      const defaultOpt = groupSelect.createEl("option", { text: this.plugin.t("default") });
      defaultOpt.value = "";
      const groupsList = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : [];
      groupsList.forEach((g) => {
        const name = g && g.name && String(g.name).trim().length > 0 ? g.name : "(unnamed group)";
        const opt = groupSelect.createEl("option", { text: name });
        opt.value = g.uid || "";
      });
      let currentGroupUid = null;
      if (this.entry) {
        if (this.entry.groupUid) {
          currentGroupUid = this.entry.groupUid;
        } else {
          for (const g of groupsList) {
            if (g.entries && g.entries.includes(this.entry)) {
              currentGroupUid = g.uid;
              break;
            }
          }
        }
      }
      groupSelect.value = currentGroupUid || "";
      groupSelect.addEventListener("change", async () => {
        const toUid = groupSelect.value || "";
        const fromUid = currentGroupUid || "";
        if (toUid === fromUid) return;
        if (this.plugin.settings.quickStyles.includes(this.entry)) {
          this.entry.groupUid = toUid;
          currentGroupUid = toUid;
          await this.plugin.saveSettings();
          return;
        }
        const settings = this.plugin.settings;
        if (!Array.isArray(settings.wordEntries)) settings.wordEntries = [];
        if (!Array.isArray(settings.wordEntryGroups)) settings.wordEntryGroups = [];
        const wordEntriesIdx = settings.wordEntries.indexOf(this.entry);
        if (wordEntriesIdx !== -1) {
          settings.wordEntries.splice(wordEntriesIdx, 1);
        }
        for (const group of settings.wordEntryGroups) {
          if (group && Array.isArray(group.entries)) {
            const groupIdx = group.entries.indexOf(this.entry);
            if (groupIdx !== -1) {
              group.entries.splice(groupIdx, 1);
            }
          }
        }
        if (toUid === "") {
          try {
            delete this.entry.groupUid;
          } catch (_) {
          }
          settings.wordEntries.push(this.entry);
        } else {
          const tgtGroup = settings.wordEntryGroups.find((g) => g && g.uid === toUid);
          if (tgtGroup) {
            if (!Array.isArray(tgtGroup.entries)) tgtGroup.entries = [];
            try {
              this.entry.groupUid = toUid;
            } catch (_) {
            }
            tgtGroup.entries.push(this.entry);
          }
        }
        currentGroupUid = toUid;
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        this.plugin.compileTextBgColoringEntries();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        this.plugin.triggerActiveDocumentRerender();
      });
    }
    const matchSelect = headerRow.createEl("select");
    matchSelect.style.minWidth = "120px";
    matchSelect.style.border = "1px solid var(--background-modifier-border)";
    matchSelect.style.borderRadius = "4px";
    matchSelect.style.background = "var(--background-modifier-form-field)";
    matchSelect.style.textAlign = "center";
    if (isGroup) {
      matchSelect.innerHTML = `<option value="per-entry">${this.plugin.t("opt_match_all", "Match Type (All)")}</option>
        <option value="exact">${this.plugin.t("match_option_exact", "exact")}</option>
        <option value="contains">${this.plugin.t("match_option_contains", "contains")}</option>
        <option value="startsWith">${this.plugin.t("match_option_starts_with", "starts with")}</option>
        <option value="endsWith">${this.plugin.t("match_option_ends_with", "ends with")}</option>`;
      const currentOverride = this.entry.matchTypeOverride;
      matchSelect.value = typeof currentOverride === "string" && currentOverride ? currentOverride : "per-entry";
    } else {
      matchSelect.innerHTML = `<option value="exact">${this.plugin.t("match_option_exact", "exact")}</option>
        <option value="contains">${this.plugin.t("match_option_contains", "contains")}</option>
        <option value="startsWith">${this.plugin.t("match_option_starts_with", "starts with")}</option>
        <option value="endsWith">${this.plugin.t("match_option_ends_with", "ends with")}</option>`;
      if (this.entry) {
        if (this.entry.isRegex) {
          matchSelect.disabled = true;
          matchSelect.style.opacity = "0.5";
        } else {
          let defaultMatch = typeof this.entry.matchType === "string" && this.entry.matchType ? this.entry.matchType.toLowerCase() : "exact";
          if (defaultMatch === "startswith" || defaultMatch === "starts with") defaultMatch = "startswith";
          if (defaultMatch === "endswith" || defaultMatch === "ends with") defaultMatch = "endswith";
          matchSelect.value = defaultMatch === "startswith" ? "startsWith" : defaultMatch === "endswith" ? "endsWith" : defaultMatch;
        }
      }
    }
    matchSelect.addEventListener("change", async () => {
      if (!this.entry) return;
      let value = matchSelect.value;
      if (value === "startsWith") value = "startswith";
      if (value === "endsWith") value = "endswith";
      if (isGroup) {
        this.entry.matchTypeOverride = value === "per-entry" ? null : value;
      } else {
        this.entry.matchType = value;
      }
      await this.plugin.saveSettings();
      this.plugin.compileWordEntries();
      this.plugin.compileTextBgColoringEntries();
      this.plugin.reconfigureEditorExtensions();
      this.plugin.forceRefreshAllEditors();
      this.plugin.triggerActiveDocumentRerender();
    });
    const topRow = contentEl.createDiv();
    topRow.addClass("act-highlight-top-row");
    const previewWrap = topRow.createDiv();
    previewWrap.addClass("act-highlight-preview-wrap");
    const words = previewWrap.createDiv();
    words.style.textAlign = "center";
    words.style.opacity = "0.8";
    words.textContent = this.previewTextOverride ? this.previewTextOverride : isGroup ? this.entry.name || "Group" : this.entry ? this.entry.isRegex ? String(this.entry.pattern || "") : Array.isArray(this.entry.groupedPatterns) && this.entry.groupedPatterns.length > 0 ? this.entry.groupedPatterns.join(", ") : String(this.entry.pattern || "") : "";
    const styleCol = topRow.createDiv();
    styleCol.addClass("act-highlight-style-col");
    const styleSelect = styleCol.createEl("select");
    styleSelect.addClass("act-highlight-style-select");
    if (isGroup) {
      const defaultOpt = styleSelect.createEl("option", { text: this.plugin.t("opt_style_default", "Default (Per-Entry)") });
      defaultOpt.value = "";
    }
    ["text", "highlight", "both"].forEach((val) => {
      const opt = styleSelect.createEl("option", { text: this.plugin.t("style_type_" + val, val === "text" ? "color" : val) });
      opt.value = val;
    });
    styleSelect.style.border = "1px solid var(--background-modifier-border)";
    styleSelect.style.borderRadius = "4px";
    styleSelect.style.background = "var(--background-modifier-form-field)";
    styleSelect.style.textAlign = "center";
    styleSelect.value = this.entry && this.entry.styleType ? this.entry.styleType : isGroup ? "" : "both";
    const pickerRow = styleCol.createDiv();
    pickerRow.addClass("act-highlight-picker-row");
    if (isGroup && !styleSelect.value) pickerRow.style.display = "none";
    const tColor = pickerRow.createEl("input", { type: "color" });
    const bColor = pickerRow.createEl("input", { type: "color" });
    tColor.value = this.entry && (this.entry.textColor && this.entry.textColor !== "currentColor" ? this.entry.textColor : this.plugin.isValidHexColor(this.entry.color) ? this.entry.color : "#ffffff") || "#ffffff";
    bColor.value = this.entry && this.entry.backgroundColor ? this.entry.backgroundColor : "#000000";
    const syncColorsFromParent = (evt) => {
      try {
        if (evt.detail && evt.detail.entry && evt.detail.entry === this.entry) {
          const initTextColor = this.entry && (this.entry.textColor && this.entry.textColor !== "currentColor" ? this.entry.textColor : this.plugin.isValidHexColor(this.entry.color) ? this.entry.color : "") || tColor.value || "#ffffff";
          const initBgColor = this.entry && (this.entry.backgroundColor || "") || bColor.value || "#000000";
          if (this.plugin.isValidHexColor(initTextColor)) tColor.value = initTextColor;
          if (this.plugin.isValidHexColor(initBgColor)) bColor.value = initBgColor;
        }
      } catch (_) {
      }
    };
    window.addEventListener("act-colors-changed", syncColorsFromParent);
    this._handlers.push({ el: window, ev: "act-colors-changed", fn: syncColorsFromParent });
    const paneRow = contentEl.createDiv();
    paneRow.addClass("act-highlight-pane-row");
    const hlWrap = paneRow.createDiv();
    hlWrap.addClass("act-highlight-pane");
    const borderWrap = paneRow.createDiv();
    borderWrap.addClass("act-highlight-pane");
    const section1Title = hlWrap.createEl("h3", { text: this.plugin.t("section_highlight_styling", "Highlight Styling") });
    const grid = hlWrap.createDiv();
    grid.addClass("act-highlight-grid");
    const makeSliderRow = (label, min, max, value, onChange, onReset) => {
      const left = grid.createDiv();
      const lab = left.createDiv();
      lab.textContent = label;
      const right = grid.createDiv();
      const slider = right.createEl("input", { type: "range" });
      slider.min = String(min);
      slider.max = String(max);
      slider.value = String(value);
      const resetBtn = right.createEl("button");
      resetBtn.addClass("act-highlight-reset-btn");
      try {
        setIcon(resetBtn, "reset");
      } catch (e) {
      }
      const handler = () => {
        onChange(Number(slider.value));
        renderPreview();
      };
      slider.addEventListener("input", handler);
      this._handlers.push({ el: slider, ev: "input", fn: handler });
      const resetHandler = () => {
        onReset(slider);
        renderPreview();
      };
      resetBtn.addEventListener("click", resetHandler);
      this._handlers.push({ el: resetBtn, ev: "click", fn: resetHandler });
      return slider;
    };
    const initOpacity = this.entry && typeof this.entry.backgroundOpacity === "number" ? this.entry.backgroundOpacity : Number(this.plugin.settings.backgroundOpacity ?? 35);
    const opacitySlider = makeSliderRow(this.plugin.t("label_highlight_opacity", "Highlight Opacity"), 0, 100, initOpacity, (v) => {
      if (this.entry) this.entry.backgroundOpacity = v;
    }, (sliderEl) => {
      if (this.entry) {
        this.entry.backgroundOpacity = void 0;
      }
      sliderEl.value = String(this.plugin.settings.backgroundOpacity ?? 35);
    });
    opacitySlider.setAttribute("data-act-opacity-slider", "true");
    const radiusInputLeft = grid.createDiv();
    radiusInputLeft.textContent = this.plugin.t("label_highlight_radius", "Highlight Border Radius");
    const radiusInputRight = grid.createDiv();
    const initRadius = this.entry && typeof this.entry.highlightBorderRadius === "number" ? this.entry.highlightBorderRadius : this.plugin.settings.highlightBorderRadius ?? 4;
    const radiusInput = radiusInputRight.createEl("input", { type: "number", value: String(initRadius) });
    radiusInput.addClass("act-highlight-input-small");
    radiusInput.setAttribute("data-act-radius-input", "true");
    radiusInput.addEventListener("change", () => {
      if (this.entry) this.entry.highlightBorderRadius = Number(radiusInput.value || 0);
      renderPreview();
    });
    const radiusReset = radiusInputRight.createEl("button");
    radiusReset.addClass("act-highlight-reset-btn");
    try {
      setIcon(radiusReset, "reset");
    } catch (e) {
    }
    radiusReset.addEventListener("click", () => {
      if (this.entry) this.entry.highlightBorderRadius = void 0;
      radiusInput.value = String(this.plugin.settings.highlightBorderRadius ?? 4);
      renderPreview();
    });
    this._handlers.push({ el: radiusInput, ev: "change", fn: () => {
    } });
    const hPadLeft = grid.createDiv();
    hPadLeft.textContent = this.plugin.t("label_horizontal_padding", "Horizontal Padding");
    const initHPad = this.entry && typeof this.entry.highlightHorizontalPadding === "number" ? this.entry.highlightHorizontalPadding : this.plugin.settings.highlightHorizontalPadding ?? 4;
    const hPadRight = grid.createDiv();
    const hPadInput = hPadRight.createEl("input", { type: "number", value: String(initHPad) });
    hPadInput.addClass("act-highlight-input-small");
    hPadInput.setAttribute("data-act-hpad-input", "true");
    hPadInput.addEventListener("change", () => {
      if (this.entry) this.entry.highlightHorizontalPadding = Number(hPadInput.value || 0);
      renderPreview();
    });
    const hPadReset = hPadRight.createEl("button");
    hPadReset.addClass("act-highlight-reset-btn");
    try {
      setIcon(hPadReset, "reset");
    } catch (e) {
    }
    hPadReset.addEventListener("click", () => {
      if (this.entry) this.entry.highlightHorizontalPadding = void 0;
      hPadInput.value = String(this.plugin.settings.highlightHorizontalPadding ?? 4);
      renderPreview();
    });
    const vPadLeft = grid.createDiv();
    vPadLeft.textContent = this.plugin.t("label_vertical_padding", "Vertical Padding");
    const initVPad = this.entry && typeof this.entry.highlightVerticalPadding === "number" ? this.entry.highlightVerticalPadding : this.plugin.settings.highlightVerticalPadding ?? 0;
    const vPadRight = grid.createDiv();
    const vPadInput = vPadRight.createEl("input", { type: "number", value: String(initVPad) });
    vPadInput.addClass("act-highlight-input-small");
    vPadInput.setAttribute("data-act-vpad-input", "true");
    vPadInput.addEventListener("change", () => {
      if (this.entry) this.entry.highlightVerticalPadding = Number(vPadInput.value || 0);
      renderPreview();
    });
    const vPadReset = vPadRight.createEl("button");
    vPadReset.addClass("act-highlight-reset-btn");
    try {
      setIcon(vPadReset, "reset");
    } catch (e) {
    }
    vPadReset.addEventListener("click", () => {
      if (this.entry) this.entry.highlightVerticalPadding = void 0;
      vPadInput.value = String(this.plugin.settings.highlightVerticalPadding ?? 0);
      renderPreview();
    });
    const grid2Title = borderWrap.createEl("h3", { text: this.plugin.t("section_highlight_border_styling", "Highlight Border Styling") });
    const grid2 = borderWrap.createDiv();
    grid2.addClass("act-highlight-grid");
    const enableLeft = grid2.createDiv();
    enableLeft.textContent = this.plugin.t("label_enable_border", "Enable Border");
    const enableRight = grid2.createDiv();
    const enableChk = enableRight.createEl("input", { type: "checkbox" });
    enableChk.setAttribute("data-act-border-enable", "true");
    enableChk.checked = this.entry && typeof this.entry.enableBorderThickness !== "undefined" ? !!this.entry.enableBorderThickness : !!this.plugin.settings.enableBorderThickness;
    enableChk.addEventListener("change", () => {
      if (this.entry) this.entry.enableBorderThickness = !!enableChk.checked;
      renderPreview();
    });
    const sidesLeft = grid2.createDiv();
    sidesLeft.textContent = this.plugin.t("label_border_sides", "Border Sides");
    const sidesRight = grid2.createDiv();
    const sidesSel = sidesRight.createEl("select");
    sidesSel.setAttribute("data-act-border-sides", "true");
    [
      ["full", this.plugin.t("opt_border_full", "Full Border (All Sides)")],
      ["top-bottom", this.plugin.t("opt_border_top_bottom", "Top & Bottom")],
      ["left-right", this.plugin.t("opt_border_left_right", "Left & Right")],
      ["top-left-right", this.plugin.t("opt_border_top_left_right", "Top, Left & Right")],
      ["bottom-left-right", this.plugin.t("opt_border_bottom_left_right", "Bottom, Left & Right")],
      ["top-right", this.plugin.t("opt_border_top_right", "Top & Right")],
      ["top-left", this.plugin.t("opt_border_top_left", "Top & Left")],
      ["bottom-right", this.plugin.t("opt_border_bottom_right", "Bottom & Right")],
      ["bottom-left", this.plugin.t("opt_border_bottom_left", "Bottom & Left")],
      ["top", this.plugin.t("opt_border_top", "Top Only")],
      ["bottom", this.plugin.t("opt_border_bottom", "Bottom Only")],
      ["left", this.plugin.t("opt_border_left", "Left Only")],
      ["right", this.plugin.t("opt_border_right", "Right Only")]
    ].forEach(([value, label]) => {
      const o = sidesSel.createEl("option", { text: label });
      o.value = value;
    });
    sidesSel.value = this.entry && this.entry.borderStyle ? this.entry.borderStyle : this.plugin.settings.borderStyle ?? "full";
    sidesSel.addEventListener("change", () => {
      if (this.entry) this.entry.borderStyle = sidesSel.value;
      renderPreview();
    });
    const sidesReset = sidesRight.createEl("button");
    sidesReset.addClass("act-highlight-reset-btn");
    try {
      setIcon(sidesReset, "reset");
    } catch (e) {
    }
    sidesReset.addEventListener("click", () => {
      if (this.entry) this.entry.borderStyle = void 0;
      sidesSel.value = this.plugin.settings.borderStyle ?? "full";
      renderPreview();
    });
    const styleLeft = grid2.createDiv();
    styleLeft.textContent = this.plugin.t("label_border_style", "Border Style");
    const styleRight = grid2.createDiv();
    const lineSel = styleRight.createEl("select");
    lineSel.setAttribute("data-act-border-line", "true");
    [
      ["solid", this.plugin.t("opt_line_solid", "Solid")],
      ["dashed", this.plugin.t("opt_line_dashed", "Dashed")],
      ["dotted", this.plugin.t("opt_line_dotted", "Dotted")],
      ["double", this.plugin.t("opt_line_double", "Double")],
      ["groove", this.plugin.t("opt_line_groove", "Groove")],
      ["ridge", this.plugin.t("opt_line_ridge", "Ridge")],
      ["inset", this.plugin.t("opt_line_inset", "Inset")],
      ["outset", this.plugin.t("opt_line_outset", "Outset")]
    ].forEach(([value, label]) => {
      const o = lineSel.createEl("option", { text: label });
      o.value = value;
    });
    lineSel.value = this.entry && this.entry.borderLineStyle ? this.entry.borderLineStyle : this.plugin.settings.borderLineStyle ?? "solid";
    lineSel.addEventListener("change", () => {
      if (this.entry) this.entry.borderLineStyle = lineSel.value;
      renderPreview();
    });
    const styleReset = styleRight.createEl("button");
    styleReset.addClass("act-highlight-reset-btn");
    try {
      setIcon(styleReset, "reset");
    } catch (e) {
    }
    styleReset.addEventListener("click", () => {
      if (this.entry) this.entry.borderLineStyle = void 0;
      lineSel.value = this.plugin.settings.borderLineStyle ?? "solid";
      renderPreview();
    });
    const bOpLeft = grid2.createDiv();
    bOpLeft.textContent = this.plugin.t("label_border_opacity", "Border Opacity");
    const bOpRight = grid2.createDiv();
    const bOpSlider = bOpRight.createEl("input", { type: "range" });
    bOpSlider.setAttribute("data-act-border-opacity", "true");
    bOpSlider.min = "0";
    bOpSlider.max = "100";
    bOpSlider.value = String(this.entry && typeof this.entry.borderOpacity === "number" ? this.entry.borderOpacity : this.plugin.settings.borderOpacity ?? 100);
    bOpSlider.addEventListener("input", () => {
      if (this.entry) this.entry.borderOpacity = Number(bOpSlider.value || 0);
      renderPreview();
    });
    const bOpReset = bOpRight.createEl("button");
    bOpReset.addClass("act-highlight-reset-btn");
    try {
      setIcon(bOpReset, "reset");
    } catch (e) {
    }
    bOpReset.addEventListener("click", () => {
      if (this.entry) this.entry.borderOpacity = void 0;
      bOpSlider.value = String(this.plugin.settings.borderOpacity ?? 100);
      renderPreview();
    });
    const thickLeft = grid2.createDiv();
    thickLeft.textContent = this.plugin.t("label_border_thickness", "Border Thickness");
    const thickRight = grid2.createDiv();
    const thickInput = thickRight.createEl("input", { type: "number", value: String(this.entry && typeof this.entry.borderThickness === "number" ? this.entry.borderThickness : this.plugin.settings.borderThickness ?? 1) });
    thickInput.addClass("act-highlight-input-small");
    thickInput.setAttribute("data-act-border-thickness", "true");
    thickInput.addEventListener("change", () => {
      if (this.entry) this.entry.borderThickness = Number(thickInput.value || 0);
      renderPreview();
    });
    const thickReset = thickRight.createEl("button");
    thickReset.addClass("act-highlight-reset-btn");
    try {
      setIcon(thickReset, "reset");
    } catch (e) {
    }
    thickReset.addEventListener("click", () => {
      if (this.entry) this.entry.borderThickness = void 0;
      thickInput.value = String(this.plugin.settings.borderThickness ?? 1);
      renderPreview();
    });
    const renderPreview = () => {
      const style = styleSelect.value;
      if (isGroup && !style) {
        const txt2 = words.textContent || "";
        try {
          while (previewWrap.firstChild) previewWrap.removeChild(previewWrap.firstChild);
          const div = document.createElement("div");
          div.textContent = txt2;
          div.style.opacity = "1";
          previewWrap.appendChild(div);
        } catch (_) {
          previewWrap.innerHTML = `<div>${escapeHtml(txt2)}</div>`;
        }
        return;
      }
      const t = tColor.value;
      const b = bColor.value;
      const p = this.plugin.getHighlightParams(this.entry);
      const rgba = this.plugin.hexToRgba(b, p.opacity ?? 25);
      const radius = p.radius ?? 8;
      const pad = p.hPad ?? 4;
      const vpad = p.vPad ?? 0;
      const borderStyle = style === "text" ? "" : style === "highlight" ? this.plugin.generateBorderStyle(null, b, this.entry) : this.plugin.generateBorderStyle(t, b, this.entry);
      const matchStyle = style === "text" ? `color:${t};background:transparent;` : style === "highlight" ? `background:${rgba};border-radius:${radius}px;padding:${vpad}px ${pad}px;color:var(--text-normal);${borderStyle}` : `color:${t};background:${rgba};border-radius:${radius}px;padding:${vpad}px ${pad}px;${borderStyle}`;
      const txt = words.textContent || "";
      try {
        while (previewWrap.firstChild) previewWrap.removeChild(previewWrap.firstChild);
        const div = document.createElement("div");
        div.setAttribute("style", matchStyle);
        div.textContent = txt;
        previewWrap.appendChild(div);
      } catch (_) {
        previewWrap.innerHTML = `<div style="${matchStyle}">${escapeHtml(txt)}</div>`;
      }
    };
    const updatePickerVisibility = () => {
      const style = styleSelect.value;
      if (style === "text") {
        tColor.style.display = "inline-block";
        bColor.style.display = "none";
      } else if (style === "highlight") {
        tColor.style.display = "none";
        bColor.style.display = "inline-block";
      } else {
        tColor.style.display = "inline-block";
        bColor.style.display = "inline-block";
      }
    };
    const styleChange = () => {
      updatePickerVisibility();
      renderPreview();
    };
    styleSelect.addEventListener("change", styleChange);
    tColor.addEventListener("input", styleChange);
    bColor.addEventListener("input", styleChange);
    this._handlers.push({ el: styleSelect, ev: "change", fn: styleChange });
    this._handlers.push({ el: tColor, ev: "input", fn: styleChange });
    this._handlers.push({ el: bColor, ev: "input", fn: styleChange });
    updatePickerVisibility();
    renderPreview();
    const actions = contentEl.createDiv();
    actions.style.display = "flex";
    actions.style.justifyContent = "space-between";
    actions.style.marginTop = "12px";
    const resetAllBtn = actions.createEl("button", { text: this.plugin.t("btn_reset_all", "Reset Highlight Style") });
    const resetAllHandler = () => {
      const isGroup2 = this.entry && Array.isArray(this.entry.entries);
      if (this.entry) {
        this.entry.backgroundOpacity = void 0;
        this.entry.highlightBorderRadius = void 0;
        this.entry.highlightHorizontalPadding = void 0;
        this.entry.highlightVerticalPadding = void 0;
        this.entry.enableBorderThickness = void 0;
        this.entry.borderStyle = void 0;
        this.entry.borderLineStyle = void 0;
        this.entry.borderOpacity = void 0;
        this.entry.borderThickness = void 0;
        if (isGroup2) {
          this.entry.styleType = void 0;
          this.entry.color = void 0;
          this.entry.textColor = void 0;
          this.entry.backgroundColor = void 0;
        }
      }
      this._resetAllApplied = true;
      try {
        opacitySlider.value = String(this.plugin.settings.backgroundOpacity ?? 35);
        radiusInput.value = String(this.plugin.settings.highlightBorderRadius ?? 4);
        hPadInput.value = String(this.plugin.settings.highlightHorizontalPadding ?? 4);
        vPadInput.value = String(this.plugin.settings.highlightVerticalPadding ?? 0);
        enableChk.checked = !!this.plugin.settings.enableBorderThickness;
        sidesSel.value = this.plugin.settings.borderStyle ?? "full";
        lineSel.value = this.plugin.settings.borderLineStyle ?? "solid";
        bOpSlider.value = String(this.plugin.settings.borderOpacity ?? 100);
        thickInput.value = String(this.plugin.settings.borderThickness ?? 1);
        if (isGroup2) {
          styleSelect.value = "";
          pickerRow.style.display = "none";
        }
      } catch (_) {
      }
      renderPreview();
      try {
        window.dispatchEvent(new CustomEvent("act-style-updated"));
      } catch (_) {
      }
    };
    resetAllBtn.addEventListener("click", resetAllHandler);
    this._handlers.push({ el: resetAllBtn, ev: "click", fn: resetAllHandler });
    const syncEntryColorsFromInputs = () => {
      if (!this.entry) return;
      const style = styleSelect.value;
      this.entry._savedTextColor = tColor.value || this.entry._savedTextColor || this.entry.color || this.entry.textColor || "";
      this.entry._savedBackgroundColor = bColor.value || this.entry._savedBackgroundColor || this.entry.backgroundColor || "";
      if (style === "text") {
        this.entry.color = tColor.value || "";
      } else if (style === "highlight") {
        this.entry.backgroundColor = bColor.value || "";
        this.entry.textColor = "currentColor";
        this.entry.color = "";
      } else {
        this.entry.textColor = tColor.value || "";
        this.entry.backgroundColor = bColor.value || "";
        this.entry.color = "";
      }
    };
    const dispatchHighlightColorsChanged = () => {
      syncEntryColorsFromInputs();
      try {
        window.dispatchEvent(new CustomEvent("act-colors-changed", { detail: { entry: this.entry } }));
      } catch (_) {
      }
    };
    const setupHighlightColorPickerRightClick = (colorInput) => {
      colorInput.addEventListener("contextmenu", (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        const currentColor = colorInput.value || "#000000";
        const isTextPicker = colorInput === tColor;
        const modal = new ColorPickerModal(this.app, this.plugin, (color, result) => {
          const tc = result && result.textColor && this.plugin.isValidHexColor(result.textColor) ? result.textColor : null;
          const bc = result && result.backgroundColor && this.plugin.isValidHexColor(result.backgroundColor) ? result.backgroundColor : null;
          const fallback = color && this.plugin.isValidHexColor(color) ? color : null;
          let changed = false;
          if (tc) {
            tColor.value = tc;
            changed = true;
          } else if (fallback && isTextPicker) {
            tColor.value = fallback;
            changed = true;
          }
          if (bc) {
            bColor.value = bc;
            changed = true;
          } else if (fallback && !isTextPicker) {
            bColor.value = fallback;
            changed = true;
          }
          if (!changed) {
            if (currentColor && this.plugin.isValidHexColor(currentColor)) {
              if (isTextPicker) tColor.value = currentColor;
              else bColor.value = currentColor;
            }
          }
          dispatchHighlightColorsChanged();
          renderPreview();
        }, isTextPicker ? "text" : "background", this.previewTextOverride || currentColor, false);
        modal._hideHeaderControls = true;
        if (tColor.value) modal._preFillTextColor = tColor.value;
        if (bColor.value) {
          modal._preFillBgColor = bColor.value;
          modal._preFillBorderColor = bColor.value;
        }
        modal.open();
      });
    };
    setupHighlightColorPickerRightClick(tColor);
    setupHighlightColorPickerRightClick(bColor);
    const tColorInputHandler = () => {
      dispatchHighlightColorsChanged();
      renderPreview();
    };
    const bColorInputHandler = () => {
      dispatchHighlightColorsChanged();
      renderPreview();
    };
    tColor.addEventListener("input", tColorInputHandler);
    bColor.addEventListener("input", bColorInputHandler);
    this._handlers.push({ el: tColor, ev: "input", fn: tColorInputHandler });
    this._handlers.push({ el: bColor, ev: "input", fn: bColorInputHandler });
    const colorSyncHandler = (evt) => {
      try {
        if (evt.detail && evt.detail.entry && evt.detail.entry === this.entry) {
          const initTextColor = this.entry && (this.entry.textColor && this.entry.textColor !== "currentColor" ? this.entry.textColor : this.plugin.isValidHexColor(this.entry.color) ? this.entry.color : "#ffffff") || "#ffffff";
          const initBgColor = this.entry && this.entry.backgroundColor ? this.entry.backgroundColor : "#000000";
          if (this.plugin.isValidHexColor(initTextColor)) tColor.value = initTextColor;
          if (this.plugin.isValidHexColor(initBgColor)) bColor.value = initBgColor;
          renderPreview();
        }
      } catch (_) {
      }
    };
    window.addEventListener("act-colors-changed", colorSyncHandler);
    this._handlers.push({ el: window, ev: "act-colors-changed", fn: colorSyncHandler });
    styleSelect.addEventListener("change", () => {
      if (this.entry) {
        const st = styleSelect.value;
        if (isGroup && !st) {
          this.entry.styleType = void 0;
          this.entry.color = void 0;
          this.entry.textColor = void 0;
          this.entry.backgroundColor = void 0;
          pickerRow.style.display = "none";
        } else {
          this.entry.styleType = st;
          pickerRow.style.display = "";
          try {
            updatePickerVisibility();
          } catch (_) {
          }
          if (st === "text") {
            this.entry.color = tColor.value || "";
            this.entry.textColor = null;
            this.entry.backgroundColor = null;
          } else if (st === "highlight") {
            this.entry.color = "";
            this.entry.textColor = "currentColor";
            this.entry.backgroundColor = bColor.value || "";
          } else {
            this.entry.color = "";
            this.entry.textColor = tColor.value || "";
            this.entry.backgroundColor = bColor.value || "";
          }
        }
      }
      renderPreview();
    });
    const saveBtn = actions.createEl("button", { text: this.plugin.t("btn_save_style", "Save Style") });
    saveBtn.addClass("mod-cta");
    const saveData = async (shouldClose = true) => {
      if (this.entry) {
        const st = styleSelect.value;
        if (isGroup && !st) {
          this.entry.styleType = void 0;
          this.entry.color = void 0;
          this.entry.textColor = void 0;
          this.entry.backgroundColor = void 0;
        } else {
          this.entry.styleType = st;
          if (st === "text") {
            this.entry.color = tColor.value || "";
            this.entry.textColor = null;
            this.entry.backgroundColor = null;
          } else if (st === "highlight") {
            this.entry.color = "";
            this.entry.textColor = "currentColor";
            this.entry.backgroundColor = bColor.value || "";
          } else {
            this.entry.color = "";
            this.entry.textColor = tColor.value || "";
            this.entry.backgroundColor = bColor.value || "";
          }
        }
        if (this._resetAllApplied) {
          this.entry.backgroundOpacity = void 0;
          this.entry.highlightBorderRadius = void 0;
          this.entry.highlightHorizontalPadding = void 0;
          this.entry.highlightVerticalPadding = void 0;
          this.entry.enableBorderThickness = void 0;
          this.entry.borderStyle = void 0;
          this.entry.borderLineStyle = void 0;
          this.entry.borderOpacity = void 0;
          this.entry.borderThickness = void 0;
        } else {
          const rawOpacity = opacitySlider.value ? Number(opacitySlider.value) : this.plugin.settings.backgroundOpacity ?? 35;
          const rawRadius = radiusInput.value ? Number(radiusInput.value) : this.plugin.settings.highlightBorderRadius ?? 4;
          const rawHPad = hPadInput.value ? Number(hPadInput.value) : this.plugin.settings.highlightHorizontalPadding ?? 4;
          const rawVPad = vPadInput.value ? Number(vPadInput.value) : this.plugin.settings.highlightVerticalPadding ?? 0;
          const rawBOpacity = bOpSlider.value ? Number(bOpSlider.value) : this.plugin.settings.borderOpacity ?? 100;
          const rawBThickness = thickInput.value ? Number(thickInput.value) : this.plugin.settings.borderThickness ?? 1;
          this.entry.backgroundOpacity = rawOpacity;
          this.entry.highlightBorderRadius = rawRadius;
          this.entry.highlightHorizontalPadding = rawHPad;
          this.entry.highlightVerticalPadding = rawVPad;
          this.entry.enableBorderThickness = !!enableChk.checked;
          this.entry.borderStyle = sidesSel.value || (this.plugin.settings.borderStyle ?? "full");
          this.entry.borderLineStyle = lineSel.value || (this.plugin.settings.borderLineStyle ?? "solid");
          this.entry.borderOpacity = rawBOpacity;
          this.entry.borderThickness = rawBThickness;
        }
        const entryUid = this.entry.uid;
        let foundArray = null;
        let foundIdx = -1;
        for (let i = 0; i < this.plugin.settings.wordEntries.length; i++) {
          if (this.plugin.settings.wordEntries[i].uid === entryUid) {
            foundArray = this.plugin.settings.wordEntries;
            foundIdx = i;
            break;
          }
        }
        if (foundIdx === -1) {
          for (let i = 0; i < this.plugin.settings.textBgColoringEntries.length; i++) {
            if (this.plugin.settings.textBgColoringEntries[i].uid === entryUid) {
              foundArray = this.plugin.settings.textBgColoringEntries;
              foundIdx = i;
              break;
            }
          }
        }
        if (foundIdx === -1 && Array.isArray(this.plugin.settings.wordEntryGroups)) {
          for (const group of this.plugin.settings.wordEntryGroups) {
            if (group && Array.isArray(group.entries)) {
              for (let i = 0; i < group.entries.length; i++) {
                if (group.entries[i].uid === entryUid) {
                  foundArray = group.entries;
                  foundIdx = i;
                  break;
                }
              }
            }
            if (foundIdx !== -1) break;
          }
        }
        if (foundIdx !== -1 && foundArray) {
          foundArray[foundIdx].styleType = this.entry.styleType;
          foundArray[foundIdx].color = this.entry.color;
          foundArray[foundIdx].textColor = this.entry.textColor;
          foundArray[foundIdx].backgroundColor = this.entry.backgroundColor;
          foundArray[foundIdx].backgroundOpacity = this.entry.backgroundOpacity;
          foundArray[foundIdx].highlightBorderRadius = this.entry.highlightBorderRadius;
          foundArray[foundIdx].highlightHorizontalPadding = this.entry.highlightHorizontalPadding;
          foundArray[foundIdx].highlightVerticalPadding = this.entry.highlightVerticalPadding;
          foundArray[foundIdx].enableBorderThickness = this.entry.enableBorderThickness;
          foundArray[foundIdx].borderStyle = this.entry.borderStyle;
          foundArray[foundIdx].borderLineStyle = this.entry.borderLineStyle;
          foundArray[foundIdx].borderOpacity = this.entry.borderOpacity;
          foundArray[foundIdx].borderThickness = this.entry.borderThickness;
        }
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        this.plugin.compileTextBgColoringEntries();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        this.plugin.forceRefreshAllReadingViews();
        this.plugin.triggerActiveDocumentRerender();
        try {
          window.dispatchEvent(new CustomEvent("act-style-updated"));
        } catch (_) {
        }
      }
      if (this.parentEditEntryModal) {
        try {
          const parentInputs = this.parentEditEntryModal.modalEl?.querySelectorAll('input[type="color"]');
          if (parentInputs && parentInputs.length >= 2) {
            const textColorInput = parentInputs[0];
            const bgColorInput = parentInputs[1];
            const st = this.entry?.styleType || "both";
            if (st === "text" || st === "both") {
              const textColor = (this.entry?.textColor && this.entry.textColor !== "currentColor" ? this.entry.textColor : this.entry?.color) || textColorInput.value;
              if (this.plugin.isValidHexColor(textColor)) {
                textColorInput.value = textColor;
              }
            }
            if (st === "highlight" || st === "both") {
              const bgColor = this.entry?.backgroundColor || bgColorInput.value;
              if (this.plugin.isValidHexColor(bgColor)) {
                bgColorInput.value = bgColor;
              }
            }
          }
          if (typeof this.parentEditEntryModal._refreshPreview === "function") {
            this.parentEditEntryModal._refreshPreview();
          }
        } catch (e) {
        }
      }
      if (shouldClose) this.close();
    };
    const saveHandler = () => saveData(true);
    saveBtn.addEventListener("click", saveHandler);
    this._handlers.push({ el: saveBtn, ev: "click", fn: saveHandler });
    this._saveData = saveData;
  }
  onClose() {
    try {
      if (this._saveData) {
        this._saveData(false);
      }
    } catch (e) {
    }
    try {
      this._handlers.forEach((h) => {
        try {
          h.el.removeEventListener(h.ev, h.fn);
        } catch (e) {
        }
      });
    } catch (e) {
    }
    this._handlers = [];
    try {
      this.contentEl.empty();
    } catch (e) {
    }
  }
};
var EditEntryModal = class extends Modal {
  constructor(app, plugin, entry, onSaved, parentModal, fromPickColorModal = false) {
    super(app);
    this.plugin = plugin;
    this.entry = entry;
    this.parentModal = parentModal;
    this.fromPickColorModal = !!fromPickColorModal;
    if (this.entry && !this.entry.uid) {
      try {
        this.entry.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
      } catch (_) {
        this.entry.uid = Date.now();
      }
    }
    this.originalEntryUid = this.entry?.uid;
    this.onSaved = onSaved;
    this._handlers = [];
    this._dropdownCleanups = [];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      this.modalEl.addClass("act-edit-entry-modal");
      this.modalEl.style.maxWidth = "900px";
      this.modalEl.style.padding = "20px";
    } catch (e) {
    }
    const isRegex = !!(this.entry && this.entry.isRegex);
    const title = contentEl.createEl("h2", { text: this.plugin.t("edit_entry_header", "Edit Entry") });
    title.style.marginTop = "0";
    title.style.marginBottom = "12px";
    const groupsList = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : [];
    let currentGroupUid = null;
    try {
      const entryUid = this.entry && this.entry.uid ? String(this.entry.uid) : "";
      const normalizePatterns = (e) => {
        try {
          if (!e) return "";
          if (Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0) return e.groupedPatterns.map((p) => String(p || "").trim()).filter(Boolean).join(",").toLowerCase();
          return String(e.pattern || "").trim().toLowerCase();
        } catch (_) {
          return "";
        }
      };
      const keyOf = (e) => {
        try {
          if (!e) return "";
          const isR = !!e.isRegex;
          const flags = String(e.flags || "").trim();
          const m = String(e.matchType || "").trim().toLowerCase();
          const p = normalizePatterns(e);
          return `${isR ? "r" : "t"}|${flags}|${m}|${p}`;
        } catch (_) {
          return "";
        }
      };
      const entryKey = keyOf(this.entry);
      const matches = (e) => {
        try {
          if (!e) return false;
          if (entryUid && e.uid && String(e.uid || "") === entryUid) return true;
          if (entryKey) return keyOf(e) === entryKey;
          return false;
        } catch (_) {
          return false;
        }
      };
      if (Array.isArray(groupsList)) {
        for (const g of groupsList) {
          if (!g || !Array.isArray(g.entries)) continue;
          if (g.entries.some(matches)) {
            currentGroupUid = g.uid || null;
            break;
          }
        }
      }
    } catch (e) {
    }
    this.originalGroupUid = currentGroupUid;
    try {
      const entryUid = this.entry && this.entry.uid ? String(this.entry.uid) : "";
      const normalizePatterns = (e) => {
        try {
          if (!e) return "";
          if (Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0) return e.groupedPatterns.map((p) => String(p || "").trim()).filter(Boolean).join(",").toLowerCase();
          return String(e.pattern || "").trim().toLowerCase();
        } catch (_) {
          return "";
        }
      };
      const keyOf = (e) => {
        try {
          if (!e) return "";
          const isR = !!e.isRegex;
          const flags = String(e.flags || "").trim();
          const m = String(e.matchType || "").trim().toLowerCase();
          const p = normalizePatterns(e);
          return `${isR ? "r" : "t"}|${flags}|${m}|${p}`;
        } catch (_) {
          return "";
        }
      };
      const entryKey = keyOf(this.entry);
      const matches = (e) => {
        try {
          if (!e) return false;
          if (entryUid && e.uid && String(e.uid || "") === entryUid) return true;
          if (entryKey) return keyOf(e) === entryKey;
          return false;
        } catch (_) {
          return false;
        }
      };
      const settings = this.plugin.settings;
      let found = null;
      if (currentGroupUid && Array.isArray(groupsList)) {
        const currentGroup = groupsList.find((g) => g && g.uid === currentGroupUid);
        if (currentGroup && Array.isArray(currentGroup.entries)) {
          found = currentGroup.entries.find(matches) || null;
        }
      }
      if (!found && Array.isArray(settings.wordEntries)) {
        found = settings.wordEntries.find(matches) || null;
      }
      if (!found && Array.isArray(groupsList)) {
        for (const g of groupsList) {
          if (!g || !Array.isArray(g.entries) || g.uid === currentGroupUid) continue;
          found = g.entries.find(matches) || null;
          if (found) break;
        }
      }
      if (found) this.entry = found;
    } catch (e) {
    }
    const mainContainer = contentEl.createDiv();
    mainContainer.style.display = "flex";
    mainContainer.style.gap = "8px";
    mainContainer.style.width = "100%";
    mainContainer.style.boxSizing = "border-box";
    const leftColumn = mainContainer.createDiv();
    leftColumn.addClass("act-edit-entry-left-column");
    leftColumn.style.flex = "1";
    leftColumn.style.minWidth = "0";
    leftColumn.style.display = "flex";
    leftColumn.style.flexDirection = "column";
    const row1 = leftColumn.createDiv();
    row1.addClass("act-edit-entry-row1");
    const box = row1.createDiv();
    box.addClass("act-edit-entry-textbox");
    box.style.border = "1px solid var(--background-modifier-border)";
    box.style.borderRadius = "4px";
    box.style.background = "var(--background-modifier-form-field)";
    const textInput = box.createEl("textarea");
    textInput.style.width = "100%";
    textInput.style.height = "40px";
    textInput.style.resize = "none";
    textInput.style.border = "none";
    textInput.style.outline = "none";
    textInput.style.background = "transparent";
    textInput.style.color = "var(--text-normal)";
    textInput.style.padding = "6px";
    textInput.style.boxSizing = "border-box";
    const row2 = leftColumn.createDiv();
    row2.addClass("act-edit-entry-row2");
    const preview = row2.createDiv();
    preview.addClass("act-edit-entry-preview");
    preview.style.flex = "1";
    preview.style.border = "1px dashed var(--background-modifier-border)";
    preview.style.borderRadius = "4px";
    preview.style.padding = "10px";
    preview.style.background = "var(--background-modifier-form-field)";
    preview.style.whiteSpace = "pre-wrap";
    preview.style.wordWrap = "break-word";
    preview.style.minHeight = "60px";
    const rightColumn = mainContainer.createDiv();
    rightColumn.addClass("act-edit-entry-right-column");
    rightColumn.style.flex = "0 0 auto";
    rightColumn.style.display = "flex";
    rightColumn.style.flexDirection = "column";
    rightColumn.style.gap = "8px";
    const styleSelect = rightColumn.createEl("select");
    styleSelect.addClass("act-edit-entry-style-select");
    styleSelect.style.minWidth = "140px";
    ["text", "highlight", "both"].forEach((val) => {
      const opt = styleSelect.createEl("option", { text: this.plugin.t("style_type_" + val, val === "text" ? "color" : val) });
      opt.value = val;
    });
    styleSelect.style.border = "1px solid var(--background-modifier-border)";
    styleSelect.style.borderRadius = "4px";
    styleSelect.style.background = "var(--background-modifier-form-field)";
    styleSelect.style.textAlign = "center";
    styleSelect.style.flex = "1 0%";
    const pickerRow = rightColumn.createDiv();
    pickerRow.addClass("act-edit-entry-pickers");
    pickerRow.style.flex = "0";
    pickerRow.style.display = "flex";
    pickerRow.style.gap = "8px";
    pickerRow.style.alignItems = "center";
    pickerRow.style.justifyContent = "center";
    const textColorInput = pickerRow.createEl("input", { type: "color" });
    const bgColorInput = pickerRow.createEl("input", { type: "color" });
    const dispatchColorsChanged = () => {
      try {
        window.dispatchEvent(new CustomEvent("act-colors-changed", { detail: { entry: this.entry } }));
      } catch (_) {
      }
      renderPreview();
    };
    const applyTextColorToEntry = (dispatch = true) => {
      const style = styleSelect.value;
      if (this.entry) this.entry._savedTextColor = textColorInput.value || this.entry._savedTextColor || this.entry.color || this.entry.textColor || "";
      if (style === "text") {
        this.entry.color = textColorInput.value || "";
      } else if (style === "both") {
        this.entry.textColor = textColorInput.value || "";
      }
      if (dispatch) dispatchColorsChanged();
    };
    const applyBgColorToEntry = (dispatch = true) => {
      const style = styleSelect.value;
      if (this.entry) this.entry._savedBackgroundColor = bgColorInput.value || this.entry._savedBackgroundColor || this.entry.backgroundColor || "";
      if (style === "highlight") {
        this.entry.backgroundColor = bgColorInput.value || "";
      } else if (style === "both") {
        this.entry.backgroundColor = bgColorInput.value || "";
      }
      if (dispatch) dispatchColorsChanged();
    };
    const setupColorPickerRightClick = (colorInput, onColorSelected) => {
      colorInput.addEventListener("contextmenu", (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        const currentColor = colorInput.value || "#000000";
        const displayText = this.entry && this.entry.isRegex ? this.entry.pattern || "" : Array.isArray(this.entry.groupedPatterns) && this.entry.groupedPatterns.length > 0 ? this.entry.groupedPatterns.map((p) => String(p).trim()).join(", ") : this.entry && this.entry.pattern ? String(this.entry.pattern) : "";
        const isTextPicker = colorInput === textColorInput;
        const modal = new ColorPickerModal(this.app, this.plugin, (color, result) => {
          const tc = result && result.textColor && this.plugin.isValidHexColor(result.textColor) ? result.textColor : null;
          const bc = result && result.backgroundColor && this.plugin.isValidHexColor(result.backgroundColor) ? result.backgroundColor : null;
          const fallback = color && this.plugin.isValidHexColor(color) ? color : null;
          let changed = false;
          if (tc) {
            textColorInput.value = tc;
            changed = true;
          } else if (fallback && isTextPicker) {
            textColorInput.value = fallback;
            changed = true;
          }
          if (bc) {
            bgColorInput.value = bc;
            changed = true;
          } else if (fallback && !isTextPicker) {
            bgColorInput.value = fallback;
            changed = true;
          }
          if (!changed) {
            if (currentColor && this.plugin.isValidHexColor(currentColor)) {
              if (isTextPicker) textColorInput.value = currentColor;
              else bgColorInput.value = currentColor;
            }
          }
          applyTextColorToEntry(false);
          applyBgColorToEntry(false);
          dispatchColorsChanged();
        }, isTextPicker ? "text" : "background", displayText, false);
        modal._hideHeaderControls = true;
        if (textColorInput.value) modal._preFillTextColor = textColorInput.value;
        if (bgColorInput.value) modal._preFillBgColor = bgColorInput.value;
        modal.open();
      });
    };
    setupColorPickerRightClick(textColorInput, applyTextColorToEntry);
    setupColorPickerRightClick(bgColorInput, applyBgColorToEntry);
    textColorInput.addEventListener("input", applyTextColorToEntry);
    this._handlers.push({ el: textColorInput, ev: "input", fn: applyTextColorToEntry });
    bgColorInput.addEventListener("input", applyBgColorToEntry);
    this._handlers.push({ el: bgColorInput, ev: "input", fn: applyBgColorToEntry });
    const colorSyncHandler = (evt) => {
      try {
        if (evt.detail && evt.detail.entry && evt.detail.entry === this.entry) {
          const initTextColor2 = this.entry && (this.entry.textColor && this.entry.textColor !== "currentColor" ? this.entry.textColor : this.plugin.isValidHexColor(this.entry.color) ? this.entry.color : "") || textColorInput.value || "#000000";
          const initBgColor2 = this.entry && (this.entry.backgroundColor || "") || bgColorInput.value || "#000000";
          if (this.plugin.isValidHexColor(initTextColor2)) textColorInput.value = initTextColor2;
          if (this.plugin.isValidHexColor(initBgColor2)) bgColorInput.value = initBgColor2;
          renderPreview();
        }
      } catch (_) {
      }
    };
    window.addEventListener("act-colors-changed", colorSyncHandler);
    this._handlers.push({ el: window, ev: "act-colors-changed", fn: colorSyncHandler });
    const controls = contentEl.createDiv();
    controls.addClass("act-edit-entry-controls");
    controls.style.display = "flex";
    controls.style.flexWrap = "wrap";
    controls.style.gap = "8px";
    controls.style.marginTop = "12px";
    controls.style.alignItems = "center";
    controls.style.width = "100%";
    controls.style.boxSizing = "border-box";
    const groupSelect = controls.createEl("select");
    groupSelect.addClass("act-edit-entry-group-select");
    groupSelect.style.flex = "1 1 max-content";
    groupSelect.style.minWidth = "max-content";
    groupSelect.style.maxWidth = "100%";
    groupSelect.style.width = "auto";
    groupSelect.style.height = "32px";
    groupSelect.style.padding = "0 10px";
    groupSelect.style.boxSizing = "border-box";
    groupSelect.style.border = "1px solid var(--background-modifier-border)";
    groupSelect.style.borderRadius = "4px";
    groupSelect.style.background = "var(--background-modifier-form-field)";
    groupSelect.style.textAlign = "center";
    const defaultOpt = groupSelect.createEl("option", { text: this.plugin.t("default") });
    defaultOpt.value = "";
    groupsList.forEach((g) => {
      const name = g && g.name && String(g.name).trim().length > 0 ? g.name : "(unnamed group)";
      const opt = groupSelect.createEl("option", { text: name });
      opt.value = g.uid || "";
    });
    groupSelect.value = currentGroupUid || "";
    if (!currentGroupUid && this.fromPickColorModal && this.entry && this.entry._preselectedGroupUid) {
      groupSelect.value = this.entry._preselectedGroupUid || "";
    }
    if (!groupsList || groupsList.length === 0) {
      groupSelect.style.display = "none";
    }
    const groupChangeHandler = async () => {
      const newGroupUid = groupSelect.value || "";
      const originalGroupUid = this.originalGroupUid;
      if (newGroupUid === originalGroupUid) return;
      const settings = this.plugin.settings;
      if (!Array.isArray(settings.wordEntries)) settings.wordEntries = [];
      if (!Array.isArray(settings.wordEntryGroups)) settings.wordEntryGroups = [];
      const wordEntriesIdx = settings.wordEntries.indexOf(this.entry);
      if (wordEntriesIdx !== -1) {
        settings.wordEntries.splice(wordEntriesIdx, 1);
      }
      for (const group of settings.wordEntryGroups) {
        if (group && Array.isArray(group.entries)) {
          const groupIdx = group.entries.indexOf(this.entry);
          if (groupIdx !== -1) {
            group.entries.splice(groupIdx, 1);
          }
        }
      }
      if (newGroupUid === "") {
        try {
          delete this.entry.groupUid;
        } catch (_) {
        }
        settings.wordEntries.push(this.entry);
      } else {
        const newGroup = settings.wordEntryGroups.find((g) => g && g.uid === newGroupUid);
        if (newGroup) {
          if (!Array.isArray(newGroup.entries)) newGroup.entries = [];
          try {
            this.entry.groupUid = newGroupUid;
          } catch (_) {
          }
          newGroup.entries.push(this.entry);
        }
      }
      currentGroupUid = newGroupUid;
      await this.plugin.saveSettings();
      this.plugin.compileWordEntries();
      this.plugin.compileTextBgColoringEntries();
      this.plugin.reconfigureEditorExtensions();
      this.plugin.forceRefreshAllEditors();
      this.plugin.forceRefreshAllReadingViews();
      this.plugin.triggerActiveDocumentRerender();
      try {
        if (typeof this.onSaved === "function") this.onSaved();
      } catch (_) {
      }
      try {
        if (this.parentModal && typeof this.parentModal._refreshEntries === "function") this.parentModal._refreshEntries();
      } catch (_) {
      }
      try {
        if (this.plugin.settingTab && typeof this.plugin.settingTab._refreshEntries === "function") this.plugin.settingTab._refreshEntries();
      } catch (_) {
      }
    };
    groupSelect.addEventListener("change", groupChangeHandler);
    this._handlers.push({ el: groupSelect, ev: "change", fn: groupChangeHandler });
    const matchSelect = controls.createEl("select");
    matchSelect.style.flex = "0.5 0 auto";
    matchSelect.style.minWidth = "160px";
    matchSelect.style.height = "32px";
    matchSelect.style.padding = "0 10px";
    matchSelect.style.boxSizing = "border-box";
    matchSelect.style.border = "1px solid var(--background-modifier-border)";
    matchSelect.style.borderRadius = "4px";
    matchSelect.style.background = "var(--background-modifier-form-field)";
    matchSelect.style.textAlign = "center";
    matchSelect.innerHTML = `<option value="exact">${this.plugin.t("match_option_exact", "exact")}</option><option value="contains">${this.plugin.t("match_option_contains", "contains")}</option><option value="startsWith">${this.plugin.t("match_option_starts_with", "starts with")}</option><option value="endsWith">${this.plugin.t("match_option_ends_with", "ends with")}</option>`;
    const caseSel = controls.createEl("select");
    caseSel.style.flex = "0.5 0 auto";
    caseSel.style.minWidth = "160px";
    caseSel.style.height = "32px";
    caseSel.style.padding = "0 10px";
    caseSel.style.boxSizing = "border-box";
    caseSel.style.border = "1px solid var(--background-modifier-border)";
    caseSel.style.borderRadius = "4px";
    caseSel.style.background = "var(--background-modifier-form-field)";
    caseSel.style.textAlign = "center";
    caseSel.innerHTML = `<option value="case">${this.plugin.t("opt_case_sensitive", "is case sensitive")}</option><option value="nocase">${this.plugin.t("opt_not_case_sensitive", "not case sensitive")}</option>`;
    let openRegexBtn = null;
    if (isRegex) {
      openRegexBtn = controls.createEl("button", { text: this.plugin.t("open_in_regex_tester", "Open in Regex Tester") });
      openRegexBtn.style.flex = "1 1 max-content";
      openRegexBtn.style.minWidth = "max-content";
      openRegexBtn.style.maxWidth = "100%";
      openRegexBtn.style.width = "auto";
      openRegexBtn.style.height = "32px";
      openRegexBtn.style.padding = "0 10px";
      openRegexBtn.style.boxSizing = "border-box";
      openRegexBtn.style.whiteSpace = "nowrap";
    }
    const hlBtn = controls.createEl("button", { text: this.plugin.t("edit_highlight_styling_btn", "Edit Highlight Styling") });
    hlBtn.style.flex = "1 1 max-content";
    hlBtn.style.minWidth = "max-content";
    hlBtn.style.maxWidth = "100%";
    hlBtn.style.width = "auto";
    hlBtn.style.height = "32px";
    hlBtn.style.padding = "0 10px";
    hlBtn.style.boxSizing = "border-box";
    hlBtn.style.whiteSpace = "nowrap";
    const rulesHeader = contentEl.createEl("h3", { text: this.plugin.t("inclusion_exclusion_header", "Inclusion / Exclusion Rules") });
    const rulesContainer = contentEl.createDiv();
    rulesContainer.style.marginTop = "8px";
    const addRuleBtn = contentEl.createEl("button", { text: this.plugin.t("btn_add_rule", "+ Add Rule") });
    addRuleBtn.addClass("mod-cta");
    addRuleBtn.style.marginTop = "6px";
    let initialStyle = this.entry && this.entry.styleType ? this.entry.styleType : null;
    if (!initialStyle) {
      const hasText = !!(this.entry && (this.entry.textColor && this.entry.textColor !== "currentColor" || this.entry.color));
      const hasBg = !!(this.entry && this.entry.backgroundColor);
      initialStyle = hasText && hasBg ? "both" : hasBg ? "highlight" : "text";
    }
    styleSelect.value = initialStyle || "text";
    const initTextColor = this.entry && (this.entry.textColor && this.entry.textColor !== "currentColor" ? this.entry.textColor : this.plugin.isValidHexColor(this.entry.color) ? this.entry.color : "") || textColorInput.value || "#000000";
    const initBgColor = this.entry && (this.entry.backgroundColor || "") || bgColorInput.value || "#000000";
    textColorInput.value = this.plugin.isValidHexColor(initTextColor) ? initTextColor : "#000000";
    if (initBgColor) bgColorInput.value = this.plugin.isValidHexColor(initBgColor) ? initBgColor : "#000000";
    if (isRegex) {
      textInput.value = this.entry.pattern || "";
      matchSelect.disabled = true;
      matchSelect.style.opacity = "0.5";
      caseSel.disabled = true;
      caseSel.style.opacity = "0.5";
    } else {
      const patterns = Array.isArray(this.entry.groupedPatterns) && this.entry.groupedPatterns.length > 0 ? this.entry.groupedPatterns : [String(this.entry.pattern || "")];
      textInput.value = patterns.map((p) => String(p).trim()).join(", ");
      let defaultMatch = typeof this.entry.matchType === "string" && this.entry.matchType ? this.entry.matchType.toLowerCase() : this.plugin.settings.partialMatch ? "contains" : "exact";
      if (defaultMatch === "startswith" || defaultMatch === "starts with") defaultMatch = "startswith";
      if (defaultMatch === "endswith" || defaultMatch === "ends with") defaultMatch = "endswith";
      matchSelect.value = defaultMatch === "startswith" ? "startsWith" : defaultMatch === "endswith" ? "endsWith" : defaultMatch;
    }
    const isCase = typeof this.entry.caseSensitive === "boolean" ? this.entry.caseSensitive : !!this.plugin.settings.caseSensitive;
    caseSel.value = isCase ? "case" : "nocase";
    const renderPreview = () => {
      const raw = String(textInput.value || "");
      const style = styleSelect.value;
      const t = textColorInput.value;
      const b = bgColorInput.value;
      const p = this.plugin.getHighlightParams(this.entry);
      const rgba = this.plugin.hexToRgba(b, p.opacity ?? 25);
      const radius = p.radius ?? 8;
      const pad = p.hPad ?? 4;
      const vpad = p.vPad ?? 0;
      const borderStyle = style === "text" ? "" : style === "highlight" ? this.plugin.generateBorderStyle(null, b, this.entry) : this.plugin.generateBorderStyle(t, b, this.entry);
      const sText = `color:${t};background:transparent;`;
      const sHighlight = `background-color:${rgba};border-radius:${radius}px;padding:${vpad}px ${pad}px;color:var(--text-normal);${borderStyle}`;
      const sBoth = `color:${t};background-color:${rgba};border-radius:${radius}px;padding:${vpad}px ${pad}px;${borderStyle}`;
      const styleStr = style === "text" ? sText : style === "highlight" ? sHighlight : sBoth;
      while (preview.firstChild) preview.removeChild(preview.firstChild);
      if (!raw) return;
      const words = raw.split(",").map((w) => w.trim()).filter(Boolean);
      const makeDiv = (text) => {
        const div = document.createElement("div");
        div.setAttribute("style", styleStr);
        div.textContent = text;
        return div;
      };
      if (words.length > 1) {
        words.forEach((w) => preview.appendChild(makeDiv(w)));
      } else {
        preview.appendChild(makeDiv(raw));
      }
    };
    if (openRegexBtn) {
      const openRegexFn = async () => {
        try {
          if (!this.entry || !this.entry.isRegex) return;
          const modal = new RealTimeRegexTesterModal(this.app, this.plugin, () => {
            try {
              textInput.value = this.entry.pattern || "";
            } catch (_) {
            }
            try {
              renderPreview();
            } catch (_) {
            }
          });
          modal._editingEntry = this.entry;
          if (this.entry.pattern) modal._preFillPattern = this.entry.pattern;
          if (this.entry.flags) modal._preFillFlags = this.entry.flags;
          if (this.entry.presetLabel) modal._preFillName = this.entry.presetLabel;
          if (this.entry.styleType) modal._preFillStyleType = this.entry.styleType;
          if (this.entry.color) modal._preFillTextColor = this.entry.color;
          else if (this.entry.textColor) modal._preFillTextColor = this.entry.textColor;
          else if (this.entry._savedTextColor) modal._preFillTextColor = this.entry._savedTextColor;
          if (this.entry.backgroundColor) modal._preFillBgColor = this.entry.backgroundColor;
          else if (this.entry._savedBackgroundColor) modal._preFillBgColor = this.entry._savedBackgroundColor;
          modal.open();
        } catch (e) {
          new Notice(this.plugin.t("notice_error_opening_regex_tester", "Error opening regex tester"));
        }
      };
      openRegexBtn.addEventListener("click", openRegexFn);
      this._handlers.push({ el: openRegexBtn, ev: "click", fn: openRegexFn });
    }
    const updatePickerVisibility = () => {
      const v = styleSelect.value;
      if (v === "text") {
        textColorInput.style.display = "inline-block";
        bgColorInput.style.display = "none";
        pickerRow.style.flexDirection = "row";
      } else if (v === "highlight") {
        textColorInput.style.display = "none";
        bgColorInput.style.display = "inline-block";
        pickerRow.style.flexDirection = "row";
      } else {
        textColorInput.style.display = "inline-block";
        bgColorInput.style.display = "inline-block";
        pickerRow.style.flexDirection = "row";
      }
      hlBtn.style.display = v === "text" ? "none" : "";
    };
    const onInputImmediate = () => {
      renderPreview();
    };
    const styleChange = async () => {
      const nextStyle = styleSelect.value;
      const curr = this.entry;
      if (nextStyle === "text") {
        curr._savedTextColor = textColorInput.value || curr._savedTextColor || curr.color || "";
        curr._savedBackgroundColor = bgColorInput.value || curr._savedBackgroundColor || "";
        curr.color = textColorInput.value || curr.color || "";
        curr.textColor = null;
        curr.backgroundColor = null;
      } else if (nextStyle === "highlight") {
        curr._savedTextColor = textColorInput.value || curr._savedTextColor || "";
        curr._savedBackgroundColor = bgColorInput.value || curr._savedBackgroundColor || "";
        curr.backgroundColor = bgColorInput.value || curr.backgroundColor || "";
        curr.textColor = "currentColor";
        curr.color = "";
      } else {
        curr.textColor = textColorInput.value || "";
        curr.backgroundColor = bgColorInput.value || "";
        curr.color = "";
        curr._savedTextColor = textColorInput.value || curr._savedTextColor || "";
        curr._savedBackgroundColor = bgColorInput.value || curr._savedBackgroundColor || "";
      }
      curr.styleType = nextStyle;
      updatePickerVisibility();
      renderPreview();
    };
    textInput.addEventListener("input", onInputImmediate);
    this._handlers.push({ el: textInput, ev: "input", fn: onInputImmediate });
    styleSelect.addEventListener("change", styleChange);
    this._handlers.push({ el: styleSelect, ev: "change", fn: styleChange });
    const hlFn = () => {
      new HighlightStylingModal(this.app, this.plugin, this.entry, this).open();
    };
    hlBtn.addEventListener("click", hlFn);
    this._handlers.push({ el: hlBtn, ev: "click", fn: hlFn });
    try {
      const styleUpdateHandler = () => {
        renderPreview();
      };
      window.addEventListener("act-style-updated", styleUpdateHandler);
      this._handlers.push({ el: window, ev: "act-style-updated", fn: styleUpdateHandler });
    } catch (e) {
    }
    const caseFn = async () => {
      const v = caseSel.value;
      this.entry.caseSensitive = v === "case";
      const idx = this.plugin.settings.wordEntries.indexOf(this.entry);
      if (idx !== -1) this.plugin.settings.wordEntries[idx].caseSensitive = v === "case";
      await this.plugin.saveSettings();
      this.plugin.compileWordEntries();
      this.plugin.compileTextBgColoringEntries();
      this.plugin.reconfigureEditorExtensions();
      this.plugin.forceRefreshAllEditors();
      this.plugin.forceRefreshAllReadingViews();
      this.plugin.triggerActiveDocumentRerender();
    };
    caseSel.addEventListener("change", caseFn);
    this._handlers.push({ el: caseSel, ev: "change", fn: caseFn });
    const matchFn = async () => {
      if (isRegex) return;
      let value = matchSelect.value;
      if (value === "startsWith") value = "startswith";
      if (value === "endsWith") value = "endswith";
      this.entry.matchType = value;
      const idx = this.plugin.settings.wordEntries.indexOf(this.entry);
      if (idx !== -1) this.plugin.settings.wordEntries[idx].matchType = value;
      await this.plugin.saveSettings();
      this.plugin.compileWordEntries();
      this.plugin.compileTextBgColoringEntries();
      this.plugin.reconfigureEditorExtensions();
      this.plugin.forceRefreshAllEditors();
      this.plugin.forceRefreshAllReadingViews();
      this.plugin.triggerActiveDocumentRerender();
    };
    matchSelect.addEventListener("change", matchFn);
    this._handlers.push({ el: matchSelect, ev: "change", fn: matchFn });
    const buildSuggestions = () => {
      const files = this.plugin.app.vault.getFiles();
      const folders = /* @__PURE__ */ new Set();
      const filePaths = [];
      files.forEach((f) => {
        const p = String(f.path).replace(/\\/g, "/");
        filePaths.push(p);
        const idx = p.lastIndexOf("/");
        const folder = idx !== -1 ? p.slice(0, idx) : "";
        if (folder) {
          const parts = folder.split("/");
          let acc = "";
          parts.forEach((part) => {
            acc = acc ? acc + "/" + part : part;
            folders.add(acc);
          });
        }
      });
      return { files: filePaths.sort(), folders: Array.from(folders).sort() };
    };
    const sugg = buildSuggestions();
    const renderRules = () => {
      rulesContainer.empty();
      const inc = Array.isArray(this.entry.inclusionRules) ? this.entry.inclusionRules : [];
      const exc = Array.isArray(this.entry.exclusionRules) ? this.entry.exclusionRules : [];
      const combined = [
        ...inc.map((r, idx) => ({ ...r, _mode: "include", _idx: idx })),
        ...exc.map((r, idx) => ({ ...r, _mode: "exclude", _idx: idx }))
      ];
      combined.forEach((r) => {
        const row = rulesContainer.createDiv();
        row.style.display = "flex";
        row.style.gap = "8px";
        row.style.alignItems = "center";
        row.style.marginBottom = "8px";
        const modeSel = row.createEl("select");
        const optIn = modeSel.createEl("option", { text: this.plugin.t("mode_only_colors_in", "only colors in") });
        optIn.value = "include";
        const optEx = modeSel.createEl("option", { text: this.plugin.t("mode_does_not_color_in", "does not color in") });
        optEx.value = "exclude";
        modeSel.value = r._mode === "exclude" ? "exclude" : "include";
        modeSel.style.textAlign = "center";
        modeSel.style.minWidth = "160px";
        modeSel.style.border = "1px solid var(--background-modifier-border)";
        modeSel.style.borderRadius = "var(--radius-m)";
        modeSel.style.background = "var(--background-modifier-form-field)";
        const pathInput = row.createEl("input", { type: "text", value: String(r.path || ""), placeholder: this.plugin.t("enter_path_or_pattern", "Enter path, pattern or tags") });
        pathInput.style.flex = "1";
        pathInput.style.padding = "6px";
        pathInput.style.border = "1px solid var(--background-modifier-border)";
        pathInput.style.borderRadius = "var(--radius-m)";
        const delBtn = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
        delBtn.addClass("mod-warning");
        const modeHandler = async () => {
          const currMode = r._mode;
          const nextMode = modeSel.value === "exclude" ? "exclude" : "include";
          if (currMode === nextMode) return;
          try {
            if (currMode === "include") {
              const idx = inc.indexOf(inc[r._idx]);
              if (idx > -1) inc.splice(idx, 1);
              exc.push({ path: String(r.path || ""), isRegex: !!r.isRegex, flags: String(r.flags || "").replace(/[^gimsuy]/g, "") });
            } else {
              const idx = exc.indexOf(exc[r._idx]);
              if (idx > -1) exc.splice(idx, 1);
              inc.push({ path: String(r.path || ""), isRegex: !!r.isRegex, flags: String(r.flags || "").replace(/[^gimsuy]/g, "") });
            }
            this.entry.inclusionRules = inc;
            this.entry.exclusionRules = exc;
            await this.plugin.saveSettings();
            renderRules();
          } catch (e) {
          }
        };
        modeSel.addEventListener("change", modeHandler);
        const updateDropdown = () => {
          if (pathInput._actDropdown) {
            const dd2 = pathInput._actDropdown;
            if (pathInput._dropdownScrollListener) {
              document.removeEventListener("scroll", pathInput._dropdownScrollListener, true);
              pathInput._dropdownScrollListener = null;
            }
            if (pathInput._dropdownClickListener) {
              document.removeEventListener("click", pathInput._dropdownClickListener);
              pathInput._dropdownClickListener = null;
            }
            if (pathInput._dropdownKeyListener) {
              document.removeEventListener("keydown", pathInput._dropdownKeyListener);
              pathInput._dropdownKeyListener = null;
            }
            dd2.remove();
            pathInput._actDropdown = null;
          }
          const val = String(pathInput.value || "").trim().toLowerCase();
          const list = [];
          sugg.folders.forEach((f) => list.push({ t: "folder", p: f }));
          sugg.files.forEach((f) => list.push({ t: "file", p: f }));
          const filteredList = val ? list.filter((x) => x.p.toLowerCase().includes(val)) : list;
          if (filteredList.length === 0) return;
          const dd = document.createElement("div");
          Object.assign(dd.style, { position: "fixed", zIndex: 2e3, background: "var(--background-primary)", color: "var(--text-normal)", border: "1px solid var(--background-modifier-border)", borderRadius: "6px", boxShadow: "0 6px 18px rgba(0,0,0,0.4)", maxHeight: "240px", overflowY: "auto", padding: "6px 0", minWidth: Math.max(240, pathInput.offsetWidth) + "px" });
          let hi = -1;
          filteredList.forEach((item) => {
            const it = document.createElement("div");
            it.textContent = item.p || "/";
            Object.assign(it.style, { padding: "8px 12px", cursor: "pointer", whiteSpace: "nowrap" });
            it.onmouseenter = () => {
              if (hi >= 0 && dd.children[hi]) dd.children[hi].style.background = "transparent";
              it.style.background = "var(--background-secondary)";
              hi = Array.from(dd.children).indexOf(it);
            };
            it.onmouseleave = () => {
              it.style.background = "transparent";
            };
            it.onclick = (e) => {
              e.stopPropagation();
              pathInput.value = item.p + (item.t === "folder" ? "/" : "");
              const ev = new Event("change", { bubbles: true });
              pathInput.dispatchEvent(ev);
              dd.remove();
              pathInput._actDropdown = null;
            };
            dd.appendChild(it);
          });
          document.body.appendChild(dd);
          const pos = () => {
            const rct = pathInput.getBoundingClientRect();
            dd.style.left = rct.left + "px";
            dd.style.top = rct.bottom + 6 + "px";
            dd.style.width = pathInput.offsetWidth + "px";
          };
          pos();
          pathInput._actDropdown = dd;
          pathInput._dropdownScrollListener = pos;
          pathInput._dropdownClickListener = (ev) => {
            if (ev.target === pathInput) return;
            if (!dd.contains(ev.target)) {
              dd.remove();
              pathInput._actDropdown = null;
              document.removeEventListener("click", pathInput._dropdownClickListener);
              document.removeEventListener("scroll", pathInput._dropdownScrollListener, true);
              document.removeEventListener("keydown", pathInput._dropdownKeyListener);
              pathInput._dropdownClickListener = null;
              pathInput._dropdownScrollListener = null;
              pathInput._dropdownKeyListener = null;
            }
          };
          pathInput._dropdownKeyListener = (ev) => {
            const items = Array.from(dd.children);
            if (items.length === 0) return;
            if (ev.key === "ArrowDown") {
              ev.preventDefault();
              hi = Math.min(hi + 1, items.length - 1);
              items.forEach((item) => item.style.background = "transparent");
              if (hi >= 0) {
                items[hi].style.background = "var(--background-secondary)";
                items[hi].scrollIntoView({ block: "nearest" });
              }
            } else if (ev.key === "ArrowUp") {
              ev.preventDefault();
              hi = Math.max(hi - 1, -1);
              items.forEach((item) => item.style.background = "transparent");
              if (hi >= 0) {
                items[hi].style.background = "var(--background-secondary)";
                items[hi].scrollIntoView({ block: "nearest" });
              }
            } else if (ev.key === "Enter" && hi >= 0) {
              ev.preventDefault();
              items[hi].click();
            } else if (ev.key === "Escape") {
              ev.preventDefault();
              dd.remove();
              pathInput._actDropdown = null;
              document.removeEventListener("keydown", pathInput._dropdownKeyListener);
              pathInput._dropdownKeyListener = null;
            }
          };
          document.addEventListener("scroll", pos, true);
          document.addEventListener("click", pathInput._dropdownClickListener);
          document.addEventListener("keydown", pathInput._dropdownKeyListener);
          this._dropdownCleanups.push(() => {
            if (pathInput._actDropdown) {
              const dd2 = pathInput._actDropdown;
              if (pathInput._dropdownScrollListener) document.removeEventListener("scroll", pathInput._dropdownScrollListener, true);
              if (pathInput._dropdownClickListener) document.removeEventListener("click", pathInput._dropdownClickListener);
              if (pathInput._dropdownKeyListener) document.removeEventListener("keydown", pathInput._dropdownKeyListener);
              dd2.remove();
              pathInput._actDropdown = null;
            }
          });
        };
        const pathHandler = async () => {
          const newPath = String(pathInput.value || "");
          try {
            if (r._mode === "include") {
              inc[r._idx].path = newPath;
            } else {
              exc[r._idx].path = newPath;
            }
            this.entry.inclusionRules = inc;
            this.entry.exclusionRules = exc;
            await this.plugin.saveSettings();
          } catch (e) {
          }
        };
        pathInput.addEventListener("focus", updateDropdown);
        pathInput.addEventListener("click", updateDropdown);
        pathInput.addEventListener("input", updateDropdown);
        pathInput.addEventListener("change", pathHandler);
        const delHandler = async () => {
          try {
            if (r._mode === "include") {
              if (inc[r._idx]) inc.splice(r._idx, 1);
            } else {
              if (exc[r._idx]) exc.splice(r._idx, 1);
            }
            this.entry.inclusionRules = inc;
            this.entry.exclusionRules = exc;
            await this.plugin.saveSettings();
            renderRules();
          } catch (e) {
          }
        };
        delBtn.addEventListener("click", delHandler);
      });
      if (combined.length === 0) {
      }
    };
    const addRuleFn = async () => {
      try {
        if (!Array.isArray(this.entry.inclusionRules)) this.entry.inclusionRules = [];
        this.entry.inclusionRules.push({ path: "", isRegex: false, flags: "" });
        await this.plugin.saveSettings();
        renderRules();
      } catch (e) {
      }
    };
    addRuleBtn.addEventListener("click", addRuleFn);
    this._handlers.push({ el: addRuleBtn, ev: "click", fn: addRuleFn });
    renderRules();
    updatePickerVisibility();
    renderPreview();
    const saveRow = contentEl.createDiv();
    saveRow.style.display = "flex";
    saveRow.style.justifyContent = "flex-end";
    saveRow.style.marginTop = "14px";
    const saveBtn = saveRow.createEl("button", { text: this.plugin.t("btn_save_entry", "Save Entry") });
    saveBtn.addClass("mod-cta");
    const saveHandler = async (shouldClose = true) => {
      const st = styleSelect.value;
      let matchTypeVal = isRegex ? "regex" : matchSelect.value;
      if (matchTypeVal === "startsWith") matchTypeVal = "startswith";
      if (matchTypeVal === "endsWith") matchTypeVal = "endswith";
      const caseSensitiveVal = caseSel.value === "case";
      const textColorVal = textColorInput.value || "";
      const bgColorVal = bgColorInput.value || "";
      const patternVal = String(textInput.value || "").trim();
      if (this.entry._isNewFromPickModal && this.entry._originalState) {
        const originalState = this.entry._originalState;
        const hasChanges = patternVal !== originalState.pattern || st !== originalState.styleType || textColorVal !== originalState.color || bgColorVal !== originalState.backgroundColor || matchTypeVal !== originalState.matchType;
        if (!hasChanges) {
          if (shouldClose) this.close();
          return;
        }
      }
      this.plugin.settings.caseSensitive = caseSensitiveVal;
      const entryUid = this.entry.uid;
      let foundEntry = null;
      let foundIdx = -1;
      let foundArray = null;
      for (let i = 0; i < this.plugin.settings.wordEntries.length; i++) {
        if (this.plugin.settings.wordEntries[i].uid === entryUid) {
          foundEntry = this.plugin.settings.wordEntries[i];
          foundIdx = i;
          foundArray = this.plugin.settings.wordEntries;
          break;
        }
      }
      if (!foundEntry && Array.isArray(this.plugin.settings.wordEntryGroups)) {
        for (const g of this.plugin.settings.wordEntryGroups) {
          if (!g || !Array.isArray(g.entries)) continue;
          const j = g.entries.findIndex((e) => e && e.uid === entryUid);
          if (j !== -1) {
            foundEntry = g.entries[j];
            foundIdx = j;
            foundArray = g.entries;
            break;
          }
        }
      }
      if (!foundEntry) {
        for (let i = 0; i < this.plugin.settings.textBgColoringEntries.length; i++) {
          if (this.plugin.settings.textBgColoringEntries[i].uid === entryUid) {
            foundEntry = this.plugin.settings.textBgColoringEntries[i];
            foundIdx = i;
            foundArray = this.plugin.settings.textBgColoringEntries;
            break;
          }
        }
      }
      if (foundEntry && foundIdx !== -1 && foundArray) {
        if (!isRegex) {
          if (!patternVal) {
            foundArray.splice(foundIdx, 1);
          } else {
            const parts = patternVal.split(",").map((p) => String(p).trim()).filter((p) => p.length > 0);
            foundArray[foundIdx].pattern = parts[0];
            foundArray[foundIdx].groupedPatterns = parts.length > 1 ? parts : null;
          }
        }
        foundArray[foundIdx].matchType = matchTypeVal;
        foundArray[foundIdx].styleType = st;
        if (st === "text") {
          foundArray[foundIdx].color = textColorVal;
          foundArray[foundIdx].textColor = null;
          foundArray[foundIdx].backgroundColor = null;
        } else if (st === "highlight") {
          foundArray[foundIdx].color = "";
          foundArray[foundIdx].textColor = "currentColor";
          foundArray[foundIdx].backgroundColor = bgColorVal;
        } else {
          foundArray[foundIdx].color = "";
          foundArray[foundIdx].textColor = textColorVal;
          foundArray[foundIdx].backgroundColor = bgColorVal;
        }
        if (typeof this.entry.backgroundOpacity === "number") foundArray[foundIdx].backgroundOpacity = this.entry.backgroundOpacity;
        if (typeof this.entry.highlightBorderRadius === "number") foundArray[foundIdx].highlightBorderRadius = this.entry.highlightBorderRadius;
        if (typeof this.entry.highlightHorizontalPadding === "number") foundArray[foundIdx].highlightHorizontalPadding = this.entry.highlightHorizontalPadding;
        if (typeof this.entry.highlightVerticalPadding === "number") foundArray[foundIdx].highlightVerticalPadding = this.entry.highlightVerticalPadding;
        if (typeof this.entry.enableBorderThickness === "boolean") foundArray[foundIdx].enableBorderThickness = this.entry.enableBorderThickness;
        if (this.entry.borderStyle) foundArray[foundIdx].borderStyle = this.entry.borderStyle;
        if (this.entry.borderLineStyle) foundArray[foundIdx].borderLineStyle = this.entry.borderLineStyle;
        if (typeof this.entry.borderOpacity === "number") foundArray[foundIdx].borderOpacity = this.entry.borderOpacity;
        if (typeof this.entry.borderThickness === "number") foundArray[foundIdx].borderThickness = this.entry.borderThickness;
        if (this.entry.inclusionRules) foundArray[foundIdx].inclusionRules = this.entry.inclusionRules;
        if (this.entry.exclusionRules) foundArray[foundIdx].exclusionRules = this.entry.exclusionRules;
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        this.plugin.compileTextBgColoringEntries();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        this.plugin.forceRefreshAllReadingViews();
        this.plugin.triggerActiveDocumentRerender();
        try {
          this.onSaved && this.onSaved(this.entry);
        } catch (e) {
        }
        if (this.parentModal) {
          try {
            this.parentModal.close();
            if (!this.fromPickColorModal && this.parentModal instanceof AddToExistingEntryModal) {
              setTimeout(() => {
                try {
                  new AddToExistingEntryModal(this.app, this.plugin, this.parentModal.selectedText, this.parentModal.view).open();
                } catch (e) {
                }
              }, 100);
            }
          } catch (e) {
          }
        }
      } else if (this.parentModal) {
        if (!patternVal) {
          this.close();
          return;
        }
        const newEntry = {
          pattern: patternVal.split(",")[0],
          groupedPatterns: patternVal.split(",").length > 1 ? patternVal.split(",").map((p) => String(p).trim()).filter((p) => p.length > 0) : null,
          color: st === "text" ? textColorVal : "",
          textColor: st === "both" ? textColorVal : st === "highlight" ? "currentColor" : null,
          backgroundColor: st === "highlight" || st === "both" ? bgColorVal : null,
          isRegex: false,
          flags: "",
          styleType: st,
          matchType: matchTypeVal,
          uid: this.entry.uid
        };
        if (typeof this.entry.backgroundOpacity === "number") newEntry.backgroundOpacity = this.entry.backgroundOpacity;
        if (typeof this.entry.highlightBorderRadius === "number") newEntry.highlightBorderRadius = this.entry.highlightBorderRadius;
        if (typeof this.entry.highlightHorizontalPadding === "number") newEntry.highlightHorizontalPadding = this.entry.highlightHorizontalPadding;
        if (typeof this.entry.highlightVerticalPadding === "number") newEntry.highlightVerticalPadding = this.entry.highlightVerticalPadding;
        if (typeof this.entry.enableBorderThickness === "boolean") newEntry.enableBorderThickness = this.entry.enableBorderThickness;
        if (this.entry.borderStyle) newEntry.borderStyle = this.entry.borderStyle;
        if (this.entry.borderLineStyle) newEntry.borderLineStyle = this.entry.borderLineStyle;
        if (typeof this.entry.borderOpacity === "number") newEntry.borderOpacity = this.entry.borderOpacity;
        if (typeof this.entry.borderThickness === "number") newEntry.borderThickness = this.entry.borderThickness;
        if (this.entry.inclusionRules) newEntry.inclusionRules = this.entry.inclusionRules;
        if (this.entry.exclusionRules) newEntry.exclusionRules = this.entry.exclusionRules;
        const toGroupUid = groupSelect.value || "";
        if (toGroupUid) {
          const groupsList2 = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : [];
          const tgtGroup = groupsList2.find((g) => g && g.uid === toGroupUid);
          if (tgtGroup) {
            if (!Array.isArray(tgtGroup.entries)) tgtGroup.entries = [];
            tgtGroup.entries.push(newEntry);
          } else {
            this.plugin.settings.wordEntries.push(newEntry);
          }
        } else {
          this.plugin.settings.wordEntries.push(newEntry);
        }
        this.plugin.settings.caseSensitive = caseSensitiveVal;
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        this.plugin.compileTextBgColoringEntries();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        this.plugin.forceRefreshAllReadingViews();
        this.plugin.triggerActiveDocumentRerender();
        try {
          this.onSaved && this.onSaved(newEntry);
        } catch (e) {
        }
        if (this.parentModal) {
          try {
            this.parentModal.close();
          } catch (e) {
          }
        }
      } else {
        if (!isRegex) {
          if (patternVal) {
            const parts = patternVal.split(",").map((p) => String(p).trim()).filter((p) => p.length > 0);
            this.entry.pattern = parts[0];
            this.entry.groupedPatterns = parts.length > 1 ? parts : null;
          }
        }
        this.entry.matchType = matchTypeVal;
        this.entry.styleType = st;
        if (st === "text") {
          this.entry.color = textColorVal;
          this.entry.textColor = null;
          this.entry.backgroundColor = null;
        } else if (st === "highlight") {
          this.entry.color = "";
          this.entry.textColor = "currentColor";
          this.entry.backgroundColor = bgColorVal;
        } else {
          this.entry.color = "";
          this.entry.textColor = textColorVal;
          this.entry.backgroundColor = bgColorVal;
        }
        try {
          this.onSaved && this.onSaved(this.entry);
        } catch (e) {
        }
      }
      if (shouldClose) this.close();
    };
    const boundSave = () => saveHandler(true);
    saveBtn.addEventListener("click", boundSave);
    this._handlers.push({ el: saveBtn, ev: "click", fn: boundSave });
    this._saveData = saveHandler;
    this._refreshPreview = renderPreview;
  }
  onClose() {
    try {
      if (this._saveData) this._saveData(false);
    } catch (e) {
    }
    try {
      this._handlers.forEach((h) => {
        try {
          h.el.removeEventListener(h.ev, h.fn);
        } catch (e) {
        }
      });
    } catch (e) {
    }
    try {
      this._dropdownCleanups.forEach((cleanup) => {
        try {
          cleanup();
        } catch (e) {
        }
      });
    } catch (e) {
    }
    this._handlers = [];
    this._dropdownCleanups = [];
    try {
      this.contentEl.empty();
    } catch (e) {
    }
  }
};
var BlacklistRegexTesterModal = class extends Modal {
  constructor(app, plugin, onAdded) {
    super(app);
    this.plugin = plugin;
    this.onAdded = onAdded;
    this._editingEntry = null;
    this._handlers = [];
    this._rafId = null;
    this._debounceId = null;
    this._preFillPattern = "";
    this._preFillFlags = "";
    this._preFillName = "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      this.modalEl.style.maxWidth = "820px";
      this.modalEl.style.padding = "20px";
    } catch (e) {
    }
    const title = contentEl.createEl("h2", { text: this.plugin.t("regex_tester_blacklist", "Regex tester - blacklist") });
    title.style.marginTop = "0";
    title.style.marginBottom = "12px";
    try {
      title.addClass("act-regex-title");
    } catch (e) {
    }
    const controlsRow = contentEl.createDiv();
    controlsRow.style.display = "flex";
    controlsRow.style.gap = "12px";
    const flagsRow = controlsRow.createDiv();
    flagsRow.style.display = "flex";
    flagsRow.style.gap = "6px";
    const flagNames = ["i", "g", "m", "s", "u", "y"];
    const flagButtons = {};
    flagNames.forEach((f) => {
      const b = flagsRow.createEl("button", { text: f });
      b.style.padding = "6px 10px";
      b.style.borderRadius = "var(--radius-m)";
      b.style.border = "1px solid var(--background-modifier-border)";
      b.style.background = "var(--background-modifier-form-field)";
      b.style.cursor = "pointer";
      flagButtons[f] = b;
    });
    const regexInput2 = contentEl.createEl("input", { type: "text" });
    regexInput2.placeholder = this.plugin.t("regex_expression_placeholder", "put your expression here");
    regexInput2.style.marginTop = "10px";
    regexInput2.style.width = "100%";
    regexInput2.style.padding = "10px 14px";
    regexInput2.style.borderRadius = "var(--radius-m)";
    regexInput2.style.border = "1px solid var(--background-modifier-border)";
    regexInput2.style.background = "var(--background-modifier-form-field)";
    regexInput2.style.fontFamily = "var(--font-ui-medium)";
    const subjectWrap = contentEl.createDiv();
    subjectWrap.style.marginTop = "10px";
    subjectWrap.style.border = "1px solid var(--background-modifier-border)";
    subjectWrap.style.borderRadius = "var(--radius-m)";
    subjectWrap.style.overflow = "hidden";
    subjectWrap.style.background = "var(--background-modifier-form-field)";
    const testInput = subjectWrap.createEl("textarea");
    testInput.placeholder = this.plugin.t("regex_subject_placeholder", "type your subject / test string here...");
    testInput.style.width = "100%";
    testInput.style.height = "120px";
    testInput.style.padding = "12px";
    testInput.style.border = "none";
    testInput.style.outline = "none";
    testInput.style.background = "transparent";
    testInput.style.color = "var(--text-normal)";
    testInput.style.fontFamily = "var(--font-ui-medium)";
    testInput.style.resize = "none";
    const previewWrap = contentEl.createDiv();
    previewWrap.style.marginTop = "10px";
    previewWrap.style.border = "1px solid var(--background-modifier-border)";
    previewWrap.style.borderRadius = "var(--radius-m)";
    previewWrap.style.padding = "12px";
    previewWrap.style.background = "var(--background-modifier-form-field)";
    previewWrap.style.whiteSpace = "pre-wrap";
    previewWrap.style.wordWrap = "break-word";
    previewWrap.style.fontFamily = "var(--font-ui-medium)";
    previewWrap.style.fontSize = "var(--font-small)";
    previewWrap.style.lineHeight = "1.5";
    const nameInput = contentEl.createEl("input", { type: "text" });
    nameInput.placeholder = this.plugin.t("regex_name_placeholder", "name your regex");
    nameInput.style.marginTop = "10px";
    nameInput.style.width = "100%";
    nameInput.style.padding = "10px 14px";
    nameInput.style.borderRadius = "var(--radius-m)";
    nameInput.style.border = "1px solid var(--background-modifier-border)";
    nameInput.style.background = "var(--background-modifier-form-field)";
    nameInput.style.boxSizing = "border-box";
    nameInput.style.fontFamily = "var(--font-ui-medium)";
    const statusRow = contentEl.createDiv();
    statusRow.style.display = "flex";
    statusRow.style.justifyContent = "space-between";
    statusRow.style.alignItems = "center";
    statusRow.style.gap = "8px";
    statusRow.style.marginTop = "14px";
    const matchFooter = statusRow.createDiv();
    matchFooter.style.opacity = "0.8";
    matchFooter.style.flex = "1";
    const addBtn = statusRow.createEl("button", { text: this._editingEntry ? this.plugin.t("btn_save_regex", "Save Regex") : this.plugin.t("btn_add_regex", "+ Add to Blacklist") });
    addBtn.addClass("mod-cta");
    const sanitizeFlags = (f) => {
      const s = String(f || "").toLowerCase().replace(/[^gimsuy]/g, "");
      let out = "";
      for (const ch of ["g", "i", "m", "s", "u", "y"]) {
        if (s.includes(ch)) out += ch;
      }
      return out;
    };
    const renderPreview = () => {
      const raw = String(testInput.value || "");
      const patRaw = String(regexInput2.value || "").trim();
      const flags = Object.keys(flagButtons).filter((k) => flagButtons[k].dataset.on === "1").join("");
      const f = flags.includes("g") ? flags : flags + "g";
      if (!patRaw) {
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 matches";
        return;
      }
      const pat = this.plugin.sanitizePattern(patRaw, true);
      if (!pat) {
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 matches";
        return;
      }
      if (!this.plugin.settings.disableRegexSafety && !this.plugin.validateAndSanitizeRegex(pat)) {
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 matches";
        return;
      }
      let re;
      try {
        re = new RegExp(pat, f);
      } catch (e) {
        previewWrap.innerHTML = escapeHtml(raw).replace(/\n/g, "<br>");
        matchFooter.textContent = "0 matches";
        return;
      }
      let lastIndex = 0;
      let out = "";
      let count = 0;
      const matchStyle = "background:rgba(255, 68, 68, 0.5);border-radius:4px;padding:0 4px;";
      for (const m of raw.matchAll(re)) {
        const s = m.index ?? 0;
        const e = s + (m[0] ? m[0].length : 0);
        out += escapeHtml(raw.slice(lastIndex, s));
        out += `<mark style="${matchStyle}">${escapeHtml(raw.slice(s, e))}</mark>`;
        lastIndex = e;
        count++;
      }
      out += escapeHtml(raw.slice(lastIndex));
      previewWrap.innerHTML = out.replace(/\n/g, "<br>");
      matchFooter.textContent = `${count} match${count === 1 ? "" : "es"}`;
    };
    const render = () => {
      if (this._rafId) cancelAnimationFrame(this._rafId);
      this._rafId = requestAnimationFrame(renderPreview);
    };
    const renderDebounced = () => {
      if (this._debounceId) clearTimeout(this._debounceId);
      this._debounceId = setTimeout(() => {
        render();
      }, 100);
    };
    const updateFlagButtonUI = () => {
      const active = Object.keys(flagButtons).filter((k) => flagButtons[k].dataset.on === "1");
      Object.keys(flagButtons).forEach((k) => {
        const on = flagButtons[k].dataset.on === "1";
        if (on) {
          flagButtons[k].addClass("mod-cta");
        } else {
          flagButtons[k].removeClass("mod-cta");
        }
      });
    };
    const flagTooltips = { "i": "ignore case", "g": "global", "m": "multiline", "s": "dotall", "u": "unicode", "y": "sticky" };
    Object.keys(flagButtons).forEach((k) => {
      const btn = flagButtons[k];
      if (flagTooltips[k]) {
        btn.setAttribute("title", flagTooltips[k]);
      }
      const fn = () => {
        btn.dataset.on = btn.dataset.on === "1" ? "0" : "1";
        updateFlagButtonUI();
        render();
      };
      btn.addEventListener("click", fn);
      this._handlers.push({ el: btn, ev: "click", fn });
    });
    updateFlagButtonUI();
    if (this._preFillPattern) {
      regexInput2.value = this._preFillPattern;
    }
    if (this._preFillFlags) {
      const flags = String(this._preFillFlags || "").split("");
      flags.forEach((f) => {
        if (flagButtons[f]) {
          flagButtons[f].dataset.on = "1";
        }
      });
      updateFlagButtonUI();
    }
    if (this._preFillName) {
      nameInput.value = this._preFillName;
    }
    const onInputImmediate = () => {
      render();
    };
    const onInputDebounced = () => {
      renderDebounced();
    };
    [regexInput2, testInput].forEach((el) => {
      const ev = el === regexInput2 ? "input" : "input";
      const fn = onInputDebounced;
      el.addEventListener(ev, fn);
      this._handlers.push({ el, ev, fn });
    });
    render();
    const addHandler = async () => {
      const patRaw = String(regexInput2.value || "").trim();
      const pat = this.plugin.sanitizePattern(patRaw, true);
      const label = String(nameInput.value || "").trim();
      const flags = Object.keys(flagButtons).filter((k) => flagButtons[k].dataset.on === "1").join("");
      if (!pat) {
        new Notice(this.plugin.t("notice_empty_pattern", "Pattern is empty"));
        return;
      }
      if (!this.plugin.settings.disableRegexSafety && !this.plugin.validateAndSanitizeRegex(pat)) {
        new Notice(this.plugin.t("notice_pattern_too_complex", "Pattern too complex"));
        return;
      }
      try {
        this.plugin.settings.enableRegexSupport = true;
      } catch (e) {
      }
      if (this._advancedRuleEntry) {
        try {
          this._advancedRuleEntry.text = pat;
          this._advancedRuleEntry.flags = flags;
          await this.plugin.saveSettings();
          try {
            this.onAdded && this.onAdded(this._advancedRuleEntry);
          } catch (e) {
          }
          new Notice(this.plugin.t("notice_rule_updated", "Rule updated"));
          this.close();
          return;
        } catch (e) {
          debugError("REGEX_TESTER", "advanced rule update error", e);
        }
      }
      if (this._editingEntry) {
        try {
          const updated = Object.assign({}, this._editingEntry, {
            pattern: pat,
            flags,
            presetLabel: label || void 0,
            isRegex: true
          });
          let entryIdx = -1;
          if (updated && updated.uid) entryIdx = this.plugin.settings.blacklistEntries.findIndex((e) => e && e.uid === updated.uid);
          if (entryIdx === -1) entryIdx = this.plugin.settings.blacklistEntries.indexOf(this._editingEntry);
          if (entryIdx === -1) entryIdx = this.plugin.settings.blacklistEntries.findIndex((e) => e && e.isRegex && String(e.pattern) === String(this._editingEntry.pattern));
          if (entryIdx !== -1) this.plugin.settings.blacklistEntries[entryIdx] = updated;
          else this.plugin.settings.blacklistEntries.push(updated);
          this._editingEntry.pattern = updated.pattern;
          this._editingEntry.flags = updated.flags;
          this._editingEntry.presetLabel = updated.presetLabel;
          this._editingEntry.isRegex = updated.isRegex;
          await this.plugin.saveSettings();
          try {
            this.onAdded && this.onAdded(updated);
          } catch (e) {
          }
          new Notice(this.plugin.t("notice_entry_updated", "Entry updated"));
          this.close();
          return;
        } catch (e) {
          debugError("REGEX_TESTER", "entry update error", e);
        }
      }
      const uid = (() => {
        try {
          return Date.now().toString(36) + Math.random().toString(36).slice(2);
        } catch (e) {
          return Date.now();
        }
      })();
      const entry = { uid, isRegex: true, pattern: pat, flags, presetLabel: label || void 0, persistAtEnd: true };
      if (!Array.isArray(this.plugin.settings.blacklistEntries)) this.plugin.settings.blacklistEntries = [];
      this.plugin.settings.blacklistEntries.push(entry);
      try {
        this.plugin.settingTab && (this.plugin.settingTab._suspendSorting = true);
      } catch (e) {
      }
      try {
        this.plugin.settingTab && entry && entry.uid && this.plugin.settingTab._blacklistNewSet && this.plugin.settingTab._blacklistNewSet.add(entry.uid);
      } catch (e) {
      }
      await this.plugin.saveSettings();
      try {
        this.onAdded && this.onAdded(entry);
      } catch (e) {
      }
      new Notice(this.plugin.t("notice_added_to_blacklist", "Pattern added to blacklist"));
      this.close();
    };
    addBtn.addEventListener("click", addHandler);
    this._handlers.push({ el: addBtn, ev: "click", fn: addHandler });
  }
  onClose() {
    try {
      if (this._rafId) cancelAnimationFrame(this._rafId);
      if (this._debounceId) clearTimeout(this._debounceId);
      if (this._handlers && Array.isArray(this._handlers)) {
        this._handlers.forEach((h) => {
          try {
            if (h.el && h.ev && h.fn && typeof h.el.removeEventListener === "function") {
              h.el.removeEventListener(h.ev, h.fn);
            }
          } catch (e) {
          }
        });
      }
    } catch (e) {
    }
    this._handlers = [];
    try {
      this.contentEl?.empty();
    } catch (e) {
    }
  }
};
var ChangelogModal = class extends Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this._mdComp = null;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      this.modalEl.style.maxWidth = "900px";
      this.modalEl.style.width = "900px";
      this.modalEl.style.padding = "25px";
    } catch (e) {
    }
    const header = contentEl.createEl("div");
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.marginBottom = "0px";
    header.style.paddingBottom = "16px";
    header.style.borderBottom = "1px solid var(--divider-color)";
    const title = header.createEl("h2", { text: this.plugin.t("header_plugin_name", "Always Color Text") });
    title.style.margin = "0";
    title.style.fontSize = "1.5em";
    title.style.fontWeight = "600";
    const link = header.createEl("a", { text: this.plugin.t("changelog_view_on_github", "View on GitHub") });
    link.href = "https://github.com/Kazi-Aidah/always-color-text/releases";
    link.target = "_blank";
    link.style.fontSize = "0.9em";
    link.style.opacity = "0.8";
    link.style.transition = "opacity 0.2s";
    link.addEventListener("mouseenter", () => link.style.opacity = "1");
    link.addEventListener("mouseleave", () => link.style.opacity = "0.8");
    const body = contentEl.createDiv();
    body.style.maxHeight = "70vh";
    body.style.overflow = "auto";
    const loading = body.createEl("div", { text: this.plugin.t("changelog_loading", "Loading releases\u2026") });
    loading.style.opacity = "0.7";
    loading.style.fontSize = "0.95em";
    loading.style.marginTop = "12px";
    try {
      const rels = await this.plugin.fetchAllReleases();
      body.empty();
      if (!Array.isArray(rels) || rels.length === 0) {
        const noInfo = body.createEl("div", { text: this.plugin.t("changelog_no_info", "No release information available.") });
        try {
          noInfo.style.marginTop = "12px";
        } catch (e) {
        }
        return;
      }
      rels.forEach(async (rel) => {
        const meta = body.createEl("div");
        meta.style.marginBottom = "6px";
        meta.style.borderBottom = "1px solid var(--divider-color)";
        const releaseName = meta.createEl("div", { text: rel.name || rel.tag_name || this.plugin.t("changelog_release", "Release") });
        releaseName.style.fontSize = "2em";
        releaseName.style.fontWeight = "900";
        releaseName.style.marginTop = "12px";
        releaseName.style.marginBottom = "12px";
        releaseName.style.color = "var(--text-normal)";
        try {
          const dateRaw = rel.published_at || rel.created_at || rel.release_date || null;
          if (dateRaw) {
            const dt = new Date(dateRaw);
            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            const formatted = `${dt.getFullYear()} ${monthNames[dt.getMonth()]} ${String(dt.getDate()).padStart(2, "0")}`;
            const dateEl = meta.createEl("div", { text: formatted });
            dateEl.style.display = "block";
            dateEl.style.opacity = "0.8";
            dateEl.style.fontSize = "0.9em";
            dateEl.style.marginTop = "-4px";
            dateEl.style.marginBottom = "16px";
          }
        } catch (_) {
        }
        const notes = body.createEl("div");
        notes.style.marginTop = "16px";
        notes.addClass("markdown-preview-view");
        notes.style.lineHeight = "1.6";
        notes.style.fontSize = "0.95em";
        try {
          notes.style.padding = "0 var(--file-margin)";
        } catch (e) {
        }
        const md = rel.body || this.plugin.t("changelog_no_notes", "No notes");
        try {
          if (!this._mdComp) {
            try {
              this._mdComp = new Component();
            } catch (e) {
              this._mdComp = null;
            }
          }
          await MarkdownRenderer.render(this.plugin.app, md, notes, "", this._mdComp || void 0);
        } catch (e) {
          const preEl = notes.createEl("pre");
          preEl.style.whiteSpace = "pre-wrap";
          preEl.style.wordWrap = "break-word";
          preEl.style.backgroundColor = "var(--background-secondary)";
          preEl.style.padding = "12px";
          preEl.style.borderRadius = "4px";
          preEl.style.fontSize = "0.9em";
          preEl.style.lineHeight = "1.5";
          preEl.textContent = md;
        }
      });
    } catch (e) {
      body.empty();
      const failed = body.createEl("div", { text: this.plugin.t("changelog_failed_to_load", "Failed to load release notes.") });
      try {
        failed.style.marginTop = "12px";
      } catch (e2) {
      }
    }
  }
  onClose() {
    try {
      if (this._mdComp && typeof this._mdComp.unload === "function") {
        this._mdComp.unload();
      }
    } catch (e) {
    }
    this._mdComp = null;
    try {
      this.contentEl.empty();
    } catch (e) {
    }
  }
};
var EditWordGroupModal = class extends Modal {
  constructor(app, plugin, group, onSave, onDelete) {
    super(app);
    this.plugin = plugin;
    this.group = JSON.parse(JSON.stringify(group));
    if (!Array.isArray(this.group.entries)) this.group.entries = [];
    this.onSave = onSave;
    this.onDelete = onDelete;
    this._searchQuery = "";
    this._limit = 0;
    this._limitRegexOnly = false;
    this._limitWordsOnly = false;
    this._limitStyle = null;
    this._limitMatchStarts = false;
    this._limitMatchEnds = false;
    this._limitMatchExact = false;
    this._listDiv = null;
    this._cleanupHandlers = [];
    this._sortMode = "last-added";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "1000px";
    this.modalEl.style.maxWidth = "95vw";
    try {
      this.modalEl.addClass("act-edit-word-group-modal");
    } catch (e) {
      try {
        this.modalEl.classList.add("act-edit-word-group-modal");
      } catch (_) {
      }
    }
    const heading = contentEl.createEl("h2", { text: this.plugin.t("edit_word_group_modal_title", "Edit Word Group") });
    heading.style.marginTop = "0";
    heading.style.marginBottom = "15px";
    const topRow = contentEl.createDiv();
    topRow.style.display = "flex";
    topRow.style.alignItems = "center";
    topRow.style.gap = "10px";
    topRow.style.marginBottom = "15px";
    topRow.style.flexWrap = "wrap";
    const activeSelect = topRow.createEl("select");
    activeSelect.addClass("act-word-group-active-select");
    activeSelect.style.padding = "6px";
    activeSelect.style.borderRadius = "4px";
    activeSelect.style.border = "1px solid var(--background-modifier-border)";
    activeSelect.style.textAlign = "center";
    activeSelect.style.flex = "0 0 auto";
    activeSelect.style.width = "fit-content";
    const optActive = activeSelect.createEl("option", { text: this.plugin.t("group_active_label", "Active"), value: "true" });
    const optInactive = activeSelect.createEl("option", { text: this.plugin.t("group_inactive_label", "Inactive"), value: "false" });
    activeSelect.value = String(!!this.group.active);
    const activeSelectHandler = () => {
      this.group.active = activeSelect.value === "true";
    };
    activeSelect.addEventListener("change", activeSelectHandler);
    this._cleanupHandlers.push(() => activeSelect.removeEventListener("change", activeSelectHandler));
    const nameInput = topRow.createEl("input", { type: "text", value: this.group.name || "" });
    nameInput.style.flex = "1";
    nameInput.style.padding = "6px";
    nameInput.style.borderRadius = "4px";
    nameInput.style.border = "1px solid var(--background-modifier-border)";
    nameInput.placeholder = this.plugin.t("group_name_placeholder", "Name your group");
    const nameInputHandler = () => {
      this.group.name = nameInput.value;
    };
    nameInput.addEventListener("input", nameInputHandler);
    this._cleanupHandlers.push(() => nameInput.removeEventListener("input", nameInputHandler));
    const caseSelect = topRow.createEl("select");
    caseSelect.style.padding = "6px";
    caseSelect.style.borderRadius = "4px";
    caseSelect.style.border = "1px solid var(--background-modifier-border)";
    caseSelect.style.textAlign = "center";
    caseSelect.style.flex = "0 0 auto";
    caseSelect.style.width = "fit-content";
    caseSelect.createEl("option", { text: this.plugin.t("opt_case_all", "Case Sensitivity (All)"), value: "per-entry" });
    caseSelect.createEl("option", { text: this.plugin.t("opt_case_sensitive", "is case sensitive"), value: "true" });
    caseSelect.createEl("option", { text: this.plugin.t("opt_not_case_sensitive", "not case sensitive"), value: "false" });
    caseSelect.value = typeof this.group.caseSensitiveOverride === "boolean" ? this.group.caseSensitiveOverride ? "true" : "false" : "per-entry";
    const caseSelectHandler = () => {
      const v = caseSelect.value;
      if (v === "per-entry") this.group.caseSensitiveOverride = null;
      else this.group.caseSensitiveOverride = v === "true";
    };
    caseSelect.addEventListener("change", caseSelectHandler);
    this._cleanupHandlers.push(() => caseSelect.removeEventListener("change", caseSelectHandler));
    const matchTypeSelect = topRow.createEl("select");
    matchTypeSelect.style.padding = "6px";
    matchTypeSelect.style.borderRadius = "4px";
    matchTypeSelect.style.border = "1px solid var(--background-modifier-border)";
    matchTypeSelect.style.textAlign = "center";
    matchTypeSelect.style.flex = "0 0 auto";
    matchTypeSelect.style.width = "fit-content";
    matchTypeSelect.createEl("option", { text: this.plugin.t("opt_match_all", "Match Type (All)"), value: "per-entry" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_contains", "Contains"), value: "contains" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_exact", "Exact"), value: "exact" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_starts_with", "Starts With"), value: "startswith" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_ends_with", "Ends With"), value: "endswith" });
    matchTypeSelect.value = this.group.matchTypeOverride ? String(this.group.matchTypeOverride) : "per-entry";
    const matchTypeHandler = () => {
      const v = matchTypeSelect.value;
      this.group.matchTypeOverride = v === "per-entry" ? null : v;
    };
    matchTypeSelect.addEventListener("change", matchTypeHandler);
    this._cleanupHandlers.push(() => matchTypeSelect.removeEventListener("change", matchTypeHandler));
    const editBtn = topRow.createEl("button");
    try {
      setIcon(editBtn, "edit-3");
    } catch (e) {
    }
    editBtn.title = this.plugin.t("edit_group_highlight_styling", "Edit Group Highlight Styling");
    editBtn.style.flex = "0 0 auto";
    editBtn.style.display = "flex";
    editBtn.style.alignItems = "center";
    editBtn.style.justifyContent = "center";
    editBtn.style.padding = "6px";
    editBtn.style.borderRadius = "4px";
    editBtn.style.border = "1px solid var(--background-modifier-border)";
    editBtn.style.background = "var(--background-modifier-form-field)";
    editBtn.style.cursor = "pointer";
    const editHandler = () => {
      new HighlightStylingModal(this.app, this.plugin, this.group, this, this.group.name).open();
    };
    editBtn.addEventListener("click", editHandler);
    this._cleanupHandlers.push(() => editBtn.removeEventListener("click", editHandler));
    const enableDisableRow = contentEl.createDiv();
    enableDisableRow.style.display = "grid";
    enableDisableRow.style.gridTemplateColumns = "auto minmax(0, 1fr) minmax(0, 1fr) auto minmax(0, 1fr) minmax(0, 1fr)";
    enableDisableRow.style.gap = "8px";
    enableDisableRow.style.alignItems = "center";
    enableDisableRow.style.marginBottom = "12px";
    const enLabel = enableDisableRow.createEl("div", { text: this.plugin.t("label_enable_in", "Enable in") });
    enLabel.style.color = "var(--text-muted)";
    const enFoldersInput = enableDisableRow.createEl("input", { type: "text" });
    enFoldersInput.placeholder = "folder1/, folder2/";
    enFoldersInput.style.padding = "6px";
    enFoldersInput.style.borderRadius = "4px";
    enFoldersInput.style.border = "1px solid var(--background-modifier-border)";
    enFoldersInput.value = Array.isArray(this.group.enableFolders) ? this.group.enableFolders.join(", ") : "";
    const enTagsInput = enableDisableRow.createEl("input", { type: "text" });
    enTagsInput.placeholder = "#tag1, #tag2";
    enTagsInput.style.padding = "6px";
    enTagsInput.style.borderRadius = "4px";
    enTagsInput.style.border = "1px solid var(--background-modifier-border)";
    enTagsInput.value = Array.isArray(this.group.enableTags) ? this.group.enableTags.map((t) => t.startsWith("#") ? t : `#${t}`).join(", ") : "";
    const disLabel = enableDisableRow.createEl("div", { text: this.plugin.t("label_disable_in", "Disable in") });
    disLabel.style.color = "var(--text-muted)";
    const disFoldersInput = enableDisableRow.createEl("input", { type: "text" });
    disFoldersInput.placeholder = "folder1/, folder2/";
    disFoldersInput.style.padding = "6px";
    disFoldersInput.style.borderRadius = "4px";
    disFoldersInput.style.border = "1px solid var(--background-modifier-border)";
    disFoldersInput.value = Array.isArray(this.group.disableFolders) ? this.group.disableFolders.join(", ") : "";
    const disTagsInput = enableDisableRow.createEl("input", { type: "text" });
    disTagsInput.placeholder = "#tag1, #tag2";
    disTagsInput.style.padding = "6px";
    disTagsInput.style.borderRadius = "4px";
    disTagsInput.style.border = "1px solid var(--background-modifier-border)";
    disTagsInput.value = Array.isArray(this.group.disableTags) ? this.group.disableTags.map((t) => t.startsWith("#") ? t : `#${t}`).join(", ") : "";
    const parseList = (raw, isTag) => {
      const arr = String(raw || "").split(",").map((s) => s.trim()).filter(Boolean);
      if (isTag) return arr.map((t) => t.replace(/^#/, "")).filter(Boolean);
      return arr;
    };
    const enFoldersHandler = () => {
      this.group.enableFolders = parseList(enFoldersInput.value, false);
    };
    const enTagsHandler = () => {
      this.group.enableTags = parseList(enTagsInput.value, true);
    };
    const disFoldersHandler = () => {
      this.group.disableFolders = parseList(disFoldersInput.value, false);
    };
    const disTagsHandler = () => {
      this.group.disableTags = parseList(disTagsInput.value, true);
    };
    enFoldersInput.addEventListener("input", enFoldersHandler);
    enTagsInput.addEventListener("input", enTagsHandler);
    disFoldersInput.addEventListener("input", disFoldersHandler);
    disTagsInput.addEventListener("input", disTagsHandler);
    this._cleanupHandlers.push(() => enFoldersInput.removeEventListener("input", enFoldersHandler));
    this._cleanupHandlers.push(() => enTagsInput.removeEventListener("input", enTagsHandler));
    this._cleanupHandlers.push(() => disFoldersInput.removeEventListener("input", disFoldersHandler));
    this._cleanupHandlers.push(() => disTagsInput.removeEventListener("input", disTagsHandler));
    const searchRow = contentEl.createDiv();
    try {
      searchRow.addClass("act-search-container");
    } catch (e) {
      try {
        searchRow.classList.add("act-search-container");
      } catch (_) {
      }
    }
    searchRow.style.display = "flex";
    searchRow.style.alignItems = "center";
    searchRow.style.gap = "8px";
    searchRow.style.margin = "8px 0";
    const searchInput = searchRow.createEl("input", { type: "text" });
    searchInput.placeholder = this.plugin.t("search_colored_words_placeholder", "Search colored words/patterns\u2026");
    try {
      searchInput.addClass("act-search-input");
    } catch (e) {
      try {
        searchInput.classList.add("act-search-input");
      } catch (_) {
      }
    }
    searchInput.style.flex = "1 1 auto";
    searchInput.style.padding = "6px";
    searchInput.style.border = "1px solid var(--background-modifier-border)";
    searchInput.style.borderRadius = "var(--input-radius)";
    searchInput.value = this._searchQuery;
    const searchHandler = () => {
      this._searchQuery = String(searchInput.value || "").trim().toLowerCase();
      this._refreshGroupEntries();
    };
    searchInput.addEventListener("input", searchHandler);
    this._cleanupHandlers.push(() => searchInput.removeEventListener("input", searchHandler));
    const searchIcon = searchRow.createDiv();
    try {
      searchIcon.addClass("act-search-icon");
    } catch (e) {
      try {
        searchIcon.classList.add("act-search-icon");
      } catch (_) {
      }
    }
    const limitInput = searchRow.createEl("input", { type: "text" });
    limitInput.value = String(this._limit);
    limitInput.placeholder = this.plugin.t("limit_input_placeholder", "limit");
    limitInput.title = this.plugin.t("limit_input_tooltip", "0=all; number=last N; r=regex; w=words; h=highlight; c=text; b=text+bg; sw=starts; ew=ends; e=exact");
    limitInput.style.width = "80px";
    limitInput.style.padding = "6px";
    limitInput.style.border = "1px solid var(--background-modifier-border)";
    limitInput.style.borderRadius = "var(--input-radius)";
    const limitHandler = () => {
      const raw = String(limitInput.value || "").trim().toLowerCase();
      const parts = raw.split(/\s+/).filter(Boolean);
      const numPart = parts.find((p) => /^\d+$/.test(p));
      const num = numPart ? parseInt(numPart, 10) : NaN;
      this._limit = !isNaN(num) && num >= 0 ? num : 0;
      this._limitRegexOnly = false;
      this._limitWordsOnly = false;
      this._limitStyle = null;
      this._limitMatchStarts = false;
      this._limitMatchEnds = false;
      this._limitMatchExact = false;
      for (const tok of parts) {
        if (tok === "r") this._limitRegexOnly = true;
        else if (tok === "w") this._limitWordsOnly = true;
        else if (tok === "h") this._limitStyle = "highlight";
        else if (tok === "c") this._limitStyle = "text";
        else if (tok === "b") this._limitStyle = "both";
        else if (tok === "sw") this._limitMatchStarts = true;
        else if (tok === "ew") this._limitMatchEnds = true;
        else if (tok === "e") this._limitMatchExact = true;
      }
      this._refreshGroupEntries();
    };
    limitInput.addEventListener("input", limitHandler);
    this._cleanupHandlers.push(() => limitInput.removeEventListener("input", limitHandler));
    const hrBelowSearch = contentEl.createEl("hr");
    hrBelowSearch.style.marginTop = "6px";
    hrBelowSearch.style.marginBottom = "6px";
    hrBelowSearch.style.border = "0px";
    try {
      hrBelowSearch.addClass("act-edit-word-group-hr");
    } catch (e) {
      try {
        hrBelowSearch.classList.add("act-edit-word-group-hr");
      } catch (_) {
      }
    }
    this._listDiv = contentEl.createDiv();
    this._listDiv.addClass("color-words-list");
    this._listDiv.style.minHeight = "200px";
    this._listDiv.style.maxHeight = "350px";
    this._listDiv.style.overflowY = "auto";
    this._listDiv.style.marginBottom = "15px";
    this._listDiv.style.borderRadius = "4px";
    this._listDiv.style.backgroundColor = "var(--background-primary)";
    this._refreshGroupEntries();
    const buttonRow = contentEl.createDiv();
    buttonRow.style.display = "flex";
    buttonRow.style.gap = "10px";
    buttonRow.style.marginBottom = "15px";
    buttonRow.style.alignItems = "center";
    const sortModes = ["last-added", "a-z", "reverse-a-z", "style-order", "color"];
    const sortLabels = {
      "last-added": this.plugin.t("sort_label_last-added", "Sort: Last Added"),
      "a-z": this.plugin.t("sort_label_a-z", "Sort: A-Z"),
      "reverse-a-z": this.plugin.t("sort_label_reverse-a-z", "Sort: Z-A"),
      "style-order": this.plugin.t("sort_label_style-order", "Sort: Style Order"),
      "color": this.plugin.t("sort_label_color", "Sort: Color")
    };
    const sortBtn = buttonRow.createEl("button");
    sortBtn.textContent = sortLabels[this._sortMode] || "Sort: Last Added";
    sortBtn.style.cursor = "pointer";
    sortBtn.style.padding = "6px 12px";
    sortBtn.style.borderRadius = "4px";
    const sortBtnHandler = () => {
      const currentIndex = sortModes.indexOf(this._sortMode);
      const nextIndex = (currentIndex + 1) % sortModes.length;
      this._sortMode = sortModes[nextIndex];
      sortBtn.textContent = sortLabels[this._sortMode];
      this._refreshGroupEntries();
    };
    sortBtn.addEventListener("click", sortBtnHandler);
    this._cleanupHandlers.push(() => sortBtn.removeEventListener("click", sortBtnHandler));
    const addWordsBtn = buttonRow.createEl("button");
    addWordsBtn.textContent = this.plugin.t("btn_add_words", "+ Add Words");
    addWordsBtn.style.cursor = "pointer";
    addWordsBtn.style.padding = "6px 12px";
    addWordsBtn.style.borderRadius = "4px";
    addWordsBtn.style.flex = "1";
    addWordsBtn.addClass("mod-cta");
    const addWordsHandler = () => {
      this.group.entries.push({ pattern: "", color: "", isRegex: false, flags: "", styleType: "text", matchType: "contains" });
      this._sortMode = "last-added";
      this._refreshGroupEntries();
      setTimeout(() => {
        this._listDiv.scrollTop = this._listDiv.scrollHeight;
      }, 50);
    };
    addWordsBtn.addEventListener("click", addWordsHandler);
    this._cleanupHandlers.push(() => addWordsBtn.removeEventListener("click", addWordsHandler));
    const addRegexBtn = buttonRow.createEl("button");
    addRegexBtn.textContent = this.plugin.t("btn_add_regex", "+ Add Regex");
    addRegexBtn.style.cursor = "pointer";
    addRegexBtn.style.padding = "6px 12px";
    addRegexBtn.style.borderRadius = "4px";
    addRegexBtn.style.flex = "1";
    addRegexBtn.addClass("mod-cta");
    const addRegexHandler = () => {
      this._sortMode = "last-added";
      const onAdded = (entry) => {
        if (entry) {
          this.group.entries.push(entry);
        }
        this._refreshGroupEntries();
      };
      new RealTimeRegexTesterModal(this.app, this.plugin, onAdded, null, true).open();
    };
    addRegexBtn.addEventListener("click", addRegexHandler);
    this._cleanupHandlers.push(() => addRegexBtn.removeEventListener("click", addRegexHandler));
    const presetsBtn = buttonRow.createEl("button");
    presetsBtn.textContent = this.plugin.t("btn_presets", "Presets");
    presetsBtn.style.cursor = "pointer";
    presetsBtn.style.padding = "6px 12px";
    presetsBtn.style.borderRadius = "4px";
    const presetsHandler = () => {
      new PresetModal(this.app, this.plugin, async (preset) => {
        if (!preset) return;
        new ColorPickerModal(this.app, this.plugin, async (color, result) => {
          const sel = result || {};
          const tc = sel.textColor && this.plugin.isValidHexColor(sel.textColor) ? sel.textColor : null;
          const bc = sel.backgroundColor && this.plugin.isValidHexColor(sel.backgroundColor) ? sel.backgroundColor : null;
          if (!tc && !bc && (!color || !this.plugin.isValidHexColor(color))) return;
          const entry = { pattern: preset.pattern, isRegex: true, flags: preset.flags || "", styleType: "text", matchType: "contains", presetLabel: preset.label };
          if (preset.affectMarkElements) entry.affectMarkElements = true;
          if (preset.targetElement) entry.targetElement = preset.targetElement;
          if (tc && bc) {
            entry.textColor = tc;
            entry.backgroundColor = bc;
            entry.color = "";
            entry.styleType = "both";
            entry._savedTextColor = tc;
            entry._savedBackgroundColor = bc;
          } else if (tc) {
            entry.color = tc;
            entry.styleType = "text";
            entry._savedTextColor = tc;
          } else if (bc) {
            entry.textColor = "currentColor";
            entry.backgroundColor = bc;
            entry.color = "";
            entry.styleType = "highlight";
            entry._savedBackgroundColor = bc;
          } else {
            entry.color = color;
            entry._savedTextColor = color;
          }
          this.group.entries.push(entry);
          this._sortMode = "last-added";
          this._refreshGroupEntries();
        }, "text-and-background", "", false).open();
      }).open();
    };
    presetsBtn.addEventListener("click", presetsHandler);
    this._cleanupHandlers.push(() => presetsBtn.removeEventListener("click", presetsHandler));
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "space-between";
    footer.style.alignItems = "center";
    footer.style.marginTop = "15px";
    footer.style.paddingTop = "15px";
    footer.style.borderTop = "1px solid var(--background-modifier-border)";
    const btnDelete = footer.createEl("button", { text: this.plugin.t("btn_delete_group", "Delete Group") });
    btnDelete.addClass("mod-warning");
    btnDelete.style.cursor = "pointer";
    btnDelete.style.padding = "8px 16px";
    const deleteHandler = () => {
      new ConfirmationModal(this.app, this.plugin, this.plugin.t("confirm_delete_group_title", "Delete Group"), this.plugin.t("confirm_delete_group_desc", "Are you sure you want to delete this group?"), async () => {
        this.close();
        this.onDelete(this.group);
      }).open();
    };
    btnDelete.addEventListener("click", deleteHandler);
    this._cleanupHandlers.push(() => btnDelete.removeEventListener("click", deleteHandler));
    const btnSave = footer.createEl("button", { text: this.plugin.t("btn_save_group", "Save Group") });
    btnSave.addClass("mod-cta");
    btnSave.style.cursor = "pointer";
    btnSave.style.padding = "8px 16px";
    const saveHandler = () => {
      this.group.entries.forEach((entry) => {
        if (!entry.hasOwnProperty("pattern")) entry.pattern = "";
        if (!entry.hasOwnProperty("color")) entry.color = "";
        if (!entry.hasOwnProperty("isRegex")) entry.isRegex = false;
        if (!entry.hasOwnProperty("flags")) entry.flags = "";
        if (!entry.hasOwnProperty("styleType")) entry.styleType = "text";
        if (!entry.hasOwnProperty("matchType")) entry.matchType = "contains";
        if (!entry.hasOwnProperty("textColor")) entry.textColor = null;
        if (!entry.hasOwnProperty("backgroundColor")) entry.backgroundColor = null;
      });
      this.onSave(this.group);
      this.close();
    };
    btnSave.addEventListener("click", saveHandler);
    this._cleanupHandlers.push(() => btnSave.removeEventListener("click", saveHandler));
  }
  _refreshGroupEntries() {
    const currentGroupInSettings = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups.find((g) => g && g.uid === this.group?.uid) : null;
    if (currentGroupInSettings) {
      this.group = currentGroupInSettings;
    }
    if (!this._listDiv) return;
    this._listDiv.empty();
    let entries = [...this.group.entries];
    if (this._searchQuery) {
      const q = this._searchQuery.toLowerCase();
      entries = entries.filter((e) => {
        const patterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "")];
        const text = [
          ...patterns.map((p) => p.toLowerCase()),
          String(e.presetLabel || "").toLowerCase(),
          String(e.flags || "").toLowerCase(),
          String(e.styleType || "").toLowerCase()
        ].join(" ");
        if (this._limitMatchExact) return text === q;
        if (this._limitMatchStarts) return text.startsWith(q);
        if (this._limitMatchEnds) return text.endsWith(q);
        return text.includes(q);
      });
    }
    if (this._limitStyle === "highlight") {
      entries = entries.filter((e) => (e.styleType || "text") === "highlight");
    } else if (this._limitStyle === "text") {
      entries = entries.filter((e) => (e.styleType || "text") === "text");
    } else if (this._limitStyle === "both") {
      entries = entries.filter((e) => (e.styleType || "text") === "both");
    }
    if (this._limitRegexOnly) {
      entries = entries.filter((e) => !!e.isRegex);
    } else if (this._limitWordsOnly) {
      entries = entries.filter((e) => !e.isRegex);
    }
    if (this._sortMode === "a-z") {
      entries.sort((a, b) => {
        const patternA = a.pattern || "";
        const patternB = b.pattern || "";
        const aEmpty = String(patternA).trim().length === 0;
        const bEmpty = String(patternB).trim().length === 0;
        if (aEmpty && !bEmpty) return 1;
        if (!aEmpty && bEmpty) return -1;
        return patternA.toLowerCase().localeCompare(patternB.toLowerCase());
      });
    } else if (this._sortMode === "reverse-a-z") {
      entries.sort((a, b) => {
        const patternA = a.pattern || "";
        const patternB = b.pattern || "";
        const aEmpty = String(patternA).trim().length === 0;
        const bEmpty = String(patternB).trim().length === 0;
        if (aEmpty && !bEmpty) return 1;
        if (!aEmpty && bEmpty) return -1;
        return patternB.toLowerCase().localeCompare(patternA.toLowerCase());
      });
    } else if (this._sortMode === "style-order") {
      const styleOrder = { "text": 0, "highlight": 1, "both": 2 };
      entries.sort((a, b) => {
        const patternA = a.pattern || "";
        const patternB = b.pattern || "";
        const aEmpty = String(patternA).trim().length === 0;
        const bEmpty = String(patternB).trim().length === 0;
        if (aEmpty && !bEmpty) return 1;
        if (!aEmpty && bEmpty) return -1;
        const styleA = styleOrder[a.styleType] ?? 0;
        const styleB = styleOrder[b.styleType] ?? 0;
        if (styleA !== styleB) return styleA - styleB;
        return patternA.toLowerCase().localeCompare(patternB.toLowerCase());
      });
    } else if (this._sortMode === "color") {
      entries.sort((a, b) => {
        const patternA = a.pattern || "";
        const patternB = b.pattern || "";
        const aEmpty = String(patternA).trim().length === 0;
        const bEmpty = String(patternB).trim().length === 0;
        if (aEmpty && !bEmpty) return 1;
        if (!aEmpty && bEmpty) return -1;
        const colorA = (a.backgroundColor || a.textColor || a.color || "").toLowerCase();
        const colorB = (b.backgroundColor || b.textColor || b.color || "").toLowerCase();
        if (colorA !== colorB) return colorA.localeCompare(colorB);
        return patternA.toLowerCase().localeCompare(patternB.toLowerCase());
      });
    }
    const visibleEntries = this._limit && this._limit > 0 ? entries.slice(-this._limit) : entries;
    if (visibleEntries.length === 0) {
      this._listDiv.createDiv({ text: this.plugin.t("no_entries_found", "No entries found.") }).style.color = "var(--text-muted)";
      return;
    }
    visibleEntries.forEach((entry) => {
      const row = this._listDiv.createDiv();
      try {
        row.addClass("act-entry-row");
      } catch (e) {
        try {
          row.classList.add("act-entry-row");
        } catch (_) {
        }
      }
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.borderRadius = "4px";
      const styleSelect = row.createEl("select");
      styleSelect.style.padding = "6px";
      styleSelect.style.borderRadius = "4px";
      styleSelect.style.border = "1px solid var(--background-modifier-border)";
      styleSelect.style.textAlign = "center";
      styleSelect.style.maxWidth = "90px";
      styleSelect.style.minWidth = "70px";
      ["text", "highlight", "both"].forEach((val) => {
        const opt = styleSelect.createEl("option", { text: this.plugin.t("style_type_" + val, val === "text" ? "color" : val) });
        opt.value = val;
      });
      styleSelect.value = entry.styleType || "text";
      const styleSelectHandler = () => {
        entry.styleType = styleSelect.value;
        this._refreshGroupEntries();
      };
      styleSelect.addEventListener("change", styleSelectHandler);
      const matchSelect = row.createEl("select");
      matchSelect.style.padding = "6px";
      matchSelect.style.borderRadius = "4px";
      matchSelect.style.border = "1px solid var(--background-modifier-border)";
      matchSelect.style.textAlign = "center";
      matchSelect.style.maxWidth = "110px";
      matchSelect.style.minWidth = "90px";
      matchSelect.innerHTML = `<option value="exact">${this.plugin.t("match_option_exact", "Exact")}</option><option value="contains">${this.plugin.t("match_option_contains", "Contains")}</option><option value="startswith">${this.plugin.t("match_option_starts_with", "Starts with")}</option><option value="endswith">${this.plugin.t("match_option_ends_with", "Ends with")}</option>`;
      matchSelect.value = entry.matchType || "contains";
      const matchSelectHandler = () => {
        entry.matchType = matchSelect.value;
      };
      matchSelect.addEventListener("change", matchSelectHandler);
      const updateVisibility = () => {
        matchSelect.style.display = entry.isRegex ? "none" : "";
      };
      updateVisibility();
      const patternInput = row.createEl("input", { type: "text", value: entry.pattern || "" });
      patternInput.style.flex = "1";
      patternInput.style.padding = "6px";
      patternInput.style.borderRadius = "4px";
      patternInput.style.border = "1px solid var(--background-modifier-border)";
      patternInput.placeholder = this.plugin.t("word_pattern_placeholder_long", "pattern, word or comma-separated words (e.g. hello, world, foo)");
      const patternHandler = () => {
        entry.pattern = patternInput.value;
      };
      patternInput.addEventListener("change", patternHandler);
      patternInput.addEventListener("blur", patternHandler);
      let flagsInput = null;
      if (entry.isRegex) {
        flagsInput = row.createEl("input", { type: "text", value: entry.flags || "" });
        flagsInput.style.width = "50px";
        flagsInput.style.padding = "6px";
        flagsInput.style.borderRadius = "4px";
        flagsInput.style.border = "1px solid var(--background-modifier-border)";
        flagsInput.placeholder = this.plugin.t("flags_placeholder", "Flags");
        flagsInput.title = "e.g., i, g, m";
        const flagsHandler = () => {
          entry.flags = flagsInput.value || "";
        };
        flagsInput.addEventListener("change", flagsHandler);
      }
      const regexChk = row.createEl("input", { type: "checkbox" });
      regexChk.checked = !!entry.isRegex;
      regexChk.title = this.plugin.t("use_regex", "Use Regex");
      const regexChkHandler = () => {
        entry.isRegex = regexChk.checked;
        updateVisibility();
        this._refreshGroupEntries();
      };
      regexChk.addEventListener("change", regexChkHandler);
      let cp = null;
      if (entry.styleType === "text" || entry.styleType === "both") {
        cp = row.createEl("input", { type: "color" });
        cp.style.width = "40px";
        cp.style.height = "40px";
        cp.style.padding = "0";
        cp.style.border = "none";
        cp.style.cursor = "pointer";
        cp.style.borderRadius = "4px";
        const textColor = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color || "#000000";
        cp.value = textColor;
        const cpHandler = () => {
          const newColor = cp.value;
          if (!this.plugin.isValidHexColor(newColor)) return;
          if (entry.backgroundColor) {
            entry.textColor = newColor;
            entry.color = "";
            entry.styleType = "both";
            entry._savedTextColor = newColor;
          } else {
            entry.color = newColor;
            entry.textColor = null;
            entry.backgroundColor = null;
            entry.styleType = "text";
            entry._savedTextColor = newColor;
          }
          styleSelect.value = entry.styleType;
        };
        cp.addEventListener("input", cpHandler);
        cp.title = "Text color";
        const cpContextHandler = (ev) => {
          try {
            ev && ev.preventDefault && ev.preventDefault();
            if (ev && ev.stopPropagation) ev.stopPropagation();
            const preFillText = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : this.plugin.isValidHexColor(entry.color) ? entry.color : cp.value;
            const displayText = entry.isRegex ? entry.pattern || "" : Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns.join(", ") : entry.pattern || "";
            const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
              const tc = result && result.textColor || color;
              if (!tc || !this.plugin.isValidHexColor(tc)) return;
              const currentStyle = entry.styleType || "text";
              if (currentStyle === "both") {
                entry.textColor = tc;
                entry.color = "";
                entry._savedTextColor = tc;
              } else {
                entry.color = tc;
                entry.textColor = null;
                entry.backgroundColor = null;
                entry._savedTextColor = tc;
              }
              cp.value = tc;
              this._refreshGroupEntries();
            }, "text", displayText, false);
            try {
              modal._preFillTextColor = preFillText;
            } catch (_) {
            }
            try {
              modal.open();
            } catch (_) {
            }
          } catch (e) {
          }
        };
        cp.addEventListener("contextmenu", cpContextHandler);
      }
      let cpBg = null;
      if (entry.styleType === "highlight" || entry.styleType === "both") {
        cpBg = row.createEl("input", { type: "color" });
        cpBg.style.width = "40px";
        cpBg.style.height = "40px";
        cpBg.style.padding = "0";
        cpBg.style.border = "none";
        cpBg.style.cursor = "pointer";
        cpBg.style.borderRadius = "4px";
        const bgColor = entry.backgroundColor || entry._savedBackgroundColor || "#000000";
        cpBg.value = bgColor;
        const cpBgHandler = () => {
          const newColor = cpBg.value;
          if (!this.plugin.isValidHexColor(newColor)) return;
          entry.backgroundColor = newColor;
          if (!entry.textColor || entry.textColor === "currentColor") {
            entry.textColor = "currentColor";
          }
          entry.color = "";
          const hasText = !!(entry.textColor && entry.textColor !== "currentColor");
          const hasBg = !!entry.backgroundColor;
          if (hasText && hasBg) {
            entry.styleType = "both";
          } else if (hasBg) {
            entry.styleType = "highlight";
          } else {
            entry.styleType = "text";
          }
          entry._savedBackgroundColor = newColor;
          styleSelect.value = entry.styleType;
        };
        cpBg.addEventListener("input", cpBgHandler);
        cpBg.title = "Highlight color";
        const cpBgContextHandler = (ev) => {
          try {
            ev && ev.preventDefault && ev.preventDefault();
            if (ev && ev.stopPropagation) ev.stopPropagation();
            const preFillBg = entry.backgroundColor || entry._savedBackgroundColor || cpBg.value;
            const displayText = entry.isRegex ? entry.pattern || "" : Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns.join(", ") : entry.pattern || "";
            const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
              const bc = result && result.backgroundColor || color;
              if (!bc || !this.plugin.isValidHexColor(bc)) return;
              entry.backgroundColor = bc;
              if (!entry.textColor || entry.textColor === "currentColor") {
                entry.textColor = "currentColor";
              }
              entry.color = "";
              entry._savedBackgroundColor = bc;
              cpBg.value = bc;
              this._refreshGroupEntries();
            }, "background", displayText, false);
            try {
              modal._preFillBgColor = preFillBg;
            } catch (_) {
            }
            try {
              modal.open();
            } catch (_) {
            }
          } catch (e) {
          }
        };
        cpBg.addEventListener("contextmenu", cpBgContextHandler);
      }
      const btnDel = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
      btnDel.addClass("mod-warning");
      btnDel.style.cursor = "pointer";
      btnDel.style.padding = "6px 10px";
      btnDel.style.border = "none";
      const delHandler = () => {
        const idx = this.group.entries.indexOf(entry);
        if (idx > -1) {
          this.group.entries.splice(idx, 1);
          this._refreshGroupEntries();
        }
      };
      btnDel.addEventListener("click", delHandler);
      const contextMenuHandler = (ev) => {
        try {
          ev && ev.preventDefault && ev.preventDefault();
          if (ev && ev.stopPropagation) ev.stopPropagation();
          const menu = new Menu(this.app);
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("edit_entry_details", "Edit Entry Details")).setIcon("pencil").onClick(() => {
              const modal = new EditEntryModal(this.app, this.plugin, entry, () => {
                this._refreshGroupEntries();
              });
              modal.open();
            });
          });
          if (entry.isRegex) {
            menu.addItem((item) => {
              item.setTitle(this.plugin.t("open_in_regex_tester", "Open in Regex Tester")).setIcon("code").onClick(() => {
                const modal = new RealTimeRegexTesterModal(this.app, this.plugin, (updatedEntry) => {
                  if (updatedEntry) {
                    Object.assign(entry, updatedEntry);
                    this._refreshGroupEntries();
                  }
                });
                modal._editingEntry = entry;
                if (entry.pattern) modal._preFillPattern = entry.pattern;
                if (entry.flags) modal._preFillFlags = entry.flags;
                if (entry.presetLabel) modal._preFillName = entry.presetLabel;
                modal.open();
              });
            });
          }
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("duplicate_entry", "Duplicate Entry")).setIcon("copy").onClick(() => {
              const dup = JSON.parse(JSON.stringify(entry));
              this.group.entries.push(dup);
              this._sortMode = "last-added";
              this._refreshGroupEntries();
            });
          });
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("context_delete_entry", "Delete entry")).setIcon("trash").onClick(() => {
              const idx = this.group.entries.indexOf(entry);
              if (idx > -1) {
                this.group.entries.splice(idx, 1);
                this._refreshGroupEntries();
              }
            });
          });
          menu.showAtPosition({ x: ev.clientX, y: ev.clientY });
        } catch (e) {
          debugError("MODAL", "context menu error", e);
        }
      };
      row.addEventListener("contextmenu", contextMenuHandler);
    });
  }
  onClose() {
    try {
      this.onSave(this.group);
    } catch (e) {
    }
    try {
      this._cleanupHandlers.forEach((cleanup) => {
        try {
          cleanup();
        } catch (e) {
        }
      });
      this._cleanupHandlers = [];
      this.contentEl.empty();
    } catch (e) {
    }
  }
};
var SelectBlacklistGroupModal = class extends FuzzySuggestModal {
  constructor(app, plugin, onSelected) {
    super(app);
    this.plugin = plugin;
    this.onSelected = onSelected;
    this.setPlaceholder(this.plugin.t("search_blacklist_groups_placeholder", "Search blacklist groups\u2026"));
  }
  getItems() {
    const groups = Array.isArray(this.plugin.settings.blacklistEntryGroups) ? this.plugin.settings.blacklistEntryGroups : [];
    const items = groups.map((group) => ({
      group,
      label: group && group.name && String(group.name).trim().length > 0 ? String(group.name) : "(unnamed group)"
    }));
    items.unshift({
      group: null,
      label: this.plugin.t("default")
    });
    return items;
  }
  getItemText(item) {
    return String(item.label || "");
  }
  onChooseItem(item, evt) {
    if (evt && evt.button === 2) return;
    const actualItem = item.item || item;
    if (this.onSelected) {
      this.onSelected(actualItem.group);
    }
  }
};
var EditBlacklistGroupModal = class extends Modal {
  constructor(app, plugin, group, onSave, onDelete) {
    super(app);
    this.plugin = plugin;
    this.group = JSON.parse(JSON.stringify(group));
    if (!Array.isArray(this.group.entries)) this.group.entries = [];
    this.onSave = onSave;
    this.onDelete = onDelete;
    this._searchQuery = "";
    this._limit = 0;
    this._limitRegexOnly = false;
    this._limitWordsOnly = false;
    this._limitMatchStarts = false;
    this._limitMatchEnds = false;
    this._limitMatchExact = false;
    this._listDiv = null;
    this._cleanupHandlers = [];
    this._sortMode = "last-added";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "900px";
    this.modalEl.style.maxWidth = "95vw";
    try {
      this.modalEl.addClass("act-edit-blacklist-group-modal");
    } catch (e) {
      try {
        this.modalEl.classList.add("act-edit-blacklist-group-modal");
      } catch (_) {
      }
    }
    const heading = contentEl.createEl("h2", { text: this.plugin.t("edit_blacklist_group_modal_title", "Edit Blacklist Group") });
    heading.style.marginTop = "0";
    heading.style.marginBottom = "15px";
    const topRow = contentEl.createDiv();
    topRow.style.display = "flex";
    topRow.style.alignItems = "center";
    topRow.style.gap = "10px";
    topRow.style.marginBottom = "15px";
    const activeSelect = topRow.createEl("select");
    activeSelect.addClass("act-blacklist-group-active-select");
    activeSelect.style.padding = "6px";
    activeSelect.style.borderRadius = "4px";
    activeSelect.style.border = "1px solid var(--background-modifier-border)";
    activeSelect.style.textAlign = "center";
    activeSelect.style.flex = "0 0 auto";
    activeSelect.style.width = "fit-content";
    const optActive = activeSelect.createEl("option", { text: this.plugin.t("group_active_label", "Active"), value: "true" });
    const optInactive = activeSelect.createEl("option", { text: this.plugin.t("group_inactive_label", "Inactive"), value: "false" });
    activeSelect.value = String(!!this.group.active);
    const activeSelectHandler = () => {
      this.group.active = activeSelect.value === "true";
    };
    activeSelect.addEventListener("change", activeSelectHandler);
    this._cleanupHandlers.push(() => activeSelect.removeEventListener("change", activeSelectHandler));
    const nameInput = topRow.createEl("input", { type: "text", value: this.group.name || "" });
    nameInput.style.flex = "1";
    nameInput.style.padding = "6px";
    nameInput.style.borderRadius = "4px";
    nameInput.style.border = "1px solid var(--background-modifier-border)";
    nameInput.placeholder = this.plugin.t("group_name_placeholder", "Name your group");
    const nameInputHandler = () => {
      this.group.name = nameInput.value;
    };
    nameInput.addEventListener("input", nameInputHandler);
    this._cleanupHandlers.push(() => nameInput.removeEventListener("input", nameInputHandler));
    const caseSelect = topRow.createEl("select");
    caseSelect.style.padding = "6px";
    caseSelect.style.borderRadius = "4px";
    caseSelect.style.border = "1px solid var(--background-modifier-border)";
    caseSelect.style.textAlign = "center";
    caseSelect.style.flex = "0 0 auto";
    caseSelect.style.width = "fit-content";
    caseSelect.createEl("option", { text: this.plugin.t("opt_case_all", "Case Sensitivity (All)"), value: "per-entry" });
    caseSelect.createEl("option", { text: this.plugin.t("opt_case_sensitive", "is case sensitive"), value: "true" });
    caseSelect.createEl("option", { text: this.plugin.t("opt_not_case_sensitive", "not case sensitive"), value: "false" });
    caseSelect.value = typeof this.group.caseSensitiveOverride === "boolean" ? this.group.caseSensitiveOverride ? "true" : "false" : "per-entry";
    const caseSelectHandler = () => {
      const v = caseSelect.value;
      if (v === "per-entry") this.group.caseSensitiveOverride = null;
      else this.group.caseSensitiveOverride = v === "true";
    };
    caseSelect.addEventListener("change", caseSelectHandler);
    this._cleanupHandlers.push(() => caseSelect.removeEventListener("change", caseSelectHandler));
    const matchTypeSelect = topRow.createEl("select");
    matchTypeSelect.style.padding = "6px";
    matchTypeSelect.style.borderRadius = "4px";
    matchTypeSelect.style.border = "1px solid var(--background-modifier-border)";
    matchTypeSelect.style.textAlign = "center";
    matchTypeSelect.style.flex = "0 0 auto";
    matchTypeSelect.style.width = "fit-content";
    matchTypeSelect.createEl("option", { text: this.plugin.t("opt_match_all", "Match Type (All)"), value: "per-entry" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_contains", "Contains"), value: "contains" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_exact", "Exact"), value: "exact" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_starts_with", "Starts With"), value: "startswith" });
    matchTypeSelect.createEl("option", { text: this.plugin.t("match_option_ends_with", "Ends With"), value: "endswith" });
    matchTypeSelect.value = this.group.matchTypeOverride ? String(this.group.matchTypeOverride) : "per-entry";
    const matchTypeHandler = () => {
      const v = matchTypeSelect.value;
      this.group.matchTypeOverride = v === "per-entry" ? null : v;
    };
    matchTypeSelect.addEventListener("change", matchTypeHandler);
    this._cleanupHandlers.push(() => matchTypeSelect.removeEventListener("change", matchTypeHandler));
    const enableDisableRow = contentEl.createDiv();
    enableDisableRow.style.display = "grid";
    enableDisableRow.style.gridTemplateColumns = "auto minmax(0, 1fr) minmax(0, 1fr) auto minmax(0, 1fr) minmax(0, 1fr)";
    enableDisableRow.style.gap = "8px";
    enableDisableRow.style.alignItems = "center";
    enableDisableRow.style.marginBottom = "12px";
    const enLabel = enableDisableRow.createEl("div", { text: this.plugin.t("label_enable_in", "Enable in") });
    enLabel.style.color = "var(--text-muted)";
    const enFoldersInput = enableDisableRow.createEl("input", { type: "text" });
    enFoldersInput.placeholder = "folder1/, folder2/";
    enFoldersInput.style.padding = "6px";
    enFoldersInput.style.borderRadius = "4px";
    enFoldersInput.style.border = "1px solid var(--background-modifier-border)";
    enFoldersInput.value = Array.isArray(this.group.enableFolders) ? this.group.enableFolders.join(", ") : "";
    const enTagsInput = enableDisableRow.createEl("input", { type: "text" });
    enTagsInput.placeholder = "#tag1, #tag2";
    enTagsInput.style.padding = "6px";
    enTagsInput.style.borderRadius = "4px";
    enTagsInput.style.border = "1px solid var(--background-modifier-border)";
    enTagsInput.value = Array.isArray(this.group.enableTags) ? this.group.enableTags.map((t) => t.startsWith("#") ? t : `#${t}`).join(", ") : "";
    const disLabel = enableDisableRow.createEl("div", { text: this.plugin.t("label_disable_in", "Disable in") });
    disLabel.style.color = "var(--text-muted)";
    const disFoldersInput = enableDisableRow.createEl("input", { type: "text" });
    disFoldersInput.placeholder = "folder1/, folder2/";
    disFoldersInput.style.padding = "6px";
    disFoldersInput.style.borderRadius = "4px";
    disFoldersInput.style.border = "1px solid var(--background-modifier-border)";
    disFoldersInput.value = Array.isArray(this.group.disableFolders) ? this.group.disableFolders.join(", ") : "";
    const disTagsInput = enableDisableRow.createEl("input", { type: "text" });
    disTagsInput.placeholder = "#tag1, #tag2";
    disTagsInput.style.padding = "6px";
    disTagsInput.style.borderRadius = "4px";
    disTagsInput.style.border = "1px solid var(--background-modifier-border)";
    disTagsInput.value = Array.isArray(this.group.disableTags) ? this.group.disableTags.map((t) => t.startsWith("#") ? t : `#${t}`).join(", ") : "";
    const parseList = (raw, isTag) => {
      const arr = String(raw || "").split(",").map((s) => s.trim()).filter(Boolean);
      if (isTag) return arr.map((t) => t.replace(/^#/, "")).filter(Boolean);
      return arr;
    };
    const enFoldersHandler = () => {
      this.group.enableFolders = parseList(enFoldersInput.value, false);
    };
    const enTagsHandler = () => {
      this.group.enableTags = parseList(enTagsInput.value, true);
    };
    const disFoldersHandler = () => {
      this.group.disableFolders = parseList(disFoldersInput.value, false);
    };
    const disTagsHandler = () => {
      this.group.disableTags = parseList(disTagsInput.value, true);
    };
    enFoldersInput.addEventListener("input", enFoldersHandler);
    enTagsInput.addEventListener("input", enTagsHandler);
    disFoldersInput.addEventListener("input", disFoldersHandler);
    disTagsInput.addEventListener("input", disTagsHandler);
    this._cleanupHandlers.push(() => enFoldersInput.removeEventListener("input", enFoldersHandler));
    this._cleanupHandlers.push(() => enTagsInput.removeEventListener("input", enTagsHandler));
    this._cleanupHandlers.push(() => disFoldersInput.removeEventListener("input", disFoldersHandler));
    this._cleanupHandlers.push(() => disTagsInput.removeEventListener("input", disTagsHandler));
    const searchRow = contentEl.createDiv();
    try {
      searchRow.addClass("act-search-container");
    } catch (e) {
      try {
        searchRow.classList.add("act-search-container");
      } catch (_) {
      }
    }
    searchRow.style.display = "flex";
    searchRow.style.alignItems = "center";
    searchRow.style.gap = "8px";
    searchRow.style.margin = "8px 0";
    searchRow.style.paddingBottom = "-4px";
    const searchInput = searchRow.createEl("input", { type: "text" });
    searchInput.placeholder = this.plugin.t("search_blacklist_placeholder", "Search blacklisted words/patterns\u2026");
    try {
      searchInput.addClass("act-search-input");
    } catch (e) {
      try {
        searchInput.classList.add("act-search-input");
      } catch (_) {
      }
    }
    searchInput.style.flex = "1 1 auto";
    searchInput.style.padding = "6px";
    searchInput.style.border = "1px solid var(--background-modifier-border)";
    searchInput.style.borderRadius = "var(--input-radius)";
    searchInput.value = this._searchQuery;
    const searchHandler = () => {
      this._searchQuery = String(searchInput.value || "").trim().toLowerCase();
      this._refreshGroupEntries();
    };
    searchInput.addEventListener("input", searchHandler);
    this._cleanupHandlers.push(() => searchInput.removeEventListener("input", searchHandler));
    const searchIcon = searchRow.createDiv();
    try {
      searchIcon.addClass("act-search-icon");
    } catch (e) {
      try {
        searchIcon.classList.add("act-search-icon");
      } catch (_) {
      }
    }
    const limitInput = searchRow.createEl("input", { type: "text" });
    limitInput.value = String(this._limit);
    limitInput.placeholder = this.plugin.t("limit_input_placeholder", "limit");
    limitInput.title = this.plugin.t("limit_input_tooltip", "0=all; number=last N; r=regex; w=words; sw=starts; ew=ends; e=exact");
    limitInput.style.width = "80px";
    limitInput.style.padding = "6px";
    limitInput.style.border = "1px solid var(--background-modifier-border)";
    limitInput.style.borderRadius = "var(--input-radius)";
    const limitHandler = () => {
      const raw = String(limitInput.value || "").trim().toLowerCase();
      const parts = raw.split(/\s+/).filter(Boolean);
      const numPart = parts.find((p) => /^\d+$/.test(p));
      const num = numPart ? parseInt(numPart, 10) : NaN;
      this._limit = !isNaN(num) && num >= 0 ? num : 0;
      this._limitRegexOnly = false;
      this._limitWordsOnly = false;
      this._limitMatchStarts = false;
      this._limitMatchEnds = false;
      this._limitMatchExact = false;
      for (const tok of parts) {
        if (tok === "r") this._limitRegexOnly = true;
        else if (tok === "w") this._limitWordsOnly = true;
        else if (tok === "sw") this._limitMatchStarts = true;
        else if (tok === "ew") this._limitMatchEnds = true;
        else if (tok === "e") this._limitMatchExact = true;
      }
      this._refreshGroupEntries();
    };
    limitInput.addEventListener("input", limitHandler);
    this._cleanupHandlers.push(() => limitInput.removeEventListener("input", limitHandler));
    const hrBelowSearch = contentEl.createEl("hr");
    hrBelowSearch.style.marginTop = "6px";
    hrBelowSearch.style.marginBottom = "0px";
    hrBelowSearch.style.border = "0px";
    try {
      hrBelowSearch.addClass("act-edit-blacklist-group-hr");
    } catch (e) {
      try {
        hrBelowSearch.classList.add("act-edit-blacklist-group-hr");
      } catch (_) {
      }
    }
    this._listDiv = contentEl.createDiv();
    this._listDiv.addClass("blacklist-entries-list");
    this._listDiv.style.minHeight = "200px";
    this._listDiv.style.maxHeight = "350px";
    this._listDiv.style.overflowY = "auto";
    this._listDiv.style.marginBottom = "15px";
    this._listDiv.style.borderRadius = "4px";
    this._refreshGroupEntries();
    const buttonRow = contentEl.createDiv();
    buttonRow.style.display = "flex";
    buttonRow.style.gap = "10px";
    buttonRow.style.marginBottom = "15px";
    buttonRow.style.alignItems = "center";
    const sortModes = ["last-added", "a-z", "reverse-a-z"];
    const sortLabels = {
      "last-added": this.plugin.t("sort_label_last-added", "Sort: Last Added"),
      "a-z": this.plugin.t("sort_label_a-z", "Sort: A-Z"),
      "reverse-a-z": this.plugin.t("sort_label_reverse-a-z", "Sort: Z-A")
    };
    const sortBtn = buttonRow.createEl("button");
    sortBtn.textContent = sortLabels[this._sortMode] || "Sort: Last Added";
    sortBtn.style.cursor = "pointer";
    sortBtn.style.padding = "6px 12px";
    sortBtn.style.borderRadius = "4px";
    const sortBtnHandler = () => {
      const currentIndex = sortModes.indexOf(this._sortMode);
      const nextIndex = (currentIndex + 1) % sortModes.length;
      this._sortMode = sortModes[nextIndex];
      sortBtn.textContent = sortLabels[this._sortMode];
      this._refreshGroupEntries();
    };
    sortBtn.addEventListener("click", sortBtnHandler);
    this._cleanupHandlers.push(() => sortBtn.removeEventListener("click", sortBtnHandler));
    const addWordsBtn = buttonRow.createEl("button");
    addWordsBtn.textContent = this.plugin.t("btn_add_words", "+ Add Words");
    addWordsBtn.style.cursor = "pointer";
    addWordsBtn.style.padding = "6px 12px";
    addWordsBtn.style.borderRadius = "4px";
    addWordsBtn.style.flex = "1";
    addWordsBtn.addClass("mod-cta");
    const addWordsHandler = () => {
      this.group.entries.push({ pattern: "", isRegex: false, flags: "", matchType: "contains" });
      this._sortMode = "last-added";
      this._refreshGroupEntries();
      setTimeout(() => {
        this._listDiv.scrollTop = this._listDiv.scrollHeight;
      }, 50);
    };
    addWordsBtn.addEventListener("click", addWordsHandler);
    this._cleanupHandlers.push(() => addWordsBtn.removeEventListener("click", addWordsHandler));
    const addRegexBtn = buttonRow.createEl("button");
    addRegexBtn.textContent = this.plugin.t("btn_add_regex", "+ Add Regex");
    addRegexBtn.style.cursor = "pointer";
    addRegexBtn.style.padding = "6px 12px";
    addRegexBtn.style.borderRadius = "4px";
    addRegexBtn.style.flex = "1";
    addRegexBtn.addClass("mod-cta");
    const addRegexHandler = () => {
      this._sortMode = "last-added";
      const onAdded = (entry) => {
        if (entry) {
          this.group.entries.push(entry);
        }
        this._refreshGroupEntries();
      };
      new BlacklistRegexTesterModal(this.app, this.plugin, onAdded).open();
    };
    addRegexBtn.addEventListener("click", addRegexHandler);
    this._cleanupHandlers.push(() => addRegexBtn.removeEventListener("click", addRegexHandler));
    const presetsBtn = buttonRow.createEl("button");
    presetsBtn.textContent = this.plugin.t("btn_presets", "Presets");
    presetsBtn.style.cursor = "pointer";
    presetsBtn.style.padding = "6px 12px";
    presetsBtn.style.borderRadius = "4px";
    const presetsHandler = () => {
      new PresetModal(this.app, this.plugin, async (preset) => {
        if (!preset) return;
        const entry = {
          pattern: preset.pattern,
          isRegex: true,
          flags: preset.flags || "",
          matchType: "contains",
          presetLabel: preset.label,
          targetElement: preset.targetElement
          // Preserve targetElement for logic-based coloring
        };
        this.group.entries.push(entry);
        this._sortMode = "last-added";
        this._refreshGroupEntries();
      }).open();
    };
    presetsBtn.addEventListener("click", presetsHandler);
    this._cleanupHandlers.push(() => presetsBtn.removeEventListener("click", presetsHandler));
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "space-between";
    footer.style.alignItems = "center";
    footer.style.marginTop = "15px";
    footer.style.paddingTop = "15px";
    footer.style.borderTop = "1px solid var(--background-modifier-border)";
    const btnDelete = footer.createEl("button", { text: this.plugin.t("btn_delete_group", "Delete Group") });
    btnDelete.addClass("mod-warning");
    btnDelete.style.cursor = "pointer";
    btnDelete.style.padding = "8px 16px";
    const deleteHandler = () => {
      new ConfirmationModal(this.app, this.plugin, this.plugin.t("confirm_delete_group_title", "Delete Group"), this.plugin.t("confirm_delete_group_desc", "Are you sure you want to delete this group?"), async () => {
        this.close();
        this.onDelete(this.group);
      }).open();
    };
    btnDelete.addEventListener("click", deleteHandler);
    this._cleanupHandlers.push(() => btnDelete.removeEventListener("click", deleteHandler));
    const btnSave = footer.createEl("button", { text: this.plugin.t("btn_save_group", "Save Group") });
    btnSave.addClass("mod-cta");
    btnSave.style.cursor = "pointer";
    btnSave.style.padding = "8px 16px";
    const saveHandler = () => {
      this.group.entries.forEach((entry) => {
        if (!entry.hasOwnProperty("pattern")) entry.pattern = "";
        if (!entry.hasOwnProperty("isRegex")) entry.isRegex = false;
        if (!entry.hasOwnProperty("flags")) entry.flags = "";
        if (!entry.hasOwnProperty("matchType")) entry.matchType = "contains";
      });
      this.onSave(this.group);
      this.close();
    };
    btnSave.addEventListener("click", saveHandler);
    this._cleanupHandlers.push(() => btnSave.removeEventListener("click", saveHandler));
  }
  _refreshGroupEntries() {
    if (!this._listDiv) return;
    this._listDiv.empty();
    let entries = [...this.group.entries];
    if (this._searchQuery) {
      const q = this._searchQuery.toLowerCase();
      entries = entries.filter((e) => {
        const patterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "")];
        const text = [
          ...patterns.map((p) => p.toLowerCase()),
          String(e.presetLabel || "").toLowerCase(),
          String(e.flags || "").toLowerCase()
        ].join(" ");
        if (this._limitMatchExact) return text === q;
        if (this._limitMatchStarts) return text.startsWith(q);
        if (this._limitMatchEnds) return text.endsWith(q);
        return text.includes(q);
      });
    }
    if (this._limitRegexOnly) {
      entries = entries.filter((e) => !!e.isRegex);
    } else if (this._limitWordsOnly) {
      entries = entries.filter((e) => !e.isRegex);
    }
    if (this._sortMode === "a-z") {
      entries.sort((a, b) => {
        const patternA = a.pattern || "";
        const patternB = b.pattern || "";
        const aEmpty = String(patternA).trim().length === 0;
        const bEmpty = String(patternB).trim().length === 0;
        if (aEmpty && !bEmpty) return 1;
        if (!aEmpty && bEmpty) return -1;
        return patternA.toLowerCase().localeCompare(patternB.toLowerCase());
      });
    } else if (this._sortMode === "reverse-a-z") {
      entries.sort((a, b) => {
        const patternA = a.pattern || "";
        const patternB = b.pattern || "";
        const aEmpty = String(patternA).trim().length === 0;
        const bEmpty = String(patternB).trim().length === 0;
        if (aEmpty && !bEmpty) return 1;
        if (!aEmpty && bEmpty) return -1;
        return patternB.toLowerCase().localeCompare(patternA.toLowerCase());
      });
    }
    const visibleEntries = this._limit && this._limit > 0 ? entries.slice(-this._limit) : entries;
    if (visibleEntries.length === 0) {
      this._listDiv.createDiv({ text: this.plugin.t("no_entries_found", "No entries found.") }).style.color = "var(--text-muted)";
      return;
    }
    visibleEntries.forEach((entry) => {
      const row = this._listDiv.createDiv();
      try {
        row.addClass("act-entry-row");
      } catch (e) {
        try {
          row.classList.add("act-entry-row");
        } catch (_) {
        }
      }
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.borderRadius = "4px";
      row.style.paddingTop = "8px";
      const matchSelect = row.createEl("select");
      matchSelect.style.padding = "6px";
      matchSelect.style.borderRadius = "4px";
      matchSelect.style.border = "1px solid var(--background-modifier-border)";
      matchSelect.style.textAlign = "center";
      matchSelect.style.maxWidth = "110px";
      matchSelect.style.minWidth = "90px";
      matchSelect.innerHTML = `<option value="exact">${this.plugin.t("match_option_exact", "Exact")}</option><option value="contains">${this.plugin.t("match_option_contains", "Contains")}</option><option value="startswith">${this.plugin.t("match_option_starts_with", "Starts with")}</option><option value="endswith">${this.plugin.t("match_option_ends_with", "Ends with")}</option>`;
      matchSelect.value = entry.matchType || "contains";
      const matchSelectHandler = () => {
        entry.matchType = matchSelect.value;
      };
      matchSelect.addEventListener("change", matchSelectHandler);
      const updateVisibility = () => {
        matchSelect.style.display = entry.isRegex ? "none" : "";
      };
      updateVisibility();
      if (entry.isRegex && entry.presetLabel) {
        const badge = row.createEl("span", { text: entry.presetLabel });
        badge.style.marginRight = "8px";
        badge.style.opacity = "0.7";
        badge.style.flex = "0 0 auto";
      }
      const displayPatterns = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns.join(", ") : entry.pattern;
      const patternInput = row.createEl("input", { type: "text", value: displayPatterns || "" });
      patternInput.style.flex = "1";
      patternInput.style.padding = "6px";
      patternInput.style.borderRadius = "4px";
      patternInput.style.border = "1px solid var(--background-modifier-border)";
      patternInput.placeholder = this.plugin.t("word_pattern_placeholder_long", "pattern, word or comma-separated words (e.g. hello, world, foo)");
      const patternHandler = () => {
        const raw = String(patternInput.value || "");
        const patterns = raw.split(",").map((p) => p.trim()).filter((p) => p.length > 0);
        entry.pattern = patterns[0] || "";
        entry.groupedPatterns = patterns.length > 1 ? patterns : null;
      };
      patternInput.addEventListener("change", patternHandler);
      patternInput.addEventListener("blur", patternHandler);
      let flagsInput = null;
      if (entry.isRegex) {
        flagsInput = row.createEl("input", { type: "text", value: entry.flags || "" });
        flagsInput.style.width = "50px";
        flagsInput.style.padding = "6px";
        flagsInput.style.borderRadius = "4px";
        flagsInput.style.border = "1px solid var(--background-modifier-border)";
        flagsInput.placeholder = this.plugin.t("flags_placeholder", "Flags");
        flagsInput.title = "e.g., i, g, m";
        const flagsHandler = () => {
          entry.flags = flagsInput.value || "";
        };
        flagsInput.addEventListener("change", flagsHandler);
      }
      const regexChk = row.createEl("input", { type: "checkbox" });
      regexChk.checked = !!entry.isRegex;
      regexChk.title = this.plugin.t("use_regex", "Use Regex");
      const regexChkHandler = () => {
        entry.isRegex = regexChk.checked;
        updateVisibility();
        this._refreshGroupEntries();
      };
      regexChk.addEventListener("change", regexChkHandler);
      const btnDelete = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
      btnDelete.addClass("mod-warning");
      btnDelete.style.padding = "4px 8px";
      btnDelete.style.borderRadius = "4px";
      btnDelete.style.cursor = "pointer";
      btnDelete.style.flex = "0 0 auto";
      const deleteHandler = () => {
        const idx = this.group.entries.indexOf(entry);
        if (idx !== -1) {
          this.group.entries.splice(idx, 1);
          this._refreshGroupEntries();
        }
      };
      btnDelete.addEventListener("click", deleteHandler);
      const contextMenuHandler = (ev) => {
        try {
          ev && ev.preventDefault && ev.preventDefault();
          if (ev && ev.stopPropagation) ev.stopPropagation();
          const menu = new Menu(this.app);
          if (entry.isRegex) {
            menu.addItem((item) => {
              item.setTitle(this.plugin.t("open_in_regex_tester", "Open in Regex Tester")).setIcon("code").onClick(() => {
                const modal = new BlacklistRegexTesterModal(this.app, this.plugin, (updatedEntry) => {
                  if (updatedEntry) {
                    Object.assign(entry, updatedEntry);
                    this._refreshGroupEntries();
                  }
                });
                modal._editingEntry = entry;
                if (entry.pattern) modal._preFillPattern = entry.pattern;
                if (entry.flags) modal._preFillFlags = entry.flags;
                if (entry.presetLabel) modal._preFillName = entry.presetLabel;
                modal.open();
              });
            });
          }
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("move_to_blacklist_group", "Move to blacklist group")).setIcon("arrow-right").onClick(() => {
              const blacklistGroups = Array.isArray(this.plugin.settings.blacklistEntryGroups) ? this.plugin.settings.blacklistEntryGroups : [];
              if (blacklistGroups.length === 0) {
                new Notice(this.plugin.t("no_blacklist_groups_available", "No blacklist groups available"));
                return;
              }
              const modal = new SelectBlacklistGroupModal(this.app, this.plugin, async (selectedGroup) => {
                try {
                  const entryToMove = JSON.parse(JSON.stringify(entry));
                  const idx = this.group.entries.indexOf(entry);
                  if (idx !== -1) {
                    this.group.entries.splice(idx, 1);
                  }
                  if (selectedGroup) {
                    if (!Array.isArray(selectedGroup.entries)) selectedGroup.entries = [];
                    entryToMove.groupUid = selectedGroup.uid;
                    selectedGroup.entries.push(entryToMove);
                  } else {
                    delete entryToMove.groupUid;
                    if (!Array.isArray(this.plugin.settings.blacklistEntries)) this.plugin.settings.blacklistEntries = [];
                    this.plugin.settings.blacklistEntries.push(entryToMove);
                  }
                  await this.plugin.saveSettings();
                  this.plugin.compileBlacklistEntries();
                  this.plugin.reconfigureEditorExtensions();
                  this.plugin.forceRefreshAllEditors();
                  this.plugin.triggerActiveDocumentRerender();
                  this._refreshGroupEntries();
                  const groupName = selectedGroup && selectedGroup.name && String(selectedGroup.name).trim().length > 0 ? selectedGroup.name : "(unnamed group)";
                  new Notice(this.plugin.t("entry_moved_to_group", 'Entry moved to "{groupName}"').replace("{groupName}", groupName));
                } catch (e) {
                  debugError("MODAL", "Error moving entry to blacklist group:", e);
                  new Notice(this.plugin.t("notice_error_moving_entry", "Error moving entry. Please try again."));
                }
              });
              modal.open();
            });
          });
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("duplicate_entry", "Duplicate Entry")).setIcon("copy").onClick(() => {
              const dup = JSON.parse(JSON.stringify(entry));
              this.group.entries.push(dup);
              this._sortMode = "last-added";
              this._refreshGroupEntries();
            });
          });
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("context_delete_entry", "Delete entry")).setIcon("trash").onClick(() => {
              const idx = this.group.entries.indexOf(entry);
              if (idx !== -1) {
                this.group.entries.splice(idx, 1);
                this._refreshGroupEntries();
              }
            });
          });
          menu.showAtPosition({ x: ev.clientX, y: ev.clientY });
        } catch (e) {
          debugError("MODAL", "context menu error", e);
        }
      };
      row.addEventListener("contextmenu", contextMenuHandler);
    });
  }
  onClose() {
    try {
      this.onSave(this.group);
    } catch (e) {
      debugError("MODAL", "auto-save error on close", e);
    }
    try {
      this._cleanupHandlers.forEach((cleanup) => {
        try {
          cleanup();
        } catch (e) {
        }
      });
      this._cleanupHandlers = [];
      this.contentEl.empty();
    } catch (e) {
    }
  }
};
var ColorSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.icon = "palette";
    this._activeTab = "general";
    this.debouncedSaveSettings = debounce(this.plugin.saveSettings.bind(this.plugin), 800);
    this._lastRerender = 0;
    this._cleanupHandlers = [];
    this._entryRows = /* @__PURE__ */ new Map();
    this._suspendSorting = false;
    this._newEntriesSet = /* @__PURE__ */ new Set();
    this._blacklistNewSet = /* @__PURE__ */ new Set();
    this._dynamicHandlers = [];
    this._cachedFolderSuggestions = null;
    this._pathRulesContainer = null;
    this._disabledFilesContainer = null;
    this._blacklistWordsContainer = null;
    this._blacklistGroupsContainer = null;
    this._customSwatchesContainer = null;
    this._wordsSortMode = this.plugin.settings && this.plugin.settings.wordsSortMode ? this.plugin.settings.wordsSortMode : "last-added";
    this._textBgSortMode = "last-added";
    this._blacklistSortMode = this.plugin.settings && this.plugin.settings.blacklistSortMode ? this.plugin.settings.blacklistSortMode : "last-added";
    this._pathSortMode = this.plugin.settings && this.plugin.settings.pathSortMode ? this.plugin.settings.pathSortMode : "last-added";
    this._defaultColorsFolded = true;
    this._customSwatchesFolded = this.plugin.settings && typeof this.plugin.settings.customSwatchesFolded !== "undefined" ? !!this.plugin.settings.customSwatchesFolded : false;
    this._filterMode = null;
    this._entriesMatchTypeStartsWith = false;
    this._entriesMatchTypeEndsWith = false;
    this._entriesMatchTypeExact = false;
    this._entriesWordsOnly = false;
    this._blacklistRegexOnly = false;
    this._blacklistWordsOnly = false;
    this._pathModeOnly = null;
    this._entriesLimit = Number(this.plugin.settings?.entriesSearchLimit ?? 0) || 0;
    this._entriesRegexOnly = false;
    this._entriesSearchMatch = "contains";
    this._blacklistLimit = Number(this.plugin.settings?.blacklistSearchLimit ?? 0) || 0;
    this._blacklistSearchMatchStarts = false;
    this._blacklistSearchMatchEnds = false;
    this._blacklistSearchMatchExact = false;
    this._pathLimit = Number(this.plugin.settings?.pathSearchLimit ?? 0) || 0;
    this._pathSearchMatch = "contains";
  }
  // Create a settings row for a single entry and track cleanup
  _createEntryRow(entry, listDiv) {
    try {
      if (!entry.uid) {
        try {
          entry.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
        } catch (e) {
          entry.uid = Date.now();
        }
      }
      const row = listDiv.createDiv();
      try {
        row.addClass("act-entry-row");
      } catch (e) {
        try {
          row.classList.add("act-entry-row");
        } catch (_) {
        }
      }
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.marginBottom = "8px";
      const styleSelect = row.createEl("select");
      styleSelect.style.padding = "6px";
      styleSelect.style.borderRadius = "4px";
      styleSelect.style.border = "1px solid var(--background-modifier-border)";
      styleSelect.style.background = "var(--background-modifier-form-field)";
      styleSelect.style.color = "var(--text-normal)";
      styleSelect.style.flex = "0 0 auto";
      styleSelect.style.maxWidth = "80px";
      styleSelect.style.width = "stretch";
      styleSelect.style.minWidth = "60px";
      styleSelect.style.textAlign = "center";
      try {
        styleSelect.addClass("act-style-select");
      } catch (e) {
        try {
          styleSelect.classList.add("act-style-select");
        } catch (_) {
        }
      }
      styleSelect.innerHTML = `<option value="text">${this.plugin.t("style_type_text", "color")}</option><option value="highlight">${this.plugin.t("style_type_highlight", "highlight")}</option><option value="both">${this.plugin.t("style_type_both", "both")}</option>`;
      const matchSelect = row.createEl("select");
      matchSelect.style.padding = "6px";
      matchSelect.style.borderRadius = "4px";
      matchSelect.style.border = "1px solid var(--background-modifier-border)";
      matchSelect.style.background = "var(--background-modifier-form-field)";
      matchSelect.style.color = "var(--text-normal)";
      matchSelect.style.flex = "0 0 auto";
      matchSelect.style.maxWidth = "120px";
      matchSelect.style.width = "stretch";
      matchSelect.style.minWidth = "100px";
      matchSelect.style.textAlign = "center";
      try {
        matchSelect.addClass("act-match-select");
      } catch (e) {
        try {
          matchSelect.classList.add("act-match-select");
        } catch (_) {
        }
      }
      matchSelect.innerHTML = `<option value="exact">${this.plugin.t("match_option_exact", "exact")}</option><option value="contains">${this.plugin.t("match_option_contains", "contains")}</option><option value="startsWith">${this.plugin.t("match_option_starts_with", "starts with")}</option><option value="endsWith">${this.plugin.t("match_option_ends_with", "ends with")}</option>`;
      let nameInput = null;
      if (entry.isRegex) {
        nameInput = row.createEl("input", { type: "text", value: String(entry.presetLabel || "") });
        nameInput.style.flex = "0 0 60px";
        nameInput.style.padding = "6px";
        nameInput.style.borderRadius = "4px";
        nameInput.style.border = "1px solid var(--background-modifier-border)";
        nameInput.placeholder = this.plugin.t("regex_name_placeholder", "name your regex");
        try {
          nameInput.addClass("act-regex-name");
        } catch (e) {
        }
      }
      const displayPatterns = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns.join(", ") : entry.pattern;
      const textInput = row.createEl("input", { type: "text", value: displayPatterns });
      textInput.style.flex = "1";
      textInput.style.minWidth = "100px";
      textInput.style.padding = "6px";
      textInput.style.borderRadius = "4px";
      textInput.style.border = "1px solid var(--background-modifier-border)";
      textInput.placeholder = this.plugin.t("word_pattern_placeholder_long", "pattern, word or comma-separated words (e.g. hello, world, foo)");
      const regexChk = row.createEl("input", { type: "checkbox" });
      regexChk.checked = !!entry.isRegex;
      regexChk.title = this.plugin.t("use_regex", "Use Regex");
      regexChk.style.cursor = "pointer";
      regexChk.style.flex = "0 0 auto";
      const regexLabel = row.createEl("label");
      regexLabel.appendChild(document.createTextNode(this.plugin.t("label_regex", "Regex")));
      regexLabel.style.flex = "0 0 auto";
      regexLabel.style.cursor = "pointer";
      regexLabel.style.userSelect = "none";
      regexLabel.style.fontSize = "0.9em";
      regexLabel.onclick = () => {
        regexChk.checked = !regexChk.checked;
      };
      regexChk.style.margin = "0";
      regexLabel.style.display = "none";
      const flagsInput = row.createEl("input", { type: "text", value: entry.flags || "" });
      flagsInput.placeholder = this.plugin.t("flags_placeholder", "flags");
      flagsInput.style.width = "64px";
      flagsInput.style.padding = "6px";
      flagsInput.style.borderRadius = "4px";
      flagsInput.style.border = "1px solid var(--background-modifier-border)";
      flagsInput.style.flex = "0 0 auto";
      const swatchesArr = Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : [];
      const cp = row.createEl("input", { type: "color" });
      cp.title = this.plugin.t("text_color_title", "Text color");
      cp.value = entry.color || "#000000";
      cp.style.width = "30px";
      cp.style.height = "30px";
      cp.style.border = "none";
      cp.style.borderRadius = "4px";
      cp.style.cursor = "pointer";
      cp.style.flex = "0 0 auto";
      let swatchSelect = null;
      if (this.plugin.settings.useSwatchNamesForText && swatchesArr.length > 0) {
        swatchSelect = row.createEl("select");
        swatchSelect.style.padding = "6px";
        swatchSelect.style.borderRadius = "4px";
        swatchSelect.style.border = "1px solid var(--background-modifier-border)";
        swatchSelect.style.background = "var(--background-modifier-form-field)";
        swatchSelect.style.color = "var(--text-normal)";
        swatchSelect.style.flex = "0 0 auto";
        swatchSelect.style.textAlign = "center";
        const defaultOpt = swatchSelect.createEl("option", { text: this.plugin.t("select_swatch", "Select swatch\u2026") });
        defaultOpt.value = "";
        swatchesArr.forEach((sw) => {
          const opt = swatchSelect.createEl("option", { text: sw.name || "" });
          opt.value = sw.name || "";
          if (sw.color && (entry.color || "").toLowerCase() === sw.color.toLowerCase()) {
            swatchSelect.value = opt.value;
          }
        });
      }
      const cpBg = row.createEl("input", { type: "color" });
      cpBg.title = this.plugin.t("highlight_color_title", "Highlight color");
      cpBg.value = entry.backgroundColor || "#000000";
      cpBg.style.width = "30px";
      cpBg.style.height = "30px";
      cpBg.style.border = "none";
      cpBg.style.borderRadius = "4px";
      cpBg.style.cursor = "pointer";
      cpBg.style.flex = "0 0 auto";
      let swatchSelect2 = null;
      if (this.plugin.settings.useSwatchNamesForText && swatchesArr.length > 0) {
        swatchSelect2 = row.createEl("select");
        swatchSelect2.style.padding = "6px";
        swatchSelect2.style.borderRadius = "4px";
        swatchSelect2.style.border = "1px solid var(--background-modifier-border)";
        swatchSelect2.style.background = "var(--background-modifier-form-field)";
        swatchSelect2.style.color = "var(--text-normal)";
        swatchSelect2.style.flex = "0 0 auto";
        swatchSelect2.style.textAlign = "center";
        const defaultOpt2 = swatchSelect2.createEl("option", { text: this.plugin.t("select_highlight_swatch", "Select highlight swatch\u2026") });
        defaultOpt2.value = "";
        swatchesArr.forEach((sw) => {
          const opt = swatchSelect2.createEl("option", { text: sw.name || "" });
          opt.value = sw.name || "";
        });
      }
      const del = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
      del.addClass("mod-warning");
      del.style.padding = "4px 8px";
      del.style.borderRadius = "4px";
      del.style.cursor = "pointer";
      del.style.flex = "0 0 auto";
      const initBgEntry = entry;
      const initialStyle = initBgEntry && initBgEntry.styleType ? initBgEntry.styleType : null;
      if (initialStyle) {
        styleSelect.value = initialStyle;
      } else if (initBgEntry && (initBgEntry.backgroundColor || initBgEntry.textColor)) {
        const hasText = !!(initBgEntry.textColor && initBgEntry.textColor !== "currentColor");
        const hasBg = !!initBgEntry.backgroundColor;
        styleSelect.value = hasText && hasBg ? "both" : hasBg ? "highlight" : "text";
      } else {
        styleSelect.value = "text";
      }
      if (initBgEntry && initBgEntry.textColor && initBgEntry.textColor !== "currentColor") cp.value = initBgEntry.textColor;
      if (initBgEntry && initBgEntry.backgroundColor) cpBg.value = initBgEntry.backgroundColor;
      flagsInput.style.display = entry.isRegex ? "" : "none";
      try {
        let defaultMatch = typeof entry.matchType === "string" && entry.matchType ? entry.matchType.toLowerCase() : this.plugin.settings.partialMatch ? "contains" : "exact";
        if (defaultMatch === "startswith" || defaultMatch === "starts with") defaultMatch = "startswith";
        if (defaultMatch === "endswith" || defaultMatch === "ends with") defaultMatch = "endswith";
        const dropdownValue = defaultMatch === "startswith" ? "startsWith" : defaultMatch === "endswith" ? "endsWith" : defaultMatch;
        matchSelect.value = dropdownValue;
        entry.matchType = defaultMatch;
      } catch (e) {
      }
      const updateInputDisplay = () => {
        if (entry.isRegex) {
          textInput.value = entry.pattern || "";
        } else {
          const patterns = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns : entry.pattern ? [entry.pattern] : [];
          textInput.value = patterns.map((p) => String(p).trim()).join(", ");
        }
      };
      const resolveIdx = () => {
        if (entry && entry.uid) {
          const byUid = this.plugin.settings.wordEntries.findIndex((e) => e && e.uid === entry.uid);
          if (byUid !== -1) return byUid;
        }
        let idx = this.plugin.settings.wordEntries.indexOf(entry);
        if (idx !== -1) return idx;
        const curr = String(textInput.value || "");
        if (!curr) return -1;
        const found = this.plugin.settings.wordEntries.findIndex((e) => {
          const pats = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "")];
          const joined = pats.map((p) => String(p).trim()).join(", ");
          return joined === curr;
        });
        return found;
      };
      const textInputHandler = async () => {
        try {
          const newPattern = textInput.value;
          const idx = resolveIdx();
          if (idx === -1) return;
          if (!newPattern) {
            this.plugin.settings.wordEntries.splice(idx, 1);
          } else if (this.plugin.settings.enableRegexSupport && entry.isRegex && !this.plugin.settings.disableRegexSafety && this.plugin.isRegexTooComplex(newPattern)) {
            new Notice(this.plugin.t("notice_pattern_too_complex", "Pattern too complex: " + newPattern.substring(0, 60) + "..."));
            updateInputDisplay();
            return;
          } else {
            if (entry.isRegex) {
              this.plugin.settings.wordEntries[idx].pattern = newPattern;
              this.plugin.settings.wordEntries[idx].groupedPatterns = null;
              entry.pattern = newPattern;
              entry.groupedPatterns = null;
              const p = newPattern;
              let te = void 0;
              if (p === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1") te = "strong";
              else if (p === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1") te = "em";
              else if (p === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1") te = "strong-em";
              if (te) {
                this.plugin.settings.wordEntries[idx].targetElement = te;
                entry.targetElement = te;
              } else if (entry.targetElement && (entry.targetElement === "strong" || entry.targetElement === "em" || entry.targetElement === "strong-em")) {
                delete this.plugin.settings.wordEntries[idx].targetElement;
                delete entry.targetElement;
              }
            } else {
              const patterns = newPattern.split(",").map((p) => String(p).trim()).filter((p) => p.length > 0);
              this.plugin.settings.wordEntries[idx].pattern = patterns[0];
              this.plugin.settings.wordEntries[idx].groupedPatterns = patterns.length > 1 ? patterns : null;
              entry.pattern = this.plugin.settings.wordEntries[idx].pattern;
              entry.groupedPatterns = this.plugin.settings.wordEntries[idx].groupedPatterns;
            }
          }
          await this.plugin.saveSettings();
          this.plugin.compileWordEntries();
          this.plugin.compileTextBgColoringEntries();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
          this.plugin.forceRefreshAllReadingViews();
          this.plugin.triggerActiveDocumentRerender();
          this._suspendSorting = this._wordsSortMode === "last-added";
          this._refreshEntries();
        } catch (error) {
          debugError("SETTINGS", "Error saving word entry", error);
          new Notice(this.plugin.t("notice_error_saving_changes", "Error saving changes. Please try again."));
        }
      };
      const duplicateHandler = async () => {
        try {
          const idx = resolveIdx();
          if (idx === -1) return;
          const orig = this.plugin.settings.wordEntries[idx];
          const dup = Object.assign({}, orig);
          try {
            dup.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (e) {
            dup.uid = Date.now();
          }
          this.plugin.settings.wordEntries.splice(idx + 1, 0, dup);
          await this.plugin.saveSettings();
          this.plugin.compileWordEntries();
          this.plugin.compileTextBgColoringEntries();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
          this.plugin.forceRefreshAllReadingViews();
          this._suspendSorting = this._wordsSortMode === "last-added";
          this._refreshEntries();
        } catch (e) {
          debugError("SETTINGS", "duplicate entry error", e);
        }
      };
      const openInRegexTesterHandler = async () => {
        try {
          if (!entry.isRegex) return;
          const onAdded = () => {
            try {
              this._refreshEntries();
            } catch (e) {
            }
          };
          const modal = new RealTimeRegexTesterModal(this.app, this.plugin, onAdded);
          modal._editingEntry = entry;
          if (entry.pattern) modal._preFillPattern = entry.pattern;
          if (entry.flags) modal._preFillFlags = entry.flags;
          if (entry.presetLabel) modal._preFillName = entry.presetLabel;
          if (entry.styleType) modal._preFillStyleType = entry.styleType;
          if (entry.color) modal._preFillTextColor = entry.color;
          else if (entry.textColor) modal._preFillTextColor = entry.textColor;
          else if (entry._savedTextColor) modal._preFillTextColor = entry._savedTextColor;
          if (entry.backgroundColor) modal._preFillBgColor = entry.backgroundColor;
          else if (entry._savedBackgroundColor) modal._preFillBgColor = entry._savedBackgroundColor;
          modal.open();
        } catch (e) {
          debugError("SETTINGS", "open in regex tester error", e);
        }
      };
      const resetTextColorHandler = async () => {
        try {
          const idx = resolveIdx();
          if (idx !== -1) {
            const entry2 = this.plugin.settings.wordEntries[idx];
            entry2.textColor = null;
            entry2.color = "";
            if (entry2.backgroundColor) {
              entry2.styleType = "highlight";
            } else {
              entry2.styleType = "text";
            }
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this._refreshEntries();
            new Notice(this.plugin.t("notice_text_color_reset", "Text color reset"));
          }
        } catch (e) {
          debugError("SETTINGS", "reset text color error", e);
        }
      };
      const resetHighlightHandler = async () => {
        try {
          const idx = resolveIdx();
          if (idx !== -1) {
            const entry2 = this.plugin.settings.wordEntries[idx];
            entry2.backgroundColor = null;
            if (entry2.textColor || entry2.color) {
              entry2.styleType = "text";
            } else {
              entry2.styleType = "text";
            }
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this._refreshEntries();
            new Notice(this.plugin.t("notice_highlight_reset", "Highlight color reset"));
          }
        } catch (e) {
          debugError("SETTINGS", "reset highlight error", e);
        }
      };
      const contextMenuHandler = (ev) => {
        try {
          ev && ev.preventDefault && ev.preventDefault();
          if (ev && ev.stopPropagation) ev.stopPropagation();
          const menu = new Menu(this.app);
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("edit_entry_details", "Edit Entry Details")).setIcon("pencil").onClick(() => {
              const modal = new EditEntryModal(this.app, this.plugin, entry, () => {
                try {
                  this._refreshEntries();
                } catch (e) {
                }
              });
              modal.open();
            });
          });
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("duplicate_entry", "Duplicate Entry")).setIcon("copy").onClick(duplicateHandler);
          });
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("reset_text_color", "Reset Text Color")).setIcon("text").onClick(resetTextColorHandler);
          });
          menu.addItem((item) => {
            item.setTitle(this.plugin.t("reset_highlight", "Reset Highlight")).setIcon("rectangle-horizontal").onClick(resetHighlightHandler);
          });
          if (entry.isRegex) {
            menu.addItem((item) => {
              item.setTitle(this.plugin.t("open_in_regex_tester", "Open in Regex Tester")).setIcon("pencil").onClick(openInRegexTesterHandler);
            });
          }
          menu.showAtPosition({ x: ev.clientX, y: ev.clientY });
        } catch (e) {
          debugError("SETTINGS", "context menu error", e);
        }
      };
      const cpHandler = async () => {
        const newColor = cp.value;
        if (!this.plugin.isValidHexColor(newColor)) {
          new Notice(this.plugin.t("notice_invalid_color_format", "Invalid color format."));
          return;
        }
        const idx = resolveIdx();
        if (idx !== -1) {
          const hasBg = !!this.plugin.settings.wordEntries[idx].backgroundColor;
          if (hasBg) {
            this.plugin.settings.wordEntries[idx].textColor = newColor;
            this.plugin.settings.wordEntries[idx].color = "";
            this.plugin.settings.wordEntries[idx].styleType = "both";
            this.plugin.settings.wordEntries[idx]._savedTextColor = newColor;
          } else {
            this.plugin.settings.wordEntries[idx].color = newColor;
            this.plugin.settings.wordEntries[idx].textColor = null;
            this.plugin.settings.wordEntries[idx].backgroundColor = null;
            this.plugin.settings.wordEntries[idx].styleType = "text";
            this.plugin.settings.wordEntries[idx]._savedTextColor = newColor;
          }
          styleSelect.value = this.plugin.settings.wordEntries[idx].styleType || "text";
        }
        if (swatchSelect) {
          try {
            const match = (Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : []).find((sw) => sw.color && sw.color.toLowerCase() === newColor.toLowerCase());
            swatchSelect.value = match ? match.name || "" : "";
          } catch (e) {
          }
        }
        await this.debouncedSaveSettings();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
      };
      const cpBgHandler = async () => {
        const newColor = cpBg.value;
        if (!this.plugin.isValidHexColor(newColor)) return;
        const idx = resolveIdx();
        if (idx !== -1) {
          this.plugin.settings.wordEntries[idx].backgroundColor = newColor;
          if (!this.plugin.settings.wordEntries[idx].textColor || this.plugin.settings.wordEntries[idx].textColor === "currentColor") {
            this.plugin.settings.wordEntries[idx].textColor = "currentColor";
          }
          this.plugin.settings.wordEntries[idx].color = "";
          this.plugin.settings.wordEntries[idx]._savedBackgroundColor = newColor;
          const hasText = !!(this.plugin.settings.wordEntries[idx].textColor && this.plugin.settings.wordEntries[idx].textColor !== "currentColor");
          const hasBg = !!this.plugin.settings.wordEntries[idx].backgroundColor;
          if (hasText && hasBg) {
            this.plugin.settings.wordEntries[idx].styleType = "both";
          } else if (hasBg) {
            this.plugin.settings.wordEntries[idx].styleType = "highlight";
          } else {
            this.plugin.settings.wordEntries[idx].styleType = "text";
          }
          styleSelect.value = this.plugin.settings.wordEntries[idx].styleType || "text";
        }
        if (swatchSelect2) {
          try {
            const match = (Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : []).find((sw) => sw.color && sw.color.toLowerCase() === newColor.toLowerCase());
            swatchSelect2.value = match ? match.name || "" : "";
          } catch (e) {
          }
        }
        await this.debouncedSaveSettings();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
      };
      const regexChkHandler = async () => {
        const idx = resolveIdx();
        if (idx !== -1) this.plugin.settings.wordEntries[idx].isRegex = regexChk.checked;
        flagsInput.style.display = regexChk.checked ? "" : "none";
        if (regexChk.checked && !this.plugin.settings.enableRegexSupport) {
          new Notice(this.plugin.t("notice_regex_support_disabled", "Regex support is disabled. Enable it in settings to use regex patterns."));
        }
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        this.plugin.compileTextBgColoringEntries();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        entry.isRegex = regexChk.checked;
        this._refreshEntries();
      };
      const flagsInputHandler = async () => {
        const idx = resolveIdx();
        if (idx !== -1) this.plugin.settings.wordEntries[idx].flags = flagsInput.value || "";
        await this.plugin.saveSettings();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        entry.flags = flagsInput.value || "";
        this._refreshEntries();
      };
      const delHandler = async () => {
        const idx = this.plugin.settings.wordEntries.indexOf(entry);
        if (idx !== -1) this.plugin.settings.wordEntries.splice(idx, 1);
        await this.plugin.saveSettings();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        const info = this._entryRows.get(entry);
        if (info) {
          try {
            info.cleanup();
          } catch (e) {
          }
          this._entryRows.delete(entry);
        }
        this._refreshEntries();
      };
      textInput.addEventListener("change", textInputHandler);
      textInput.addEventListener("blur", textInputHandler);
      row.addEventListener("contextmenu", contextMenuHandler);
      cp.addEventListener("input", cpHandler);
      cpBg.addEventListener("input", cpBgHandler);
      const cpContextHandler = (ev) => {
        try {
          ev && ev.preventDefault && ev.preventDefault();
          if (ev && ev.stopPropagation) ev.stopPropagation();
          const idx = resolveIdx();
          const preExisting = idx !== -1 ? this.plugin.settings.wordEntries[idx] : entry;
          const preFillText = preExisting && (preExisting.textColor && preExisting.textColor !== "currentColor" ? preExisting.textColor : this.plugin.isValidHexColor(preExisting.color) ? preExisting.color : null) || cp.value;
          const displayText = preExisting && preExisting.isRegex ? preExisting.pattern || "" : Array.isArray(preExisting?.groupedPatterns) && preExisting.groupedPatterns.length > 0 ? preExisting.groupedPatterns.map((p) => String(p).trim()).join(", ") : preExisting && preExisting.pattern ? String(preExisting.pattern) : "";
          const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
            const tc = result && result.textColor || color;
            if (!tc || !this.plugin.isValidHexColor(tc)) return;
            const i = resolveIdx();
            if (i !== -1) {
              const s = this.plugin.settings.wordEntries[i];
              if (s.backgroundColor) {
                s.textColor = tc;
                s.color = "";
                s.styleType = "both";
                s._savedTextColor = tc;
              } else {
                s.color = tc;
                s.textColor = null;
                s.backgroundColor = null;
                s.styleType = "text";
                s._savedTextColor = tc;
              }
              await this.plugin.saveSettings();
              cp.value = tc;
              styleSelect.value = s.styleType || "text";
              this.plugin.reconfigureEditorExtensions();
              this.plugin.forceRefreshAllEditors();
            }
          }, "text", displayText, false);
          try {
            modal._preFillTextColor = preFillText || cp.value;
          } catch (_) {
          }
          try {
            modal.open();
          } catch (_) {
          }
        } catch (_) {
        }
      };
      const cpBgContextHandler = (ev) => {
        try {
          ev && ev.preventDefault && ev.preventDefault();
          if (ev && ev.stopPropagation) ev.stopPropagation();
          const idx = resolveIdx();
          const preExisting = idx !== -1 ? this.plugin.settings.wordEntries[idx] : entry;
          const preFillBg = preExisting && preExisting.backgroundColor || cpBg.value;
          const displayText = preExisting && preExisting.isRegex ? preExisting.pattern || "" : Array.isArray(preExisting?.groupedPatterns) && preExisting.groupedPatterns.length > 0 ? preExisting.groupedPatterns.map((p) => String(p).trim()).join(", ") : preExisting && preExisting.pattern ? String(preExisting.pattern) : "";
          const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
            const bc = result && result.backgroundColor || color;
            if (!bc || !this.plugin.isValidHexColor(bc)) return;
            const i = resolveIdx();
            if (i !== -1) {
              const s = this.plugin.settings.wordEntries[i];
              s.backgroundColor = bc;
              if (!s.textColor || s.textColor === "currentColor") s.textColor = "currentColor";
              s.color = "";
              const hasText = !!(s.textColor && s.textColor !== "currentColor");
              s.styleType = hasText ? "both" : "highlight";
              s._savedBackgroundColor = bc;
              await this.plugin.saveSettings();
              cpBg.value = bc;
              styleSelect.value = s.styleType || "highlight";
              this.plugin.reconfigureEditorExtensions();
              this.plugin.forceRefreshAllEditors();
            }
          }, "background", displayText, false);
          try {
            modal._preFillBgColor = preFillBg || cpBg.value;
          } catch (_) {
          }
          try {
            modal.open();
          } catch (_) {
          }
        } catch (_) {
        }
      };
      cp.addEventListener("contextmenu", cpContextHandler);
      cpBg.addEventListener("contextmenu", cpBgContextHandler);
      regexChk.addEventListener("change", regexChkHandler);
      flagsInput.addEventListener("change", flagsInputHandler);
      del.addEventListener("click", delHandler);
      const nameInputHandler = async () => {
        if (!nameInput) return;
        const idx = resolveIdx();
        if (idx !== -1) {
          const val = String(nameInput.value || "").trim();
          this.plugin.settings.wordEntries[idx].presetLabel = val || void 0;
          entry.presetLabel = val || void 0;
          await this.plugin.saveSettings();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
        }
      };
      if (nameInput) {
        nameInput.addEventListener("change", nameInputHandler);
        nameInput.addEventListener("blur", nameInputHandler);
      }
      const swatchSelectHandler = async () => {
        if (!swatchSelect) return;
        const chosen = (Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : []).find((sw) => (sw.name || "") === swatchSelect.value);
        if (!chosen) return;
        const c = chosen.color;
        if (!this.plugin.isValidHexColor(c)) return;
        cp.value = c;
        await cpHandler();
      };
      if (swatchSelect) {
        swatchSelect.addEventListener("change", swatchSelectHandler);
      }
      const swatchSelect2Handler = async () => {
        if (!swatchSelect2) return;
        const chosen = (Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : []).find((sw) => (sw.name || "") === swatchSelect2.value);
        if (!chosen) return;
        const c = chosen.color;
        if (!this.plugin.isValidHexColor(c)) return;
        cpBg.value = c;
        await cpBgHandler();
      };
      if (swatchSelect2) {
        swatchSelect2.addEventListener("change", swatchSelect2Handler);
      }
      const updateVisibility = () => {
        const style = styleSelect.value;
        matchSelect.style.display = entry.isRegex ? "none" : "";
        if (style === "text") {
          cp.style.display = "";
          if (swatchSelect) swatchSelect.style.display = "";
          cpBg.style.display = "none";
          if (swatchSelect2) swatchSelect2.style.display = "none";
          flagsInput.style.display = entry.isRegex ? "" : "none";
          if (nameInput) nameInput.style.display = entry.isRegex ? "" : "none";
          try {
            const val = entry.color || (entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.backgroundColor || "") || cp.value;
            if (val && this.plugin.isValidHexColor(val)) cp.value = val;
          } catch (e) {
          }
        } else if (style === "highlight") {
          cp.style.display = "none";
          if (swatchSelect) swatchSelect.style.display = "none";
          cpBg.style.display = "";
          if (swatchSelect2) swatchSelect2.style.display = "";
          flagsInput.style.display = entry.isRegex ? "" : "none";
          if (nameInput) nameInput.style.display = entry.isRegex ? "" : "none";
          try {
            const val = entry.backgroundColor || (entry.color || (entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : "")) || cpBg.value;
            if (val && this.plugin.isValidHexColor(val)) cpBg.value = val;
          } catch (e) {
          }
        } else {
          cp.style.display = "";
          if (swatchSelect) swatchSelect.style.display = "";
          cpBg.style.display = "";
          if (swatchSelect2) swatchSelect2.style.display = "";
          flagsInput.style.display = entry.isRegex ? "" : "none";
          if (nameInput) nameInput.style.display = entry.isRegex ? "" : "none";
          try {
            const t = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color || "";
            const b = entry.backgroundColor || "";
            if (t && this.plugin.isValidHexColor(t)) cp.value = t;
            if (b && this.plugin.isValidHexColor(b)) cpBg.value = b;
          } catch (e) {
          }
        }
      };
      updateVisibility();
      const styleChangeHandler = async () => {
        const idx = this.plugin.settings.wordEntries.indexOf(entry);
        if (idx !== -1) {
          const curr = this.plugin.settings.wordEntries[idx];
          const prevStyle = curr.styleType || "text";
          const nextStyle = styleSelect.value;
          if (prevStyle !== nextStyle) {
            if (nextStyle === "text") {
              if (curr.textColor && curr.textColor !== "currentColor") curr._savedTextColor = curr.textColor;
              if (curr.color) curr._savedTextColor = curr.color;
              if (curr.backgroundColor) curr._savedBackgroundColor = curr.backgroundColor;
              const textOnly = curr._savedTextColor || (curr.textColor && curr.textColor !== "currentColor" ? curr.textColor : this.plugin.isValidHexColor(curr.color) ? curr.color : "");
              curr.color = textOnly || curr.color || "";
              curr.textColor = null;
              curr.backgroundColor = null;
            } else if (nextStyle === "highlight") {
              if (curr.textColor && curr.textColor !== "currentColor") curr._savedTextColor = curr.textColor;
              if (curr.color) curr._savedTextColor = curr.color;
              if (curr.backgroundColor) curr._savedBackgroundColor = curr.backgroundColor;
              const bgOnly = curr._savedBackgroundColor || curr.backgroundColor || curr._savedTextColor || (this.plugin.isValidHexColor(curr.color) ? curr.color : null);
              curr.backgroundColor = bgOnly;
              curr.textColor = "currentColor";
              curr.color = "";
            } else {
              const textBase = curr._savedTextColor || (curr.textColor && curr.textColor !== "currentColor" ? curr.textColor : null) || (curr.color || null);
              const bgBase = curr._savedBackgroundColor || (curr.backgroundColor || null);
              if (textBase) curr.textColor = textBase;
              if (bgBase) curr.backgroundColor = bgBase;
              curr.color = "";
            }
          }
          curr.styleType = nextStyle;
          await this.plugin.saveSettings();
        }
        updateVisibility();
        try {
          const t = entry.textColor && entry.textColor !== "currentColor" ? entry.textColor : entry.color || "";
          const b = entry.backgroundColor || "";
          if (t && this.plugin.isValidHexColor(t)) cp.value = t;
          if (b && this.plugin.isValidHexColor(b)) cpBg.value = b;
        } catch (e) {
        }
      };
      styleSelect.addEventListener("change", styleChangeHandler);
      const matchChangeHandler = async () => {
        const idx = resolveIdx();
        if (idx !== -1) {
          let value = matchSelect.value;
          if (value === "startsWith") value = "startswith";
          if (value === "endsWith") value = "endswith";
          this.plugin.settings.wordEntries[idx].matchType = value;
          entry.matchType = value;
          try {
            debugLog("MATCH_CHANGE_SAVE", `idx=${idx}, dropdown="${matchSelect.value}", stored="${value}", pattern="${entry.pattern.substring(0, 20)}"`);
          } catch (_) {
          }
          await this.plugin.saveSettings();
          this.plugin.compileWordEntries();
          this.plugin.compileTextBgColoringEntries();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
          this.plugin.forceRefreshAllReadingViews();
          this._refreshEntries();
        }
      };
      matchSelect.addEventListener("change", matchChangeHandler);
      matchSelect.addEventListener("input", matchChangeHandler);
      const cleanup = () => {
        try {
          textInput.removeEventListener("change", textInputHandler);
        } catch (e) {
        }
        try {
          textInput.removeEventListener("blur", textInputHandler);
        } catch (e) {
        }
        try {
          row.removeEventListener("contextmenu", contextMenuHandler);
        } catch (e) {
        }
        try {
          cp.removeEventListener("input", cpHandler);
        } catch (e) {
        }
        try {
          cpBg.removeEventListener("input", cpBgHandler);
        } catch (e) {
        }
        try {
          cp.removeEventListener("contextmenu", cpContextHandler);
        } catch (e) {
        }
        try {
          cpBg.removeEventListener("contextmenu", cpBgContextHandler);
        } catch (e) {
        }
        try {
          regexChk.removeEventListener("change", regexChkHandler);
        } catch (e) {
        }
        try {
          flagsInput.removeEventListener("change", flagsInputHandler);
        } catch (e) {
        }
        try {
          del.removeEventListener("click", delHandler);
        } catch (e) {
        }
        try {
          if (swatchSelect) swatchSelect.removeEventListener("change", swatchSelectHandler);
        } catch (e) {
        }
        try {
          if (swatchSelect2) swatchSelect2.removeEventListener("change", swatchSelect2Handler);
        } catch (e) {
        }
        try {
          styleSelect.removeEventListener("change", styleChangeHandler);
        } catch (e) {
        }
        try {
          matchSelect.removeEventListener("change", matchChangeHandler);
        } catch (e) {
        }
        try {
          row.remove();
        } catch (e) {
        }
      };
      this._entryRows.set(entry, { row, elements: { nameInput, textInput, styleSelect, matchSelect, cp, cpBg, regexChk, flagsInput, del }, cleanup });
      this._cleanupHandlers.push(cleanup);
    } catch (e) {
      debugError("SETTINGS", "_createEntryRow error", e);
    }
  }
  _refreshDisabledFiles() {
    try {
      if (!this._disabledFilesContainer) return;
      const hasAny = Array.isArray(this.plugin.settings.disabledFiles) && this.plugin.settings.disabledFiles.length > 0;
      if (!this._disabledFilesHeaderEl) {
        this._disabledFilesContainer.empty();
        this._disabledFilesHeaderEl = this._disabledFilesContainer.createEl("h5", { text: this.plugin.t("disabled_files_header", "Files with coloring disabled:") });
        this._disabledFilesHeaderEl.style.margin = "20px 0 8px 0";
        this._disabledFilesHeaderEl.style.marginTop = "20px";
        this._disabledFilesSearchContainer = this._disabledFilesContainer.createDiv();
        try {
          this._disabledFilesSearchContainer.addClass("act-search-container");
        } catch (e) {
          try {
            this._disabledFilesSearchContainer.classList.add("act-search-container");
          } catch (_) {
          }
        }
        this._disabledFilesSearchContainer.style.margin = "8px 0";
        this._disabledFilesSearchContainer.style.display = "flex";
        this._disabledFilesSearchContainer.style.alignItems = "center";
        this._disabledFilesSearchInput = this._disabledFilesSearchContainer.createEl("input", { type: "text" });
        try {
          this._disabledFilesSearchInput.addClass("act-search-input");
        } catch (e) {
          try {
            this._disabledFilesSearchInput.classList.add("act-search-input");
          } catch (_) {
          }
        }
        this._disabledFilesSearchInput.placeholder = this.plugin.t("search_disabled_files_placeholder", "Search disabled files\u2026");
        this._disabledFilesSearchInput.title = this.plugin.t("search_disabled_files_aria_label", "Search disabled files");
        try {
          this._disabledFilesSearchInput.setAttribute("aria-label", this.plugin.t("search_disabled_files_aria_label", "Search disabled files"));
        } catch (_) {
        }
        this._disabledFilesSearchInput.style.flex = "1 1 auto";
        this._disabledFilesSearchInput.style.padding = "6px 6px 6px 30px";
        this._disabledFilesSearchInput.style.border = "1px solid var(--background-modifier-border)";
        this._disabledFilesSearchInput.value = String(this._disabledFilesSearchQuery || "");
        this._disabledFilesSearchIcon = this._disabledFilesSearchContainer.createDiv();
        try {
          this._disabledFilesSearchIcon.addClass("act-search-icon");
        } catch (e) {
          try {
            this._disabledFilesSearchIcon.classList.add("act-search-icon");
          } catch (_) {
          }
        }
        const searchHandler = () => {
          this._disabledFilesSearchQuery = String(this._disabledFilesSearchInput.value || "");
          this._refreshDisabledFiles();
        };
        this._disabledFilesSearchInput.addEventListener("input", searchHandler);
        this._disabledFilesSearchInput.addEventListener("click", searchHandler);
        try {
          this._cleanupHandlers && this._cleanupHandlers.push(() => {
            try {
              this._disabledFilesSearchInput.removeEventListener("input", searchHandler);
            } catch (_) {
            }
            try {
              this._disabledFilesSearchInput.removeEventListener("click", searchHandler);
            } catch (_) {
            }
          });
        } catch (_) {
        }
        this._disabledFilesListEl = this._disabledFilesContainer.createDiv();
      }
      this._disabledFilesHeaderEl.style.display = hasAny ? "" : "none";
      this._disabledFilesSearchContainer.style.display = hasAny ? "flex" : "none";
      try {
        this._disabledFilesListEl.empty();
      } catch (e) {
        try {
          this._disabledFilesListEl.innerHTML = "";
        } catch (_) {
        }
      }
      if (!hasAny) return;
      if (this._disabledFilesSearchInput && String(this._disabledFilesSearchInput.value || "") !== String(this._disabledFilesSearchQuery || "")) {
        this._disabledFilesSearchInput.value = String(this._disabledFilesSearchQuery || "");
      }
      const q = String(this._disabledFilesSearchQuery || "").trim().toLowerCase();
      const matchesQuery = (filePath) => {
        if (!q) return true;
        const fp = String(filePath || "");
        const name = fp.split("/").pop() || fp;
        return fp.toLowerCase().includes(q) || name.toLowerCase().includes(q);
      };
      this.plugin.settings.disabledFiles.filter(matchesQuery).forEach((filePath) => {
        new Setting(this._disabledFilesListEl).setName(filePath).addExtraButton((btn) => btn.setIcon("x").setTooltip(this.plugin.t("tooltip_enable_for_file", "Enable for this file")).onClick(async () => {
          const index = this.plugin.settings.disabledFiles.indexOf(filePath);
          if (index > -1) {
            this.plugin.settings.disabledFiles.splice(index, 1);
          }
          await this.plugin.saveSettings();
          this._refreshDisabledFiles();
        }));
      });
    } catch (e) {
      debugError("SETTINGS", "_refreshDisabledFiles error", e);
    }
  }
  _refreshBlacklistWords() {
    try {
      if (!this._blacklistWordsContainer) return;
      this._blacklistWordsContainer.empty();
      let entries = Array.isArray(this.plugin.settings.blacklistEntries) ? [...this.plugin.settings.blacklistEntries] : [];
      const q = String(this._blacklistSearchQuery || "").trim().toLowerCase();
      if (q) {
        entries = entries.filter((e) => {
          const patterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "")];
          const text = [
            ...patterns.map((p) => p.toLowerCase()),
            String(e.presetLabel || "").toLowerCase(),
            String(e.flags || "").toLowerCase()
          ].join(" ");
          const hay = text;
          if (this._blacklistSearchMatchStarts || this._blacklistSearchMatchEnds || this._blacklistSearchMatchExact) {
            let matches = false;
            if (this._blacklistSearchMatchStarts) matches = matches || hay.startsWith(q);
            if (this._blacklistSearchMatchEnds) matches = matches || hay.endsWith(q);
            if (this._blacklistSearchMatchExact) matches = matches || hay === q;
            return matches;
          }
          return hay.includes(q);
        });
      }
      if (this._blacklistRegexOnly) {
        entries = entries.filter((e) => !!e.isRegex);
      } else if (this._blacklistWordsOnly) {
        entries = entries.filter((e) => !e.isRegex);
      }
      if (this._blacklistSortMode === "a-z") {
        entries.sort((a, b) => {
          const aPat = Array.isArray(a.groupedPatterns) && a.groupedPatterns.length > 0 ? a.groupedPatterns[0] : a.pattern || "";
          const bPat = Array.isArray(b.groupedPatterns) && b.groupedPatterns.length > 0 ? b.groupedPatterns[0] : b.pattern || "";
          const aEmpty = String(aPat).trim().length === 0;
          const bEmpty = String(bPat).trim().length === 0;
          if (aEmpty && !bEmpty) return 1;
          if (!aEmpty && bEmpty) return -1;
          return String(aPat).toLowerCase().localeCompare(String(bPat).toLowerCase());
        });
      } else if (this._blacklistSortMode === "reverse-a-z") {
        entries.sort((a, b) => {
          const aPat = Array.isArray(a.groupedPatterns) && a.groupedPatterns.length > 0 ? a.groupedPatterns[0] : a.pattern || "";
          const bPat = Array.isArray(b.groupedPatterns) && b.groupedPatterns.length > 0 ? b.groupedPatterns[0] : b.pattern || "";
          const aEmpty = String(aPat).trim().length === 0;
          const bEmpty = String(bPat).trim().length === 0;
          if (aEmpty && !bEmpty) return 1;
          if (!aEmpty && bEmpty) return -1;
          return String(bPat).toLowerCase().localeCompare(String(aPat).toLowerCase());
        });
      }
      if (this._blacklistNewSet && this._blacklistNewSet.size > 0) {
        const newList = [];
        const baseOrder = Array.isArray(this.plugin.settings.blacklistEntries) ? [...this.plugin.settings.blacklistEntries] : [];
        baseOrder.forEach((e) => {
          if (e && e.uid && this._blacklistNewSet.has(e.uid)) newList.push(e);
        });
        const oldList = entries.filter((e) => !(e && e.uid && this._blacklistNewSet.has(e.uid)));
        entries = [...oldList, ...newList];
      }
      const persistAtEndEntries = entries.filter((e) => e && e.persistAtEnd === true);
      const regularEntries = entries.filter((e) => !e || e.persistAtEnd !== true);
      const limitedRegularEntries = this._blacklistLimit && this._blacklistLimit > 0 ? regularEntries.slice(-this._blacklistLimit) : regularEntries;
      const limitedEntries = [...limitedRegularEntries, ...persistAtEndEntries];
      limitedEntries.forEach((entry) => {
        const row = this._blacklistWordsContainer.createDiv();
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.marginBottom = "8px";
        row.style.gap = "8px";
        const displayPatterns = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns.join(", ") : entry.pattern || "";
        if (entry.presetLabel) {
          const badge = row.createEl("span", { text: entry.presetLabel });
          badge.style.marginRight = "8px";
          badge.style.opacity = "0.7";
        }
        const textInput = row.createEl("input", { type: "text", value: displayPatterns });
        textInput.style.flex = "1";
        textInput.style.padding = "6px";
        textInput.style.borderRadius = "4px";
        textInput.style.border = "1px solid var(--background-modifier-border)";
        textInput.placeholder = this.plugin.t("word_pattern_placeholder_short", "Keyword or pattern, or comma-separated words");
        const regexChk = row.createEl("input", { type: "checkbox" });
        regexChk.checked = !!entry.isRegex;
        regexChk.title = this.plugin.t("use_regex", "Use Regex");
        regexChk.style.cursor = "pointer";
        const flagsInput = row.createEl("input", { type: "text", value: entry.flags || "" });
        flagsInput.placeholder = this.plugin.t("flags_placeholder", "flags");
        flagsInput.style.width = "50px";
        flagsInput.style.padding = "6px";
        flagsInput.style.borderRadius = "4px";
        flagsInput.style.border = "1px solid var(--background-modifier-border)";
        if (!entry.isRegex) flagsInput.style.display = "none";
        const del = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
        del.addClass("mod-warning");
        del.style.padding = "4px 8px";
        del.style.borderRadius = "4px";
        del.style.cursor = "pointer";
        if (!entry.uid) {
          try {
            entry.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (e) {
            entry.uid = Date.now();
          }
        }
        const updateInputDisplay = () => {
          if (regexChk && regexChk.checked) {
            textInput.value = entry.pattern || "";
          } else {
            const patterns = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns : entry.pattern ? [entry.pattern] : [];
            textInput.value = patterns.map((p) => String(p).trim()).join(", ");
          }
        };
        const resolveBlacklistIndex = () => {
          let entryIdx = -1;
          if (entry && entry.uid) {
            entryIdx = this.plugin.settings.blacklistEntries.findIndex((e) => e && e.uid === entry.uid);
          }
          if (entryIdx === -1) {
            const currJoined = (() => {
              const pats = Array.isArray(entry.groupedPatterns) && entry.groupedPatterns.length > 0 ? entry.groupedPatterns : entry.pattern ? [entry.pattern] : [];
              return pats.map((p) => String(p).trim()).join(", ");
            })();
            entryIdx = this.plugin.settings.blacklistEntries.findIndex((e) => {
              const pats = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : e.pattern ? [e.pattern] : [];
              const joined = pats.map((p) => String(p).trim()).join(", ");
              return joined === currJoined && !!e.isRegex === !!entry.isRegex && String(e.flags || "") === String(entry.flags || "") && String(e.presetLabel || "") === String(entry.presetLabel || "");
            });
          }
          if (entryIdx !== -1 && (!entry.uid || !this.plugin.settings.blacklistEntries[entryIdx].uid)) {
            try {
              const uid = entry.uid || Date.now().toString(36) + Math.random().toString(36).slice(2);
              this.plugin.settings.blacklistEntries[entryIdx].uid = uid;
              entry.uid = uid;
            } catch (e) {
            }
          }
          return entryIdx;
        };
        const textInputHandler = async () => {
          try {
            const newPattern = textInput.value;
            let entryIdx = resolveBlacklistIndex();
            if (entryIdx === -1) return;
            if (!newPattern) {
              this.plugin.settings.blacklistEntries.splice(entryIdx, 1);
            } else if (this.plugin.settings.enableRegexSupport && entry.isRegex && !this.plugin.settings.disableRegexSafety && this.plugin.isRegexTooComplex(newPattern)) {
              new Notice(this.plugin.t("notice_pattern_too_complex", "Pattern too complex: " + newPattern.substring(0, 60) + "..."));
              updateInputDisplay();
              return;
            } else {
              if (entry.isRegex) {
                this.plugin.settings.blacklistEntries[entryIdx].pattern = newPattern;
                this.plugin.settings.blacklistEntries[entryIdx].groupedPatterns = null;
                entry.pattern = newPattern;
                entry.groupedPatterns = null;
              } else {
                const patterns = newPattern.split(",").map((p) => String(p).trim()).filter((p) => p.length > 0);
                this.plugin.settings.blacklistEntries[entryIdx].pattern = patterns[0];
                this.plugin.settings.blacklistEntries[entryIdx].groupedPatterns = patterns.length > 1 ? patterns : null;
                entry.pattern = this.plugin.settings.blacklistEntries[entryIdx].pattern;
                entry.groupedPatterns = this.plugin.settings.blacklistEntries[entryIdx].groupedPatterns;
              }
            }
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this.plugin.triggerActiveDocumentRerender();
            this._refreshBlacklistWords();
          } catch (error) {
            debugError("SETTINGS", "Error saving blacklist entry", error);
            new Notice(this.plugin.t("notice_error_saving_changes", "Error saving changes. Please try again."));
          }
        };
        const regexChkHandler = async () => {
          let entryIdx = resolveBlacklistIndex();
          if (entryIdx === -1) return;
          this.plugin.settings.blacklistEntries[entryIdx].isRegex = regexChk.checked;
          flagsInput.style.display = regexChk.checked ? "inline-block" : "none";
          await this.plugin.saveSettings();
          entry.isRegex = regexChk.checked;
          this._refreshBlacklistWords();
        };
        const flagsInputHandler = async () => {
          let entryIdx = resolveBlacklistIndex();
          if (entryIdx === -1) return;
          this.plugin.settings.blacklistEntries[entryIdx].flags = flagsInput.value || "";
          await this.plugin.saveSettings();
          entry.flags = flagsInput.value || "";
          this._refreshBlacklistWords();
        };
        const delHandler = async () => {
          let entryIdx = resolveBlacklistIndex();
          if (entryIdx === -1) return;
          this.plugin.settings.blacklistEntries.splice(entryIdx, 1);
          await this.plugin.saveSettings();
          this._refreshBlacklistWords();
        };
        const duplicateHandler = async () => {
          try {
            let entryIdx = resolveBlacklistIndex();
            if (entryIdx === -1) return;
            const orig = this.plugin.settings.blacklistEntries[entryIdx];
            const dup = Object.assign({}, orig);
            try {
              dup.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
            } catch (e) {
              dup.uid = Date.now();
            }
            this.plugin.settings.blacklistEntries.splice(entryIdx + 1, 0, dup);
            await this.plugin.saveSettings();
            this._suspendSorting = this._blacklistSortMode === "last-added";
            this._refreshBlacklistWords();
          } catch (e) {
            debugError("SETTINGS", "duplicate blacklist entry error", e);
          }
        };
        const openInRegexTesterHandler = async () => {
          try {
            if (!entry.isRegex) return;
            const onAdded = () => {
              try {
                this._refreshBlacklistWords();
              } catch (e) {
              }
            };
            const modal = new BlacklistRegexTesterModal(this.app, this.plugin, onAdded);
            modal._editingEntry = entry;
            if (entry.pattern) modal._preFillPattern = entry.pattern;
            if (entry.flags) modal._preFillFlags = entry.flags;
            if (entry.presetLabel) modal._preFillName = entry.presetLabel;
            modal.open();
          } catch (e) {
            debugError("SETTINGS", "open in regex tester error", e);
          }
        };
        const contextMenuHandler = (ev) => {
          try {
            ev && ev.preventDefault && ev.preventDefault();
            if (ev && ev.stopPropagation) ev.stopPropagation();
            const menu = new Menu(this.app);
            menu.addItem((item) => {
              item.setTitle(this.plugin.t("move_to_blacklist_group", "Move to blacklist group")).setIcon("arrow-right").onClick(() => {
                const blacklistGroups = Array.isArray(this.plugin.settings.blacklistEntryGroups) ? this.plugin.settings.blacklistEntryGroups : [];
                if (blacklistGroups.length === 0) {
                  new Notice(this.plugin.t("no_blacklist_groups_available", "No blacklist groups available"));
                  return;
                }
                const modal = new SelectBlacklistGroupModal(this.app, this.plugin, async (selectedGroup) => {
                  if (!selectedGroup) return;
                  try {
                    const entryToMove = JSON.parse(JSON.stringify(entry));
                    let entryIdx = resolveBlacklistIndex();
                    if (entryIdx !== -1) {
                      this.plugin.settings.blacklistEntries.splice(entryIdx, 1);
                    }
                    if (!Array.isArray(selectedGroup.entries)) selectedGroup.entries = [];
                    entryToMove.groupUid = selectedGroup.uid;
                    selectedGroup.entries.push(entryToMove);
                    await this.plugin.saveSettings();
                    this.plugin.compileBlacklistEntries();
                    this.plugin.reconfigureEditorExtensions();
                    this.plugin.forceRefreshAllEditors();
                    this.plugin.triggerActiveDocumentRerender();
                    this._refreshBlacklistWords();
                    const groupName = selectedGroup && selectedGroup.name && String(selectedGroup.name).trim().length > 0 ? selectedGroup.name : "(unnamed group)";
                    new Notice(this.plugin.t("entry_moved_to_group", 'Entry moved to "{groupName}"').replace("{groupName}", groupName));
                  } catch (e) {
                    debugError("SETTINGS", "Error moving entry to blacklist group:", e);
                    new Notice(this.plugin.t("notice_error_moving_entry", "Error moving entry. Please try again."));
                  }
                });
                modal.open();
              });
            });
            menu.addItem((item) => {
              item.setTitle(this.plugin.t("duplicate_entry", "Duplicate Entry")).setIcon("copy").onClick(duplicateHandler);
            });
            if (entry.isRegex) {
              menu.addItem((item) => {
                item.setTitle(this.plugin.t("open_in_regex_tester", "Open in Regex Tester")).setIcon("pencil").onClick(openInRegexTesterHandler);
              });
            }
            menu.addItem((item) => {
              item.setTitle(this.plugin.t("context_delete_entry", "Delete entry")).setIcon("trash").onClick(delHandler);
            });
            menu.showAtPosition({ x: ev.clientX, y: ev.clientY });
          } catch (e) {
            debugError("SETTINGS", "context menu error", e);
          }
        };
        textInput.addEventListener("change", textInputHandler);
        textInput.addEventListener("blur", textInputHandler);
        row.addEventListener("contextmenu", contextMenuHandler);
        regexChk.addEventListener("change", regexChkHandler);
        flagsInput.addEventListener("change", flagsInputHandler);
        del.addEventListener("click", delHandler);
        this._cleanupHandlers.push(() => {
          try {
            textInput.removeEventListener("change", textInputHandler);
          } catch (e) {
          }
          try {
            textInput.removeEventListener("blur", textInputHandler);
          } catch (e) {
          }
          try {
            row.removeEventListener("contextmenu", contextMenuHandler);
          } catch (e) {
          }
          try {
            regexChk.removeEventListener("change", regexChkHandler);
          } catch (e) {
          }
          try {
            flagsInput.removeEventListener("change", flagsInputHandler);
          } catch (e) {
          }
          try {
            del.removeEventListener("click", delHandler);
          } catch (e) {
          }
        });
      });
    } catch (e) {
      debugError("SETTINGS", "_refreshBlacklistWords error", e);
    }
  }
  _refreshPathRules() {
    try {
      if (!this._pathRulesContainer) return;
      this._pathRulesContainer.empty();
      const rows = Array.isArray(this.plugin.settings.pathRules) ? [...this.plugin.settings.pathRules] : [];
      const q = String(this._pathRulesSearchQuery || "").trim().toLowerCase();
      let filteredRows = q ? rows.filter((r) => {
        const text = [String(r.path || ""), String(r.mode || ""), String(r.matchType || "")].join(" ").toLowerCase();
        const hay = text;
        if (this._pathSearchMatch === "starts") return hay.startsWith(q);
        if (this._pathSearchMatch === "ends") return hay.endsWith(q);
        if (this._pathSearchMatch === "exact") return hay === q;
        return hay.includes(q);
      }) : rows;
      if (this._pathModeOnly === "include") {
        filteredRows = filteredRows.filter((r) => String(r.mode || "") === "include");
      } else if (this._pathModeOnly === "exclude") {
        filteredRows = filteredRows.filter((r) => String(r.mode || "") === "exclude");
      }
      if (!this._suspendSorting) {
        if (this._pathSortMode === "a-z") {
          filteredRows.sort((a, b) => {
            const aPath = String(a.path || "");
            const bPath = String(b.path || "");
            const aEmpty = aPath.trim().length === 0;
            const bEmpty = bPath.trim().length === 0;
            if (aEmpty && !bEmpty) return 1;
            if (!aEmpty && bEmpty) return -1;
            return aPath.toLowerCase().localeCompare(bPath.toLowerCase());
          });
        } else if (this._pathSortMode === "reverse-a-z") {
          filteredRows.sort((a, b) => {
            const aPath = String(a.path || "");
            const bPath = String(b.path || "");
            const aEmpty = aPath.trim().length === 0;
            const bEmpty = bPath.trim().length === 0;
            if (aEmpty && !bEmpty) return 1;
            if (!aEmpty && bEmpty) return -1;
            return bPath.toLowerCase().localeCompare(aPath.toLowerCase());
          });
        } else if (this._pathSortMode === "mode") {
          const order = { "exclude": 0, "include": 1 };
          filteredRows.sort((a, b) => {
            const aPath = String(a.path || "");
            const bPath = String(b.path || "");
            const aEmpty = aPath.trim().length === 0;
            const bEmpty = bPath.trim().length === 0;
            if (aEmpty && !bEmpty) return 1;
            if (!aEmpty && bEmpty) return -1;
            const styleCmp = (order[String(a.mode || "")] ?? 1) - (order[String(b.mode || "")] ?? 1);
            if (styleCmp !== 0) return styleCmp;
            return aPath.toLowerCase().localeCompare(bPath.toLowerCase());
          });
        } else if (this._pathSortMode === "type") {
          filteredRows.sort((a, b) => {
            const aPath = String(a.path || "");
            const bPath = String(b.path || "");
            const aEmpty = aPath.trim().length === 0;
            const bEmpty = bPath.trim().length === 0;
            if (aEmpty && !bEmpty) return 1;
            if (!aEmpty && bEmpty) return -1;
            const typeCmp = Boolean(a.isFolder) === Boolean(b.isFolder) ? 0 : a.isFolder ? -1 : 1;
            if (typeCmp !== 0) return typeCmp;
            return aPath.toLowerCase().localeCompare(bPath.toLowerCase());
          });
        }
      }
      const buildSuggestions = () => {
        const files = this.app.vault.getFiles();
        const folders = /* @__PURE__ */ new Set();
        const filePaths = [];
        files.forEach((f) => {
          const p = String(f.path).replace(/\\/g, "/");
          filePaths.push(p);
          const idx = p.lastIndexOf("/");
          const folder = idx !== -1 ? p.slice(0, idx) : "";
          if (folder) {
            const parts = folder.split("/");
            let acc = "";
            parts.forEach((part) => {
              acc = acc ? acc + "/" + part : part;
              folders.add(acc);
            });
          }
        });
        return { files: filePaths.sort(), folders: Array.from(folders).sort() };
      };
      const sugg = buildSuggestions();
      const limitedRows = this._pathLimit && this._pathLimit > 0 ? filteredRows.slice(-this._pathLimit) : filteredRows;
      limitedRows.forEach((entry, filterIndex) => {
        const actualIndex = rows.indexOf(entry);
        if (actualIndex === -1) return;
        const row = this._pathRulesContainer.createDiv();
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.marginBottom = "8px";
        const modeSel = row.createEl("select");
        modeSel.style.flex = "0 0 auto";
        modeSel.style.padding = "6px";
        modeSel.style.borderRadius = "4px";
        modeSel.style.border = "1px solid var(--background-modifier-border)";
        modeSel.style.background = "var(--background-modifier-form-field)";
        modeSel.style.textAlign = "center";
        ["include", "exclude"].forEach((val) => {
          const opt = modeSel.createEl("option", { text: this.plugin.t("path_rule_mode_" + val, val === "include" ? "Include" : "Exclude") });
          opt.value = val;
        });
        modeSel.value = entry.mode === "exclude" ? "exclude" : "include";
        const input = row.createEl("input", { type: "text", value: entry.path || "" });
        input.placeholder = this.plugin.t("enter_path_or_pattern", "Enter path or pattern");
        input.style.flex = "1";
        input.style.padding = "6px";
        input.style.borderRadius = "4px";
        input.style.border = "1px solid var(--background-modifier-border)";
        const del = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
        del.addClass("mod-warning");
        del.style.border = "none";
        del.style.cursor = "pointer";
        del.style.flex = "0 0 auto";
        const updateDropdown = () => {
          if (input._actDropdown) {
            const dd2 = input._actDropdown;
            if (input._dropdownScrollListener) {
              document.removeEventListener("scroll", input._dropdownScrollListener, true);
              input._dropdownScrollListener = null;
            }
            if (input._dropdownClickListener) {
              document.removeEventListener("click", input._dropdownClickListener);
              input._dropdownClickListener = null;
            }
            if (input._dropdownKeyListener) {
              document.removeEventListener("keydown", input._dropdownKeyListener);
              input._dropdownKeyListener = null;
            }
            dd2.remove();
            input._actDropdown = null;
          }
          const val = String(input.value || "").trim().toLowerCase();
          const list = [];
          sugg.folders.forEach((f) => list.push({ t: "folder", p: f }));
          sugg.files.forEach((f) => list.push({ t: "file", p: f }));
          const filtered = val ? list.filter((x) => x.p.toLowerCase().includes(val)) : list;
          if (filtered.length === 0) return;
          const dd = document.createElement("div");
          Object.assign(dd.style, { position: "fixed", zIndex: 2e3, background: "var(--background-primary)", color: "var(--text-normal)", border: "1px solid var(--background-modifier-border)", borderRadius: "6px", boxShadow: "0 6px 18px rgba(0,0,0,0.4)", maxHeight: "240px", overflowY: "auto", padding: "6px 0", minWidth: Math.max(240, input.offsetWidth) + "px" });
          let hi = -1;
          filtered.forEach((item) => {
            const it = document.createElement("div");
            it.textContent = item.p || "/";
            Object.assign(it.style, { padding: "8px 12px", cursor: "pointer", whiteSpace: "nowrap" });
            it.onmouseenter = () => {
              if (hi >= 0 && dd.children[hi]) dd.children[hi].style.background = "transparent";
              it.style.background = "var(--background-secondary)";
              hi = Array.from(dd.children).indexOf(it);
            };
            it.onmouseleave = () => {
              it.style.background = "transparent";
            };
            it.onclick = async (e) => {
              e.stopPropagation();
              input.value = item.p + (item.t === "folder" ? "/" : "");
              const ev = new Event("change", { bubbles: true });
              input.dispatchEvent(ev);
              dd.remove();
              input._actDropdown = null;
            };
            dd.appendChild(it);
          });
          document.body.appendChild(dd);
          const pos = () => {
            const r = input.getBoundingClientRect();
            dd.style.left = r.left + "px";
            dd.style.top = r.bottom + 6 + "px";
            dd.style.width = input.offsetWidth + "px";
          };
          pos();
          input._actDropdown = dd;
          input._dropdownScrollListener = pos;
          input._dropdownClickListener = (ev) => {
            if (ev.target === input) return;
            if (!dd.contains(ev.target)) {
              dd.remove();
              input._actDropdown = null;
              document.removeEventListener("click", input._dropdownClickListener);
              document.removeEventListener("scroll", input._dropdownScrollListener, true);
              document.removeEventListener("keydown", input._dropdownKeyListener);
              input._dropdownClickListener = null;
              input._dropdownScrollListener = null;
              input._dropdownKeyListener = null;
            }
          };
          input._dropdownKeyListener = (ev) => {
            const items = Array.from(dd.children);
            if (items.length === 0) return;
            if (ev.key === "ArrowDown") {
              ev.preventDefault();
              hi = Math.min(hi + 1, items.length - 1);
              items.forEach((item) => item.style.background = "transparent");
              if (hi >= 0) {
                items[hi].style.background = "var(--background-secondary)";
                items[hi].scrollIntoView({ block: "nearest" });
              }
            } else if (ev.key === "ArrowUp") {
              ev.preventDefault();
              hi = Math.max(hi - 1, -1);
              items.forEach((item) => item.style.background = "transparent");
              if (hi >= 0) {
                items[hi].style.background = "var(--background-secondary)";
                items[hi].scrollIntoView({ block: "nearest" });
              }
            } else if (ev.key === "Enter" && hi >= 0) {
              ev.preventDefault();
              items[hi].click();
            } else if (ev.key === "Escape") {
              ev.preventDefault();
              dd.remove();
              input._actDropdown = null;
              document.removeEventListener("keydown", input._dropdownKeyListener);
              input._dropdownKeyListener = null;
            }
          };
          document.addEventListener("scroll", pos, true);
          document.addEventListener("click", input._dropdownClickListener);
          document.addEventListener("keydown", input._dropdownKeyListener);
          this._cleanupHandlers.push(() => {
            try {
              document.removeEventListener("scroll", pos, true);
            } catch (e) {
            }
            try {
              document.removeEventListener("click", input._dropdownClickListener);
            } catch (e) {
            }
            try {
              document.removeEventListener("keydown", input._dropdownKeyListener);
            } catch (e) {
            }
            if (input._actDropdown) {
              try {
                input._actDropdown.remove();
              } catch (e) {
              }
              input._actDropdown = null;
            }
          });
        };
        const focusHandler = () => {
          updateDropdown();
        };
        input.addEventListener("focus", focusHandler);
        const clickHandler = () => {
          updateDropdown();
        };
        input.addEventListener("click", clickHandler);
        this._cleanupHandlers.push(() => input.removeEventListener("focus", focusHandler));
        this._cleanupHandlers.push(() => input.removeEventListener("click", clickHandler));
        const inputHandler = () => {
          updateDropdown();
        };
        input.addEventListener("input", inputHandler);
        this._cleanupHandlers.push(() => input.removeEventListener("input", inputHandler));
        const changeHandler = async () => {
          let newPath = String(input.value || "").trim().replace(/\\\\/g, "/");
          const isFolderSel = /\/$/.test(newPath) || !/\.[a-zA-Z0-9]+$/.test(newPath) && newPath.includes("/");
          if (isFolderSel && !/\/$/.test(newPath)) newPath = newPath + "/";
          this.plugin.settings.pathRules[actualIndex].path = newPath;
          this.plugin.settings.pathRules[actualIndex].isFolder = isFolderSel;
          await this.plugin.saveSettings();
          this._refreshPathRules();
        };
        input.addEventListener("change", changeHandler);
        this._cleanupHandlers.push(() => input.removeEventListener("change", changeHandler));
        const modeHandler = async () => {
          this.plugin.settings.pathRules[actualIndex].mode = modeSel.value;
          await this.plugin.saveSettings();
          this._refreshPathRules();
        };
        modeSel.addEventListener("change", modeHandler);
        this._cleanupHandlers.push(() => modeSel.removeEventListener("change", modeHandler));
        const delHandler = async () => {
          if (actualIndex !== -1 && this.plugin.settings.pathRules[actualIndex]) {
            this.plugin.settings.pathRules.splice(actualIndex, 1);
            await this.plugin.saveSettings();
            this._refreshPathRules();
          }
        };
        del.addEventListener("click", delHandler);
        this._cleanupHandlers.push(() => del.removeEventListener("click", delHandler));
      });
      if (rows.length === 0) {
        this._pathRulesContainer.createEl("p", { text: this.plugin.t("no_rules_configured", "No rules configured.") });
      }
    } catch (e) {
      debugError("SETTINGS", "_refreshPathRules error", e);
    }
  }
  _refreshCustomSwatches() {
    try {
      if (!this._customSwatchesContainer) return;
      this._customSwatchesContainer.empty();
      if (typeof this._defaultColorsFolded === "undefined") {
        this._defaultColorsFolded = true;
      }
      if (typeof this._customSwatchesFolded === "undefined") {
        this._customSwatchesFolded = this.plugin.settings.customSwatchesFolded || false;
      }
      const defaultColorsHeaderDiv = this._customSwatchesContainer.createDiv();
      defaultColorsHeaderDiv.style.display = "flex";
      defaultColorsHeaderDiv.style.alignItems = "center";
      defaultColorsHeaderDiv.style.gap = "8px";
      defaultColorsHeaderDiv.style.marginTop = "16px";
      defaultColorsHeaderDiv.style.marginBottom = "8px";
      defaultColorsHeaderDiv.style.cursor = "pointer";
      const defaultColorsToggle = defaultColorsHeaderDiv.createEl("span");
      defaultColorsToggle.textContent = this._defaultColorsFolded ? "\u25B6" : "\u25BC";
      defaultColorsToggle.style.fontSize = "12px";
      defaultColorsToggle.style.fontWeight = "bold";
      defaultColorsToggle.style.display = "inline-block";
      defaultColorsToggle.style.width = "16px";
      const defaultColorsTitle = defaultColorsHeaderDiv.createEl("h5", { text: this.plugin.t("default_colors_header", "Default Swatches") });
      defaultColorsTitle.style.margin = "0";
      defaultColorsTitle.style.padding = "0";
      defaultColorsTitle.style.flex = "1";
      defaultColorsTitle.style.fontSize = "16px";
      defaultColorsTitle.style.fontWeight = "600";
      const defaultColorsContent = this._customSwatchesContainer.createDiv();
      defaultColorsContent.style.display = this._defaultColorsFolded ? "none" : "block";
      defaultColorsContent.style.marginBottom = "16px";
      const defaultColorsToggleHandler = () => {
        this._defaultColorsFolded = !this._defaultColorsFolded;
        defaultColorsToggle.textContent = this._defaultColorsFolded ? "\u25B6" : "\u25BC";
        defaultColorsContent.style.display = this._defaultColorsFolded ? "none" : "block";
      };
      defaultColorsHeaderDiv.addEventListener("click", defaultColorsToggleHandler);
      this._cleanupHandlers.push(() => defaultColorsHeaderDiv.removeEventListener("click", defaultColorsToggleHandler));
      const swatches = Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : [];
      swatches.forEach((sw) => {
        const row = defaultColorsContent.createDiv();
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.marginBottom = "8px";
        const nameInput = row.createEl("input", { type: "text", value: sw && sw.name ? sw.name : "Unnamed" });
        nameInput.style.flex = "1";
        nameInput.style.padding = "6px";
        nameInput.style.borderRadius = "4px";
        nameInput.style.border = "1px solid var(--background-modifier-border)";
        nameInput.disabled = true;
        const colorPicker = row.createEl("input", { type: "color" });
        colorPicker.value = sw && sw.color ? sw.color : "#000000";
        colorPicker.style.width = "30px";
        colorPicker.style.height = "30px";
        colorPicker.style.border = "none";
        colorPicker.style.borderRadius = "4px";
        colorPicker.style.cursor = "pointer";
        colorPicker.disabled = true;
        const infoSpan = row.createEl("span", { text: this.plugin.t("label_built_in", "(built-in)") });
        infoSpan.style.fontSize = "12px";
        infoSpan.style.opacity = "0.6";
        infoSpan.style.flex = "0 0 auto";
      });
      const customSwatchesHeaderDiv = this._customSwatchesContainer.createDiv();
      customSwatchesHeaderDiv.style.display = "flex";
      customSwatchesHeaderDiv.style.alignItems = "center";
      customSwatchesHeaderDiv.style.gap = "8px";
      customSwatchesHeaderDiv.style.marginTop = "16px";
      customSwatchesHeaderDiv.style.marginBottom = "8px";
      customSwatchesHeaderDiv.style.cursor = "pointer";
      const customSwatchesToggle = customSwatchesHeaderDiv.createEl("span");
      customSwatchesToggle.textContent = this._customSwatchesFolded ? "\u25B6" : "\u25BC";
      customSwatchesToggle.style.fontSize = "12px";
      customSwatchesToggle.style.fontWeight = "bold";
      customSwatchesToggle.style.display = "inline-block";
      customSwatchesToggle.style.width = "16px";
      const customSwatchesTitle = customSwatchesHeaderDiv.createEl("h5", { text: this.plugin.t("custom_swatches_header", "Custom Swatches") });
      customSwatchesTitle.style.margin = "0";
      customSwatchesTitle.style.padding = "0";
      customSwatchesTitle.style.flex = "1";
      customSwatchesTitle.style.fontSize = "16px";
      customSwatchesTitle.style.fontWeight = "600";
      const customSwatchesContent = this._customSwatchesContainer.createDiv();
      customSwatchesContent.style.display = this._customSwatchesFolded ? "none" : "block";
      customSwatchesContent.style.marginBottom = "16px";
      const customSwatchesToggleHandler = async () => {
        this._customSwatchesFolded = !this._customSwatchesFolded;
        this.plugin.settings.customSwatchesFolded = this._customSwatchesFolded;
        await this.plugin.saveSettings();
        customSwatchesToggle.textContent = this._customSwatchesFolded ? "\u25B6" : "\u25BC";
        customSwatchesContent.style.display = this._customSwatchesFolded ? "none" : "block";
      };
      customSwatchesHeaderDiv.addEventListener("click", customSwatchesToggleHandler);
      this._cleanupHandlers.push(() => customSwatchesHeaderDiv.removeEventListener("click", customSwatchesToggleHandler));
      const userCustomSwatches = Array.isArray(this.plugin.settings.userCustomSwatches) ? this.plugin.settings.userCustomSwatches : [];
      if (userCustomSwatches.length === 0) {
        const emptyMsg = customSwatchesContent.createEl("p", { text: this.plugin.t("no_custom_swatches_yet", 'No custom swatches yet. Click "+ Add color" to create one.') });
        emptyMsg.style.opacity = "0.6";
        emptyMsg.style.fontSize = "12px";
      } else {
        let dragSource = null;
        let dragStartOrder = null;
        const saveDragReorder = async () => {
          const swatchRows = Array.from(customSwatchesContent.querySelectorAll("div[data-swatch-index]"));
          const newOrder = swatchRows.map((r) => {
            const idx = parseInt(r.getAttribute("data-swatch-index"), 10);
            return this.plugin.settings.userCustomSwatches[idx];
          });
          this.plugin.settings.userCustomSwatches = newOrder;
          this.plugin.settings.customSwatches = this.plugin.settings.userCustomSwatches.map((s) => s.color);
          await this.plugin.saveSettings();
          this._refreshCustomSwatches();
        };
        userCustomSwatches.forEach((sw, i) => {
          const row = customSwatchesContent.createDiv();
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.style.marginBottom = "8px";
          row.setAttribute("data-swatch-index", i.toString());
          const dragHandle = row.createEl("button");
          setIcon(dragHandle, "menu");
          dragHandle.style.padding = "0";
          dragHandle.style.border = "none";
          dragHandle.style.background = "transparent";
          dragHandle.style.boxShadow = "none";
          dragHandle.style.cursor = "grab";
          dragHandle.style.color = "var(--text-muted)";
          dragHandle.style.flexShrink = "0";
          dragHandle.style.display = "flex";
          dragHandle.style.alignItems = "center";
          dragHandle.style.justifyContent = "center";
          dragHandle.setAttribute("aria-label", this.plugin.t("drag_to_reorder", "Drag to reorder"));
          const nameInput = row.createEl("input", { type: "text", value: sw && sw.name ? sw.name : `Swatch ${i + 1}` });
          nameInput.style.flex = "1";
          nameInput.style.padding = "6px";
          nameInput.style.borderRadius = "4px";
          nameInput.style.border = "1px solid var(--background-modifier-border)";
          const colorPicker = row.createEl("input", { type: "color" });
          colorPicker.value = sw && sw.color ? sw.color : "#000000";
          colorPicker.style.width = "30px";
          colorPicker.style.height = "30px";
          colorPicker.style.border = "none";
          colorPicker.style.borderRadius = "4px";
          colorPicker.style.cursor = "pointer";
          colorPicker.style.flexShrink = "0";
          const colorPickerContextHandler = (ev) => {
            try {
              ev.preventDefault();
              ev.stopPropagation();
              const modal = new ColorPickerModal(this.app, this.plugin, async (color) => {
                if (color && this.plugin.isValidHexColor(color)) {
                  colorPicker.value = color;
                  await colorHandler();
                }
              }, "text", sw && sw.name ? sw.name : "");
              modal._hideHeaderControls = true;
              modal._preFillTextColor = colorPicker.value;
              modal.open();
            } catch (_) {
            }
          };
          const delBtn = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
          delBtn.addClass("mod-warning");
          delBtn.style.padding = "4px 8px";
          delBtn.style.borderRadius = "4px";
          delBtn.style.cursor = "pointer";
          delBtn.style.flexShrink = "0";
          const nameHandler = async () => {
            const val = nameInput.value.trim();
            this.plugin.settings.userCustomSwatches[i].name = val || `Swatch ${i + 1}`;
            this.plugin.settings.customSwatches = this.plugin.settings.userCustomSwatches.map((s) => s.color);
            await this.plugin.saveSettings();
          };
          const colorHandler = async () => {
            const val = colorPicker.value;
            if (!this.plugin.isValidHexColor(val)) return;
            const prev = this.plugin.settings.userCustomSwatches[i].color;
            const swName = this.plugin.settings.userCustomSwatches[i].name || `Swatch ${i + 1}`;
            this.plugin.settings.userCustomSwatches[i].color = val;
            this.plugin.settings.customSwatches = this.plugin.settings.userCustomSwatches.map((s) => s.color);
            if (this.plugin.settings.linkSwatchUpdatesToEntries) {
              const updateEntry = (e) => {
                try {
                  if (e) {
                    if (typeof e.color === "string" && e.color.toLowerCase() === String(prev || "").toLowerCase()) {
                      e.color = val;
                      e._savedTextColor = val;
                    }
                    if (typeof e.textColor === "string" && e.textColor !== "currentColor" && e.textColor.toLowerCase() === String(prev || "").toLowerCase()) {
                      e.textColor = val;
                      e._savedTextColor = val;
                    }
                    if (typeof e.backgroundColor === "string" && e.backgroundColor.toLowerCase() === String(prev || "").toLowerCase()) {
                      e.backgroundColor = val;
                      e._savedBackgroundColor = val;
                    }
                  }
                } catch (_) {
                }
              };
              const entries = Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries : [];
              entries.forEach(updateEntry);
              const groups = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : [];
              groups.forEach((g) => {
                if (g && Array.isArray(g.entries)) {
                  g.entries.forEach(updateEntry);
                }
              });
            }
            await this.plugin.saveSettings();
            try {
              this.plugin.compileWordEntries();
              this.plugin.compileTextBgColoringEntries();
              this.plugin.reconfigureEditorExtensions();
              this.plugin.forceRefreshAllEditors();
              this.plugin.forceRefreshAllReadingViews();
              this.plugin.triggerActiveDocumentRerender();
              this._refreshEntries();
            } catch (_) {
            }
          };
          const delHandler = async () => {
            this.plugin.settings.userCustomSwatches.splice(i, 1);
            this.plugin.settings.customSwatches = this.plugin.settings.userCustomSwatches.map((s) => s.color);
            await this.plugin.saveSettings();
            this._refreshCustomSwatches();
          };
          dragHandle.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const startX = e.clientX;
            const startY = e.clientY;
            const rect = row.getBoundingClientRect();
            const offsetX = startX - rect.left;
            const offsetY = startY - rect.top;
            if (navigator.vibrate) navigator.vibrate(100);
            const ghost = document.body.createDiv({ cls: "drag-reorder-ghost" });
            const clone = row.cloneNode(true);
            const originalInputs = row.querySelectorAll("input, select, textarea");
            const clonedInputs = clone.querySelectorAll("input, select, textarea");
            originalInputs.forEach((el, idx) => {
              if (clonedInputs[idx]) clonedInputs[idx].value = el.value;
            });
            ghost.appendChild(clone);
            ghost.style.width = `${rect.width}px`;
            ghost.style.height = `${rect.height}px`;
            ghost.style.left = `${rect.left}px`;
            ghost.style.top = `${rect.top}px`;
            row.classList.add("drag-ghost-hidden");
            const onMove = (moveEvent) => {
              moveEvent.preventDefault();
              const currentX = moveEvent.clientX;
              const currentY = moveEvent.clientY;
              ghost.style.left = `${currentX - offsetX}px`;
              ghost.style.top = `${currentY - offsetY}px`;
              const children = Array.from(customSwatchesContent.querySelectorAll("div[data-swatch-index]"));
              const currentIndex = children.indexOf(row);
              if (currentIndex === -1) return;
              if (currentIndex > 0) {
                const prevRow = children[currentIndex - 1];
                const prevRect = prevRow.getBoundingClientRect();
                const prevOverdrag = prevRect.height * 0.25;
                if (currentY < prevRect.bottom - prevOverdrag) {
                  if (navigator.vibrate) navigator.vibrate(100);
                  customSwatchesContent.insertBefore(row, prevRow);
                  const item = userCustomSwatches.splice(currentIndex, 1)[0];
                  userCustomSwatches.splice(currentIndex - 1, 0, item);
                  Array.from(customSwatchesContent.querySelectorAll("div[data-swatch-index]")).forEach((r, idx) => {
                    r.setAttribute("data-swatch-index", idx.toString());
                  });
                  return;
                }
              }
              if (currentIndex < children.length - 1) {
                const nextRow = children[currentIndex + 1];
                const nextRect = nextRow.getBoundingClientRect();
                const nextOverdrag = nextRect.height * 0.25;
                if (currentY > nextRect.top + nextOverdrag) {
                  if (navigator.vibrate) navigator.vibrate(100);
                  nextRow.after(row);
                  const item = userCustomSwatches.splice(currentIndex, 1)[0];
                  userCustomSwatches.splice(currentIndex + 1, 0, item);
                  Array.from(customSwatchesContent.querySelectorAll("div[data-swatch-index]")).forEach((r, idx) => {
                    r.setAttribute("data-swatch-index", idx.toString());
                  });
                  return;
                }
              }
            };
            const onEnd = async () => {
              document.removeEventListener("mousemove", onMove);
              document.removeEventListener("mouseup", onEnd);
              ghost.remove();
              row.classList.remove("drag-ghost-hidden");
              this.plugin.settings.userCustomSwatches = userCustomSwatches;
              this.plugin.settings.customSwatches = this.plugin.settings.userCustomSwatches.map((s) => s.color);
              await this.plugin.saveSettings();
              this._refreshCustomSwatches();
            };
            document.addEventListener("mousemove", onMove);
            document.addEventListener("mouseup", onEnd);
          });
          nameInput.addEventListener("change", nameHandler);
          colorPicker.addEventListener("input", colorHandler);
          colorPicker.addEventListener("contextmenu", colorPickerContextHandler);
          delBtn.addEventListener("click", delHandler);
        });
      }
      const addButtonSetting = new Setting(customSwatchesContent);
      addButtonSetting.addButton((b) => b.setButtonText(this.plugin.t("btn_add_color", "+ Add color")).onClick(async () => {
        const nextIndex = (Array.isArray(this.plugin.settings.userCustomSwatches) ? this.plugin.settings.userCustomSwatches.length : 0) + 1;
        const newSwatch = { name: `Swatch ${nextIndex}`, color: "#000000" };
        if (!Array.isArray(this.plugin.settings.userCustomSwatches)) this.plugin.settings.userCustomSwatches = [];
        this.plugin.settings.userCustomSwatches.push(newSwatch);
        this.plugin.settings.customSwatches = this.plugin.settings.userCustomSwatches.map((s) => s.color);
        await this.plugin.saveSettings();
        this._customSwatchesFolded = false;
        this._refreshCustomSwatches();
      }));
      try {
        addButtonSetting.settingEl.style.display = "flex";
        addButtonSetting.settingEl.style.justifyContent = "flex-end";
        addButtonSetting.settingEl.style.border = "none";
        addButtonSetting.settingEl.style.background = "transparent";
        addButtonSetting.settingEl.style.padding = "0";
        addButtonSetting.settingEl.style.marginBottom = "10px";
        addButtonSetting.settingEl.style.marginTop = "12px";
      } catch (_) {
      }
    } catch (e) {
      debugError("SETTINGS", "_refreshCustomSwatches error", e);
    }
  }
  _refreshQuickColors() {
    try {
      if (!this._quickColorsContainer) return;
      this._quickColorsContainer.empty();
      const headerDiv = this._quickColorsContainer.createDiv();
      headerDiv.style.display = "flex";
      headerDiv.style.alignItems = "center";
      headerDiv.style.justifyContent = "space-between";
      headerDiv.style.marginTop = "30px";
      headerDiv.style.marginBottom = "8px";
      const leftDiv = headerDiv.createDiv();
      leftDiv.style.display = "flex";
      leftDiv.style.alignItems = "center";
      leftDiv.style.gap = "10px";
      leftDiv.createEl("h3", { text: this.plugin.t("quick_colors_header", "Quick Colors"), style: "margin: 0;" });
      const toggle = new Setting(leftDiv).addToggle((t) => t.setValue(this.plugin.settings.quickColorsEnabled).onChange(async (v) => {
        this.plugin.settings.quickColorsEnabled = v;
        await this.plugin.saveSettings();
        this._refreshQuickColors();
      }));
      toggle.settingEl.style.border = "none";
      toggle.settingEl.style.padding = "0";
      toggle.settingEl.style.background = "none";
      toggle.settingEl.addClass("act-toggle");
      const desc = this._quickColorsContainer.createDiv();
      desc.addClass("act-desc");
      desc.style.margin = "-16px 0 14px";
      desc.textContent = this.plugin.t("quick_colors_desc", "Allows you to quickly highlight or color text by showing colors in the right-click menu. If Quick Colors are off, per-style colors in Quick Styles will be used.");
      const listDiv = this._quickColorsContainer.createDiv();
      listDiv.style.display = "flex";
      listDiv.style.flexWrap = "wrap";
      listDiv.style.gap = "8px";
      listDiv.style.alignItems = "center";
      listDiv.style.width = "100%";
      listDiv.style.boxSizing = "border-box";
      const colors = Array.isArray(this.plugin.settings.quickColors) ? this.plugin.settings.quickColors : [];
      if (colors.length > 0) {
        colors.forEach((pair, i) => {
          if (!pair || typeof pair !== "object") pair = { textColor: "#87c760", backgroundColor: "#1d5010", uid: Date.now().toString(36) + Math.random().toString(36).slice(2) };
          const row = listDiv.createDiv();
          row.style.display = "inline-flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.style.marginBottom = "8px";
          row.style.border = "1px solid var(--background-modifier-border)";
          row.style.borderRadius = "var(--setting-items-radius)";
          row.style.backgroundColor = "var(--setting-items-background)";
          row.style.padding = "6px";
          row.style.flex = "0 0 auto";
          row.setAttribute("data-qc-index", String(i));
          const dragHandle = row.createEl("button");
          setIcon(dragHandle, "menu");
          dragHandle.style.padding = "0";
          dragHandle.style.border = "none";
          dragHandle.style.background = "transparent";
          dragHandle.style.boxShadow = "none";
          dragHandle.style.cursor = "grab";
          dragHandle.style.color = "var(--text-muted)";
          dragHandle.style.flexShrink = "0";
          dragHandle.style.display = "flex";
          dragHandle.style.alignItems = "center";
          dragHandle.style.justifyContent = "center";
          dragHandle.setAttribute("aria-label", this.plugin.t("drag_to_reorder", "Drag to reorder"));
          const tCp = row.createEl("input", { type: "color" });
          tCp.value = pair.textColor && this.plugin.isValidHexColor(pair.textColor) ? pair.textColor : "#87c760";
          tCp.style.width = "30px";
          tCp.style.height = "30px";
          tCp.style.borderRadius = "50%";
          tCp.style.border = "none";
          tCp.style.padding = "0";
          tCp.style.overflow = "hidden";
          tCp.style.background = "transparent";
          tCp.style.cursor = "pointer";
          tCp.title = this.plugin.t("text_color_title", "Text Color");
          const tChange = async () => {
            const val = tCp.value;
            if (!this.plugin.isValidHexColor(val)) return;
            this.plugin.settings.quickColors[i].textColor = val;
            await this.plugin.saveSettings();
          };
          tCp.addEventListener("input", tChange);
          tCp.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
              const chosen = result && result.textColor && this.plugin.isValidHexColor(result.textColor) ? result.textColor : color && this.plugin.isValidHexColor(color) ? color : tCp.value;
              if (chosen && this.plugin.isValidHexColor(chosen)) {
                tCp.value = chosen;
                await tChange();
              }
            }, "text", this.plugin.t("selected_text_preview", "Selected Text"));
            modal._hideHeaderControls = true;
            modal._preFillTextColor = tCp.value;
            modal.open();
          });
          const bCp = row.createEl("input", { type: "color" });
          bCp.value = pair.backgroundColor && this.plugin.isValidHexColor(pair.backgroundColor) ? pair.backgroundColor : "#1d5010";
          bCp.style.width = "30px";
          bCp.style.height = "30px";
          bCp.style.borderRadius = "50%";
          bCp.style.border = "none";
          bCp.style.padding = "0";
          bCp.style.overflow = "hidden";
          bCp.style.background = "transparent";
          bCp.style.cursor = "pointer";
          bCp.title = this.plugin.t("highlight_color_title", "Highlight Color");
          const bChange = async () => {
            const val = bCp.value;
            if (!this.plugin.isValidHexColor(val)) return;
            this.plugin.settings.quickColors[i].backgroundColor = val;
            await this.plugin.saveSettings();
          };
          bCp.addEventListener("input", bChange);
          bCp.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            const modal = new ColorPickerModal(this.app, this.plugin, async (color, result) => {
              const chosen = result && result.backgroundColor && this.plugin.isValidHexColor(result.backgroundColor) ? result.backgroundColor : color && this.plugin.isValidHexColor(color) ? color : bCp.value;
              if (chosen && this.plugin.isValidHexColor(chosen)) {
                bCp.value = chosen;
                await bChange();
              }
            }, "background", this.plugin.t("selected_text_preview", "Selected Text"), false);
            modal._hideHeaderControls = true;
            modal._preFillBgColor = bCp.value;
            modal._preFillBorderColor = bCp.value;
            modal.open();
          });
          const delBtn = row.createEl("button", { text: this.plugin.t("delete_button_text", "\u2715") });
          delBtn.addClass("mod-warning");
          delBtn.style.padding = "4px 8px";
          delBtn.style.borderRadius = "4px";
          delBtn.style.cursor = "pointer";
          delBtn.style.flexShrink = "0";
          delBtn.addEventListener("click", async () => {
            this.plugin.settings.quickColors.splice(i, 1);
            await this.plugin.saveSettings();
            this._refreshQuickColors();
          });
          dragHandle.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const startX = e.clientX;
            const startY = e.clientY;
            const rect = row.getBoundingClientRect();
            const offsetX = startX - rect.left;
            const offsetY = startY - rect.top;
            if (navigator.vibrate) navigator.vibrate(100);
            const ghost = document.body.createDiv({ cls: "drag-reorder-ghost" });
            const clone = row.cloneNode(true);
            const originalInputs = row.querySelectorAll("input, select, textarea");
            const clonedInputs = clone.querySelectorAll("input, select, textarea");
            originalInputs.forEach((el, idx) => {
              if (clonedInputs[idx]) clonedInputs[idx].value = el.value;
            });
            ghost.appendChild(clone);
            ghost.style.width = `${rect.width}px`;
            ghost.style.height = `${rect.height}px`;
            ghost.style.left = `${rect.left}px`;
            ghost.style.top = `${rect.top}px`;
            row.classList.add("drag-ghost-hidden");
            const onMove = (moveEvent) => {
              moveEvent.preventDefault();
              const currentX = moveEvent.clientX;
              const currentY = moveEvent.clientY;
              ghost.style.left = `${currentX - offsetX}px`;
              ghost.style.top = `${currentY - offsetY}px`;
              const target = document.elementFromPoint(currentX, currentY);
              const targetRow = target ? target.closest("div[data-qc-index]") : null;
              if (targetRow && targetRow !== row && targetRow.parentNode === listDiv) {
                const children = Array.from(listDiv.querySelectorAll("div[data-qc-index]"));
                const currentIndex = children.indexOf(row);
                const targetIndex = children.indexOf(targetRow);
                if (currentIndex !== -1 && targetIndex !== -1) {
                  if (currentIndex < targetIndex) {
                    if (navigator.vibrate) navigator.vibrate(100);
                    targetRow.after(row);
                    const item = colors.splice(currentIndex, 1)[0];
                    colors.splice(targetIndex, 0, item);
                    Array.from(listDiv.querySelectorAll("div[data-qc-index]")).forEach((r, idx) => {
                      r.setAttribute("data-qc-index", idx.toString());
                    });
                    return;
                  } else if (currentIndex > targetIndex) {
                    if (navigator.vibrate) navigator.vibrate(100);
                    listDiv.insertBefore(row, targetRow);
                    const item = colors.splice(currentIndex, 1)[0];
                    colors.splice(targetIndex, 0, item);
                    Array.from(listDiv.querySelectorAll("div[data-qc-index]")).forEach((r, idx) => {
                      r.setAttribute("data-qc-index", idx.toString());
                    });
                    return;
                  }
                }
              }
            };
            const onEnd = async () => {
              document.removeEventListener("mousemove", onMove);
              document.removeEventListener("mouseup", onEnd);
              ghost.remove();
              row.classList.remove("drag-ghost-hidden");
              this.plugin.settings.quickColors = colors;
              await this.plugin.saveSettings();
              this._refreshQuickColors();
            };
            document.addEventListener("mousemove", onMove);
            document.addEventListener("mouseup", onEnd);
          });
        });
      }
      const btnRow = this._quickColorsContainer.createDiv();
      btnRow.style.display = "flex";
      btnRow.style.justifyContent = "flex-end";
      btnRow.style.marginTop = "10px";
      const addBtn = btnRow.createEl("button", { text: this.plugin.t("btn_add_color", "+ Add Color") });
      addBtn.addEventListener("click", async () => {
        const newPair = { textColor: "#87c760", backgroundColor: "#1d5010", uid: Date.now().toString(36) + Math.random().toString(36).slice(2) };
        this.plugin.settings.quickColors.push(newPair);
        await this.plugin.saveSettings();
        this._refreshQuickColors();
      });
      const modeSetting = new Setting(this._quickColorsContainer).setName(this.plugin.t("quick_colors_apply_mode_label", "The text coloring will apply as")).addDropdown((d) => {
        d.addOption("act", this.plugin.t("quick_colors_apply_mode_act", "Always Color Text"));
        d.addOption("html", this.plugin.t("quick_colors_apply_mode_html", "Inline HTML"));
        d.setValue(this.plugin.settings.quickColorsApplyMode || "html");
        d.onChange(async (v) => {
          this.plugin.settings.quickColorsApplyMode = v;
          await this.plugin.saveSettings();
        });
        if (d.selectEl) {
          d.selectEl.style.textAlign = "center";
          d.selectEl.style.textAlignLast = "center";
          d.selectEl.style.minWidth = "180px";
        }
      });
      try {
        modeSetting.settingEl.style.marginTop = "10px";
      } catch (e) {
      }
    } catch (e) {
      debugError("SETTINGS", e);
    }
  }
  _refreshQuickStyles() {
    try {
      if (!this._quickStylesContainer) return;
      this._quickStylesContainer.empty();
      const headerDiv = this._quickStylesContainer.createDiv();
      headerDiv.style.display = "flex";
      headerDiv.style.alignItems = "center";
      headerDiv.style.justifyContent = "space-between";
      headerDiv.style.marginTop = "30px";
      headerDiv.style.marginBottom = "8px";
      const leftDiv = headerDiv.createDiv();
      leftDiv.style.display = "flex";
      leftDiv.style.alignItems = "center";
      leftDiv.style.gap = "10px";
      leftDiv.createEl("h3", { text: this.plugin.t("quick_styles_header", "Quick Styles"), style: "margin: 0;" });
      const toggle = new Setting(leftDiv).addToggle((t) => t.setValue(!!this.plugin.settings.quickStylesEnabled).onChange(async (v) => {
        this.plugin.settings.quickStylesEnabled = !!v;
        await this.plugin.saveSettings();
        this._refreshQuickStyles();
      }));
      toggle.settingEl.style.border = "none";
      toggle.settingEl.style.padding = "0";
      toggle.settingEl.style.background = "none";
      toggle.settingEl.addClass("act-toggle");
      const desc = this._quickStylesContainer.createDiv();
      desc.addClass("act-desc");
      desc.style.margin = "-16px 0 14px";
      desc.textContent = this.plugin.t("quick_styles_desc", "Define named styles for applying text color and highlights. If Quick Colors are off, per-style colors here will be used.");
      const listDiv = this._quickStylesContainer.createDiv();
      const styles = Array.isArray(this.plugin.settings.quickStyles) ? this.plugin.settings.quickStyles : [];
      let dragSource = null;
      styles.forEach((style, i) => {
        if (!style.uid) style.uid = Date.now() + Math.random().toString(36).slice(2);
        const row = listDiv.createDiv();
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.marginBottom = "8px";
        row.style.padding = "4px";
        row.style.border = "1px solid var(--background-modifier-border)";
        row.style.borderRadius = "var(--setting-items-radius)";
        row.style.background = "var(--setting-items-background)";
        const dragHandle = row.createDiv();
        dragHandle.innerHTML = '<svg viewBox="0 0 100 100" width="30" height="20" fill="currentColor"><path d="M30 20h40v10H30zM30 45h40v10H30zM30 70h40v10H30z"/></svg>';
        dragHandle.style.cursor = "grab";
        dragHandle.style.opacity = "0.6";
        dragHandle.style.display = "flex";
        dragHandle.style.alignItems = "center";
        dragHandle.style.justifyContent = "center";
        const previewEl = row.createDiv();
        previewEl.textContent = this.plugin.t("preview_text", "Text");
        previewEl.style.flex = "0 0 auto";
        const styleType2 = style && style.styleType ? style.styleType : "both";
        const tc = style.textColor || style.color || null;
        const bc = style.backgroundColor || null;
        const params = this.plugin.getHighlightParams(style);
        const borderCss = this.plugin.generateBorderStyle(tc, bc, style);
        let previewStyleStr = "";
        if (styleType2 === "text") {
          if (tc) previewStyleStr += `color:${tc};`;
        } else if (styleType2 === "highlight") {
          if (bc) {
            const bg = this.plugin.hexToHexWithAlpha(bc, params.opacity ?? 25);
            previewStyleStr += `background-color:${bg};`;
          }
          previewStyleStr += `border-radius:${params.radius ?? 8}px; padding:${params.vPad ?? 0}px ${params.hPad ?? 4}px;${borderCss}`;
        } else {
          if (tc) previewStyleStr += `color:${tc};`;
          if (bc) {
            const bg = this.plugin.hexToHexWithAlpha(bc, params.opacity ?? 25);
            previewStyleStr += `background-color:${bg};`;
          }
          previewStyleStr += `border-radius:${params.radius ?? 8}px; padding:${params.vPad ?? 0}px ${params.hPad ?? 4}px;${borderCss}`;
        }
        previewEl.setAttr("style", previewStyleStr);
        const nameInput = row.createEl("input", { type: "text", value: style.name || `Style ${i + 1}` });
        nameInput.style.flex = "1";
        nameInput.placeholder = this.plugin.t("style_name_placeholder", "Style Name");
        nameInput.addEventListener("change", async () => {
          style.name = nameInput.value;
          await this.plugin.saveSettings();
        });
        const settingsBtn = row.createDiv();
        settingsBtn.style.cursor = "pointer";
        settingsBtn.style.display = "flex";
        settingsBtn.style.paddingLeft = "0";
        settingsBtn.style.paddingRight = "4px";
        setIcon(settingsBtn, "settings");
        settingsBtn.addEventListener("click", () => {
          if (!style.styleType) style.styleType = "both";
          const modal = new HighlightStylingModal(this.app, this.plugin, style, null, this.plugin.t("selected_text_preview", "Selected Text"));
          const originalOnClose = modal.onClose.bind(modal);
          modal.onClose = async () => {
            originalOnClose();
            await this.plugin.saveSettings();
            setTimeout(() => {
              try {
                this._refreshQuickStyles();
              } catch (e) {
                debugError("SETTINGS", e);
              }
            }, 50);
          };
          modal.open();
        });
        row.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          const menu = new Menu();
          menu.addItem((item) => item.setTitle(this.plugin.t("duplicate_entry", "Duplicate Entry")).setIcon("copy").onClick(async () => {
            const clone = JSON.parse(JSON.stringify(style));
            clone.uid = Date.now() + Math.random().toString(36).slice(2);
            clone.name = (clone.name || "") + " (Copy)";
            this.plugin.settings.quickStyles.splice(i + 1, 0, clone);
            await this.plugin.saveSettings();
            this._refreshQuickStyles();
          }));
          menu.addItem((item) => item.setTitle("Delete Entry").setIcon("trash").onClick(async () => {
            this.plugin.settings.quickStyles.splice(i, 1);
            await this.plugin.saveSettings();
            this._refreshQuickStyles();
          }));
          menu.showAtMouseEvent(e);
        });
        dragHandle.addEventListener("mousedown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const startX = e.clientX;
          const startY = e.clientY;
          const rect = row.getBoundingClientRect();
          const offsetX = startX - rect.left;
          const offsetY = startY - rect.top;
          if (navigator.vibrate) navigator.vibrate(100);
          const ghost = document.body.createDiv({ cls: "drag-reorder-ghost" });
          const clone = row.cloneNode(true);
          const originalInputs = row.querySelectorAll("input, select, textarea");
          const clonedInputs = clone.querySelectorAll("input, select, textarea");
          originalInputs.forEach((el, idx) => {
            if (clonedInputs[idx]) clonedInputs[idx].value = el.value;
          });
          ghost.appendChild(clone);
          ghost.style.width = `${rect.width}px`;
          ghost.style.height = `${rect.height}px`;
          ghost.style.left = `${rect.left}px`;
          ghost.style.top = `${rect.top}px`;
          row.classList.add("drag-ghost-hidden");
          const onMove = (moveEvent) => {
            moveEvent.preventDefault();
            const currentX = moveEvent.clientX;
            const currentY = moveEvent.clientY;
            ghost.style.left = `${currentX - offsetX}px`;
            ghost.style.top = `${currentY - offsetY}px`;
            const children = Array.from(listDiv.children);
            const currentIndex = children.indexOf(row);
            if (currentIndex === -1) return;
            if (currentIndex > 0) {
              const prevRow = children[currentIndex - 1];
              const prevRect = prevRow.getBoundingClientRect();
              const prevOverdrag = prevRect.height * 0.25;
              if (currentY < prevRect.bottom - prevOverdrag) {
                if (navigator.vibrate) navigator.vibrate(100);
                listDiv.insertBefore(row, prevRow);
                const item = styles.splice(currentIndex, 1)[0];
                styles.splice(currentIndex - 1, 0, item);
                return;
              }
            }
            if (currentIndex < children.length - 1) {
              const nextRow = children[currentIndex + 1];
              const nextRect = nextRow.getBoundingClientRect();
              const nextOverdrag = nextRect.height * 0.25;
              if (currentY > nextRect.top + nextOverdrag) {
                if (navigator.vibrate) navigator.vibrate(100);
                nextRow.after(row);
                const item = styles.splice(currentIndex, 1)[0];
                styles.splice(currentIndex + 1, 0, item);
                return;
              }
            }
          };
          const onEnd = async () => {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onEnd);
            ghost.remove();
            row.classList.remove("drag-ghost-hidden");
            await this.plugin.saveSettings();
            this._refreshQuickStyles();
          };
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onEnd);
        });
      });
      const btnRow = this._quickStylesContainer.createDiv();
      btnRow.style.display = "flex";
      btnRow.style.justifyContent = "flex-end";
      const addBtn = btnRow.createEl("button", { text: this.plugin.t("btn_add_style", "+ Add Style") });
      addBtn.style.marginBottom = "10px";
      addBtn.addEventListener("click", async () => {
        this.plugin.settings.quickStyles.push({ name: "New Style", styleType: "both", textColor: "#ffffff", backgroundColor: "#000000" });
        await this.plugin.saveSettings();
        this._refreshQuickStyles();
      });
    } catch (e) {
      debugError("SETTINGS", e);
    }
  }
  _refreshEntries() {
    try {
      const listDiv = this.containerEl.querySelector(".color-words-list");
      if (!listDiv) return;
      const newIds = this._newEntriesSet || /* @__PURE__ */ new Set();
      const isNew = (e) => {
        try {
          return e && e.uid && newIds.has(e.uid) || !!e.persistAtEnd;
        } catch (_) {
          return !!(e && e.persistAtEnd);
        }
      };
      listDiv.empty();
      const entriesToDisplay = [...this.plugin.settings.wordEntries];
      const persistAtEndEntriesRaw = entriesToDisplay.filter((e) => e && e.persistAtEnd === true);
      const regularEntriesToFilter = entriesToDisplay.filter((e) => !e || e.persistAtEnd !== true);
      const q = String(this._entriesSearchQuery || "").trim().toLowerCase();
      const filtered = q ? regularEntriesToFilter.filter((e) => {
        const patterns = Array.isArray(e.groupedPatterns) && e.groupedPatterns.length > 0 ? e.groupedPatterns : [String(e.pattern || "")];
        const swDefault = Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : [];
        const swCustom = Array.isArray(this.plugin.settings.userCustomSwatches) ? this.plugin.settings.userCustomSwatches : [];
        const allSwatches = [...swDefault, ...swCustom];
        const getSwatchName = (hex) => {
          try {
            if (!hex || !this.plugin.isValidHexColor(hex)) return "";
            const m = allSwatches.find((sw) => sw && sw.color && String(sw.color).toLowerCase() === String(hex).toLowerCase());
            return String(m && m.name ? m.name : "").toLowerCase();
          } catch (_) {
            return "";
          }
        };
        const tHex = e && e.textColor && e.textColor !== "currentColor" ? e.textColor : this.plugin.isValidHexColor(e && e.color) ? e.color : "";
        const bHex = this.plugin.isValidHexColor(e && e.backgroundColor) ? e.backgroundColor : "";
        const tName = getSwatchName(tHex);
        const bName = getSwatchName(bHex);
        const text = [
          ...patterns.map((p) => p.toLowerCase()),
          String(e.presetLabel || "").toLowerCase(),
          String(e.flags || "").toLowerCase(),
          String(e.styleType || "").toLowerCase(),
          tName,
          bName
        ].join(" ");
        if (this._entriesSearchMatch === "starts") return text.startsWith(q);
        if (this._entriesSearchMatch === "ends") return text.endsWith(q);
        if (this._entriesSearchMatch === "exact") return text === q;
        return text.includes(q);
      }) : regularEntriesToFilter;
      let finalFiltered = filtered;
      if (this._filterMode === "highlight") {
        finalFiltered = filtered.filter((e) => e.styleType === "highlight");
      } else if (this._filterMode === "text") {
        finalFiltered = filtered.filter((e) => e.styleType === "text");
      } else if (this._filterMode === "both") {
        finalFiltered = filtered.filter((e) => e.styleType === "both");
      }
      if (this._entriesMatchTypeStartsWith || this._entriesMatchTypeEndsWith || this._entriesMatchTypeExact) {
        finalFiltered = finalFiltered.filter((e) => {
          const mt = String(e.matchType || "").toLowerCase();
          let matches = false;
          if (this._entriesMatchTypeStartsWith) matches = matches || mt === "startswith";
          if (this._entriesMatchTypeEndsWith) matches = matches || mt === "endswith";
          if (this._entriesMatchTypeExact) matches = matches || mt === "exact";
          return matches;
        });
      }
      if (this._entriesRegexOnly) {
        finalFiltered = finalFiltered.filter((e) => !!e.isRegex);
      }
      if (this._entriesWordsOnly) {
        finalFiltered = finalFiltered.filter((e) => !e.isRegex);
      }
      if (!this._suspendSorting && this._wordsSortMode === "a-z") {
        finalFiltered.sort((a, b) => {
          const patternA = Array.isArray(a.groupedPatterns) && a.groupedPatterns.length > 0 ? a.groupedPatterns[0] : a.pattern || "";
          const patternB = Array.isArray(b.groupedPatterns) && b.groupedPatterns.length > 0 ? b.groupedPatterns[0] : b.pattern || "";
          const aEmpty = String(patternA).trim().length === 0;
          const bEmpty = String(patternB).trim().length === 0;
          if (aEmpty && !bEmpty) return 1;
          if (!aEmpty && bEmpty) return -1;
          const aHasSpecialChars = /[^a-zA-Z0-9\s]/.test(patternA);
          const bHasSpecialChars = /[^a-zA-Z0-9\s]/.test(patternB);
          if (aHasSpecialChars && !bHasSpecialChars) return -1;
          if (!aHasSpecialChars && bHasSpecialChars) return 1;
          return patternA.toLowerCase().localeCompare(patternB.toLowerCase());
        });
      } else if (!this._suspendSorting && this._wordsSortMode === "reverse-a-z") {
        finalFiltered.sort((a, b) => {
          const patternA = Array.isArray(a.groupedPatterns) && a.groupedPatterns.length > 0 ? a.groupedPatterns[0] : a.pattern || "";
          const patternB = Array.isArray(b.groupedPatterns) && b.groupedPatterns.length > 0 ? b.groupedPatterns[0] : b.pattern || "";
          const aEmpty = String(patternA).trim().length === 0;
          const bEmpty = String(patternB).trim().length === 0;
          if (aEmpty && !bEmpty) return 1;
          if (!aEmpty && bEmpty) return -1;
          const aHasSpecialChars = /[^a-zA-Z0-9\s]/.test(patternA);
          const bHasSpecialChars = /[^a-zA-Z0-9\s]/.test(patternB);
          if (aHasSpecialChars && !bHasSpecialChars) return -1;
          if (!aHasSpecialChars && bHasSpecialChars) return 1;
          return patternB.toLowerCase().localeCompare(patternA.toLowerCase());
        });
      } else if (!this._suspendSorting && this._wordsSortMode === "style-order") {
        const styleOrder = { "text": 0, "highlight": 1, "both": 2 };
        finalFiltered.sort((a, b) => {
          const patternA = Array.isArray(a.groupedPatterns) && a.groupedPatterns.length > 0 ? a.groupedPatterns[0] : a.pattern || "";
          const patternB = Array.isArray(b.groupedPatterns) && b.groupedPatterns.length > 0 ? b.groupedPatterns[0] : b.pattern || "";
          const aEmpty = String(patternA).trim().length === 0;
          const bEmpty = String(patternB).trim().length === 0;
          if (aEmpty && !bEmpty) return 1;
          if (!aEmpty && bEmpty) return -1;
          const styleA = styleOrder[a.styleType] ?? 0;
          const styleB = styleOrder[b.styleType] ?? 0;
          if (styleA !== styleB) return styleA - styleB;
          return patternA.toLowerCase().localeCompare(patternB.toLowerCase());
        });
      } else if (!this._suspendSorting && this._wordsSortMode === "color") {
        finalFiltered.sort((a, b) => {
          const patternA = Array.isArray(a.groupedPatterns) && a.groupedPatterns.length > 0 ? a.groupedPatterns[0] : a.pattern || "";
          const patternB = Array.isArray(b.groupedPatterns) && b.groupedPatterns.length > 0 ? b.groupedPatterns[0] : b.pattern || "";
          const aEmpty = String(patternA).trim().length === 0;
          const bEmpty = String(patternB).trim().length === 0;
          if (aEmpty && !bEmpty) return 1;
          if (!aEmpty && bEmpty) return -1;
          const colorA = (a.backgroundColor || a.textColor || a.color || "").toLowerCase();
          const colorB = (b.backgroundColor || b.textColor || b.color || "").toLowerCase();
          if (colorA !== colorB) return colorA.localeCompare(colorB);
          return patternA.toLowerCase().localeCompare(patternB.toLowerCase());
        });
      }
      let entriesFiltered;
      if (this._suspendSorting || this._wordsSortMode === "last-added") {
        const baseOrder = [...this.plugin.settings.wordEntries];
        const newFiltered = finalFiltered.filter((e) => isNew(e));
        const oldFiltered = finalFiltered.filter((e) => !isNew(e));
        const newInInsertionOrder = baseOrder.filter((e) => isNew(e) && newFiltered.includes(e));
        entriesFiltered = [...oldFiltered, ...newInInsertionOrder];
      } else {
        entriesFiltered = finalFiltered;
      }
      const limitedRegularEntries = this._entriesLimit && this._entriesLimit > 0 ? entriesFiltered.slice(-this._entriesLimit) : entriesFiltered;
      const limitedEntries = [...limitedRegularEntries, ...persistAtEndEntriesRaw];
      limitedEntries.forEach((entry) => {
        this._createEntryRow(entry, listDiv);
      });
      this._entryRows.clear();
      entriesFiltered.forEach((entry) => {
        const rowInfo = this._entryRows.get(entry);
        if (rowInfo) {
        } else {
        }
      });
      this._initializedSettingsUI = true;
    } catch (e) {
      debugError("SETTINGS", "_refreshEntries error", e);
    }
  }
  _refreshGroups() {
    try {
      const container = this.containerEl.querySelector(".act-groups-container");
      if (!container) return;
      container.empty();
      const allGroups = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : [];
      const q = String(this._groupSearch || "").toLowerCase().trim();
      const swDefault = Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : [];
      const swCustom = Array.isArray(this.plugin.settings.userCustomSwatches) ? this.plugin.settings.userCustomSwatches : [];
      const allSwatches = [...swDefault, ...swCustom];
      const getSwatchName = (hex) => {
        try {
          if (!hex || !this.plugin.isValidHexColor(hex)) return "";
          const m = allSwatches.find((sw) => sw && sw.color && String(sw.color).toLowerCase() === String(hex).toLowerCase());
          return String(m && m.name ? m.name : "").toLowerCase();
        } catch (_) {
          return "";
        }
      };
      const groups = q ? allGroups.filter((g) => {
        const matchesName = String(g?.name || "").toLowerCase().includes(q);
        const matchesActive = q === "active" && g?.active;
        const matchesInactive = q === "inactive" && !g?.active;
        const matchesSwatch = (Array.isArray(g.entries) ? g.entries : []).some((e) => {
          const tHex = e && e.textColor && e.textColor !== "currentColor" ? e.textColor : this.plugin.isValidHexColor(e && e.color) ? e.color : "";
          const bHex = this.plugin.isValidHexColor(e && e.backgroundColor) ? e.backgroundColor : "";
          const tName = getSwatchName(tHex);
          const bName = getSwatchName(bHex);
          return tName.includes(q) || bName.includes(q);
        });
        return matchesName || matchesActive || matchesInactive || matchesSwatch;
      }) : allGroups;
      const saveDragReorder = async () => {
        const groupRows = Array.from(container.querySelectorAll("div[data-group-uid]"));
        const newOrder = groupRows.map((r) => {
          const uid = r.getAttribute("data-group-uid");
          return allGroups.find((g) => g && g.uid === uid);
        }).filter((g) => g);
        this.plugin.settings.wordEntryGroups = newOrder;
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        if (this.plugin.settings.showWordGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
        this._refreshGroups();
      };
      groups.forEach((group, index) => {
        const row = container.createDiv();
        try {
          row.addClass("act-group-row");
        } catch (e) {
          try {
            row.classList.add("act-group-row");
          } catch (_) {
          }
        }
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "10px";
        row.style.marginBottom = "10px";
        row.style.padding = "10px";
        row.style.border = "1px solid var(--background-modifier-border)";
        row.style.borderRadius = "var(--setting-items-radius)";
        row.style.backgroundColor = "var(--setting-items-background)";
        row.setAttribute("data-group-uid", group.uid || "");
        const dragHandle = row.createEl("button");
        setIcon(dragHandle, "menu");
        dragHandle.style.padding = "0";
        dragHandle.style.border = "none";
        dragHandle.style.background = "transparent";
        dragHandle.style.boxShadow = "none";
        dragHandle.style.cursor = "grab";
        dragHandle.style.color = "var(--text-muted)";
        dragHandle.style.flexShrink = "0";
        dragHandle.style.display = "flex";
        dragHandle.style.alignItems = "center";
        dragHandle.style.justifyContent = "center";
        dragHandle.setAttribute("aria-label", this.plugin.t("drag_to_reorder", "Drag to reorder"));
        const activeSelect = row.createEl("select");
        try {
          activeSelect.addClass("dropdown");
        } catch (e) {
        }
        try {
          activeSelect.addClass("act-group-select");
        } catch (e) {
          try {
            activeSelect.classList.add("act-group-select");
          } catch (_) {
          }
        }
        activeSelect.style.minWidth = "100px";
        activeSelect.createEl("option", { text: this.plugin.t("group_active_label", "Active"), value: "true" });
        activeSelect.createEl("option", { text: this.plugin.t("group_inactive_label", "Inactive"), value: "false" });
        if (!group.uid) {
          try {
            group.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (_) {
          }
        }
        activeSelect.value = String(!!group.active);
        const activeHandler = async () => {
          group.active = activeSelect.value === "true";
          await this.plugin.saveSettings();
          this.plugin.compileWordEntries();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
          this.plugin.forceRefreshAllReadingViews();
          if (this.plugin.settings.showWordGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
        };
        activeSelect.onchange = activeHandler;
        if (group.textColor || group.backgroundColor || typeof group.enableBorderThickness !== "undefined" && group.enableBorderThickness) {
          const preview = row.createDiv();
          try {
            preview.addClass("act-group-styling-preview");
          } catch (e) {
            try {
              preview.classList.add("act-group-styling-preview");
            } catch (_) {
            }
          }
          preview.style.flexShrink = "0";
          preview.style.display = "flex";
          preview.style.alignItems = "center";
          preview.style.justifyContent = "center";
          preview.style.fontSize = "12px";
          preview.style.fontWeight = "bold";
          preview.style.cursor = "default";
          preview.textContent = "Text";
          const t = group.textColor && group.textColor !== "currentColor" ? group.textColor : "";
          const b = group.backgroundColor || "";
          const p = this.plugin.getHighlightParams(group);
          const rgba = b ? this.plugin.hexToRgba(b, p.opacity ?? 25) : "transparent";
          if (t) preview.style.color = t;
          else preview.style.color = "var(--text-normal)";
          if (b) {
            preview.style.backgroundColor = rgba;
          } else {
            preview.style.backgroundColor = "transparent";
          }
          preview.style.borderRadius = (p.radius ?? 8) + "px";
          preview.style.paddingLeft = (p.hPad ?? 4) + "px";
          preview.style.paddingRight = (p.hPad ?? 4) + "px";
          preview.style.paddingTop = (p.vPad ?? 0) + "px";
          preview.style.paddingBottom = (p.vPad ?? 0) + "px";
          if (p.enableBorder) {
            const borderStyle = this.plugin.generateBorderStyle(t, b, group);
            if (borderStyle) {
              preview.style.cssText += borderStyle;
            }
          } else {
            preview.style.border = "1px solid var(--background-modifier-border)";
          }
        }
        const nameInput = row.createEl("input", { type: "text", value: group.name || "" });
        nameInput.style.flex = "1";
        nameInput.placeholder = this.plugin.t("group_name_placeholder", "Name your group");
        const nameHandler = async () => {
          group.name = nameInput.value;
          await this.plugin.saveSettings();
          if (this.plugin.settings.showWordGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
        };
        nameInput.onchange = nameHandler;
        const btnDuplicate = row.createEl("div");
        btnDuplicate.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        btnDuplicate.style.cursor = "pointer";
        btnDuplicate.style.color = "var(--text-muted)";
        btnDuplicate.title = this.plugin.t("tooltip_duplicate_group", "Duplicate Group");
        btnDuplicate.style.display = "flex";
        btnDuplicate.style.alignItems = "center";
        btnDuplicate.onclick = async () => {
          const newGroup = JSON.parse(JSON.stringify(group));
          newGroup.name = (newGroup.name || "") + " (Copy)";
          try {
            newGroup.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (_) {
          }
          this.plugin.settings.wordEntryGroups.push(newGroup);
          await this.plugin.saveSettings();
          this.plugin.compileWordEntries();
          this._refreshGroups();
          if (this.plugin.settings.showWordGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
        };
        const btnEdit = row.createEl("div");
        btnEdit.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>';
        btnEdit.style.cursor = "pointer";
        btnEdit.style.color = "var(--text-muted)";
        btnEdit.title = this.plugin.t("tooltip_edit_group_settings", "Edit Group Settings");
        btnEdit.style.display = "flex";
        btnEdit.style.alignItems = "center";
        btnEdit.onclick = () => {
          const latestGroup = this.plugin.settings.wordEntryGroups.find((g) => g && g.uid === group.uid) || group;
          new EditWordGroupModal(this.app, this.plugin, latestGroup, async (updatedGroup) => {
            const idx = this.plugin.settings.wordEntryGroups.findIndex((g) => g && g.uid === updatedGroup.uid);
            if (idx !== -1) this.plugin.settings.wordEntryGroups[idx] = updatedGroup;
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this._refreshGroups();
            if (this.plugin.settings.showWordGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
          }, async (groupToDelete) => {
            const actualIndex = this.plugin.settings.wordEntryGroups.findIndex((g) => g && g.uid === groupToDelete.uid);
            if (actualIndex !== -1) this.plugin.settings.wordEntryGroups.splice(actualIndex, 1);
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this._refreshGroups();
            if (this.plugin.settings.showWordGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
          }).open();
        };
        dragHandle.addEventListener("mousedown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const startX = e.clientX;
          const startY = e.clientY;
          const rect = row.getBoundingClientRect();
          const offsetX = startX - rect.left;
          const offsetY = startY - rect.top;
          if (navigator.vibrate) navigator.vibrate(100);
          const originalDisabled = [];
          const allInteractive = row.querySelectorAll("input, select, button");
          allInteractive.forEach((el) => {
            originalDisabled.push(el.disabled);
            el.disabled = true;
          });
          const ghost = document.body.createDiv({ cls: "drag-reorder-ghost" });
          const clone = row.cloneNode(true);
          const originalInputs = row.querySelectorAll("input, select, textarea");
          const clonedInputs = clone.querySelectorAll("input, select, textarea");
          originalInputs.forEach((el, idx) => {
            if (clonedInputs[idx]) clonedInputs[idx].value = el.value;
          });
          ghost.appendChild(clone);
          ghost.style.width = `${rect.width}px`;
          ghost.style.height = `${rect.height}px`;
          ghost.style.left = `${rect.left}px`;
          ghost.style.top = `${rect.top}px`;
          row.classList.add("drag-ghost-hidden");
          const onMove = (moveEvent) => {
            moveEvent.preventDefault();
            const currentX = moveEvent.clientX;
            const currentY = moveEvent.clientY;
            ghost.style.left = `${currentX - offsetX}px`;
            ghost.style.top = `${currentY - offsetY}px`;
            const children = Array.from(container.querySelectorAll("div[data-group-uid]"));
            const currentIndex = children.indexOf(row);
            if (currentIndex === -1) return;
            if (currentIndex > 0) {
              const prevRow = children[currentIndex - 1];
              const prevRect = prevRow.getBoundingClientRect();
              const prevOverdrag = prevRect.height * 0.25;
              if (currentY < prevRect.bottom - prevOverdrag) {
                if (navigator.vibrate) navigator.vibrate(100);
                container.insertBefore(row, prevRow);
                return;
              }
            }
            if (currentIndex < children.length - 1) {
              const nextRow = children[currentIndex + 1];
              const nextRect = nextRow.getBoundingClientRect();
              const nextOverdrag = nextRect.height * 0.25;
              if (currentY > nextRect.top + nextOverdrag) {
                if (navigator.vibrate) navigator.vibrate(100);
                nextRow.after(row);
                return;
              }
            }
          };
          const onEnd = async () => {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onEnd);
            ghost.remove();
            row.classList.remove("drag-ghost-hidden");
            allInteractive.forEach((el, idx) => {
              el.disabled = originalDisabled[idx];
            });
            await saveDragReorder();
          };
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onEnd);
        });
      });
    } catch (e) {
    }
  }
  _refreshBlacklistGroups() {
    try {
      const container = this.containerEl.querySelector(".act-blacklist-groups-container");
      if (!container) return;
      container.empty();
      const allGroups = Array.isArray(this.plugin.settings.blacklistEntryGroups) ? this.plugin.settings.blacklistEntryGroups : [];
      const q = String(this._blacklistGroupSearch || "").toLowerCase().trim();
      const groups = q ? allGroups.filter((g) => {
        const matchesName = String(g?.name || "").toLowerCase().includes(q);
        const matchesActive = q === "active" && g?.active;
        const matchesInactive = q === "inactive" && !g?.active;
        return matchesName || matchesActive || matchesInactive;
      }) : allGroups;
      const saveDragReorder = async () => {
        const groupRows = Array.from(container.querySelectorAll("div[data-group-uid]"));
        const newOrder = groupRows.map((r) => {
          const uid = r.getAttribute("data-group-uid");
          return allGroups.find((g) => g && g.uid === uid);
        }).filter((g) => g);
        this.plugin.settings.blacklistEntryGroups = newOrder;
        await this.plugin.saveSettings();
        if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
        this._refreshBlacklistGroups();
      };
      groups.forEach((group, index) => {
        const row = container.createDiv();
        try {
          row.addClass("act-blacklist-group-row");
        } catch (e) {
          try {
            row.classList.add("act-blacklist-group-row");
          } catch (_) {
          }
        }
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "10px";
        row.style.marginBottom = "10px";
        row.style.padding = "10px";
        row.style.border = "1px solid var(--background-modifier-border)";
        row.style.borderRadius = "var(--setting-items-radius)";
        row.style.backgroundColor = "var(--setting-items-background)";
        row.setAttribute("data-group-uid", group.uid || "");
        const dragHandle = row.createEl("button");
        setIcon(dragHandle, "menu");
        dragHandle.style.padding = "0";
        dragHandle.style.border = "none";
        dragHandle.style.background = "transparent";
        dragHandle.style.boxShadow = "none";
        dragHandle.style.cursor = "grab";
        dragHandle.style.color = "var(--text-muted)";
        dragHandle.style.flexShrink = "0";
        dragHandle.style.display = "flex";
        dragHandle.style.alignItems = "center";
        dragHandle.style.justifyContent = "center";
        dragHandle.setAttribute("aria-label", this.plugin.t("drag_to_reorder", "Drag to reorder"));
        const activeSelect = row.createEl("select");
        try {
          activeSelect.addClass("dropdown");
        } catch (e) {
        }
        try {
          activeSelect.addClass("act-group-select");
        } catch (e) {
          try {
            activeSelect.classList.add("act-group-select");
          } catch (_) {
          }
        }
        activeSelect.style.minWidth = "100px";
        activeSelect.createEl("option", { text: this.plugin.t("group_active_label", "Active"), value: "true" });
        activeSelect.createEl("option", { text: this.plugin.t("group_inactive_label", "Inactive"), value: "false" });
        if (!group.uid) {
          try {
            group.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (_) {
          }
        }
        activeSelect.value = String(!!group.active);
        const activeHandler = async () => {
          group.active = activeSelect.value === "true";
          await this.plugin.saveSettings();
          if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
        };
        activeSelect.onchange = activeHandler;
        const nameInput = row.createEl("input", { type: "text", value: group.name || "" });
        nameInput.style.flex = "1";
        nameInput.placeholder = this.plugin.t("group_name_placeholder", "Name your group");
        const nameHandler = async () => {
          group.name = nameInput.value;
          await this.plugin.saveSettings();
          if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
        };
        nameInput.onchange = nameHandler;
        const btnDuplicate = row.createEl("div");
        btnDuplicate.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        btnDuplicate.style.cursor = "pointer";
        btnDuplicate.style.color = "var(--text-muted)";
        btnDuplicate.title = this.plugin.t("tooltip_duplicate_group", "Duplicate Group");
        btnDuplicate.style.display = "flex";
        btnDuplicate.style.alignItems = "center";
        btnDuplicate.onclick = async () => {
          const newGroup = JSON.parse(JSON.stringify(group));
          newGroup.name = (newGroup.name || "") + " (Copy)";
          try {
            newGroup.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (_) {
          }
          this.plugin.settings.blacklistEntryGroups.push(newGroup);
          await this.plugin.saveSettings();
          if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
          this._refreshBlacklistGroups();
        };
        const btnEdit = row.createEl("div");
        btnEdit.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>';
        btnEdit.style.cursor = "pointer";
        btnEdit.style.color = "var(--text-muted)";
        btnEdit.title = this.plugin.t("tooltip_edit_group_settings", "Edit Group Settings");
        btnEdit.style.display = "flex";
        btnEdit.style.alignItems = "center";
        btnEdit.onclick = () => {
          const latestGroup = this.plugin.settings.blacklistEntryGroups.find((g) => g && g.uid === group.uid) || group;
          new EditBlacklistGroupModal(this.app, this.plugin, latestGroup, async (updatedGroup) => {
            const idx = this.plugin.settings.blacklistEntryGroups.findIndex((g) => g && g.uid === updatedGroup.uid);
            if (idx !== -1) this.plugin.settings.blacklistEntryGroups[idx] = updatedGroup;
            await this.plugin.saveSettings();
            if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
            this._refreshBlacklistGroups();
          }, async (groupToDelete) => {
            const actualIndex = this.plugin.settings.blacklistEntryGroups.findIndex((g) => g && g.uid === groupToDelete.uid);
            if (actualIndex !== -1) this.plugin.settings.blacklistEntryGroups.splice(actualIndex, 1);
            await this.plugin.saveSettings();
            if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
            this._refreshBlacklistGroups();
          }).open();
        };
        dragHandle.addEventListener("mousedown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const startX = e.clientX;
          const startY = e.clientY;
          const rect = row.getBoundingClientRect();
          const offsetX = startX - rect.left;
          const offsetY = startY - rect.top;
          if (navigator.vibrate) navigator.vibrate(100);
          const originalDisabled = [];
          const allInteractive = row.querySelectorAll("input, select, button");
          allInteractive.forEach((el) => {
            originalDisabled.push(el.disabled);
            el.disabled = true;
          });
          const ghost = document.body.createDiv({ cls: "drag-reorder-ghost" });
          const clone = row.cloneNode(true);
          const originalInputs = row.querySelectorAll("input, select, textarea");
          const clonedInputs = clone.querySelectorAll("input, select, textarea");
          originalInputs.forEach((el, idx) => {
            if (clonedInputs[idx]) clonedInputs[idx].value = el.value;
          });
          ghost.appendChild(clone);
          ghost.style.width = `${rect.width}px`;
          ghost.style.height = `${rect.height}px`;
          ghost.style.left = `${rect.left}px`;
          ghost.style.top = `${rect.top}px`;
          row.classList.add("drag-ghost-hidden");
          const onMove = (moveEvent) => {
            moveEvent.preventDefault();
            const currentX = moveEvent.clientX;
            const currentY = moveEvent.clientY;
            ghost.style.left = `${currentX - offsetX}px`;
            ghost.style.top = `${currentY - offsetY}px`;
            const children = Array.from(container.querySelectorAll("div[data-group-uid]"));
            const currentIndex = children.indexOf(row);
            if (currentIndex === -1) return;
            if (currentIndex > 0) {
              const prevRow = children[currentIndex - 1];
              const prevRect = prevRow.getBoundingClientRect();
              const prevOverdrag = prevRect.height * 0.25;
              if (currentY < prevRect.bottom - prevOverdrag) {
                if (navigator.vibrate) navigator.vibrate(100);
                container.insertBefore(row, prevRow);
                return;
              }
            }
            if (currentIndex < children.length - 1) {
              const nextRow = children[currentIndex + 1];
              const nextRect = nextRow.getBoundingClientRect();
              const nextOverdrag = nextRect.height * 0.25;
              if (currentY > nextRect.top + nextOverdrag) {
                if (navigator.vibrate) navigator.vibrate(100);
                nextRow.after(row);
                return;
              }
            }
          };
          const onEnd = async () => {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onEnd);
            ghost.remove();
            row.classList.remove("drag-ghost-hidden");
            allInteractive.forEach((el, idx) => {
              el.disabled = originalDisabled[idx];
            });
            await saveDragReorder();
          };
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onEnd);
        });
      });
    } catch (e) {
    }
  }
  // Clean up event listeners to prevent leaks
  onClose() {
    try {
      try {
        if (this.debouncedSaveSettings && typeof this.debouncedSaveSettings.flush === "function") {
          this.debouncedSaveSettings.flush();
        }
      } catch (e) {
        debugError("SETTINGS", "debounce flush error", e);
      }
      try {
        const rows = Array.from(this._entryRows?.entries() || []);
        rows.forEach(([entry, info]) => {
          if (!entry || !info || !info.elements) return;
          const { textInput, styleSelect, cp, cpBg, regexChk, flagsInput } = info.elements;
          let idx = -1;
          if (entry && entry.uid) idx = this.plugin.settings.wordEntries.findIndex((e) => e && e.uid === entry.uid);
          if (idx === -1) idx = this.plugin.settings.wordEntries.indexOf(entry);
          if (idx === -1) return;
          const s = this.plugin.settings.wordEntries[idx];
          if (textInput && typeof textInput.value === "string") {
            const raw = String(textInput.value || "");
            const patterns = raw.split(",").filter((p) => p.length > 0);
            s.pattern = patterns[0] || "";
            s.groupedPatterns = patterns.length > 1 ? patterns : null;
          }
          if (regexChk) {
            s.isRegex = !!regexChk.checked;
          }
          if (flagsInput && typeof flagsInput.value === "string") {
            s.flags = String(flagsInput.value || "");
          }
          const style = styleSelect ? styleSelect.value : s.styleType || "text";
          if (style === "text") {
            const val = cp && typeof cp.value === "string" ? cp.value : s.color;
            s.color = this.plugin.isValidHexColor(val) ? val : "";
            s.textColor = null;
            s.backgroundColor = null;
            s.styleType = "text";
            s._savedTextColor = this.plugin.isValidHexColor(s.color) ? s.color : s._savedTextColor || null;
          } else if (style === "highlight") {
            const bgCandidate = cpBg && typeof cpBg.value === "string" ? cpBg.value : s.backgroundColor || s._savedBackgroundColor || s._savedTextColor || (this.plugin.isValidHexColor(s.color) ? s.color : "");
            s.backgroundColor = this.plugin.isValidHexColor(bgCandidate) ? bgCandidate : null;
            s.textColor = "currentColor";
            s.color = "";
            s.styleType = "highlight";
            s._savedBackgroundColor = this.plugin.isValidHexColor(s.backgroundColor) ? s.backgroundColor : s._savedBackgroundColor || null;
          } else {
            const t = cp && typeof cp.value === "string" ? cp.value : s.textColor;
            const b = cpBg && typeof cpBg.value === "string" ? cpBg.value : s.backgroundColor;
            s.textColor = this.plugin.isValidHexColor(t) ? t : s.textColor === "currentColor" ? "currentColor" : null;
            s.backgroundColor = this.plugin.isValidHexColor(b) ? b : null;
            s.color = "";
            s.styleType = "both";
            s._savedTextColor = this.plugin.isValidHexColor(s.textColor) ? s.textColor : s._savedTextColor || null;
            s._savedBackgroundColor = this.plugin.isValidHexColor(s.backgroundColor) ? s.backgroundColor : s._savedBackgroundColor || null;
          }
        });
        this.plugin.saveSettings();
      } catch (e) {
        debugError("SETTINGS", "snapshot rows on close error", e);
      }
      try {
        const allInputs = this.containerEl?.querySelectorAll('input[type="text"]') || [];
        allInputs.forEach((input) => {
          if (input._actDropdown) {
            const dd = input._actDropdown;
            if (input._dropdownScrollListener) {
              document.removeEventListener("scroll", input._dropdownScrollListener, true);
              input._dropdownScrollListener = null;
            }
            if (input._dropdownClickListener) {
              document.removeEventListener("click", input._dropdownClickListener);
              input._dropdownClickListener = null;
            }
            if (input._dropdownKeyListener) {
              document.removeEventListener("keydown", input._dropdownKeyListener);
              input._dropdownKeyListener = null;
            }
            try {
              dd.remove();
            } catch (e) {
            }
            input._actDropdown = null;
          }
          if (input._dropdownCleanup && typeof input._dropdownCleanup === "function") {
            try {
              input._dropdownCleanup();
            } catch (e) {
            }
            input._dropdownCleanup = null;
          }
        });
      } catch (e) {
        debugError("SETTINGS", "dropdown cleanup error", e);
      }
      this._cleanupHandlers?.forEach((cleanup) => {
        try {
          cleanup();
        } catch (e) {
          debugError("SETTINGS", "cleanup error", e);
        }
      });
      this._cleanupHandlers = [];
      if (Array.isArray(this._dynamicHandlers)) {
        this._dynamicHandlers.forEach((h) => {
          try {
            h();
          } catch (e) {
          }
        });
        this._dynamicHandlers = [];
      }
      this._cachedFolderSuggestions = null;
      try {
        this.containerEl?.empty();
      } catch (e) {
      }
      this._pathRulesContainer = null;
      this._disabledFilesContainer = null;
      this._disabledFilesHeaderEl = null;
      this._disabledFilesSearchContainer = null;
      this._disabledFilesSearchInput = null;
      this._disabledFilesSearchIcon = null;
      this._disabledFilesListEl = null;
      this._blacklistWordsContainer = null;
      this._blacklistGroupsContainer = null;
      this._customSwatchesContainer = null;
      this._suspendSorting = false;
      try {
        this._newEntriesSet && this._newEntriesSet.clear();
      } catch (e) {
      }
      try {
        this._blacklistNewSet && this._blacklistNewSet.clear();
      } catch (e) {
      }
      try {
        if (Array.isArray(this.plugin.settings.wordEntries)) {
          this.plugin.settings.wordEntries.forEach((e) => {
            if (e && e.persistAtEnd) delete e.persistAtEnd;
          });
        }
        if (Array.isArray(this.plugin.settings.blacklistEntries)) {
          this.plugin.settings.blacklistEntries.forEach((e) => {
            if (e && e.persistAtEnd) delete e.persistAtEnd;
          });
        }
      } catch (e) {
      }
      try {
        this._refreshPathRules();
      } catch (e) {
      }
      try {
        this._refreshBlacklistWords();
      } catch (e) {
      }
    } catch (e) {
      debugError("SETTINGS", "onClose error", e);
    }
  }
  display() {
    const { containerEl: containerEl2 } = this;
    this.containerEl = containerEl2;
    if (this._initializedSettingsUI) {
      try {
        if (this._activeTab === "always-color-texts") {
          this._refreshEntries();
          this._refreshGroups();
        }
        if (this._activeTab === "blacklist") this._refreshBlacklistWords();
        if (this._activeTab === "file-folder-rules") {
          this._refreshPathRules();
          this._refreshDisabledFiles();
        }
      } catch (e) {
      }
      return;
    }
    containerEl2.empty();
    this.onClose();
    this._cleanupHandlers = [];
    containerEl2.createEl("h1", { text: this.plugin.t("settings_title", "Always Color Text Settings") });
    const tabContainer = containerEl2.createDiv();
    tabContainer.addClass("act-tabs-container");
    tabContainer.style.display = "flex";
    tabContainer.style.flexWrap = "wrap";
    tabContainer.style.gap = "10px";
    tabContainer.style.marginBottom = "20px";
    tabContainer.style.borderBottom = "1px solid var(--background-modifier-border)";
    tabContainer.style.paddingBottom = "10px";
    const tabs = [
      { id: "general", label: this.plugin.t("settings_tab_general", "General") },
      { id: "always-color-texts", label: this.plugin.t("settings_tab_colored_texts", "Colored Texts") },
      { id: "blacklist", label: this.plugin.t("settings_tab_blacklists", "Blacklists") },
      { id: "file-folder-rules", label: this.plugin.t("settings_tab_file_folder_rules", "File / Folder Rules") },
      { id: "data", label: this.plugin.t("settings_tab_data", "Data") }
    ];
    tabs.forEach((tab) => {
      const btn = tabContainer.createEl("button", { text: tab.label });
      btn.addClass("act-tab-button");
      btn.style.flex = "1 1 auto";
      btn.style.cursor = "pointer";
      btn.style.border = "none";
      btn.style.background = "transparent";
      btn.style.boxShadow = "none";
      btn.style.borderRadius = "4px";
      btn.style.padding = "8px 16px";
      if (this._activeTab === tab.id) {
        btn.addClass("mod-cta");
        btn.addClass("act-tab-active");
        btn.style.fontWeight = "bold";
      } else {
        btn.style.color = "var(--text-muted)";
      }
      btn.onclick = () => {
        this._activeTab = tab.id;
        this._initializedSettingsUI = false;
        this.display();
      };
    });
    if (this._activeTab === "general") {
      const releaseNotesSettingEl = new Setting(containerEl2).setName(this.plugin.t("latest_release_notes_label", "Latest Release Notes")).setDesc(this.plugin.t("latest_release_notes_desc", "View the most recent plugin release notes")).addButton((btn) => btn.setButtonText(this.plugin.t("open_changelog_button", "Open Changelog")).onClick(() => {
        try {
          new ChangelogModal(this.app, this.plugin).open();
        } catch (e) {
        }
      }));
      try {
        releaseNotesSettingEl.settingEl.style.borderTop = "none";
      } catch (e) {
      }
      new Setting(containerEl2).setName(this.plugin.t("language_label", "Language")).setDesc(this.plugin.t("language_desc", "Select the language to be used in this plugin")).addDropdown((d) => {
        const langs = this.plugin.getAvailableLanguages();
        const names = { auto: this.plugin.t("language_auto", "System Default"), en: "English", es: "Spanish", fr: "French", eu: "Basque", ru: "Russian" };
        try {
          d.selectEl.style.textAlign = "center";
        } catch (e) {
        }
        langs.forEach((code) => {
          const dict = this.plugin._translations && this.plugin._translations[code] || {};
          const display = String(dict.__name || names[code] || code.toUpperCase());
          d.addOption(code, display);
        });
        d.setValue(this.plugin.settings.language || "en").onChange(async (v) => {
          this.plugin.settings.language = v;
          await this.plugin.saveSettings();
          this._initializedSettingsUI = false;
          this.plugin.reregisterCommandsWithLanguage();
          this.display();
        });
        return d;
      });
      new Setting(containerEl2).setName(this.plugin.t("show_toggle_statusbar", "Show Toggle in Status Bar")).addToggle((t) => t.setValue(!this.plugin.settings.disableToggleModes.statusBar).onChange(async (v) => {
        this.plugin.settings.disableToggleModes.statusBar = !v;
        await this.plugin.saveSettings();
        try {
          if (v && !this.plugin.statusBar) {
            this.plugin.statusBar = this.plugin.addStatusBarItem();
            this.plugin.updateStatusBar();
            this.plugin.statusBar.onclick = () => {
              this.plugin.settings.enabled = !this.plugin.settings.enabled;
              this.plugin.saveSettings();
              this.plugin.updateStatusBar();
              this.plugin.reconfigureEditorExtensions();
              this.plugin.forceRefreshAllEditors();
              this.plugin.forceRefreshAllReadingViews();
            };
          } else if (!v && this.plugin.statusBar) {
            try {
              this.plugin.statusBar.remove();
            } catch (e) {
            }
            this.plugin.statusBar = null;
          }
        } catch (e) {
        }
      }));
      new Setting(containerEl2).setName(this.plugin.t("show_toggle_ribbon", "Show Toggle icon in ribbon")).addToggle((t) => t.setValue(!this.plugin.settings.disableToggleModes.ribbon).onChange(async (v) => {
        this.plugin.settings.disableToggleModes.ribbon = !v;
        await this.plugin.saveSettings();
        try {
          if (v && !this.ribbonIcon) {
            this.ribbonIcon = this.addRibbonIcon("palette", this.t("ribbon_title", "Always color text"), async () => {
              this.settings.enabled = !this.settings.enabled;
              await this.saveSettings();
              this.updateStatusBar();
              this.reconfigureEditorExtensions();
              this.forceRefreshAllEditors();
              this.forceRefreshAllReadingViews();
              if (this.settings.enabled) new Notice(this.t("notice_enabled", "Always color text enabled"));
              else new Notice(this.t("notice_disabled", "Always color text disabled"));
            });
          } else if (!v && this.ribbonIcon && this.ribbonIcon.remove) {
            try {
              this.ribbonIcon.remove();
            } catch (e) {
            }
            this.ribbonIcon = null;
          }
        } catch (e) {
        }
      }));
      new Setting(containerEl2).setName(this.plugin.t("show_toggle_command", "Show Toggle in command")).addToggle((t) => t.setValue(!this.plugin.settings.disableToggleModes.command).onChange(async (v) => {
        this.plugin.settings.disableToggleModes.command = !v;
        await this.plugin.saveSettings();
        try {
          if (v) {
            if (!this.plugin._commandsRegistered) {
              try {
                this.plugin.registerCommandPalette?.();
              } catch (e) {
              }
              this.plugin._commandsRegistered = true;
            }
          } else {
            new ConfirmationModal(this.app, this.plugin, this.plugin.t("restart_required_title", "Restart required"), this.plugin.t("restart_required_desc", "Disabling the command palette toggle requires restarting Obsidian to fully remove commands from the palette. Restart now?"), () => {
              try {
                location.reload();
              } catch (e) {
              }
            }).open();
          }
        } catch (e) {
        }
      }));
      containerEl2.createEl("h3", { text: this.plugin.t("color_rendering_header", "Color Rendering & Performance") });
      new Setting(containerEl2).setName(this.plugin.t("enable_document_color", "Enable Global Color")).addToggle((t) => t.setValue(this.plugin.settings.enabled).onChange(async (v) => {
        this.plugin.settings.enabled = v;
        await this.debouncedSaveSettings();
      }));
      new Setting(containerEl2).setName(this.plugin.t("color_in_live_preview_mode", "Color in live preview mode")).addToggle((t) => t.setValue(!this.plugin.settings.disableLivePreviewColoring).onChange(async (v) => {
        this.plugin.settings.disableLivePreviewColoring = !v;
        await this.debouncedSaveSettings();
        try {
          if (this.plugin.settings.enabled) {
            if (v) {
              try {
                this.plugin.applyEnabledLivePreviewCalloutStyles();
              } catch (_) {
              }
              try {
                this.plugin.applyEnabledLivePreviewTextColorStyles();
              } catch (_) {
              }
            } else {
              try {
                this.plugin.removeEnabledLivePreviewCalloutStyles();
              } catch (_) {
              }
              try {
                this.plugin.removeEnabledLivePreviewTextColorStyles();
              } catch (_) {
              }
            }
            try {
              this.plugin.refreshAllLivePreviewCallouts();
            } catch (_) {
            }
            try {
              this.plugin.forceReprocessLivePreviewCallouts();
            } catch (_) {
            }
            try {
              this.plugin.refreshAllLivePreviewTables();
            } catch (_) {
            }
            try {
              this.plugin.forceReprocessLivePreviewTables();
            } catch (_) {
            }
          } else {
            try {
              this.plugin.removeEnabledLivePreviewCalloutStyles();
            } catch (_) {
            }
            try {
              this.plugin.removeEnabledLivePreviewTextColorStyles();
            } catch (_) {
            }
          }
        } catch (_) {
        }
      }));
      new Setting(containerEl2).setName(this.plugin.t("color_in_reading_mode", "Color in reading mode")).addToggle((t) => t.setValue(!this.plugin.settings.disableReadingModeColoring).onChange(async (v) => {
        this.plugin.settings.disableReadingModeColoring = !v;
        await this.debouncedSaveSettings();
        try {
          if (!v) {
            this.plugin.app.workspace.iterateAllLeaves((leaf) => {
              if (leaf.view instanceof MarkdownView && leaf.view.getMode && leaf.view.getMode() === "preview") {
                try {
                  const root = leaf.view.previewMode && leaf.view.previewMode.containerEl || leaf.view.contentEl || leaf.view.containerEl;
                  if (root) {
                    try {
                      this.plugin.clearHighlightsInRoot(root);
                    } catch (e) {
                    }
                    try {
                      const obs = this.plugin._viewportObservers && this.plugin._viewportObservers.get && this.plugin._viewportObservers.get(root);
                      if (obs && typeof obs.disconnect === "function") {
                        try {
                          obs.disconnect();
                        } catch (e) {
                        }
                        try {
                          this.plugin._viewportObservers.delete(root);
                        } catch (e) {
                        }
                      }
                    } catch (e) {
                    }
                  }
                } catch (e) {
                }
              }
            });
          } else {
            try {
              this.plugin.forceRefreshAllReadingViews();
            } catch (e) {
            }
          }
        } catch (e) {
          debugError("SETTINGS", "disableReadingModeColoring handler failed", e);
        }
      }));
      new Setting(containerEl2).setName(this.plugin.t("force_full_render_reading", "Force full render in Reading mode")).setDesc(this.plugin.t("force_full_render_reading_desc", "When ON, reading-mode will attempt to color the entire document in one pass. May cause performance issues on large documents. Use with caution!")).addToggle((t) => t.setValue(this.plugin.settings.forceFullRenderInReading).onChange(async (v) => {
        this.plugin.settings.forceFullRenderInReading = v;
        await this.debouncedSaveSettings();
        try {
          this.plugin.forceRefreshAllReadingViews();
        } catch (e) {
          debugError("SETTINGS", "forceFullRenderInReading handler failed", e);
        }
      }));
      new Setting(containerEl2).setName(this.plugin.t("lightweight_mode", "Lightweight mode (Experimental)")).setDesc(this.plugin.t("lightweight_mode_desc", "")).addToggle((t) => t.setValue(this.plugin.settings.extremeLightweightMode).onChange(async (v) => {
        this.plugin.settings.extremeLightweightMode = v;
        await this.debouncedSaveSettings();
        try {
          this.plugin.reconfigureEditorExtensions();
        } catch (e) {
        }
        try {
          this.plugin.forceRefreshAllEditors();
        } catch (e) {
        }
        try {
          this.plugin.forceRefreshAllReadingViews();
        } catch (e) {
        }
      }));
      new Setting(containerEl2).setName(this.plugin.t("smart_update_mode", "Smart Updates (Experimental)")).setDesc(this.plugin.t("smart_update_mode_desc", "Only updates coloring for active line while typing and freezes other lines to improve performance.")).addToggle((t) => t.setValue(this.plugin.settings.enableSmartUpdates).onChange(async (v) => {
        this.plugin.settings.enableSmartUpdates = v;
        await this.debouncedSaveSettings();
        try {
          this.plugin.reconfigureEditorExtensions();
        } catch (e) {
        }
        try {
          this.plugin.forceRefreshAllEditors();
        } catch (e) {
        }
      }));
      containerEl2.createEl("h3", { text: this.plugin.t("matching_behavior_header", "Matching Behavior") });
      new Setting(containerEl2).setName(this.plugin.t("case_sensitive", "Case sensitive")).setDesc(this.plugin.t("case_sensitive_desc", `If this is on, "word" and "Word" are treated as different. If it's off, they're colored the same.`)).addToggle((t) => t.setValue(this.plugin.settings.caseSensitive).onChange(async (v) => {
        this.plugin.settings.caseSensitive = v;
        await this.debouncedSaveSettings();
      }));
      new Setting(containerEl2).setName(this.plugin.t("partial_match", "Partial match")).setDesc(this.plugin.t("partial_match_desc", 'If enabled, the whole word will be colored if any colored word is found inside it (e.g., "as" colors "Jasper").')).addToggle((t) => t.setValue(this.plugin.settings.partialMatch).onChange(async (v) => {
        this.plugin.settings.partialMatch = v;
        await this.debouncedSaveSettings();
      }));
      new Setting(containerEl2).setName(this.plugin.t("regex_support", "Regex support")).setDesc(this.plugin.t("regex_support_desc", "Allow patterns to be regular expressions. Invalid regexes are ignored for safety.")).addToggle((t) => t.setValue(this.plugin.settings.enableRegexSupport).onChange(async (v) => {
        this.plugin.settings.enableRegexSupport = v;
        await this.plugin.saveSettings();
        this._initializedSettingsUI = false;
        this.display();
      }));
      new Setting(containerEl2).setName(this.plugin.t("disable_regex_safety", "Disable regex safety")).setDesc(this.plugin.t("disable_regex_safety_desc", "Allow complex or potentially dangerous expressions. May cause performance issues or freezes.")).addToggle((t) => t.setValue(this.plugin.settings.disableRegexSafety).onChange(async (v) => {
        this.plugin.settings.disableRegexSafety = v;
        await this.plugin.saveSettings();
        try {
          this.plugin.reconfigureEditorExtensions();
        } catch (e) {
        }
        try {
          this.plugin.forceRefreshAllEditors();
        } catch (e) {
        }
        try {
          this.plugin.forceRefreshAllReadingViews();
        } catch (e) {
        }
      }));
      containerEl2.createEl("h3", { text: this.plugin.t("theme_support_header", "Theme Support") });
      new Setting(containerEl2).setName(this.plugin.t("light_mode_fixer", "Light Mode Text Color Fixer")).setDesc(this.plugin.t("light_mode_fixer_desc", "Automatically darkens colored text when using Light theme to improve visibility.")).addToggle((t) => t.setValue(this.plugin.settings.lightModeFixer).onChange(async (v) => {
        this.plugin.settings.lightModeFixer = v;
        await this.debouncedSaveSettings();
        this.plugin.updateLightModeFixer();
      }));
      new Setting(containerEl2).setName(this.plugin.t("dark_mode_fixer", "Dark Mode Text Color Fixer")).setDesc(this.plugin.t("dark_mode_fixer_desc", "Automatically lightens colored text when using Dark theme to improve visibility.")).addToggle((t) => t.setValue(this.plugin.settings.darkModeFixer).onChange(async (v) => {
        this.plugin.settings.darkModeFixer = v;
        await this.debouncedSaveSettings();
        this.plugin.updateDarkModeFixer();
      }));
      containerEl2.createEl("h3", { text: this.plugin.t("menu_options_header", "Menu Options") });
      new Setting(containerEl2).setName(this.plugin.t("show_always_color_text_menu", 'Show "Always Color Text" in right-click menu')).setDesc(this.plugin.t("show_always_color_text_menu_desc", "Adds a right-click menu item to color selected text.")).addToggle((t) => t.setValue(this.plugin.settings.enableAlwaysColorTextMenu).onChange(async (v) => {
        this.plugin.settings.enableAlwaysColorTextMenu = v;
        await this.plugin.saveSettings();
      }));
      new Setting(containerEl2).setName(this.plugin.t("show_add_to_existing_menu", 'Show "Add to Existing Entry" in right-click menu')).setDesc(this.plugin.t("show_add_to_existing_menu_desc", "Adds a right-click menu item to add selected text to an existing entry.")).addToggle((t) => t.setValue(this.plugin.settings.enableAddToExistingMenu).onChange(async (v) => {
        this.plugin.settings.enableAddToExistingMenu = v;
        await this.plugin.saveSettings();
      }));
      new Setting(containerEl2).setName(this.plugin.t("show_blacklist_menu", 'Show "Blacklist Word" in right-click menu')).setDesc(this.plugin.t("show_blacklist_menu_desc", "Adds a right-click menu item to blacklist selected text from coloring.")).addToggle((t) => t.setValue(this.plugin.settings.enableBlacklistMenu).onChange(async (v) => {
        this.plugin.settings.enableBlacklistMenu = v;
        await this.plugin.saveSettings();
      }));
      const otaHeaderDiv = containerEl2.createDiv();
      otaHeaderDiv.style.display = "flex";
      otaHeaderDiv.style.alignItems = "center";
      otaHeaderDiv.style.gap = "8px";
      otaHeaderDiv.style.marginTop = "16px";
      otaHeaderDiv.style.marginBottom = "10px";
      otaHeaderDiv.style.cursor = "pointer";
      const otaToggle = otaHeaderDiv.createEl("span");
      otaToggle.textContent = this.plugin.settings.oneTimeActionsFolded ? "\u25B6" : "\u25BC";
      otaToggle.style.fontSize = "12px";
      otaToggle.style.fontWeight = "bold";
      otaToggle.style.display = "inline-block";
      otaToggle.style.width = "16px";
      const otaTitle = otaHeaderDiv.createEl("h2", { text: this.plugin.t("one_time_actions_header", "One-Time Actions") });
      otaTitle.style.margin = "0";
      otaTitle.style.padding = "0";
      otaTitle.style.flex = "1";
      const otaContainer = containerEl2.createDiv();
      otaContainer.style.display = this.plugin.settings.oneTimeActionsFolded ? "none" : "block";
      const otaToggleHandler = async () => {
        this.plugin.settings.oneTimeActionsFolded = !this.plugin.settings.oneTimeActionsFolded;
        otaContainer.style.display = this.plugin.settings.oneTimeActionsFolded ? "none" : "block";
        otaToggle.textContent = this.plugin.settings.oneTimeActionsFolded ? "\u25B6" : "\u25BC";
        await this.debouncedSaveSettings();
      };
      otaHeaderDiv.addEventListener("click", otaToggleHandler);
      try {
        this._cleanupHandlers.push(() => otaHeaderDiv.removeEventListener("click", otaToggleHandler));
      } catch (_) {
      }
      new Setting(otaContainer).setName(this.plugin.t("setting_color_once", "Color Once")).setDesc(this.plugin.t("setting_color_once_desc", "Inserts HTML inline for the selected text. This persists even if the plugin is turned off.")).addToggle((t) => t.setValue(this.plugin.settings.enableQuickColorOnce).onChange(async (v) => {
        this.plugin.settings.enableQuickColorOnce = v;
        await this.plugin.saveSettings();
      }));
      new Setting(otaContainer).setName(this.plugin.t("setting_highlight_once", "Highlight Once")).setDesc(this.plugin.t("setting_highlight_once_desc", "Inserts HTML inline with background styling. This persists even if the plugin is turned off.")).addToggle((t) => t.setValue(this.plugin.settings.enableQuickHighlightOnce).onChange(async (v) => {
        this.plugin.settings.enableQuickHighlightOnce = v;
        await this.plugin.saveSettings();
        this._initializedSettingsUI = false;
        this.display();
      }));
      new Setting(otaContainer).setName(this.plugin.t("setting_color_highlight_once", "Color & Highlight Once")).setDesc(this.plugin.t("setting_color_highlight_once_desc", "Opens the unified color picker to apply both text color and background highlight inline. Uses Unified Menu.")).addToggle((t) => t.setValue(this.plugin.settings.enableQuickColorHighlightOnce).onChange(async (v) => {
        this.plugin.settings.enableQuickColorHighlightOnce = v;
        await this.plugin.saveSettings();
      }));
      if (this.plugin.settings.enableQuickHighlightOnce || this.plugin.settings.enableQuickColorHighlightOnce) {
        new Setting(otaContainer).setName(this.plugin.t("use_global_highlight_style", "Use Global Highlight Style for Highlight Once")).setDesc(this.plugin.t("use_global_highlight_style_desc", "Uses your global inline style. The added HTML/CSS may be long.")).addToggle((t) => t.setValue(this.plugin.settings.quickHighlightUseGlobalStyle).onChange(async (v) => {
          this.plugin.settings.quickHighlightUseGlobalStyle = v;
          await this.plugin.saveSettings();
          this._initializedSettingsUI = false;
          this.display();
        }));
        new Setting(otaContainer).setName(this.plugin.t("style_highlight_once", "Style Highlight Once")).setDesc(this.plugin.t("style_highlight_once_desc", "Uses your custom inline style. The added HTML/CSS may be long.")).addToggle((t) => t.setValue(this.plugin.settings.quickHighlightStyleEnable).onChange(async (v) => {
          this.plugin.settings.quickHighlightStyleEnable = v;
          await this.plugin.saveSettings();
          this._initializedSettingsUI = false;
          this.display();
        }));
        if (this.plugin.settings.quickHighlightStyleEnable && !this.plugin.settings.quickHighlightUseGlobalStyle) {
          const previewSection2 = otaContainer.createDiv();
          previewSection2.style.margin = "8px 0 12px 0";
          previewSection2.style.padding = "12px";
          previewSection2.style.borderRadius = "8px";
          previewSection2.style.border = "1px solid var(--background-modifier-border)";
          previewSection2.style.backgroundColor = "var(--background-secondary)";
          const previewLabel2 = previewSection2.createEl("div");
          previewLabel2.style.marginBottom = "8px";
          previewLabel2.style.fontWeight = "600";
          previewLabel2.style.fontSize = "14px";
          previewLabel2.textContent = this.plugin.t("highlight_once_preview", "Highlight Once Preview");
          const previewText2 = previewSection2.createEl("div");
          previewText2.textContent = this.plugin.t("highlight_once_preview_text", "This is how Highlight Once will look like!");
          previewText2.style.display = "inline-block";
          const updateQuickOncePreview = () => {
            const sampleColor = "#fa8231";
            const hexWithAlpha = this.plugin.hexToHexWithAlpha(sampleColor, this.plugin.settings.quickHighlightOpacity ?? 25);
            const radius = this.plugin.settings.quickHighlightBorderRadius ?? 8;
            const pad = this.plugin.settings.quickHighlightHorizontalPadding ?? 4;
            const vpad = this.plugin.settings.quickHighlightVerticalPadding ?? 0;
            previewText2.style.backgroundColor = hexWithAlpha;
            previewText2.style.borderRadius = radius + "px";
            previewText2.style.paddingLeft = previewText2.style.paddingRight = pad + "px";
            try {
              previewText2.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px");
              previewText2.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px");
              if (vpad < 0) {
                previewText2.style.setProperty("margin-top", vpad + "px");
                previewText2.style.setProperty("margin-bottom", vpad + "px");
              }
            } catch (e) {
              previewText2.style.paddingTop = previewText2.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
              if (vpad < 0) {
                previewText2.style.marginTop = vpad + "px";
                previewText2.style.marginBottom = vpad + "px";
              }
            }
            previewText2.style.border = "";
            previewText2.style.borderTop = "";
            previewText2.style.borderBottom = "";
            previewText2.style.borderLeft = "";
            previewText2.style.borderRight = "";
            const borderCss = this.plugin.generateOnceBorderStyle(sampleColor);
            try {
              previewText2.style.cssText += borderCss;
            } catch (e) {
            }
          };
          updateQuickOncePreview();
          this._updateQuickOncePreview = updateQuickOncePreview;
        }
        if (this.plugin.settings.quickHighlightStyleEnable && !this.plugin.settings.quickHighlightUseGlobalStyle) {
          new Setting(otaContainer).setName(this.plugin.t("highlight_once_opacity", "Highlight once opacity")).addSlider((slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.quickHighlightOpacity ?? 25).setDynamicTooltip().onChange(async (v) => {
            this.plugin.settings.quickHighlightOpacity = v;
            await this.plugin.saveSettings();
            try {
              this._updateQuickOncePreview?.();
            } catch (e) {
            }
          }));
          {
            let brInput;
            new Setting(otaContainer).setName(this.plugin.t("highlight_once_border_radius", "Highlight once border radius (px)")).addText((text) => {
              brInput = text;
              text.setPlaceholder("e.g. 0, 4, 8").setValue(String(this.plugin.settings.quickHighlightBorderRadius ?? 8)).onChange(async (v) => {
                let val = parseInt(v);
                if (isNaN(val) || val < 0) val = 0;
                this.plugin.settings.quickHighlightBorderRadius = val;
                await this.plugin.saveSettings();
                try {
                  this._updateQuickOncePreview?.();
                } catch (e) {
                }
              });
            }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_8", "Reset to 8")).onClick(async () => {
              this.plugin.settings.quickHighlightBorderRadius = 8;
              await this.plugin.saveSettings();
              if (brInput) brInput.setValue("8");
              try {
                this._updateQuickOncePreview?.();
              } catch (e) {
              }
            }));
          }
          {
            let hpInput;
            new Setting(otaContainer).setName(this.plugin.t("highlight_horizontal_padding", "Highlight horizontal padding (px)")).addText((text) => {
              hpInput = text;
              text.setPlaceholder("e.g. 0, 4, 8").setValue(String(this.plugin.settings.quickHighlightHorizontalPadding ?? 4)).onChange(async (v) => {
                let val = parseInt(v);
                if (isNaN(val) || val < 0) val = 0;
                this.plugin.settings.quickHighlightHorizontalPadding = val;
                await this.plugin.saveSettings();
                try {
                  this._updateQuickOncePreview?.();
                } catch (e) {
                }
              });
            }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_4", "Reset to 4")).onClick(async () => {
              this.plugin.settings.quickHighlightHorizontalPadding = 4;
              await this.plugin.saveSettings();
              if (hpInput) hpInput.setValue("4");
              try {
                this._updateQuickOncePreview?.();
              } catch (e) {
              }
            }));
          }
          {
            let vpInput;
            new Setting(otaContainer).setName(this.plugin.t("highlight_vertical_padding", "Highlight vertical padding (px)")).addText((text) => {
              vpInput = text;
              text.setPlaceholder("e.g. 0, 1, 2").setValue(String(this.plugin.settings.quickHighlightVerticalPadding ?? 0)).onChange(async (v) => {
                let val = parseInt(v);
                if (isNaN(val)) val = 0;
                this.plugin.settings.quickHighlightVerticalPadding = val;
                await this.plugin.saveSettings();
                try {
                  this._updateQuickOncePreview?.();
                } catch (e) {
                }
              });
            }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_0", "Reset to 0")).onClick(async () => {
              this.plugin.settings.quickHighlightVerticalPadding = 0;
              await this.plugin.saveSettings();
              if (vpInput) vpInput.setValue("0");
              try {
                this._updateQuickOncePreview?.();
              } catch (e) {
              }
            }));
          }
          new Setting(otaContainer).setName(this.plugin.t("enable_border_highlight_once", "Enable Border for Highlight Once")).setDesc(this.plugin.t("enable_border_highlight_once_desc", "Add a border to your inline highlight. The added HTML/CSS WILL be long.")).addToggle((t) => t.setValue(this.plugin.settings.quickHighlightEnableBorder ?? false).onChange(async (v) => {
            this.plugin.settings.quickHighlightEnableBorder = v;
            await this.plugin.saveSettings();
            try {
              this._updateQuickOncePreview?.();
            } catch (e) {
            }
            this._initializedSettingsUI = false;
            this.display();
          }));
          if (this.plugin.settings.quickHighlightEnableBorder) {
            new Setting(otaContainer).setName(this.plugin.t("highlight_once_border_style", "Highlight Once Border Sides")).addDropdown((d) => {
              d.selectEl.style.width = "200px";
              return d.addOption("full", this.plugin.t("opt_border_full", "Full border (all sides)")).addOption("top-bottom", this.plugin.t("opt_border_top_bottom", "Top & Bottom borders")).addOption("left-right", this.plugin.t("opt_border_left_right", "Left & Right borders")).addOption("top-left-right", this.plugin.t("opt_border_top_left_right", "Top, Left & Right borders")).addOption("bottom-left-right", this.plugin.t("opt_border_bottom_left_right", "Bottom, Left & Right borders")).addOption("top-right", this.plugin.t("opt_border_top_right", "Top & Right borders")).addOption("top-left", this.plugin.t("opt_border_top_left", "Top & Left borders")).addOption("bottom-right", this.plugin.t("opt_border_bottom_right", "Bottom & Right borders")).addOption("bottom-left", this.plugin.t("opt_border_bottom_left", "Bottom & Left borders")).addOption("top", this.plugin.t("opt_border_top", "Top border only")).addOption("bottom", this.plugin.t("opt_border_bottom", "Bottom border only")).addOption("left", this.plugin.t("opt_border_left", "Left border only")).addOption("right", this.plugin.t("opt_border_right", "Right border only")).setValue(this.plugin.settings.quickHighlightBorderStyle ?? "full").onChange(async (v) => {
                this.plugin.settings.quickHighlightBorderStyle = v;
                await this.plugin.saveSettings();
                try {
                  this._updateQuickOncePreview?.();
                } catch (e) {
                }
              });
            });
            new Setting(otaContainer).setName(this.plugin.t("highlight_once_border_line_style", "Border Style")).addDropdown((d) => {
              d.selectEl.style.width = "200px";
              return d.addOption("solid", this.plugin.t("opt_line_solid", "Solid")).addOption("dashed", this.plugin.t("opt_line_dashed", "Dashed")).addOption("dotted", this.plugin.t("opt_line_dotted", "Dotted")).addOption("double", this.plugin.t("opt_line_double", "Double")).addOption("groove", this.plugin.t("opt_line_groove", "Groove")).addOption("ridge", this.plugin.t("opt_line_ridge", "Ridge")).addOption("inset", this.plugin.t("opt_line_inset", "Inset")).addOption("outset", this.plugin.t("opt_line_outset", "Outset")).setValue(this.plugin.settings.quickHighlightBorderLineStyle ?? "solid").onChange(async (v) => {
                this.plugin.settings.quickHighlightBorderLineStyle = v;
                await this.plugin.saveSettings();
                try {
                  this._updateQuickOncePreview?.();
                } catch (e) {
                }
              });
            });
            new Setting(otaContainer).setName(this.plugin.t("highlight_once_border_opacity", "Highlight Once Border Opacity")).addSlider((slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.quickHighlightBorderOpacity ?? 100).setDynamicTooltip().onChange(async (v) => {
              this.plugin.settings.quickHighlightBorderOpacity = v;
              await this.plugin.saveSettings();
              try {
                this._updateQuickOncePreview?.();
              } catch (e) {
              }
            }));
            {
              let btInput;
              new Setting(otaContainer).setName(this.plugin.t("highlight_once_border_thickness", "Highlight Once Border Thickness (px)")).addText((text) => {
                btInput = text;
                text.setPlaceholder("e.g. 1, 2.5, 3.7").setValue(String(this.plugin.settings.quickHighlightBorderThickness ?? 1)).onChange(async (v) => {
                  let val = parseFloat(v);
                  if (isNaN(val) || val < 0) val = 0;
                  if (val > 5) val = 5;
                  this.plugin.settings.quickHighlightBorderThickness = val;
                  await this.plugin.saveSettings();
                  try {
                    this._updateQuickOncePreview?.();
                  } catch (e) {
                  }
                });
              }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_1", "Reset to 1")).onClick(async () => {
                this.plugin.settings.quickHighlightBorderThickness = 1;
                await this.plugin.saveSettings();
                if (btInput) btInput.setValue("1");
                try {
                  this._updateQuickOncePreview?.();
                } catch (e) {
                }
              }));
            }
          }
        }
      }
      const ghHeaderDiv = containerEl2.createDiv();
      ghHeaderDiv.style.display = "flex";
      ghHeaderDiv.style.alignItems = "center";
      ghHeaderDiv.style.gap = "8px";
      ghHeaderDiv.style.marginTop = "16px";
      ghHeaderDiv.style.marginBottom = "10px";
      ghHeaderDiv.style.cursor = "pointer";
      const ghToggle = ghHeaderDiv.createEl("span");
      ghToggle.textContent = this.plugin.settings.globalHighlightFolded ? "\u25B6" : "\u25BC";
      ghToggle.style.fontSize = "12px";
      ghToggle.style.fontWeight = "bold";
      ghToggle.style.display = "inline-block";
      ghToggle.style.width = "16px";
      const ghTitle = ghHeaderDiv.createEl("h3", { text: this.plugin.t("global_highlight_appearance_header", "Global Highlight Coloring Appearance") });
      ghTitle.style.margin = "0";
      ghTitle.style.padding = "0";
      ghTitle.style.flex = "1";
      ghTitle.style.fontSize = "16px";
      ghTitle.style.fontWeight = "600";
      const ghContainer = containerEl2.createDiv();
      ghContainer.style.display = this.plugin.settings.globalHighlightFolded ? "none" : "block";
      const ghToggleHandler = async () => {
        this.plugin.settings.globalHighlightFolded = !this.plugin.settings.globalHighlightFolded;
        ghContainer.style.display = this.plugin.settings.globalHighlightFolded ? "none" : "block";
        ghToggle.textContent = this.plugin.settings.globalHighlightFolded ? "\u25B6" : "\u25BC";
        await this.debouncedSaveSettings();
      };
      ghHeaderDiv.addEventListener("click", ghToggleHandler);
      try {
        this._cleanupHandlers.push(() => ghHeaderDiv.removeEventListener("click", ghToggleHandler));
      } catch (_) {
      }
      const previewSection = ghContainer.createDiv();
      previewSection.style.marginBottom = "16px";
      previewSection.style.padding = "12px";
      previewSection.style.borderRadius = "8px";
      previewSection.style.border = "1px solid var(--background-modifier-border)";
      previewSection.style.backgroundColor = "var(--background-secondary)";
      const previewLabel = previewSection.createEl("div");
      previewLabel.style.marginBottom = "8px";
      previewLabel.style.fontWeight = "600";
      previewLabel.style.fontSize = "14px";
      previewLabel.textContent = this.plugin.t("highlight_preview", "Highlight Preview");
      const previewText = previewSection.createEl("div");
      previewText.style.borderRadius = `${this.plugin.settings.highlightBorderRadius ?? 8}px`;
      previewText.style.display = "inline-block";
      previewText.style.maxWidth = "auto";
      previewText.style.wordWrap = "break-word";
      previewText.textContent = this.plugin.t("highlight_preview_text", "This is how your highlight will look like!");
      const updatePreview2 = () => {
        const color = "#01c8ff";
        const rgba = this.plugin.hexToRgba(color, this.plugin.settings.backgroundOpacity ?? 25);
        previewText.style.backgroundColor = rgba;
        previewText.style.borderRadius = `${this.plugin.settings.highlightBorderRadius ?? 8}px`;
        previewText.style.paddingLeft = previewText.style.paddingRight = `${this.plugin.settings.highlightHorizontalPadding ?? 4}px`;
        try {
          const vpad = this.plugin.settings.highlightVerticalPadding ?? 0;
          previewText.style.setProperty("padding-top", (vpad >= 0 ? vpad : 0) + "px");
          previewText.style.setProperty("padding-bottom", (vpad >= 0 ? vpad : 0) + "px");
          if (vpad < 0) {
            previewText.style.setProperty("margin-top", vpad + "px");
            previewText.style.setProperty("margin-bottom", vpad + "px");
          }
        } catch (e) {
          const vpad = this.plugin.settings.highlightVerticalPadding ?? 0;
          previewText.style.paddingTop = (vpad >= 0 ? vpad : 0) + "px";
          previewText.style.paddingBottom = (vpad >= 0 ? vpad : 0) + "px";
          if (vpad < 0) {
            previewText.style.marginTop = vpad + "px";
            previewText.style.marginBottom = vpad + "px";
          }
        }
        previewText.style.border = "";
        previewText.style.borderTop = "";
        previewText.style.borderBottom = "";
        previewText.style.borderLeft = "";
        previewText.style.borderRight = "";
        if (this.plugin.settings.enableBorderThickness) {
          this.plugin.applyBorderStyleToElement(previewText, null, color);
        }
      };
      updatePreview2();
      new Setting(ghContainer).setName(this.plugin.t("highlight_opacity", "Highlight opacity")).setDesc(this.plugin.t("highlight_opacity_desc", "Set the opacity of the highlight (0-100%)")).addSlider((slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.backgroundOpacity ?? 25).setDynamicTooltip().onChange(async (v) => {
        this.plugin.settings.backgroundOpacity = v;
        await this.debouncedSaveSettings();
        updatePreview2();
      }));
      {
        let brInput;
        new Setting(ghContainer).setName(this.plugin.t("highlight_border_radius", "Highlight border radius (px)")).setDesc(this.plugin.t("highlight_border_radius_desc", "Set the border radius (in px) for rounded highlight corners")).addText((text) => {
          brInput = text;
          text.setPlaceholder("e.g. 0, 4, 8").setValue(String(this.plugin.settings.highlightBorderRadius ?? 8)).onChange(async (v) => {
            let val = parseInt(v);
            if (isNaN(val) || val < 0) val = 0;
            this.plugin.settings.highlightBorderRadius = val;
            await this.debouncedSaveSettings();
            updatePreview2();
          });
        }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_8", "Reset to 8")).onClick(async () => {
          this.plugin.settings.highlightBorderRadius = 8;
          await this.debouncedSaveSettings();
          if (brInput) brInput.setValue("8");
          updatePreview2();
        }));
      }
      {
        let hpInput;
        new Setting(ghContainer).setName(this.plugin.t("highlight_horizontal_padding", "Highlight horizontal padding (px)")).setDesc(this.plugin.t("highlight_horizontal_padding_desc", "Set the left and right padding (in px) for highlighted text")).addText((text) => {
          hpInput = text;
          text.setPlaceholder("e.g. 0, 4, 8").setValue(String(this.plugin.settings.highlightHorizontalPadding ?? 4)).onChange(async (v) => {
            let val = parseInt(v);
            if (isNaN(val) || val < 0) val = 0;
            this.plugin.settings.highlightHorizontalPadding = val;
            await this.debouncedSaveSettings();
            updatePreview2();
          });
        }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_4", "Reset to 4")).onClick(async () => {
          this.plugin.settings.highlightHorizontalPadding = 4;
          await this.debouncedSaveSettings();
          if (hpInput) hpInput.setValue("4");
          updatePreview2();
        }));
      }
      {
        let vpInput;
        new Setting(ghContainer).setName(this.plugin.t("highlight_vertical_padding", "Highlight vertical padding (px)")).setDesc(this.plugin.t("highlight_vertical_padding_desc", "Set the top and bottom padding (in px) for highlighted text")).addText((text) => {
          vpInput = text;
          text.setPlaceholder("e.g. 0, 1, 2").setValue(String(this.plugin.settings.highlightVerticalPadding ?? 0)).onChange(async (v) => {
            let val = parseInt(v);
            if (isNaN(val) || val < 0) val = 0;
            this.plugin.settings.highlightVerticalPadding = val;
            await this.debouncedSaveSettings();
            updatePreview2();
          });
        }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_0", "Reset to 0")).onClick(async () => {
          this.plugin.settings.highlightVerticalPadding = 0;
          await this.debouncedSaveSettings();
          if (vpInput) vpInput.setValue("0");
          updatePreview2();
        }));
      }
      new Setting(ghContainer).setName(this.plugin.t("rounded_corners_wrapping", "Rounded corners on line wrapping")).setDesc(this.plugin.t("rounded_corners_wrapping_desc", "When enabled, highlights will have rounded corners on all sides, even when text wraps to a new line.")).addToggle((t) => t.setValue(this.plugin.settings.enableBoxDecorationBreak ?? true).onChange(async (v) => {
        this.plugin.settings.enableBoxDecorationBreak = v;
        await this.debouncedSaveSettings();
      }));
      new Setting(ghContainer).setName(this.plugin.t("enable_highlight_border", "Enable Highlight Border")).setDesc(this.plugin.t("enable_highlight_border_desc", "Add a border around highlights. The border will match the text or highlight color.")).addToggle((t) => t.setValue(this.plugin.settings.enableBorderThickness ?? false).onChange(async (v) => {
        this.plugin.settings.enableBorderThickness = v;
        await this.plugin.saveSettings();
        updatePreview2();
        this._initializedSettingsUI = false;
        this.display();
      }));
      if (this.plugin.settings.enableBorderThickness) {
        new Setting(ghContainer).setName(this.plugin.t("border_style", "Border Sides")).setDesc(this.plugin.t("border_style_desc", "Choose which sides to apply the border")).addDropdown((d) => {
          d.selectEl.style.width = "200px";
          try {
            d.selectEl.style.textAlign = "center";
          } catch (e) {
          }
          return d.addOption("full", this.plugin.t("opt_border_full", "Full border (all sides)")).addOption("top-bottom", this.plugin.t("opt_border_top_bottom", "Top & Bottom borders")).addOption("left-right", this.plugin.t("opt_border_left_right", "Left & Right borders")).addOption("top-left-right", this.plugin.t("opt_border_top_left_right", "Top, Left & Right borders")).addOption("bottom-left-right", this.plugin.t("opt_border_bottom_left_right", "Bottom, Left & Right borders")).addOption("top-right", this.plugin.t("opt_border_top_right", "Top & Right borders")).addOption("top-left", this.plugin.t("opt_border_top_left", "Top & Left borders")).addOption("bottom-right", this.plugin.t("opt_border_bottom_right", "Bottom & Right borders")).addOption("bottom-left", this.plugin.t("opt_border_bottom_left", "Bottom & Left borders")).addOption("top", this.plugin.t("opt_border_top", "Top border only")).addOption("bottom", this.plugin.t("opt_border_bottom", "Bottom border only")).addOption("left", this.plugin.t("opt_border_left", "Left border only")).addOption("right", this.plugin.t("opt_border_right", "Right border only")).setValue(this.plugin.settings.borderStyle ?? "full").onChange(async (v) => {
            this.plugin.settings.borderStyle = v;
            await this.debouncedSaveSettings();
            updatePreview2();
          });
        });
        new Setting(ghContainer).setName(this.plugin.t("border_line_style", "Border Style")).setDesc(this.plugin.t("border_line_style_desc", "Choose the border line style")).addDropdown((d) => {
          d.selectEl.style.width = "200px";
          try {
            d.selectEl.style.textAlign = "center";
          } catch (e) {
          }
          return d.addOption("solid", this.plugin.t("opt_line_solid", "Solid")).addOption("dashed", this.plugin.t("opt_line_dashed", "Dashed")).addOption("dotted", this.plugin.t("opt_line_dotted", "Dotted")).addOption("double", this.plugin.t("opt_line_double", "Double")).addOption("groove", this.plugin.t("opt_line_groove", "Groove")).addOption("ridge", this.plugin.t("opt_line_ridge", "Ridge")).addOption("inset", this.plugin.t("opt_line_inset", "Inset")).addOption("outset", this.plugin.t("opt_line_outset", "Outset")).setValue(this.plugin.settings.borderLineStyle ?? "solid").onChange(async (v) => {
            this.plugin.settings.borderLineStyle = v;
            await this.debouncedSaveSettings();
            updatePreview2();
          });
        });
        new Setting(ghContainer).setName(this.plugin.t("border_opacity", "Border Opacity")).setDesc(this.plugin.t("border_opacity_desc", "Set the opacity of the border (0-100%)")).addSlider((slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.borderOpacity ?? 100).setDynamicTooltip().onChange(async (v) => {
          this.plugin.settings.borderOpacity = v;
          await this.debouncedSaveSettings();
          updatePreview2();
        }));
        {
          let btInput;
          new Setting(ghContainer).setName(this.plugin.t("border_thickness", "Border Thickness (px)")).setDesc(this.plugin.t("border_thickness_desc", "Set the border thickness from 0-5 pixels (e.g. 1, 2.5, 5)")).addText((text) => {
            btInput = text;
            text.setPlaceholder("e.g. 1, 2.5, 3.7").setValue(String(this.plugin.settings.borderThickness ?? 1)).onChange(async (v) => {
              let val = parseFloat(v);
              if (isNaN(val) || val < 0) val = 0;
              if (val > 5) val = 5;
              this.plugin.settings.borderThickness = val;
              await this.debouncedSaveSettings();
              updatePreview2();
            });
          }).addExtraButton((btn) => btn.setIcon("reset").setTooltip(this.plugin.t("reset_to_1", "Reset to 1")).onClick(async () => {
            this.plugin.settings.borderThickness = 1;
            await this.debouncedSaveSettings();
            if (btInput) btInput.setValue("1");
            updatePreview2();
          }));
        }
      }
      const swHeaderDiv = containerEl2.createDiv();
      swHeaderDiv.style.display = "flex";
      swHeaderDiv.style.alignItems = "center";
      swHeaderDiv.style.gap = "8px";
      swHeaderDiv.style.marginTop = "24px";
      swHeaderDiv.style.marginBottom = "10px";
      swHeaderDiv.style.cursor = "pointer";
      const swToggle = swHeaderDiv.createEl("span");
      swToggle.textContent = this.plugin.settings.colorSwatchesFolded ? "\u25B6" : "\u25BC";
      swToggle.style.fontSize = "12px";
      swToggle.style.fontWeight = "bold";
      swToggle.style.display = "inline-block";
      swToggle.style.width = "16px";
      swToggle.style.marginTop = "-8px";
      const swTitle = swHeaderDiv.createEl("h2", { text: this.plugin.t("color_swatches_header", "Color Management") });
      swTitle.style.margin = "0";
      swTitle.style.marginTop = "-8px";
      swTitle.style.padding = "0";
      swTitle.style.flex = "1";
      const swContainer = containerEl2.createDiv();
      swContainer.style.display = this.plugin.settings.colorSwatchesFolded ? "none" : "block";
      const swToggleHandler = async () => {
        this.plugin.settings.colorSwatchesFolded = !this.plugin.settings.colorSwatchesFolded;
        swContainer.style.display = this.plugin.settings.colorSwatchesFolded ? "none" : "block";
        swToggle.textContent = this.plugin.settings.colorSwatchesFolded ? "\u25B6" : "\u25BC";
        await this.debouncedSaveSettings();
      };
      swHeaderDiv.addEventListener("click", swToggleHandler);
      try {
        this._cleanupHandlers.push(() => swHeaderDiv.removeEventListener("click", swToggleHandler));
      } catch (_) {
      }
      new Setting(swContainer).setName(this.plugin.t("color_picker_layout", "Color Picker Layout")).setDesc(this.plugin.t("color_picker_layout_desc", "Choose which color types to show when picking colors for text")).addDropdown((dd) => {
        dd.addOption("both", this.plugin.t("opt_both_text_left", "Both: Text left, Highlight right"));
        dd.addOption("both-bg-left", this.plugin.t("opt_both_bg_left", "Both: Highlight left, Text right"));
        dd.addOption("both-v-text-top", this.plugin.t("opt_both_text_top", "Both (vertical): Text above, Highlight below"));
        dd.addOption("both-v-bg-top", this.plugin.t("opt_both_bg_top", "Both (vertical): Highlight above, Text below"));
        dd.addOption("text", this.plugin.t("opt_text_only", "Text color only"));
        dd.addOption("background", this.plugin.t("opt_background_only", "Highlight color only"));
        dd.setValue(this.plugin.settings.colorPickerMode || "both");
        try {
          dd.selectEl.style.minWidth = "230px";
        } catch (e) {
        }
        try {
          dd.selectEl.style.textAlign = "center";
        } catch (e) {
        }
        dd.onChange(async (v) => {
          this.plugin.settings.colorPickerMode = v;
          await this.plugin.saveSettings();
        });
      });
      new Setting(swContainer).setName(this.plugin.t("enable_custom_swatches", "Enable custom swatches")).setDesc(this.plugin.t("enable_custom_swatches_desc", "Turn this on if you want to pick your own colors for the color picker.")).addToggle((t) => t.setValue(this.plugin.settings.customSwatchesEnabled).onChange(async (v) => {
        this.plugin.settings.customSwatchesEnabled = v;
        await this.plugin.saveSettings();
        this._refreshCustomSwatches();
      }));
      new Setting(swContainer).setName(this.plugin.t("replace_default_swatches", "Replace default swatches")).setDesc(this.plugin.t("replace_default_swatches_desc", "If enabled, only your custom swatches will be shown. If disabled, they will be appended to the default ones.")).addToggle((t) => t.setValue(this.plugin.settings.replaceDefaultSwatches).onChange(async (v) => {
        this.plugin.settings.replaceDefaultSwatches = v;
        await this.plugin.saveSettings();
      }));
      new Setting(swContainer).setName(this.plugin.t("use_swatch_names", "Use swatch names for coloring text")).setDesc(this.plugin.t("use_swatch_names_desc", 'If enabled, the text will be colored using the name of the swatch (e.g., "Red") instead of the hex code.')).addToggle((t) => t.setValue(this.plugin.settings.useSwatchNamesForText).onChange(async (v) => {
        this.plugin.settings.useSwatchNamesForText = v;
        await this.plugin.saveSettings();
      }));
      new Setting(swContainer).setName(this.plugin.t("link_swatch_updates", "Link swatch updates to text colors")).setDesc(this.plugin.t("link_swatch_updates_desc", "If enabled, updating a swatch color will update all text colored with that swatch.")).addToggle((t) => t.setValue(this.plugin.settings.linkSwatchUpdatesToEntries).onChange(async (v) => {
        this.plugin.settings.linkSwatchUpdatesToEntries = v;
        await this.plugin.saveSettings();
      }));
      this._customSwatchesContainer = swContainer.createDiv();
      this._refreshCustomSwatches();
      this._quickColorsContainer = containerEl2.createDiv();
      this._refreshQuickColors();
      this._quickStylesContainer = containerEl2.createDiv();
      this._refreshQuickStyles();
    }
    if (this._activeTab === "always-color-texts") {
      const headerEl = containerEl2.createEl("h3", { text: this.plugin.t("colored_texts_header", "Colored Texts") });
      try {
        headerEl.className = "always-colored-texts-header";
      } catch (e) {
      }
      try {
        headerEl.style.marginTop = "30px !important";
      } catch (e) {
      }
      const desc = containerEl2.createEl("p", { text: this.plugin.t("always_colored_texts_desc", "Here's where you manage your word / patterns and their colors.") });
      desc.addClass("act-desc");
      desc.style.marginTop = "-7px";
      const dividerSetting = new Setting(containerEl2);
      try {
        dividerSetting.settingEl.classList.add("act-section-divider");
      } catch (_) {
      }
      const entriesSearchContainer = containerEl2.createDiv();
      try {
        entriesSearchContainer.addClass("act-search-container");
      } catch (e) {
        try {
          entriesSearchContainer.classList.add("act-search-container");
        } catch (_) {
        }
      }
      entriesSearchContainer.style.margin = "8px 0";
      entriesSearchContainer.style.marginTop = "-10px";
      entriesSearchContainer.style.display = "flex";
      entriesSearchContainer.style.alignItems = "center";
      entriesSearchContainer.style.gap = "8px";
      const entriesSearch = entriesSearchContainer.createEl("input", { type: "text" });
      try {
        entriesSearch.addClass("act-search-input");
      } catch (e) {
        try {
          entriesSearch.classList.add("act-search-input");
        } catch (_) {
        }
      }
      entriesSearch.placeholder = this.plugin.t("search_colored_words_placeholder", "Search colored words/patterns\u2026");
      entriesSearch.style.flex = "1 1 auto";
      entriesSearch.style.padding = "6px";
      entriesSearch.style.border = "1px solid var(--background-modifier-border)";
      const entriesIcon = entriesSearchContainer.createDiv();
      try {
        entriesIcon.addClass("act-search-icon");
      } catch (e) {
        try {
          entriesIcon.classList.add("act-search-icon");
        } catch (_) {
        }
      }
      const entriesSearchHandler = () => {
        this._entriesSearchQuery = String(entriesSearch.value || "").trim().toLowerCase();
        try {
          this._refreshEntries();
        } catch (e) {
        }
      };
      entriesSearch.addEventListener("input", entriesSearchHandler);
      this._cleanupHandlers.push(() => entriesSearch.removeEventListener("input", entriesSearchHandler));
      const entriesLimitInput = entriesSearchContainer.createEl("input", { type: "text" });
      entriesLimitInput.value = String(this.plugin.settings?.entriesSearchLimit ?? 0);
      entriesLimitInput.placeholder = this.plugin.t("limit_input_placeholder", "limit");
      entriesLimitInput.title = this.plugin.t("limit_input_tooltip", "0=all; number=last N; r=regex; w=words; h=highlight; c=text; b=text+bg; sw=starts; ew=ends; e=exact");
      entriesLimitInput.style.width = "64px";
      entriesLimitInput.style.padding = "6px";
      entriesLimitInput.style.border = "1px solid var(--background-modifier-border)";
      entriesLimitInput.style.borderRadius = "var(--input-radius)";
      const entriesLimitHandler = () => {
        const raw = String(entriesLimitInput.value || "").trim().toLowerCase();
        const parts = raw.split(/\s+/).filter(Boolean);
        const numPart = parts.find((p) => /^\d+$/.test(p));
        const num = numPart ? parseInt(numPart, 10) : NaN;
        this._entriesLimit = !isNaN(num) && num >= 0 ? num : 0;
        try {
          this.plugin.settings.entriesSearchLimit = this._entriesLimit;
          this.debouncedSaveSettings();
        } catch (e) {
        }
        this._entriesRegexOnly = false;
        this._entriesWordsOnly = false;
        this._filterMode = null;
        this._entriesSearchMatch = "contains";
        this._entriesMatchTypeStartsWith = false;
        this._entriesMatchTypeEndsWith = false;
        this._entriesMatchTypeExact = false;
        for (const tok of parts) {
          if (tok === "r") this._entriesRegexOnly = true;
          else if (tok === "w") this._entriesWordsOnly = true;
          else if (tok === "h") this._filterMode = "highlight";
          else if (tok === "c") this._filterMode = "text";
          else if (tok === "b") this._filterMode = "both";
          else if (tok === "sw") this._entriesMatchTypeStartsWith = true;
          else if (tok === "ew") this._entriesMatchTypeEndsWith = true;
          else if (tok === "e") this._entriesMatchTypeExact = true;
        }
        try {
          this._refreshEntries();
        } catch (e) {
        }
      };
      entriesLimitInput.addEventListener("input", entriesLimitHandler);
      this._cleanupHandlers.push(() => entriesLimitInput.removeEventListener("input", entriesLimitHandler));
      const listDiv = containerEl2.createDiv();
      listDiv.addClass("color-words-list");
      try {
        this._refreshEntries();
      } catch (e) {
      }
      const buttonRowDiv = containerEl2.createDiv();
      buttonRowDiv.addClass("entries-button-row");
      const sortBtn = buttonRowDiv.createEl("button");
      const sortModes = ["last-added", "a-z", "reverse-a-z", "style-order", "color"];
      const sortLabels = {
        "last-added": this.plugin.t("sort_label_last-added", "Sort: Last Added"),
        "a-z": this.plugin.t("sort_label_a-z", "Sort: A-Z"),
        "reverse-a-z": this.plugin.t("sort_label_reverse-a-z", "Sort: Z-A"),
        "style-order": this.plugin.t("sort_label_style-order", "Sort: Style Order"),
        "color": this.plugin.t("sort_label_color", "Sort: Color")
      };
      sortBtn.textContent = this.plugin.t("sort_label_" + (this._wordsSortMode || "last-added"), sortLabels[this._wordsSortMode] || "Sort: Last Added");
      sortBtn.style.cursor = "pointer";
      sortBtn.style.flex = "0 0 auto";
      const sortBtnHandler = async () => {
        const currentIndex = sortModes.indexOf(this._wordsSortMode);
        const nextIndex = (currentIndex + 1) % sortModes.length;
        this._wordsSortMode = sortModes[nextIndex];
        sortBtn.textContent = sortLabels[this._wordsSortMode];
        try {
          this.plugin.settings.wordsSortMode = this._wordsSortMode;
          await this.plugin.saveSettings();
        } catch (e) {
        }
        this._suspendSorting = false;
        this._refreshEntries();
      };
      sortBtn.addEventListener("click", sortBtnHandler);
      this._cleanupHandlers.push(() => sortBtn.removeEventListener("click", sortBtnHandler));
      const addWordsBtn = buttonRowDiv.createEl("button");
      addWordsBtn.textContent = this.plugin.t("btn_add_words", "+ Add Words");
      addWordsBtn.style.cursor = "pointer";
      addWordsBtn.style.flex = "1";
      addWordsBtn.addClass("mod-cta");
      const addWordsHandler = async () => {
        const uid = (() => {
          try {
            return Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (e) {
            return Date.now();
          }
        })();
        this.plugin.settings.wordEntries.push({ pattern: "", color: "", isRegex: false, flags: "", groupedPatterns: null, styleType: "text", uid, persistAtEnd: true, matchType: this.plugin.settings.partialMatch ? "contains" : "exact" });
        this._suspendSorting = this._wordsSortMode === "last-added";
        try {
          this._newEntriesSet && this._newEntriesSet.add(uid);
        } catch (e) {
        }
        await this.plugin.saveSettings();
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        this.plugin.forceRefreshAllReadingViews();
        this._refreshEntries();
      };
      addWordsBtn.addEventListener("click", addWordsHandler);
      this._cleanupHandlers.push(() => addWordsBtn.removeEventListener("click", addWordsHandler));
      const addRegexBtn = buttonRowDiv.createEl("button");
      addRegexBtn.textContent = this.plugin.t("btn_add_regex", "+ Add Regex");
      addRegexBtn.style.cursor = "pointer";
      addRegexBtn.style.flex = "1";
      addRegexBtn.addClass("mod-cta");
      addRegexBtn.style.display = this.plugin.settings.enableRegexSupport ? "" : "none";
      const addRegexHandler = () => {
        try {
          this._suspendSorting = this._wordsSortMode === "last-added";
          const onAdded = (entry) => {
            try {
              if (entry && entry.uid) {
                this._newEntriesSet && this._newEntriesSet.add(entry.uid);
              }
              this._refreshEntries();
            } catch (e) {
            }
          };
          new RealTimeRegexTesterModal(this.app, this.plugin, onAdded).open();
        } catch (e) {
        }
      };
      addRegexBtn.addEventListener("click", addRegexHandler);
      this._cleanupHandlers.push(() => addRegexBtn.removeEventListener("click", addRegexHandler));
      const presetsBtn = buttonRowDiv.createEl("button");
      presetsBtn.textContent = this.plugin.t("btn_presets", "Presets");
      presetsBtn.style.cursor = "pointer";
      presetsBtn.style.flex = "0 0 auto";
      const presetsHandler = () => {
        new PresetModal(this.app, this.plugin, async (preset) => {
          if (!preset) return;
          new ColorPickerModal(this.app, this.plugin, async (color, result) => {
            const sel = result || {};
            const tc = sel.textColor && this.plugin.isValidHexColor(sel.textColor) ? sel.textColor : null;
            const bc = sel.backgroundColor && this.plugin.isValidHexColor(sel.backgroundColor) ? sel.backgroundColor : null;
            if (!tc && !bc && (!color || !this.plugin.isValidHexColor(color))) return;
            const entry = { pattern: preset.pattern, isRegex: true, flags: preset.flags || "", groupedPatterns: null, presetLabel: preset.label, persistAtEnd: true, matchType: this.plugin.settings.partialMatch ? "contains" : "exact" };
            if (preset.affectMarkElements) entry.affectMarkElements = true;
            if (preset.targetElement) entry.targetElement = preset.targetElement;
            try {
              entry.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
            } catch (e) {
              entry.uid = Date.now();
            }
            if (tc && bc) {
              entry.textColor = tc;
              entry.backgroundColor = bc;
              entry.color = "";
              entry.styleType = "both";
              entry._savedTextColor = tc;
              entry._savedBackgroundColor = bc;
            } else if (tc) {
              entry.color = tc;
              entry.styleType = "text";
              entry._savedTextColor = tc;
            } else if (bc) {
              entry.textColor = "currentColor";
              entry.backgroundColor = bc;
              entry.color = "";
              entry.styleType = "highlight";
              entry._savedBackgroundColor = bc;
            } else {
              entry.color = color;
              entry._savedTextColor = color;
            }
            this.plugin.settings.wordEntries.push(entry);
            this._suspendSorting = this._wordsSortMode === "last-added";
            try {
              this._newEntriesSet && entry && entry.uid && this._newEntriesSet.add(entry.uid);
            } catch (e) {
            }
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.compileTextBgColoringEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this._refreshEntries();
          }, "text-and-background", "", false).open();
        }).open();
      };
      presetsBtn.addEventListener("click", presetsHandler);
      this._cleanupHandlers.push(() => presetsBtn.removeEventListener("click", presetsHandler));
      const deleteAllWordsSetting = new Setting(containerEl2).addExtraButton((b) => b.setIcon("trash").setTooltip(this.plugin.t("tooltip_delete_all_words", "Delete all defined words/patterns")).onClick(async () => {
        new ConfirmationModal(this.app, this.plugin, this.plugin.t("confirm_delete_all_title", "Delete all words"), this.plugin.t("confirm_delete_all_desc", "Are you sure you want to delete all your colored words/patterns? You can't undo this!"), async () => {
          this.plugin.settings.wordEntries = [];
          await this.plugin.saveSettings();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
          this._refreshEntries();
        }).open();
      }));
      try {
        deleteAllWordsSetting.settingEl.classList.add("act-delete-groups-setting");
      } catch (_) {
      }
      containerEl2.createEl("h3", { text: this.plugin.t("grouped_entries_header", "Grouped Entries") });
      new Setting(containerEl2).setName(this.plugin.t("hide_inactive_groups_in_dropdowns", "Hide Inactive Groups in Dropdowns")).setDesc(this.plugin.t("hide_inactive_groups_in_dropdowns_desc", "Hide inactive word groups when displaying group lists in dropdowns.")).addToggle((t) => t.setValue(!!this.plugin.settings.hideInactiveGroupsInDropdowns).onChange(async (v) => {
        this.plugin.settings.hideInactiveGroupsInDropdowns = !!v;
        await this.plugin.saveSettings();
      }));
      new Setting(containerEl2).setName(this.plugin.t("show_word_groups_in_commands", "Show word groups in commands")).setDesc(this.plugin.t("show_word_groups_in_commands_desc", "When enabled, word groups appear in the command palette with Activate/Deactivate commands.")).addToggle((t) => t.setValue(!!this.plugin.settings.showWordGroupsInCommands).onChange(async (v) => {
        this.plugin.settings.showWordGroupsInCommands = !!v;
        await this.plugin.saveSettings();
        this.plugin.reregisterCommandsWithLanguage();
      }));
      const groupSearchContainer = containerEl2.createDiv();
      try {
        groupSearchContainer.addClass("act-search-container");
      } catch (e) {
        try {
          groupSearchContainer.classList.add("act-search-container");
        } catch (_) {
        }
      }
      groupSearchContainer.style.margin = "8px 0";
      groupSearchContainer.style.display = "flex";
      groupSearchContainer.style.alignItems = "center";
      groupSearchContainer.style.gap = "8px";
      const groupSearch = groupSearchContainer.createEl("input", { type: "text" });
      try {
        groupSearch.addClass("act-search-input");
      } catch (e) {
        try {
          groupSearch.classList.add("act-search-input");
        } catch (_) {
        }
      }
      groupSearch.placeholder = this.plugin.t("search_groups_placeholder", "Search groups\u2026");
      groupSearch.style.flex = "1 1 auto";
      groupSearch.style.padding = "6px";
      groupSearch.style.border = "1px solid var(--background-modifier-border)";
      groupSearch.addEventListener("input", () => {
        this._groupSearch = groupSearch.value || "";
        this._refreshGroups();
      });
      const groupIcon = groupSearchContainer.createDiv();
      try {
        groupIcon.addClass("act-search-icon");
      } catch (e) {
        try {
          groupIcon.classList.add("act-search-icon");
        } catch (_) {
        }
      }
      const groupsContainer = containerEl2.createDiv();
      groupsContainer.addClass("act-groups-container");
      this._refreshGroups();
      const groupButtonsContainer = containerEl2.createDiv();
      groupButtonsContainer.style.display = "flex";
      groupButtonsContainer.style.gap = "8px";
      groupButtonsContainer.style.marginTop = "10px";
      groupButtonsContainer.style.justifyContent = "space-between";
      const btnCreateGroup = groupButtonsContainer.createEl("button", { text: this.plugin.t("btn_create_new_group", "+ Create New Group") });
      btnCreateGroup.addClass("mod-cta");
      btnCreateGroup.onclick = async () => {
        if (!this.plugin.settings.wordEntryGroups) this.plugin.settings.wordEntryGroups = [];
        const newGroup = {
          active: true,
          name: "",
          entries: [],
          enableFolders: [],
          disableFolders: [],
          enableTags: [],
          disableTags: []
        };
        try {
          newGroup.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
        } catch (_) {
        }
        this.plugin.settings.wordEntryGroups.push(newGroup);
        await this.plugin.saveSettings();
        this.plugin.compileWordEntries();
        try {
          new EditWordGroupModal(this.app, this.plugin, newGroup, async (updatedGroup) => {
            const idx = this.plugin.settings.wordEntryGroups.findIndex((g) => g && g.uid === newGroup.uid);
            if (idx !== -1) {
              this.plugin.settings.wordEntryGroups[idx] = updatedGroup;
            }
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this._refreshGroups();
          }, async (groupToDelete) => {
            const actualIndex = this.plugin.settings.wordEntryGroups.findIndex((g) => g && g.uid === groupToDelete.uid);
            if (actualIndex !== -1) {
              this.plugin.settings.wordEntryGroups.splice(actualIndex, 1);
            }
            await this.plugin.saveSettings();
            this.plugin.compileWordEntries();
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            this.plugin.forceRefreshAllReadingViews();
            this._refreshGroups();
          }).open();
        } catch (_) {
          this._refreshGroups();
        }
      };
      new Setting(groupButtonsContainer).addExtraButton((b) => b.setIcon("trash").setTooltip(this.plugin.t("tooltip_delete_all_groups", "Delete all Word Groups")).onClick(async () => {
        new ConfirmationModal(this.app, this.plugin, this.plugin.t("confirm_delete_all_groups_title", "Delete All Word Groups"), this.plugin.t("confirm_delete_all_groups_desc", "Are you sure you want to delete ALL word groups? This cannot be undone!"), async () => {
          this.plugin.settings.wordEntryGroups = [];
          await this.plugin.saveSettings();
          this.plugin.compileWordEntries();
          this.plugin.reconfigureEditorExtensions();
          this.plugin.forceRefreshAllEditors();
          this.plugin.forceRefreshAllReadingViews();
          this._refreshGroups();
        }).open();
      })).then((setting) => {
        setting.settingEl.classList.add("act-delete-groups-setting");
      });
    }
    if (this._activeTab === "blacklist") {
      containerEl2.createEl("h3", { text: this.plugin.t("blacklist_words_header", "Blacklist words") });
      const desc = containerEl2.createEl("p", { text: this.plugin.t("blacklist_words_desc", "Keywords or patterns here will never be colored, even for partial matches.") });
      desc.addClass("act-desc");
      desc.style.marginTop = "-7px";
      const blSearchContainer = containerEl2.createDiv();
      try {
        blSearchContainer.addClass("act-search-container");
      } catch (e) {
        try {
          blSearchContainer.classList.add("act-search-container");
        } catch (_) {
        }
      }
      blSearchContainer.style.margin = "8px 0";
      blSearchContainer.style.display = "flex";
      blSearchContainer.style.alignItems = "center";
      blSearchContainer.style.gap = "8px";
      const blSearch = blSearchContainer.createEl("input", { type: "text" });
      try {
        blSearch.addClass("act-search-input");
      } catch (e) {
        try {
          blSearch.classList.add("act-search-input");
        } catch (_) {
        }
      }
      blSearch.placeholder = this.plugin.t("search_blacklist_placeholder", "Search blacklisted words or patterns\u2026");
      blSearch.style.flex = "1 1 auto";
      blSearch.style.padding = "6px";
      blSearch.style.border = "1px solid var(--background-modifier-border)";
      const blIcon = blSearchContainer.createDiv();
      try {
        blIcon.addClass("act-search-icon");
      } catch (e) {
        try {
          blIcon.classList.add("act-search-icon");
        } catch (_) {
        }
      }
      const blSearchHandler = () => {
        this._blacklistSearchQuery = String(blSearch.value || "").trim().toLowerCase();
        try {
          this._refreshBlacklistWords();
        } catch (e) {
        }
      };
      blSearch.addEventListener("input", blSearchHandler);
      this._cleanupHandlers.push(() => blSearch.removeEventListener("input", blSearchHandler));
      const blLimitInput = blSearchContainer.createEl("input", { type: "text" });
      blLimitInput.value = String(this.plugin.settings?.blacklistSearchLimit ?? 0);
      blLimitInput.placeholder = this.plugin.t("limit_input_placeholder", "limit");
      blLimitInput.title = this.plugin.t("limit_input_tooltip", "0=all; number=last N; r=regex; w=words; sw=starts; ew=ends; e=exact");
      blLimitInput.style.width = "64px";
      blLimitInput.style.padding = "6px";
      blLimitInput.style.border = "1px solid var(--background-modifier-border)";
      blLimitInput.style.borderRadius = "var(--input-radius)";
      const blLimitHandler = () => {
        const raw = String(blLimitInput.value || "").trim().toLowerCase();
        const parts = raw.split(/\s+/).filter(Boolean);
        const numPart = parts.find((p) => /^\d+$/.test(p));
        const num = numPart ? parseInt(numPart, 10) : NaN;
        this._blacklistLimit = !isNaN(num) && num >= 0 ? num : 0;
        this._blacklistRegexOnly = false;
        this._blacklistWordsOnly = false;
        this._blacklistSearchMatchStarts = false;
        this._blacklistSearchMatchEnds = false;
        this._blacklistSearchMatchExact = false;
        for (const tok of parts) {
          if (tok === "r") this._blacklistRegexOnly = true;
          else if (tok === "w") this._blacklistWordsOnly = true;
          else if (tok === "sw") this._blacklistSearchMatchStarts = true;
          else if (tok === "ew") this._blacklistSearchMatchEnds = true;
          else if (tok === "e") this._blacklistSearchMatchExact = true;
        }
        try {
          this.plugin.settings.blacklistSearchLimit = this._blacklistLimit;
          this.debouncedSaveSettings();
        } catch (e) {
        }
        try {
          this._refreshBlacklistWords();
        } catch (e) {
        }
      };
      blLimitInput.addEventListener("input", blLimitHandler);
      this._cleanupHandlers.push(() => blLimitInput.removeEventListener("input", blLimitHandler));
      this._blacklistWordsContainer = containerEl2.createDiv();
      this._blacklistWordsContainer.addClass("blacklist-words-list");
      this._refreshBlacklistWords();
      const blacklistButtonRowDiv = containerEl2.createDiv();
      blacklistButtonRowDiv.addClass("blacklist-button-row");
      const blacklistSortBtn = blacklistButtonRowDiv.createEl("button");
      const blSortModes = ["last-added", "a-z", "reverse-a-z"];
      const blSortLabels = {
        "last-added": this.plugin.t("blacklist_sort_label_last-added", "Sort: Last Added"),
        "a-z": this.plugin.t("blacklist_sort_label_a-z", "Sort: A-Z"),
        "reverse-a-z": this.plugin.t("blacklist_sort_label_reverse-a-z", "Sort: Z-A")
      };
      blacklistSortBtn.textContent = blSortLabels[this._blacklistSortMode] || "Sort: Last Added";
      blacklistSortBtn.style.cursor = "pointer";
      blacklistSortBtn.style.flex = "0 0 auto";
      const blacklistSortHandler = async () => {
        const i = blSortModes.indexOf(this._blacklistSortMode);
        const ni = (i + 1) % blSortModes.length;
        this._blacklistSortMode = blSortModes[ni];
        blacklistSortBtn.textContent = blSortLabels[this._blacklistSortMode];
        try {
          this.plugin.settings.blacklistSortMode = this._blacklistSortMode;
          await this.plugin.saveSettings();
        } catch (e) {
        }
        this._refreshBlacklistWords();
      };
      blacklistSortBtn.addEventListener("click", blacklistSortHandler);
      this._cleanupHandlers.push(() => blacklistSortBtn.removeEventListener("click", blacklistSortHandler));
      const blacklistAddBtn = blacklistButtonRowDiv.createEl("button");
      blacklistAddBtn.textContent = this.plugin.t("btn_add_blacklist_word", "+ Add blacklist word");
      blacklistAddBtn.style.cursor = "pointer";
      blacklistAddBtn.style.flex = "1";
      blacklistAddBtn.addClass("mod-cta");
      const blacklistAddHandler = async () => {
        const uid = (() => {
          try {
            return Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (e) {
            return Date.now();
          }
        })();
        const newEntry = { pattern: "", isRegex: false, flags: "", groupedPatterns: null, uid, persistAtEnd: true };
        if (!Array.isArray(this.plugin.settings.blacklistEntries)) this.plugin.settings.blacklistEntries = [];
        this.plugin.settings.blacklistEntries.push(newEntry);
        this._suspendSorting = this._blacklistSortMode === "last-added";
        try {
          this._blacklistNewSet && this._blacklistNewSet.add(uid);
        } catch (e) {
        }
        await this.plugin.saveSettings();
        this._refreshBlacklistWords();
      };
      blacklistAddBtn.addEventListener("click", blacklistAddHandler);
      this._cleanupHandlers.push(() => blacklistAddBtn.removeEventListener("click", blacklistAddHandler));
      const blacklistAddRegexBtn = blacklistButtonRowDiv.createEl("button");
      blacklistAddRegexBtn.textContent = this.plugin.t("btn_add_blacklist_regex", "+ Add blacklist regex");
      blacklistAddRegexBtn.style.cursor = "pointer";
      blacklistAddRegexBtn.style.flex = "1";
      blacklistAddRegexBtn.addClass("mod-cta");
      blacklistAddRegexBtn.style.display = this.plugin.settings.enableRegexSupport ? "" : "none";
      const blacklistAddRegexHandler = () => {
        try {
          const onAdded = (entry) => {
            try {
              if (entry && entry.uid) {
                this._blacklistNewSet && this._blacklistNewSet.add(entry.uid);
              }
              this._refreshBlacklistWords();
            } catch (e) {
            }
          };
          new BlacklistRegexTesterModal(this.app, this.plugin, onAdded).open();
        } catch (e) {
        }
      };
      blacklistAddRegexBtn.addEventListener("click", blacklistAddRegexHandler);
      this._cleanupHandlers.push(() => blacklistAddRegexBtn.removeEventListener("click", blacklistAddRegexHandler));
      const blacklistPresetsBtn = blacklistButtonRowDiv.createEl("button");
      blacklistPresetsBtn.textContent = this.plugin.t("btn_presets", "Presets");
      blacklistPresetsBtn.style.cursor = "pointer";
      blacklistPresetsBtn.style.flex = "0 0 auto";
      const blacklistPresetsHandler = () => {
        new PresetModal(this.app, this.plugin, async (preset) => {
          if (!preset) return;
          const newEntry = { pattern: preset.pattern, isRegex: true, flags: preset.flags || "", groupedPatterns: null, presetLabel: preset.label, persistAtEnd: true, targetElement: preset.targetElement };
          try {
            newEntry.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
          } catch (e) {
            newEntry.uid = Date.now();
          }
          if (!Array.isArray(this.plugin.settings.blacklistEntries)) this.plugin.settings.blacklistEntries = [];
          this.plugin.settings.blacklistEntries.push(newEntry);
          this._suspendSorting = this._blacklistSortMode === "last-added";
          try {
            this._blacklistNewSet && newEntry && newEntry.uid && this._blacklistNewSet.add(newEntry.uid);
          } catch (e) {
          }
          await this.plugin.saveSettings();
          this._refreshBlacklistWords();
        }).open();
      };
      blacklistPresetsBtn.addEventListener("click", blacklistPresetsHandler);
      this._cleanupHandlers.push(() => blacklistPresetsBtn.removeEventListener("click", blacklistPresetsHandler));
      const deleteAllBlacklistSetting = new Setting(containerEl2).addExtraButton((b) => b.setIcon("trash").setTooltip(this.plugin.t("tooltip_delete_all_blacklist", "Delete all blacklisted words/patterns")).onClick(async () => {
        new ConfirmationModal(this.app, this.plugin, this.plugin.t("confirm_delete_all_blacklist_title", "Delete all blacklisted words"), this.plugin.t("confirm_delete_all_blacklist_desc", "Are you sure you want to delete all blacklist entries? You can't undo this!"), async () => {
          this.plugin.settings.blacklistEntries = [];
          await this.plugin.saveSettings();
          this._refreshBlacklistWords();
        }).open();
      }));
      try {
        deleteAllBlacklistSetting.settingEl.classList.add("act-delete-groups-setting");
      } catch (_) {
      }
      containerEl2.createEl("h3", { text: this.plugin.t("blacklist_grouped_entries_header", "Blacklist Group Entries") });
      new Setting(containerEl2).setName(this.plugin.t("show_blacklist_groups_in_commands", "Show blacklist groups in commands")).setDesc(this.plugin.t("show_blacklist_groups_in_commands_desc", "When enabled, blacklist groups appear in the command palette with Activate/Deactivate commands.")).addToggle((t) => t.setValue(!!this.plugin.settings.showBlacklistGroupsInCommands).onChange(async (v) => {
        this.plugin.settings.showBlacklistGroupsInCommands = !!v;
        await this.plugin.saveSettings();
        this.plugin.reregisterCommandsWithLanguage();
      }));
      const blGroupSearchContainer = containerEl2.createDiv();
      try {
        blGroupSearchContainer.addClass("act-search-container");
      } catch (e) {
        try {
          blGroupSearchContainer.classList.add("act-search-container");
        } catch (_) {
        }
      }
      blGroupSearchContainer.style.margin = "8px 0";
      blGroupSearchContainer.style.display = "flex";
      blGroupSearchContainer.style.alignItems = "center";
      blGroupSearchContainer.style.gap = "8px";
      const blGroupSearch = blGroupSearchContainer.createEl("input", { type: "text" });
      try {
        blGroupSearch.addClass("act-search-input");
      } catch (e) {
        try {
          blGroupSearch.classList.add("act-search-input");
        } catch (_) {
        }
      }
      blGroupSearch.placeholder = this.plugin.t("search_blacklist_groups_placeholder", "Search blacklist groups\u2026");
      blGroupSearch.style.flex = "1 1 auto";
      blGroupSearch.style.padding = "6px";
      blGroupSearch.style.border = "1px solid var(--background-modifier-border)";
      blGroupSearch.addEventListener("input", () => {
        this._blacklistGroupSearch = blGroupSearch.value || "";
        this._refreshBlacklistGroups();
      });
      const blGroupIcon = blGroupSearchContainer.createDiv();
      try {
        blGroupIcon.addClass("act-search-icon");
      } catch (e) {
        try {
          blGroupIcon.classList.add("act-search-icon");
        } catch (_) {
        }
      }
      const blGroupsContainer = containerEl2.createDiv();
      blGroupsContainer.addClass("act-blacklist-groups-container");
      this._blacklistGroupsContainer = blGroupsContainer;
      this._refreshBlacklistGroups();
      const blGroupButtonsContainer = containerEl2.createDiv();
      blGroupButtonsContainer.style.display = "flex";
      blGroupButtonsContainer.style.gap = "8px";
      blGroupButtonsContainer.style.marginTop = "10px";
      blGroupButtonsContainer.style.justifyContent = "space-between";
      const btnCreateBlacklistGroup = blGroupButtonsContainer.createEl("button", { text: this.plugin.t("btn_create_new_blacklist_group", "+ Create New Blacklist Group") });
      btnCreateBlacklistGroup.addClass("mod-cta");
      btnCreateBlacklistGroup.onclick = async () => {
        if (!this.plugin.settings.blacklistEntryGroups) this.plugin.settings.blacklistEntryGroups = [];
        const newGroup = {
          active: true,
          name: "",
          entries: []
        };
        try {
          newGroup.uid = Date.now().toString(36) + Math.random().toString(36).slice(2);
        } catch (_) {
        }
        this.plugin.settings.blacklistEntryGroups.push(newGroup);
        await this.plugin.saveSettings();
        try {
          new EditBlacklistGroupModal(this.app, this.plugin, newGroup, async (updatedGroup) => {
            const idx = this.plugin.settings.blacklistEntryGroups.findIndex((g) => g && g.uid === newGroup.uid);
            if (idx !== -1) {
              this.plugin.settings.blacklistEntryGroups[idx] = updatedGroup;
            }
            await this.plugin.saveSettings();
            if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
            this._refreshBlacklistGroups();
          }, async (groupToDelete) => {
            const actualIndex = this.plugin.settings.blacklistEntryGroups.findIndex((g) => g && g.uid === groupToDelete.uid);
            if (actualIndex !== -1) {
              this.plugin.settings.blacklistEntryGroups.splice(actualIndex, 1);
            }
            await this.plugin.saveSettings();
            if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
            this._refreshBlacklistGroups();
          }).open();
        } catch (_) {
          this._refreshBlacklistGroups();
        }
      };
      new Setting(blGroupButtonsContainer).addExtraButton((b) => b.setIcon("trash").setTooltip(this.plugin.t("tooltip_delete_all_blacklist_groups", "Delete all Blacklist Groups")).onClick(async () => {
        new ConfirmationModal(this.app, this.plugin, this.plugin.t("confirm_delete_all_blacklist_groups_title", "Delete All Blacklist Groups"), this.plugin.t("confirm_delete_all_blacklist_groups_desc", "Are you sure you want to delete ALL blacklist groups? This cannot be undone!"), async () => {
          this.plugin.settings.blacklistEntryGroups = [];
          await this.plugin.saveSettings();
          if (this.plugin.settings.showBlacklistGroupsInCommands) this.plugin.reregisterCommandsWithLanguage();
          this._refreshBlacklistGroups();
        }).open();
      })).then((setting) => {
        setting.settingEl.classList.add("act-delete-groups-setting");
      });
    }
    if (this._activeTab === "file-folder-rules") {
      containerEl2.createEl("h3", { text: this.plugin.t("file_folder_rules_header", "File & Folder Coloring Rules") });
      const desc = containerEl2.createEl("p", { text: this.plugin.t("file_folder_rules_desc", "Control coloring with name matching, exact paths, or regex patterns. Leave an empty exclude entry to disable coloring vault-wide.") });
      desc.addClass("act-desc");
      desc.style.marginTop = "-7px";
      const prSearchContainer = containerEl2.createDiv();
      try {
        prSearchContainer.addClass("act-search-container");
      } catch (e) {
        try {
          prSearchContainer.classList.add("act-search-container");
        } catch (_) {
        }
      }
      prSearchContainer.style.margin = "8px 0";
      prSearchContainer.style.display = "flex";
      prSearchContainer.style.alignItems = "center";
      prSearchContainer.style.gap = "8px";
      const prSearch = prSearchContainer.createEl("input", { type: "text" });
      try {
        prSearch.addClass("act-search-input");
      } catch (e) {
        try {
          prSearch.classList.add("act-search-input");
        } catch (_) {
        }
      }
      prSearch.placeholder = this.plugin.t("search_file_folder_rules_placeholder", "Search file/folder rules\u2026");
      prSearch.style.flex = "1 1 auto";
      prSearch.style.padding = "6px";
      prSearch.style.border = "1px solid var(--background-modifier-border)";
      const prIcon = prSearchContainer.createDiv();
      try {
        prIcon.addClass("act-search-icon");
      } catch (e) {
        try {
          prIcon.classList.add("act-search-icon");
        } catch (_) {
        }
      }
      const prSearchHandler = () => {
        this._pathRulesSearchQuery = String(prSearch.value || "").trim().toLowerCase();
        try {
          this._refreshPathRules();
        } catch (e) {
        }
      };
      prSearch.addEventListener("input", prSearchHandler);
      prSearch.addEventListener("click", prSearchHandler);
      this._cleanupHandlers.push(() => prSearch.removeEventListener("input", prSearchHandler));
      const prLimitInput = prSearchContainer.createEl("input", { type: "text" });
      prLimitInput.value = String(this.plugin.settings?.pathSearchLimit ?? 0);
      prLimitInput.placeholder = this.plugin.t("limit_input_placeholder", "limit");
      prLimitInput.title = this.plugin.t("limit_input_tooltip", "0=all; number=last N; in=include; ex=exclude; sw=starts; ew=ends; e=exact");
      prLimitInput.style.width = "64px";
      prLimitInput.style.padding = "6px";
      prLimitInput.style.border = "1px solid var(--background-modifier-border)";
      prLimitInput.style.borderRadius = "var(--input-radius)";
      const prLimitHandler = () => {
        const raw = String(prLimitInput.value || "").trim().toLowerCase();
        const parts = raw.split(/\s+/).filter(Boolean);
        const numPart = parts.find((p) => /^\d+$/.test(p));
        const num = numPart ? parseInt(numPart, 10) : NaN;
        this._pathLimit = !isNaN(num) && num >= 0 ? num : 0;
        this._pathModeOnly = null;
        for (const tok of parts) {
          if (tok === "in") this._pathModeOnly = "include";
          else if (tok === "ex") this._pathModeOnly = "exclude";
        }
        try {
          this.plugin.settings.pathSearchLimit = this._pathLimit;
          this.debouncedSaveSettings();
        } catch (e) {
        }
        this._pathSearchMatch = "contains";
        for (const tok of parts) {
          if (tok === "sw") this._pathSearchMatch = "starts";
          else if (tok === "ew") this._pathSearchMatch = "ends";
          else if (tok === "e") this._pathSearchMatch = "exact";
        }
        try {
          this._refreshPathRules();
        } catch (e) {
        }
      };
      prLimitInput.addEventListener("input", prLimitHandler);
      this._cleanupHandlers.push(() => prLimitInput.removeEventListener("input", prLimitHandler));
      this._pathRulesContainer = containerEl2.createDiv();
      this._pathRulesContainer.addClass("path-rules-list");
      this._refreshPathRules();
      const pathBtnRow = containerEl2.createDiv();
      pathBtnRow.addClass("path-button-row");
      const pathSortBtn = pathBtnRow.createEl("button");
      const pathSortModes = ["last-added", "a-z", "reverse-a-z", "mode", "type"];
      const pathSortLabels = { "last-added": "Sort: Last Added", "a-z": "Sort: A-Z", "reverse-a-z": "Sort: Z-A", "mode": "Sort: Mode", "type": "Sort: Type" };
      pathSortBtn.textContent = this.plugin.t("path_sort_label_" + (this._pathSortMode || "last-added"), pathSortLabels[this._pathSortMode] || "Sort: Last Added");
      pathSortBtn.style.cursor = "pointer";
      pathSortBtn.style.flex = "0 0 auto";
      const pathSortHandler = async () => {
        const i = pathSortModes.indexOf(this._pathSortMode);
        const ni = (i + 1) % pathSortModes.length;
        this._pathSortMode = pathSortModes[ni];
        pathSortBtn.textContent = this.plugin.t("path_sort_label_" + (this._pathSortMode || "last-added"), pathSortLabels[this._pathSortMode] || "Sort: Last Added");
        try {
          this.plugin.settings.pathSortMode = this._pathSortMode;
          await this.plugin.saveSettings();
        } catch (e) {
        }
        this._suspendSorting = false;
        this._refreshPathRules();
      };
      pathSortBtn.addEventListener("click", pathSortHandler);
      this._cleanupHandlers.push(() => pathSortBtn.removeEventListener("click", pathSortHandler));
      const pathAddBtn = pathBtnRow.createEl("button");
      pathAddBtn.textContent = this.plugin.t("btn_add_file_folder_rule", "+ Add file/folder rule");
      pathAddBtn.style.cursor = "pointer";
      pathAddBtn.style.flex = "1";
      pathAddBtn.addClass("mod-cta");
      const pathAddHandler = async () => {
        const newEntry = { path: "", mode: "include", matchType: "has-name" };
        if (!Array.isArray(this.plugin.settings.pathRules)) this.plugin.settings.pathRules = [];
        this.plugin.settings.pathRules.push(newEntry);
        this._suspendSorting = this._pathSortMode === "last-added";
        await this.plugin.saveSettings();
        this._refreshPathRules();
      };
      pathAddBtn.addEventListener("click", pathAddHandler);
      this._cleanupHandlers.push(() => pathAddBtn.removeEventListener("click", pathAddHandler));
      new Setting(containerEl2).setName(this.plugin.t("disable_coloring_current_file", "Disable coloring for current file")).setDesc(this.plugin.t("disable_coloring_current_file_desc", "Adds an exclude rule for the active file under File & Folder Coloring Rules.")).addButton((b) => b.setButtonText(this.plugin.t("btn_disable_for_this_file", "Disable for this file")).onClick(async () => {
        const md = this.app.workspace.getActiveFile();
        if (!md) {
          new Notice(this.plugin.t("notice_no_active_file_to_disable", "No active file to disable coloring for."));
          return;
        }
        const p = String(md.path || "");
        if (!Array.isArray(this.plugin.settings.pathRules)) this.plugin.settings.pathRules = [];
        const np = this.plugin.normalizePath(p);
        const exists = this.plugin.settings.pathRules.some((r) => r && r.mode === "exclude" && !r.isFolder && this.plugin.normalizePath(String(r.path || "")) === np);
        if (exists) {
          new Notice(this.plugin.t("notice_already_disabled_for_path", `Coloring is already disabled for {path}`, { path: md.path }));
          return;
        }
        this.plugin.settings.pathRules.push({ path: p, mode: "exclude", isFolder: false });
        await this.plugin.saveSettings();
        this._refreshPathRules();
        this._initializedSettingsUI = false;
        try {
          this.display();
        } catch (e) {
        }
        new Notice(this.plugin.t("notice_coloring_disabled_for_path", `Coloring disabled for {path}`, { path: md.path }));
      }));
      this._disabledFilesContainer = containerEl2.createDiv();
      this._refreshDisabledFiles();
    }
    if (this._activeTab === "data") {
      containerEl2.createEl("h2", { text: this.plugin.t("data_export_import_header", "Data Export/Import") });
      new Setting(containerEl2).setName(this.plugin.t("export_plugin_data", "Export plugin data")).setDesc(this.plugin.t("export_plugin_data_desc", "Export settings, words, and rules to a JSON file.")).addButton((b) => b.setButtonText(this.plugin.t("btn_export", "Export")).onClick(async () => {
        try {
          const fname = await this.plugin.exportSettingsToPickedLocation();
          new Notice(this.plugin.t("notice_exported", `Exported: {fname}`, { fname }));
        } catch (e) {
          new Notice(this.plugin.t("notice_export_failed", "Export failed"));
        }
      }));
      new Setting(containerEl2).setName(this.plugin.t("import_plugin_data", "Import plugin data")).setDesc(this.plugin.t("import_plugin_data_desc", "Import settings from a JSON file")).addButton((b) => b.setButtonText(this.plugin.t("btn_import", "Import")).onClick(() => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.addEventListener("change", () => {
          const file = input.files && input.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = async () => {
            try {
              await this.plugin.importSettingsFromJson(String(reader.result || ""));
              this._initializedSettingsUI = false;
              this.display();
              new Notice(this.plugin.t("notice_import_completed", "Import completed"));
            } catch (e) {
              new Notice(this.plugin.t("notice_import_failed", "Import failed"));
            }
          };
          reader.readAsText(file);
        });
        input.click();
      }));
    }
  }
  // Method to focus and/or create a text & background coloring entry with pre-filled text
  async focusTextBgEntry(selectedText) {
    try {
      if (!selectedText || !this.containerEl) return;
      let foundEntry = (Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries : []).find(
        (e) => e && (e.pattern === selectedText || Array.isArray(e.groupedPatterns) && e.groupedPatterns.includes(selectedText))
      );
      let isNewEntry = false;
      if (!foundEntry) {
        isNewEntry = true;
        foundEntry = {
          pattern: selectedText,
          color: "",
          textColor: "currentColor",
          backgroundColor: "",
          isRegex: false,
          flags: "",
          groupedPatterns: null
        };
        if (!Array.isArray(this.plugin.settings.wordEntries)) this.plugin.settings.wordEntries = [];
        this.plugin.settings.wordEntries.push(foundEntry);
        this.plugin.compileTextBgColoringEntries();
        await this.plugin.saveSettings();
        this._initializedSettingsUI = false;
        this.display();
      }
      setTimeout(() => {
        const textBgListDiv = this.containerEl.querySelector(".text-bg-coloring-list");
        if (textBgListDiv) {
          textBgListDiv.scrollIntoView({ behavior: "auto", block: "center" });
          setTimeout(() => {
            const inputs = textBgListDiv.querySelectorAll('input[type="text"]');
            for (const input of inputs) {
              if (input.value.includes(selectedText)) {
                input.focus();
                input.select();
                input.style.borderColor = "var(--color-accent)";
                input.style.boxShadow = "0 0 0 2px var(--color-accent-1)";
                input.style.transition = "border-color 0.2s ease, box-shadow 0.2s ease";
                setTimeout(() => {
                  input.style.borderColor = "var(--background-modifier-border)";
                  input.style.boxShadow = "none";
                }, 3e3);
                break;
              }
            }
          }, 300);
        }
      }, isNewEntry ? 500 : 100);
    } catch (e) {
      debugError("FOCUS_TEXTBG", "Failed to focus text bg entry", e);
    }
  }
};
var ColorPickerModal = class extends Modal {
  constructor(app, plugin, callback, mode = "text", selectedText = "", isQuickOnce = false) {
    super(app);
    this.plugin = plugin;
    this.callback = callback;
    this.mode = mode === "background" || mode === "text-and-background" ? mode : "text";
    this._selectedText = selectedText || "";
    this._eventListeners = [];
    this.isQuickOnce = !!isQuickOnce;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this._eventListeners = [];
    this._hasUserChanges = false;
    const cpm = this.plugin.settings.colorPickerMode || "both";
    const forcedSingle = this.mode === "text" || this.mode === "background";
    const isBoth = !forcedSingle && (cpm === "both" || cpm === "both-bg-left" || cpm === "both-v-text-top" || cpm === "both-v-bg-top");
    const isHorizontalBoth = !forcedSingle && (cpm === "both" || cpm === "both-bg-left");
    const isVerticalBoth = !forcedSingle && (cpm === "both-v-text-top" || cpm === "both-v-bg-top");
    this.modalEl.style.maxWidth = isHorizontalBoth ? "650px" : "480px";
    this.modalEl.style.width = "100%";
    this.modalEl.style.margin = "0";
    this.modalEl.style.padding = "0";
    try {
      this.modalEl.addClass("act-color-picker-modal");
    } catch (e) {
    }
    contentEl.style.padding = "24px";
    contentEl.style.boxSizing = "border-box";
    contentEl.style.display = "grid";
    contentEl.style.gridTemplateColumns = isHorizontalBoth ? "1fr 1fr" : "1fr";
    contentEl.style.columnGap = "10px";
    contentEl.style.rowGap = "10px";
    contentEl.style.alignItems = "stretch";
    try {
      contentEl.addClass("act-color-picker-content");
    } catch (e) {
    }
    const headerRow = contentEl.createDiv();
    headerRow.style.display = "flex";
    headerRow.style.alignItems = "center";
    headerRow.style.gap = "8px";
    headerRow.style.gridColumn = "1 / -1";
    headerRow.style.marginBottom = "16px";
    try {
      headerRow.addClass("act-modal-header-controls");
    } catch (e) {
      try {
        headerRow.classList.add("act-modal-header-controls");
      } catch (_) {
      }
    }
    const h2 = headerRow.createEl("h2", { text: this.plugin.t("pick_color_header", "Pick Color") });
    h2.style.marginTop = "0";
    h2.style.marginBottom = "0px";
    h2.style.flex = "1 1 auto";
    const hideControls = !!this._hideHeaderControls || this.isQuickOnce;
    const groupsRaw = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : [];
    const groups = this.plugin.settings.hideInactiveGroupsInDropdowns ? groupsRaw.filter((g) => g && g.active) : groupsRaw;
    if (!hideControls && groups.length > 0) {
      const groupSelect = headerRow.createEl("select");
      groupSelect.style.padding = "6px";
      groupSelect.style.borderRadius = "4px";
      groupSelect.style.border = "1px solid var(--background-modifier-border)";
      groupSelect.style.textAlign = "center";
      groupSelect.style.maxWidth = "120px";
      try {
        groupSelect.style.setProperty("max-width", "120px", "important");
        groupSelect.style.setProperty("width", "120px", "important");
        groupSelect.style.setProperty("min-width", "120px", "important");
      } catch (e) {
      }
      groupSelect.style.flex = "0 0 auto";
      groupSelect.style.marginLeft = "auto";
      groupSelect.createEl("option", { text: this.plugin.t("default", "Default"), value: "" });
      groups.forEach((g) => {
        groupSelect.createEl("option", { text: String(g?.name || "Unnamed Group"), value: String(g?.uid || "") });
      });
      groupSelect.value = "";
      const groupChange = () => {
        this._selectedGroupUid = groupSelect.value || null;
        this._hasUserChanges = true;
      };
      groupSelect.addEventListener("change", groupChange);
      this._eventListeners.push({ el: groupSelect, event: "change", handler: groupChange });
      this._groupSelect = groupSelect;
    }
    if (!hideControls) {
      const matchSelect = headerRow.createEl("select");
      matchSelect.style.padding = "6px";
      matchSelect.style.borderRadius = "4px";
      matchSelect.style.border = "1px solid var(--background-modifier-border)";
      matchSelect.style.textAlign = "center";
      matchSelect.style.maxWidth = "100px";
      try {
        matchSelect.style.setProperty("max-width", "100px", "important");
        matchSelect.style.setProperty("width", "100px", "important");
        matchSelect.style.setProperty("min-width", "100px", "important");
      } catch (e) {
      }
      matchSelect.style.flex = "0 0 auto";
      matchSelect.innerHTML = `<option value="exact">${this.plugin.t("match_option_exact", "Exact")}</option><option value="contains">${this.plugin.t("match_option_contains", "Contains")}</option><option value="startswith">${this.plugin.t("match_option_starts_with", "Starts with")}</option><option value="endswith">${this.plugin.t("match_option_ends_with", "Ends with")}</option>`;
      this._matchType = this.plugin.settings.partialMatch ? "contains" : "exact";
      matchSelect.value = this._matchType;
      const mtHandler = () => {
        this._matchType = matchSelect.value;
        this._hasUserChanges = true;
      };
      matchSelect.addEventListener("change", mtHandler);
      this._eventListeners.push({ el: matchSelect, event: "change", handler: mtHandler });
      this._matchSelect = matchSelect;
    }
    let editBtn = null;
    if (!hideControls) {
      editBtn = headerRow.createEl("button");
      try {
        setIcon(editBtn, "edit-3");
      } catch (e) {
      }
      editBtn.title = this.plugin.t("edit_entry_header", "Edit Entry");
      editBtn.style.flex = "0 0 auto";
      editBtn.style.display = "flex";
      editBtn.style.alignItems = "center";
      editBtn.style.justifyContent = "center";
      editBtn.style.padding = "6px";
      editBtn.style.borderRadius = "4px";
      editBtn.style.border = "1px solid var(--background-modifier-border)";
      editBtn.style.background = "var(--background-modifier-form-field)";
      editBtn.style.cursor = "pointer";
      editBtn.disabled = true;
    }
    this.selectedTextColor = null;
    this.selectedBgColor = null;
    const previewWrap = contentEl.createDiv();
    previewWrap.style.border = "1px solid var(--background-modifier-border)";
    previewWrap.style.borderRadius = "14px";
    previewWrap.style.padding = "14px";
    previewWrap.style.marginBottom = "0";
    previewWrap.style.display = "flex";
    previewWrap.style.alignItems = "center";
    previewWrap.style.justifyContent = "center";
    previewWrap.style.gridColumn = "1 / -1";
    const preview = previewWrap.createDiv();
    const displayText = String(this._selectedText || this._preFillPattern || this._preFillName || "").trim();
    preview.textContent = displayText ? displayText : this.plugin.t("selected_text_preview", "Selected Text");
    preview.style.display = "inline-block";
    preview.style.borderRadius = "8px";
    preview.style.fontWeight = "600";
    preview.style.backgroundColor = "";
    preview.style.color = "";
    if (this.isQuickOnce) {
      try {
        preview.style.backgroundColor = "";
        preview.style.border = "";
        preview.style.borderTop = "";
        preview.style.borderBottom = "";
        preview.style.borderLeft = "";
        preview.style.borderRight = "";
        preview.style.borderRadius = "";
        preview.style.paddingLeft = "";
        preview.style.paddingRight = "";
      } catch (e) {
      }
    }
    const updateGridCols = () => {
      try {
        if (isHorizontalBoth && window.innerWidth > 768) {
          contentEl.style.gridTemplateColumns = "1fr 1fr";
        } else {
          contentEl.style.gridTemplateColumns = "1fr";
        }
      } catch (e) {
      }
    };
    updateGridCols();
    try {
      window.addEventListener("resize", updateGridCols);
      this._eventListeners.push({ el: window, event: "resize", handler: updateGridCols });
    } catch (e) {
    }
    const defaultSwatches = [
      "#eb3b5a",
      "#fa8231",
      "#e5a216",
      "#20bf6b",
      "#0fb9b1",
      "#2d98da",
      "#3867d6",
      "#5454d0",
      "#8854d0",
      "#b554d0",
      "#e832c1",
      "#e83289",
      "#965b3b",
      "#8392a4"
    ];
    const namedSwatches = Array.isArray(this.plugin.settings.swatches) ? this.plugin.settings.swatches : [];
    const namedColors = namedSwatches.map((sw) => sw && sw.color).filter(Boolean);
    const userCustomSwatches = Array.isArray(this.plugin.settings.userCustomSwatches) ? this.plugin.settings.userCustomSwatches : [];
    const userCustomColors = userCustomSwatches.map((sw) => sw && sw.color).filter((c) => typeof c === "string" && this.plugin.isValidHexColor(c));
    let colorPool = [];
    const replaceDefaults = !!this.plugin.settings.replaceDefaultSwatches;
    if (replaceDefaults && userCustomColors.length > 0) {
      colorPool = userCustomColors;
    } else if (replaceDefaults && namedColors.length > 0 && userCustomColors.length === 0) {
      colorPool = namedColors;
    } else if (!replaceDefaults) {
      colorPool = namedColors.concat(userCustomColors);
    } else {
      colorPool = namedColors;
    }
    const seen = /* @__PURE__ */ new Set();
    const swatchItems = [];
    for (const c of colorPool) {
      if (!c || typeof c !== "string") continue;
      const lc = c.toLowerCase();
      if (!this.plugin.isValidHexColor(c)) continue;
      if (seen.has(lc)) continue;
      seen.add(lc);
      const match = namedSwatches.find((sw) => sw && sw.color && sw.color.toLowerCase() === lc);
      const customMatch = userCustomSwatches.find((sw) => sw && sw.color && sw.color.toLowerCase() === lc);
      swatchItems.push({ color: c, name: customMatch && customMatch.name || match && match.name });
    }
    const panelStates = {};
    const buildPanel = (titleText, type) => {
      const col = contentEl.createDiv();
      col.style.border = "1px solid var(--background-modifier-border)";
      col.style.borderRadius = "12px";
      col.style.padding = "12px";
      col.addClass("color-picker-panel");
      col.style.marginBottom = "0";
      col.style.height = "100%";
      const header = col.createDiv();
      header.style.display = "flex";
      header.style.alignItems = "center";
      header.style.gap = "8px";
      const label = header.createEl("div", { text: titleText });
      label.style.opacity = "0.9";
      const resetBtn = header.createEl("button", { text: this.plugin.t("btn_reset", "Reset") });
      resetBtn.style.marginLeft = "auto";
      resetBtn.style.fontSize = "12px";
      resetBtn.style.padding = "4px 8px";
      const row = col.createDiv();
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "10px";
      row.style.marginTop = "10px";
      row.style.flexWrap = "wrap";
      const colorInput = row.createEl("input", { type: "color" });
      colorInput.title = titleText;
      colorInput.style.width = "44px";
      colorInput.style.height = "44px";
      colorInput.style.border = "none";
      colorInput.style.borderRadius = "12px";
      colorInput.style.cursor = "pointer";
      colorInput.value = "#000000";
      const hex = row.createEl("input", { type: "text" });
      hex.title = titleText;
      hex.style.flex = "1";
      hex.style.padding = "8px";
      hex.style.borderRadius = "8px";
      hex.style.border = "1px solid var(--background-modifier-border)";
      hex.style.width = "120px";
      hex.placeholder = "#000000";
      hex.value = "";
      const grid = col.createDiv();
      grid.title = titleText;
      grid.addClass("color-swatch-grid");
      const apply = (val) => {
        if (type === "text") {
          this.selectedTextColor = val;
          preview.style.color = val;
          try {
            preview.style.setProperty("--highlight-color", val);
          } catch (e) {
          }
          this._hasUserChanges = true;
        } else {
          this.selectedBgColor = val;
          preview.style.border = "";
          preview.style.borderTop = "";
          preview.style.borderBottom = "";
          preview.style.borderLeft = "";
          preview.style.borderRight = "";
          if (this.isQuickOnce) {
            if (this.plugin.settings.quickHighlightUseGlobalStyle) {
              const rgba = this.plugin.hexToRgba(val, this.plugin.settings.backgroundOpacity ?? 25);
              const radius = this.plugin.settings.highlightBorderRadius ?? 8;
              const pad = this.plugin.settings.highlightHorizontalPadding ?? 4;
              const vpad = this.plugin.settings.highlightVerticalPadding ?? 0;
              preview.style.backgroundColor = rgba;
              preview.style.borderRadius = radius + "px";
              preview.style.paddingLeft = preview.style.paddingRight = pad + "px";
              try {
                preview.style.setProperty("padding-top", vpad + "px");
                preview.style.setProperty("padding-bottom", vpad + "px");
              } catch (e) {
                preview.style.paddingTop = preview.style.paddingBottom = vpad + "px";
              }
              if (this.plugin.settings.enableBoxDecorationBreak ?? true) {
                preview.style.boxDecorationBreak = "clone";
                preview.style.WebkitBoxDecorationBreak = "clone";
              }
              this.plugin.applyBorderStyleToElement(preview, null, val);
            } else if (this.plugin.settings.quickHighlightStyleEnable) {
              const hexWithAlpha = this.plugin.hexToHexWithAlpha(val, this.plugin.settings.quickHighlightOpacity ?? 25);
              const radius = this.plugin.settings.quickHighlightBorderRadius ?? 8;
              const pad = this.plugin.settings.quickHighlightHorizontalPadding ?? 4;
              const vpad = this.plugin.settings.quickHighlightVerticalPadding ?? 0;
              preview.style.backgroundColor = hexWithAlpha;
              preview.style.borderRadius = radius + "px";
              preview.style.paddingLeft = preview.style.paddingRight = pad + "px";
              try {
                preview.style.setProperty("padding-top", vpad + "px");
                preview.style.setProperty("padding-bottom", vpad + "px");
              } catch (e) {
                preview.style.paddingTop = preview.style.paddingBottom = vpad + "px";
              }
              const borderCss = this.plugin.generateOnceBorderStyle(val);
              try {
                preview.style.cssText += borderCss;
              } catch (e) {
              }
            } else {
              const rgba = this.plugin.hexToRgba(val, 25);
              preview.style.backgroundColor = rgba;
              preview.style.borderRadius = "";
              preview.style.paddingLeft = preview.style.paddingRight = "";
              preview.style.paddingTop = preview.style.paddingBottom = "";
            }
            this._hasUserChanges = true;
          } else {
            const op = matchedEntry && typeof matchedEntry.backgroundOpacity === "number" ? matchedEntry.backgroundOpacity : this.plugin.settings.backgroundOpacity ?? 25;
            const rgba = this.plugin.hexToRgba(val, op);
            preview.style.backgroundColor = rgba;
            this.plugin.applyBorderStyleToElement(preview, null, val, matchedEntry);
            const hPad = matchedEntry && typeof matchedEntry.highlightHorizontalPadding === "number" ? matchedEntry.highlightHorizontalPadding : this.plugin.settings.highlightHorizontalPadding ?? 4;
            const vPad = matchedEntry && typeof matchedEntry.highlightVerticalPadding === "number" ? matchedEntry.highlightVerticalPadding : this.plugin.settings.highlightVerticalPadding ?? 0;
            const radius = matchedEntry && typeof matchedEntry.highlightBorderRadius === "number" ? matchedEntry.highlightBorderRadius : this.plugin.settings.highlightBorderRadius ?? 8;
            preview.style.paddingLeft = preview.style.paddingRight = hPad + "px";
            try {
              preview.style.setProperty("padding-top", vPad + "px");
              preview.style.setProperty("padding-bottom", vPad + "px");
            } catch (e) {
              preview.style.paddingTop = preview.style.paddingBottom = vPad + "px";
            }
            preview.style.borderRadius = radius + "px";
            if (this.plugin.settings.enableBoxDecorationBreak ?? true) {
              preview.style.boxDecorationBreak = "clone";
              preview.style.WebkitBoxDecorationBreak = "clone";
            }
            this._hasUserChanges = true;
          }
        }
        hex.value = val;
        colorInput.value = val;
      };
      const colorChange = () => {
        const v = colorInput.value;
        apply(v);
      };
      colorInput.addEventListener("input", colorChange);
      this._eventListeners.push({ el: colorInput, event: "input", handler: colorChange });
      colorInput.addEventListener("change", colorChange);
      this._eventListeners.push({ el: colorInput, event: "change", handler: colorChange });
      const hexChange = () => {
        let v = hex.value.trim();
        if (!v.startsWith("#")) v = "#" + v;
        if (/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(v)) {
          apply(v);
        } else {
          new Notice(this.plugin.t("notice_invalid_hex_format", "Invalid hex color format. Use #RRGGBB or #RGB."));
        }
      };
      hex.addEventListener("change", hexChange);
      this._eventListeners.push({ el: hex, event: "change", handler: hexChange });
      const resetHandler = () => {
        if (type === "text") {
          this.selectedTextColor = null;
          preview.style.color = "";
        } else {
          this.selectedBgColor = null;
          preview.style.backgroundColor = "";
          preview.style.border = "";
          preview.style.borderTop = "";
          preview.style.borderBottom = "";
          preview.style.borderLeft = "";
          preview.style.borderRight = "";
        }
        hex.value = "";
        colorInput.value = "#000000";
        this._hasUserChanges = true;
      };
      resetBtn.addEventListener("click", resetHandler);
      this._eventListeners.push({ el: resetBtn, event: "click", handler: resetHandler });
      swatchItems.forEach((item) => {
        const btn = grid.createEl("button");
        btn.style.backgroundColor = item.color;
        btn.style.width = "100%";
        btn.style.aspectRatio = "1 / 1";
        btn.style.minWidth = "44px";
        btn.style.minHeight = "44px";
        btn.style.setProperty("border", "transparent", "important");
        btn.style.borderRadius = "12px";
        btn.style.cursor = "pointer";
        btn.style.opacity = "1";
        btn.setAttr("title", item.name || item.color);
        const clickHandler = () => {
          apply(item.color);
        };
        btn.addEventListener("click", clickHandler);
        this._eventListeners.push({ el: btn, event: "click", handler: clickHandler });
      });
      panelStates[type] = { hex, colorInput };
      return col;
    };
    let lastPanelEl = null;
    if (this.mode === "text") {
      lastPanelEl = buildPanel(this.plugin.t("text_color_title", "Text Color"), "text");
    } else if (this.mode === "background") {
      lastPanelEl = buildPanel(this.plugin.t("highlight_color_title", "Highlight Color"), "background");
    } else {
      if (cpm === "text") {
        lastPanelEl = buildPanel(this.plugin.t("text_color_title", "Text Color"), "text");
      } else if (cpm === "background") {
        lastPanelEl = buildPanel(this.plugin.t("highlight_color_title", "Highlight Color"), "background");
      } else if (cpm === "both-v-bg-top") {
        buildPanel(this.plugin.t("highlight_color_title", "Highlight Color"), "background");
        lastPanelEl = buildPanel(this.plugin.t("text_color_title", "Text Color"), "text");
      } else if (cpm === "both-v-text-top") {
        buildPanel(this.plugin.t("text_color_title", "Text Color"), "text");
        lastPanelEl = buildPanel(this.plugin.t("highlight_color_title", "Highlight Color"), "background");
      } else if (cpm === "both-bg-left") {
        buildPanel(this.plugin.t("highlight_color_title", "Highlight Color"), "background");
        lastPanelEl = buildPanel(this.plugin.t("text_color_title", "Text Color"), "text");
      } else {
        buildPanel(this.plugin.t("text_color_title", "Text Color"), "text");
        lastPanelEl = buildPanel(this.plugin.t("highlight_color_title", "Highlight Color"), "background");
      }
    }
    const s = this._selectedText || "";
    let initText = null;
    let initBg = null;
    let existingStyle = null;
    let matchedEntry = null;
    let matchedGroupUid = null;
    let matchedMatchType = null;
    const caseSensitive = !!this.plugin.settings.caseSensitive;
    const eq = (a, b) => caseSensitive ? String(a) === String(b) : String(a).toLowerCase() === String(b).toLowerCase();
    let allEntries = Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries.map((e) => Object.assign({}, e, { _groupUid: null })) : [];
    if (Array.isArray(this.plugin.settings.wordEntryGroups)) {
      this.plugin.settings.wordEntryGroups.forEach((g) => {
        if (g && g.active && Array.isArray(g.entries)) {
          g.entries.forEach((e) => {
            allEntries.push(Object.assign({}, e, { _groupUid: g.uid }));
          });
        }
      });
    }
    for (const e of allEntries) {
      if (!e || e.isRegex) continue;
      const entryMatchType = (e.matchType || "").toLowerCase();
      const a = caseSensitive ? String(s) : String(s).toLowerCase();
      const b = caseSensitive ? String(e.pattern || "") : String(e.pattern || "").toLowerCase();
      let matches = false;
      if (entryMatchType === "exact") {
        matches = eq(e.pattern || "", s) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq(p, s));
      } else if (entryMatchType === "startswith") {
        matches = b && a.startsWith(b);
      } else if (entryMatchType === "endswith") {
        matches = b && a.endsWith(b);
      } else if (entryMatchType === "contains") {
        matches = b && a.includes(b);
      } else {
        const literalMatch = eq(e.pattern || "", s) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq(p, s));
        if (!literalMatch && this.plugin.settings.partialMatch && !e.isRegex) {
          matches = b && a.includes(b);
        } else if (!literalMatch && !this.plugin.settings.partialMatch) {
          matches = false;
        } else {
          matches = literalMatch;
        }
      }
      if (!matches) continue;
      if (e.backgroundColor) {
        if (e.textColor && e.textColor !== "currentColor" && this.plugin.isValidHexColor(e.textColor)) initText = e.textColor;
        if (this.plugin.isValidHexColor(e.backgroundColor)) initBg = e.backgroundColor;
        existingStyle = e.styleType || (e.textColor && e.textColor !== "currentColor" && e.backgroundColor ? "both" : e.backgroundColor ? "highlight" : "text");
        matchedGroupUid = e._groupUid || null;
        matchedMatchType = e.matchType || matchedMatchType;
        matchedEntry = e;
        break;
      } else if (e.color && this.plugin.isValidHexColor(e.color)) {
        initText = e.color;
        existingStyle = existingStyle || "text";
        matchedGroupUid = e._groupUid || null;
        matchedMatchType = e.matchType || matchedMatchType;
        matchedEntry = e;
        break;
      }
    }
    if (!initText && this.plugin.settings.enableRegexSupport) {
      for (const e of allEntries) {
        if (!e || !e.isRegex) continue;
        try {
          const re = new RegExp(e.pattern, e.flags || "");
          if (re.test(s)) {
            if (e.backgroundColor) {
              if (e.textColor && e.textColor !== "currentColor" && this.plugin.isValidHexColor(e.textColor)) initText = e.textColor;
              if (this.plugin.isValidHexColor(e.backgroundColor)) initBg = e.backgroundColor;
              existingStyle = e.styleType || (e.textColor && e.textColor !== "currentColor" && e.backgroundColor ? "both" : e.backgroundColor ? "highlight" : "text");
            } else if (e.color && this.plugin.isValidHexColor(e.color)) {
              initText = e.color;
              existingStyle = existingStyle || "text";
            }
            matchedGroupUid = e._groupUid || null;
            matchedMatchType = e.matchType || matchedMatchType;
            matchedEntry = e;
            break;
          }
        } catch (err) {
        }
      }
    }
    this._selectedGroupUid = matchedGroupUid || null;
    if (this._groupSelect) {
      this._groupSelect.value = this._selectedGroupUid || "";
    }
    if (this._matchSelect) {
      this._matchType = matchedMatchType || (this.plugin.settings.partialMatch ? "contains" : "exact");
      this._matchSelect.value = this._matchType;
    }
    if (editBtn) {
      let originalEntry = null;
      if (matchedEntry) {
        try {
          const word = this._selectedText || "";
          const caseSensitive2 = !!this.plugin.settings.caseSensitive;
          const eq2 = (a, b) => caseSensitive2 ? String(a) === String(b) : String(a).toLowerCase() === String(b).toLowerCase();
          if (matchedGroupUid) {
            const group = (Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : []).find((g) => g && g.uid === matchedGroupUid);
            if (group && Array.isArray(group.entries)) {
              originalEntry = group.entries.find((e) => {
                if (!e) return false;
                if (e.isRegex && this.plugin.settings.enableRegexSupport) {
                  try {
                    const re = new RegExp(e.pattern, e.flags || "");
                    return re.test(word);
                  } catch (_) {
                    return false;
                  }
                }
                return eq2(e.pattern || "", word) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word));
              }) || null;
            }
          } else {
            const arr = Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries : [];
            originalEntry = arr.find((e) => {
              if (!e) return false;
              if (e.isRegex && this.plugin.settings.enableRegexSupport) {
                try {
                  const re = new RegExp(e.pattern, e.flags || "");
                  return re.test(word);
                } catch (_) {
                  return false;
                }
              }
              return eq2(e.pattern || "", word) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word));
            }) || null;
          }
        } catch (_) {
          originalEntry = null;
        }
      }
      editBtn.disabled = false;
      const editHandler = () => {
        try {
          let entryToEdit = originalEntry;
          if (!entryToEdit) {
            const ts = this.selectedTextColor;
            const bs = this.selectedBgColor;
            const textSelected = ts && this.plugin.isValidHexColor(ts);
            const bgSelected = bs && this.plugin.isValidHexColor(bs);
            const mt = this._matchType || (this.plugin.settings.partialMatch ? "contains" : "exact");
            if (textSelected && bgSelected) {
              entryToEdit = {
                pattern: this._selectedText || "",
                color: "",
                textColor: ts,
                backgroundColor: bs,
                isRegex: false,
                flags: "",
                styleType: "both",
                matchType: mt,
                uid: Date.now().toString(36) + Math.random().toString(36).slice(2),
                _isNewFromPickModal: true,
                _preselectedGroupUid: this._selectedGroupUid || null,
                _originalState: {
                  pattern: this._selectedText || "",
                  color: "",
                  textColor: ts,
                  backgroundColor: bs,
                  isRegex: false,
                  flags: "",
                  styleType: "both",
                  matchType: mt
                }
              };
            } else if (textSelected) {
              entryToEdit = {
                pattern: this._selectedText || "",
                color: ts,
                textColor: null,
                backgroundColor: null,
                isRegex: false,
                flags: "",
                styleType: "text",
                matchType: mt,
                uid: Date.now().toString(36) + Math.random().toString(36).slice(2),
                _isNewFromPickModal: true,
                _preselectedGroupUid: this._selectedGroupUid || null,
                _originalState: {
                  pattern: this._selectedText || "",
                  color: ts,
                  textColor: null,
                  backgroundColor: null,
                  isRegex: false,
                  flags: "",
                  styleType: "text",
                  matchType: mt
                }
              };
            } else if (bgSelected) {
              entryToEdit = {
                pattern: this._selectedText || "",
                color: "",
                textColor: "currentColor",
                backgroundColor: bs,
                isRegex: false,
                flags: "",
                styleType: "highlight",
                matchType: mt,
                uid: Date.now().toString(36) + Math.random().toString(36).slice(2),
                _isNewFromPickModal: true,
                _preselectedGroupUid: this._selectedGroupUid || null,
                _originalState: {
                  pattern: this._selectedText || "",
                  color: "",
                  textColor: "currentColor",
                  backgroundColor: bs,
                  isRegex: false,
                  flags: "",
                  styleType: "highlight",
                  matchType: mt
                }
              };
            } else {
              entryToEdit = {
                pattern: this._selectedText || "",
                color: "",
                textColor: null,
                backgroundColor: null,
                isRegex: false,
                flags: "",
                styleType: "text",
                matchType: mt,
                uid: Date.now().toString(36) + Math.random().toString(36).slice(2),
                _isNewFromPickModal: true,
                _preselectedGroupUid: this._selectedGroupUid || null,
                _originalState: {
                  pattern: this._selectedText || "",
                  color: "",
                  textColor: null,
                  backgroundColor: null,
                  isRegex: false,
                  flags: "",
                  styleType: "text",
                  matchType: mt
                }
              };
            }
          }
          const onSaved = async () => {
            try {
              await this.plugin.saveSettings();
              this.plugin.compileWordEntries();
              this.plugin.reconfigureEditorExtensions();
              this.plugin.forceRefreshAllEditors();
              this.plugin.forceRefreshAllReadingViews();
              this.plugin.triggerActiveDocumentRerender();
            } catch (_) {
            }
          };
          new EditEntryModal(this.app, this.plugin, entryToEdit, onSaved, this, true).open();
        } catch (_) {
        }
      };
      editBtn.addEventListener("click", editHandler);
      this._eventListeners.push({ el: editBtn, event: "click", handler: editHandler });
    }
    if (this._preFillTextColor && this.plugin.isValidHexColor(this._preFillTextColor)) {
      initText = this._preFillTextColor;
      existingStyle = existingStyle || "text";
    }
    if (this._preFillBgColor && this.plugin.isValidHexColor(this._preFillBgColor)) {
      initBg = this._preFillBgColor;
      existingStyle = existingStyle || (initText ? "both" : "highlight");
    }
    const tp = panelStates["text"];
    const bp = panelStates["background"];
    if (!existingStyle) {
      existingStyle = initText && initBg ? "both" : initBg ? "highlight" : initText ? "text" : this.mode;
    }
    if (!forcedSingle) {
      this.mode = existingStyle === "highlight" ? "background" : existingStyle === "both" ? "text-and-background" : "text";
    }
    if (initText && tp && this.mode !== "background") {
      preview.style.color = initText;
      tp.hex.value = initText;
      tp.colorInput.value = initText;
      this.selectedTextColor = initText;
    }
    const applyPrefill = (val, type) => {
      if (type === "text") {
        if (tp && val) {
          tp.colorInput.value = val;
          tp.hex.value = val;
          this.selectedTextColor = val;
          preview.style.color = val;
          try {
            preview.style.setProperty("--highlight-color", val);
          } catch (e) {
          }
        }
      } else if (type === "background") {
        if (bp && val) {
          bp.colorInput.value = val;
          bp.hex.value = val;
          this.selectedBgColor = val;
          const op = matchedEntry && typeof matchedEntry.backgroundOpacity === "number" ? matchedEntry.backgroundOpacity : this.plugin.settings.backgroundOpacity ?? 25;
          const rgba = this.plugin.hexToRgba(val, op);
          preview.style.backgroundColor = rgba;
          const borderSrc = this._preFillBorderColor && this.plugin.isValidHexColor(this._preFillBorderColor) ? this._preFillBorderColor : initText || this.selectedTextColor;
          this.plugin.applyBorderStyleToElement(preview, borderSrc, val, matchedEntry);
        }
      }
    };
    if (initBg && bp && this.mode !== "text") {
      applyPrefill(initBg, "background");
      const hPad = matchedEntry && typeof matchedEntry.highlightHorizontalPadding === "number" ? matchedEntry.highlightHorizontalPadding : this.plugin.settings.highlightHorizontalPadding ?? 4;
      const vPad = matchedEntry && typeof matchedEntry.highlightVerticalPadding === "number" ? matchedEntry.highlightVerticalPadding : this.plugin.settings.highlightVerticalPadding ?? 0;
      const radius = matchedEntry && typeof matchedEntry.highlightBorderRadius === "number" ? matchedEntry.highlightBorderRadius : this.plugin.settings.highlightBorderRadius ?? 8;
      preview.style.paddingLeft = preview.style.paddingRight = hPad + "px";
      try {
        preview.style.setProperty("padding-top", vPad + "px");
        preview.style.setProperty("padding-bottom", vPad + "px");
      } catch (e) {
        preview.style.paddingTop = preview.style.paddingBottom = vPad + "px";
      }
      if (hPad > 0 && radius === 0) {
        preview.style.borderRadius = "0px";
      } else {
        preview.style.borderRadius = radius + "px";
      }
      if (this.plugin.settings.enableBoxDecorationBreak ?? true) {
        preview.style.boxDecorationBreak = "clone";
        preview.style.WebkitBoxDecorationBreak = "clone";
      }
      bp.hex.value = initBg;
      bp.colorInput.value = initBg;
      this.selectedBgColor = initBg;
    }
    const actionRow = contentEl.createDiv();
    actionRow.style.display = "flex";
    actionRow.style.justifyContent = "flex-end";
    actionRow.style.gap = "8px";
    actionRow.style.marginTop = "6px";
    actionRow.style.gridColumn = "1 / -1";
    const submitFn = async () => {
      const textPanel = panelStates["text"];
      const bgPanel = panelStates["background"];
      const textColor = this.selectedTextColor || (textPanel && textPanel.hex.value ? textPanel.hex.value : null);
      const bgColor = this.selectedBgColor || (bgPanel && bgPanel.hex.value ? bgPanel.hex.value : null);
      const textSelected = !!(textColor && this.plugin.isValidHexColor(textColor));
      const bgSelected = !!(bgColor && this.plugin.isValidHexColor(bgColor));
      debugLog("MODAL", "submit", { word: this._selectedText, textSelected, bgSelected, textColor, bgColor });
      const groupsList = Array.isArray(this.plugin.settings.wordEntryGroups) ? this.plugin.settings.wordEntryGroups : [];
      const selectedGroup = groupsList.find((g) => g && g.uid === this._selectedGroupUid);
      const targetArr = selectedGroup ? Array.isArray(selectedGroup.entries) ? selectedGroup.entries : selectedGroup.entries = [] : Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries : this.plugin.settings.wordEntries = [];
      try {
        const fromGroupUid = matchedGroupUid || null;
        const toGroupUid = this._selectedGroupUid || null;
        if (matchedEntry && fromGroupUid !== toGroupUid) {
          const word2 = this._selectedText || "";
          const caseSensitive2 = !!this.plugin.settings.caseSensitive;
          const eq2 = (a, b) => caseSensitive2 ? String(a) === String(b) : String(a).toLowerCase() === String(b).toLowerCase();
          let sourceArr = null;
          if (fromGroupUid) {
            const srcGroup = groupsList.find((g) => g && g.uid === fromGroupUid);
            sourceArr = srcGroup && Array.isArray(srcGroup.entries) ? srcGroup.entries : null;
          } else {
            sourceArr = Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries : null;
          }
          if (sourceArr) {
            let srcIdx = -1;
            for (let i = 0; i < sourceArr.length; i++) {
              const e = sourceArr[i];
              if (!e) continue;
              let match = false;
              if (e.isRegex && this.plugin.settings.enableRegexSupport) {
                try {
                  const re = new RegExp(e.pattern, e.flags || "");
                  match = re.test(word2);
                } catch (_) {
                  match = false;
                }
              } else {
                match = eq2(e.pattern || "", word2) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word2));
              }
              if (match) {
                srcIdx = i;
                break;
              }
            }
            if (srcIdx !== -1) {
              const moved = sourceArr.splice(srcIdx, 1)[0];
              const existsInTarget = targetArr.some((e) => {
                if (!e) return false;
                if (e.isRegex && this.plugin.settings.enableRegexSupport) {
                  try {
                    const re = new RegExp(e.pattern, e.flags || "");
                    return re.test(word2);
                  } catch (_) {
                    return false;
                  }
                }
                return eq2(e.pattern || "", word2) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word2));
              });
              if (!existsInTarget) {
                targetArr.push(moved);
              }
              matchedGroupUid = toGroupUid;
            }
          }
        }
      } catch (_) {
      }
      if (!textSelected && !bgSelected) {
        const word2 = this._selectedText || "";
        const caseSensitive2 = !!this.plugin.settings.caseSensitive;
        const eq2 = (a, b) => caseSensitive2 ? String(a) === String(b) : String(a).toLowerCase() === String(b).toLowerCase();
        for (let i = targetArr.length - 1; i >= 0; i--) {
          const e = targetArr[i];
          if (!e) continue;
          let match = false;
          if (e.isRegex && this.plugin.settings.enableRegexSupport) {
            try {
              const re = new RegExp(e.pattern, e.flags || "");
              match = re.test(word2);
            } catch (err) {
              match = false;
            }
          } else {
            match = eq2(e.pattern || "", word2) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word2));
          }
          if (match) {
            targetArr.splice(i, 1);
            await this.plugin.saveSettings();
            if (selectedGroup) {
              this.plugin.compileWordEntries();
            }
            this.plugin.reconfigureEditorExtensions();
            this.plugin.forceRefreshAllEditors();
            break;
          }
        }
        return;
      }
      const word = this._selectedText || "";
      try {
        if (typeof this.callback === "function") {
          try {
            this.callback(textSelected ? textColor : bgSelected ? bgColor : null, { textColor: textSelected ? textColor : null, backgroundColor: bgSelected ? bgColor : null, word, selectedGroupUid: this._selectedGroupUid || null, matchType: this._matchType || (this.plugin.settings.partialMatch ? "contains" : "exact") });
          } catch (e) {
          }
          return;
        }
        const caseSensitive2 = !!this.plugin.settings.caseSensitive;
        const eq2 = (a, b) => caseSensitive2 ? String(a) === String(b) : String(a).toLowerCase() === String(b).toLowerCase();
        let updated = false;
        if (textSelected && bgSelected) {
          for (let i = 0; i < targetArr.length; i++) {
            const e = targetArr[i];
            if (!e) continue;
            let match = false;
            if (e.isRegex && this.plugin.settings.enableRegexSupport) {
              try {
                const re = new RegExp(e.pattern, e.flags || "");
                match = re.test(word);
              } catch (err) {
                match = false;
              }
            } else {
              match = eq2(e.pattern || "", word) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word));
            }
            if (match) {
              e.textColor = textColor;
              e.backgroundColor = bgColor;
              e.color = "";
              e.styleType = "both";
              debugLog("MODAL", "update both", e);
              updated = true;
              break;
            }
          }
          if (!updated) {
            const newEntry = {
              pattern: word,
              color: "",
              textColor,
              backgroundColor: bgColor,
              isRegex: false,
              flags: "",
              styleType: "both",
              matchType: this._matchType || (this.plugin.settings.partialMatch ? "contains" : "exact")
            };
            if (newEntry.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "strong";
            else if (newEntry.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "em";
            else if (newEntry.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "strong-em";
            targetArr.push(newEntry);
            debugLog("MODAL", "create both", newEntry);
          }
          await this.plugin.saveSettings();
          if (selectedGroup) {
            this.plugin.compileWordEntries();
          } else {
            this.plugin.compileTextBgColoringEntries();
          }
        } else if (textSelected) {
          for (let i = 0; i < targetArr.length; i++) {
            const e = targetArr[i];
            if (!e) continue;
            if (e.isRegex && this.plugin.settings.enableRegexSupport) {
              try {
                const re = new RegExp(e.pattern, e.flags || "");
                if (re.test(word)) {
                  e.color = textColor;
                  e.textColor = null;
                  e.backgroundColor = null;
                  e.styleType = "text";
                  updated = true;
                  if (!e.isRegex) e.matchType = this._matchType || e.matchType || (this.plugin.settings.partialMatch ? "contains" : "exact");
                  break;
                }
              } catch (err) {
              }
            } else {
              if (eq2(e.pattern || "", word)) {
                e.color = textColor;
                e.textColor = null;
                e.backgroundColor = null;
                e.styleType = "text";
                updated = true;
                if (!e.isRegex) e.matchType = this._matchType || e.matchType || (this.plugin.settings.partialMatch ? "contains" : "exact");
                break;
              }
              if (Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word))) {
                e.color = textColor;
                e.textColor = null;
                e.backgroundColor = null;
                e.styleType = "text";
                updated = true;
                if (!e.isRegex) e.matchType = this._matchType || e.matchType || (this.plugin.settings.partialMatch ? "contains" : "exact");
                break;
              }
            }
          }
          if (!updated) {
            if (selectedGroup) {
              const newEntry = { pattern: word, color: textColor, isRegex: false, flags: "", styleType: "text", matchType: this._matchType || (this.plugin.settings.partialMatch ? "contains" : "exact") };
              if (newEntry.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "strong";
              else if (newEntry.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "em";
              else if (newEntry.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "strong-em";
              targetArr.push(newEntry);
              await this.plugin.saveSettings();
              this.plugin.compileWordEntries();
            } else {
              await this.plugin.saveEntry(word, textColor);
              const ne = this.plugin.settings.wordEntries.find((e) => e && e.pattern === word && !e.isRegex);
              if (ne) {
                ne.styleType = "text";
              }
            }
          } else {
            await this.plugin.saveSettings();
            if (selectedGroup) {
              this.plugin.compileWordEntries();
            }
          }
          debugLog("MODAL", "text-only", { word, textColor });
        } else if (bgSelected) {
          const arr = Array.isArray(this.plugin.settings.wordEntries) ? this.plugin.settings.wordEntries : [];
          for (let i = 0; i < arr.length; i++) {
            const e = arr[i];
            if (!e) continue;
            let match = false;
            if (e.isRegex && this.plugin.settings.enableRegexSupport) {
              try {
                const re = new RegExp(e.pattern, e.flags || "");
                match = re.test(word);
              } catch (err) {
                match = false;
              }
            } else {
              match = eq2(e.pattern || "", word) || Array.isArray(e.groupedPatterns) && e.groupedPatterns.some((p) => eq2(p, word));
            }
            if (match) {
              e.backgroundColor = bgColor;
              e.textColor = "currentColor";
              e.color = "";
              e.styleType = "highlight";
              debugLog("MODAL", "update highlight", e);
              updated = true;
              break;
            }
          }
          if (!updated) {
            const newEntry = {
              pattern: word,
              color: "",
              textColor: "currentColor",
              backgroundColor: bgColor,
              isRegex: false,
              flags: "",
              styleType: "highlight",
              matchType: this._matchType || (this.plugin.settings.partialMatch ? "contains" : "exact")
            };
            if (newEntry.pattern === "(\\*\\*|__)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "strong";
            else if (newEntry.pattern === "(\\*|_)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "em";
            else if (newEntry.pattern === "(\\*\\*\\*|___)(?=\\S)([^\\r]*?\\S)\\1") newEntry.targetElement = "strong-em";
            targetArr.push(newEntry);
            debugLog("MODAL", "create highlight", newEntry);
          }
          await this.plugin.saveSettings();
          if (selectedGroup) {
            this.plugin.compileWordEntries();
          } else {
            this.plugin.compileTextBgColoringEntries();
          }
        }
        this.plugin.reconfigureEditorExtensions();
        this.plugin.forceRefreshAllEditors();
        this.plugin.forceRefreshAllReadingViews();
      } catch (e) {
      }
    };
    this._submitFn = submitFn;
    try {
      const originalSubmit = this._submitFn;
      this._submitFn = async () => {
        await originalSubmit();
        if (this.plugin.settingTab) {
          try {
            this.plugin.settingTab._suspendSorting = true;
          } catch (e) {
          }
          try {
            this.plugin.settingTab._refreshEntries();
          } catch (e) {
          }
        }
      };
    } catch (e) {
    }
  }
  onClose() {
    try {
      if (this._hasUserChanges && typeof this._submitFn === "function") this._submitFn();
    } catch (e) {
    }
    this._eventListeners.forEach(({ el, event, handler }) => {
      el.removeEventListener(event, handler);
    });
    this._eventListeners = [];
    this.contentEl.empty();
  }
};
var ConfirmationModal = class extends Modal {
  constructor(app, plugin, title, message, onConfirm) {
    super(app);
    this.plugin = plugin;
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this._eventListeners = [];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this._eventListeners = [];
    const h2 = contentEl.createEl("h2", { text: this.title });
    h2.style.marginTop = "0";
    contentEl.createEl("p", { text: this.message });
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.display = "flex";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.marginTop = "20px";
    buttonDiv.style.gap = "10px";
    const cancelButton = buttonDiv.createEl("button", { text: this.plugin.t("btn_cancel", "Cancel") });
    const cancelHandler = () => this.close();
    cancelButton.addEventListener("click", cancelHandler);
    this._eventListeners.push({ el: cancelButton, event: "click", handler: cancelHandler });
    const confirmButton = buttonDiv.createEl("button", { text: this.plugin.t("btn_confirm", "Confirm") });
    confirmButton.addClass("mod-warning");
    const confirmHandler = () => {
      this.onConfirm();
      this.close();
    };
    confirmButton.addEventListener("click", confirmHandler);
    this._eventListeners.push({ el: confirmButton, event: "click", handler: confirmHandler });
  }
  onClose() {
    this._eventListeners.forEach(({ el, event, handler }) => {
      el.removeEventListener(event, handler);
    });
    this._eventListeners = [];
    this.contentEl.empty();
  }
};
